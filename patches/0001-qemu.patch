From be1e8b94caa6fb1297e014660fd5b41a952b00bb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E8=B0=93=E5=A5=87?= <liuyunzhuo.lyz@alibaba-inc.com>
Date: Fri, 24 May 2024 08:02:07 -0400
Subject: [PATCH] fastiov

---
 .cirrus.yml                                   |  110 +
 .dir-locals.el                                |    2 +
 .editorconfig                                 |   49 +
 .exrc                                         |    7 +
 .gdbinit                                      |    8 +
 .git-submodule-status                         |    2 +
 .gitattributes                                |    3 +
 .gitlab-ci.d/buildtest-template.yml           |   81 +
 .gitlab-ci.d/buildtest.yml                    |  649 +++++
 .gitlab-ci.d/check-dco.py                     |   94 +
 .gitlab-ci.d/check-patch.py                   |   56 +
 .gitlab-ci.d/cirrus.yml                       |   91 +
 .gitlab-ci.d/cirrus/README.rst                |   54 +
 .gitlab-ci.d/cirrus/build.yml                 |   36 +
 .gitlab-ci.d/cirrus/freebsd-12.vars           |   13 +
 .gitlab-ci.d/cirrus/freebsd-13.vars           |   13 +
 .gitlab-ci.d/cirrus/macos-11.vars             |   15 +
 .gitlab-ci.d/container-core.yml               |   17 +
 .gitlab-ci.d/container-cross.yml              |  193 ++
 .gitlab-ci.d/container-template.yml           |   21 +
 .gitlab-ci.d/containers.yml                   |   45 +
 .gitlab-ci.d/crossbuild-template.yml          |   47 +
 .gitlab-ci.d/crossbuilds.yml                  |  216 ++
 .gitlab-ci.d/custom-runners.yml               |   19 +
 .../custom-runners/centos-stream-8-x86_64.yml |   28 +
 .../custom-runners/ubuntu-18.04-s390x.yml     |  118 +
 .../custom-runners/ubuntu-20.04-aarch64.yml   |  118 +
 .gitlab-ci.d/edk2.yml                         |   60 +
 .gitlab-ci.d/edk2/Dockerfile                  |   27 +
 .gitlab-ci.d/opensbi.yml                      |   63 +
 .gitlab-ci.d/opensbi/Dockerfile               |   33 +
 .gitlab-ci.d/qemu-project.yml                 |   13 +
 .gitlab-ci.d/stages.yml                       |    8 +
 .gitlab-ci.d/static_checks.yml                |   49 +
 .gitlab-ci.yml                                |   24 +
 .gitlab/issue_templates/bug.md                |   64 +
 .gitlab/issue_templates/feature_request.md    |   32 +
 .gitmodules                                   |   66 +
 .gitpublish                                   |   51 +
 .mailmap                                      |  184 ++
 .patchew.yml                                  |  299 +++
 .readthedocs.yml                              |   20 +
 .travis.yml                                   |  307 +++
 .vscode/settings.json                         |   10 +
 GNUmakefile                                   |   20 +
 accel/kvm/kvm-all.c                           |   30 +-
 backends/hostmem-file.c                       |    8 +
 backends/hostmem-memfd.c                      |    8 +
 backends/hostmem-ram.c                        |    8 +
 backends/hostmem.c                            |   27 +
 build_qemu.sh                                 |    3 +
 docs/system/i386/sgx.rst                      |   31 +-
 dtc/.cirrus.yml                               |   23 +
 dtc/.editorconfig                             |   30 +
 dtc/.travis.yml                               |   65 +
 dtc/BSD-2-Clause                              |   32 +
 dtc/Documentation/dt-object-internal.txt      |  310 +++
 dtc/Documentation/dtc-paper.bib               |   43 +
 dtc/Documentation/dtc-paper.tex               |  597 ++++
 dtc/Documentation/dts-format.txt              |  122 +
 dtc/Documentation/manual.txt                  |  762 ++++++
 dtc/GPL                                       |  339 +++
 dtc/Makefile                                  |  384 +++
 dtc/Makefile.convert-dtsv0                    |   14 +
 dtc/Makefile.dtc                              |   23 +
 dtc/Makefile.utils                            |   31 +
 dtc/README                                    |   91 +
 dtc/README.license                            |   56 +
 dtc/TODO                                      |    8 +
 dtc/checks.c                                  | 1981 ++++++++++++++
 dtc/convert-dtsv0-lexer.l                     |  235 ++
 dtc/data.c                                    |  256 ++
 dtc/dtc-lexer.l                               |  297 ++
 dtc/dtc-parser.y                              |  576 ++++
 dtc/dtc.c                                     |  371 +++
 dtc/dtc.h                                     |  342 +++
 dtc/dtdiff                                    |   39 +
 dtc/fdtdump.c                                 |  248 ++
 dtc/fdtget.c                                  |  369 +++
 dtc/fdtoverlay.c                              |  208 ++
 dtc/fdtput.c                                  |  466 ++++
 dtc/flattree.c                                |  925 +++++++
 dtc/fstree.c                                  |   76 +
 dtc/libfdt/Makefile.libfdt                    |   18 +
 dtc/libfdt/TODO                               |    3 +
 dtc/libfdt/fdt.c                              |  335 +++
 dtc/libfdt/fdt.h                              |   66 +
 dtc/libfdt/fdt_addresses.c                    |  101 +
 dtc/libfdt/fdt_check.c                        |   93 +
 dtc/libfdt/fdt_empty_tree.c                   |   38 +
 dtc/libfdt/fdt_overlay.c                      |  882 ++++++
 dtc/libfdt/fdt_ro.c                           |  859 ++++++
 dtc/libfdt/fdt_rw.c                           |  500 ++++
 dtc/libfdt/fdt_strerror.c                     |   59 +
 dtc/libfdt/fdt_sw.c                           |  384 +++
 dtc/libfdt/fdt_wip.c                          |   94 +
 dtc/libfdt/libfdt.h                           | 2122 +++++++++++++++
 dtc/libfdt/libfdt_env.h                       |   96 +
 dtc/libfdt/libfdt_internal.h                  |  192 ++
 dtc/libfdt/meson.build                        |   50 +
 dtc/libfdt/version.lds                        |   82 +
 dtc/livetree.c                                | 1032 +++++++
 dtc/meson.build                               |  129 +
 dtc/meson_options.txt                         |   10 +
 dtc/pylibfdt/Makefile.pylibfdt                |   30 +
 dtc/pylibfdt/libfdt.i                         | 1118 ++++++++
 dtc/pylibfdt/meson.build                      |   13 +
 dtc/pylibfdt/setup.py                         |   59 +
 dtc/scripts/kup-dtc                           |   32 +
 dtc/scripts/setlocalversion                   |   23 +
 dtc/srcpos.c                                  |  406 +++
 dtc/srcpos.h                                  |  103 +
 dtc/tests/Makefile.tests                      |  102 +
 dtc/tests/add_subnode_with_nops.c             |   71 +
 dtc/tests/addr_size_cells.c                   |   56 +
 dtc/tests/addr_size_cells2.c                  |   49 +
 dtc/tests/addresses.dts                       |   40 +
 dtc/tests/aliases.dts                         |   25 +
 dtc/tests/appendprop.dts                      |    8 +
 dtc/tests/appendprop1.c                       |   57 +
 dtc/tests/appendprop2.c                       |   51 +
 dtc/tests/appendprop_addrrange.c              |   95 +
 dtc/tests/asm_tree_dump.c                     |   48 +
 dtc/tests/bad-chosen.dts                      |   10 +
 dtc/tests/bad-dma-ranges.dts                  |   12 +
 dtc/tests/bad-empty-ranges.dts                |   11 +
 dtc/tests/bad-gpio.dts                        |   13 +
 dtc/tests/bad-graph.dts                       |   24 +
 dtc/tests/bad-interrupt-cells.dts             |   12 +
 dtc/tests/bad-interrupt-controller.dts        |    7 +
 dtc/tests/bad-name-property.dts               |    7 +
 dtc/tests/bad-ncells.dts                      |    7 +
 dtc/tests/bad-octal-literal.dts               |    5 +
 dtc/tests/bad-phandle-cells.dts               |   11 +
 dtc/tests/bad-reg-ranges.dts                  |   12 +
 dtc/tests/bad-size-cells.dts                  |   12 +
 dtc/tests/bad-string-props.dts                |   14 +
 dtc/tests/base01.asm                          |  175 ++
 dtc/tests/base01.cmd                          |    1 +
 dtc/tests/base01.dts                          |   33 +
 dtc/tests/base01.stderr                       |    6 +
 dtc/tests/boot-cpuid.c                        |   34 +
 dtc/tests/boot-cpuid.dts                      |   16 +
 dtc/tests/char_literal.c                      |   36 +
 dtc/tests/char_literal.dts                    |    5 +
 dtc/tests/check_full.c                        |   50 +
 dtc/tests/check_header.c                      |  115 +
 dtc/tests/check_path.c                        |   70 +
 dtc/tests/comments-cmp.dts                    |   16 +
 dtc/tests/comments.dts                        |   39 +
 dtc/tests/data.S                              |    3 +
 dtc/tests/default-addr-size.dts               |    7 +
 dtc/tests/del_node.c                          |  110 +
 dtc/tests/del_property.c                      |   77 +
 dtc/tests/delete_reinstate_multilabel.dts     |   37 +
 dtc/tests/delete_reinstate_multilabel_ref.dts |    9 +
 dtc/tests/dependencies.cmp                    |    1 +
 dtc/tests/dependencies.dts                    |    6 +
 dtc/tests/deps_inc1.dtsi                      |    1 +
 dtc/tests/deps_inc2.dtsi                      |    1 +
 dtc/tests/division-by-zero.dts                |    6 +
 dtc/tests/dtb_reverse.c                       |  150 ++
 dtc/tests/dtbs_equal_ordered.c                |  160 ++
 dtc/tests/dtbs_equal_unordered.c              |  230 ++
 dtc/tests/dtc-checkfails.sh                   |   45 +
 dtc/tests/dtc-fails.sh                        |   31 +
 dtc/tests/dtc-fatal.sh                        |   15 +
 dtc/tests/dumptrees.c                         |   69 +
 dtc/tests/dup-nodename.dts                    |    8 +
 dtc/tests/dup-phandle.dts                     |   10 +
 dtc/tests/dup-propname.dts                    |    6 +
 dtc/tests/embedded_nul.dts                    |  Bin 0 -> 152 bytes
 dtc/tests/embedded_nul_equiv.dts              |    6 +
 dtc/tests/empty.dts                           |    4 +
 dtc/tests/escapes.dts                         |    7 +
 dtc/tests/extra-terminating-null.c            |   45 +
 dtc/tests/extra-terminating-null.dts          |   11 +
 dtc/tests/fdtdump-runtest.sh                  |   31 +
 dtc/tests/fdtdump.dts                         |   38 +
 dtc/tests/fdtget-runtest.sh                   |   25 +
 dtc/tests/fdtoverlay-runtest.sh               |   41 +
 dtc/tests/fdtput-runtest.sh                   |   40 +
 dtc/tests/find_property.c                     |   28 +
 dtc/tests/fs_tree1.c                          |  155 ++
 dtc/tests/get_alias.c                         |   44 +
 dtc/tests/get_mem_rsv.c                       |   35 +
 dtc/tests/get_name.c                          |   69 +
 dtc/tests/get_path.c                          |   80 +
 dtc/tests/get_phandle.c                       |   87 +
 dtc/tests/get_prop_offset.c                   |   43 +
 dtc/tests/getprop.c                           |   29 +
 dtc/tests/good-gpio.dts                       |   12 +
 dtc/tests/incbin.bin                          |    1 +
 dtc/tests/incbin.c                            |   65 +
 dtc/tests/incbin.dts                          |    6 +
 dtc/tests/include0.dts                        |    1 +
 dtc/tests/include1.dts                        |   32 +
 dtc/tests/include2.dts                        |    1 +
 dtc/tests/include3.dts                        |    1 +
 dtc/tests/include4.dts                        |    1 +
 dtc/tests/include5.dts                        |    1 +
 dtc/tests/include5a.dts                       |    1 +
 dtc/tests/include6.dts                        |    1 +
 dtc/tests/include7.dts                        |   14 +
 dtc/tests/include8.dts                        |    2 +
 dtc/tests/integer-expressions.c               |  103 +
 dtc/tests/label01.dts                         |   63 +
 dtc/tests/label_repeated.dts                  |   15 +
 dtc/tests/line_directives.dts                 |   26 +
 dtc/tests/lorem.txt                           |   35 +
 dtc/tests/mangle-layout.c                     |  147 +
 dtc/tests/meson.build                         |  131 +
 dtc/tests/minusone-phandle.dts                |    7 +
 dtc/tests/move_and_save.c                     |   62 +
 dtc/tests/multilabel.dts                      |   49 +
 dtc/tests/multilabel_merge.dts                |   75 +
 dtc/tests/node_check_compatible.c             |   68 +
 dtc/tests/node_offset_by_compatible.c         |   72 +
 dtc/tests/node_offset_by_phandle.c            |   50 +
 dtc/tests/node_offset_by_prop_value.c         |   97 +
 dtc/tests/nonexist-label-ref.dts              |    8 +
 dtc/tests/nonexist-node-ref.dts               |    8 +
 dtc/tests/nonexist-node-ref2.dts              |   10 +
 dtc/tests/nop_node.c                          |   91 +
 dtc/tests/nop_property.c                      |   57 +
 dtc/tests/nopulate.c                          |   92 +
 dtc/tests/notfound.c                          |   57 +
 dtc/tests/nul-in-escape.dts                   |  Bin 0 -> 36 bytes
 dtc/tests/nul-in-line-info1.dts               |  Bin 0 -> 8 bytes
 dtc/tests/nul-in-line-info2.dts               |    1 +
 .../obsolete-chosen-interrupt-controller.dts  |   13 +
 dtc/tests/omit-no-ref.dts                     |   26 +
 dtc/tests/open_pack.c                         |   58 +
 dtc/tests/overlay.c                           |  220 ++
 dtc/tests/overlay_bad_fixup.c                 |   57 +
 dtc/tests/overlay_bad_fixup_bad_index.dts     |   14 +
 dtc/tests/overlay_bad_fixup_base.dtsi         |   18 +
 dtc/tests/overlay_bad_fixup_empty.dts         |   14 +
 dtc/tests/overlay_bad_fixup_empty_index.dts   |   14 +
 .../overlay_bad_fixup_index_trailing.dts      |   14 +
 .../overlay_bad_fixup_path_empty_prop.dts     |   14 +
 dtc/tests/overlay_bad_fixup_path_only.dts     |   14 +
 dtc/tests/overlay_bad_fixup_path_only_sep.dts |   14 +
 dtc/tests/overlay_bad_fixup_path_prop.dts     |   14 +
 dtc/tests/overlay_base.dts                    |   25 +
 dtc/tests/overlay_base_manual_symbols.dts     |   25 +
 dtc/tests/overlay_overlay.dts                 |   52 +
 dtc/tests/overlay_overlay_bypath.dts          |   48 +
 dtc/tests/overlay_overlay_local_merge.dts     |   29 +
 dtc/tests/overlay_overlay_long_path.dts       |   32 +
 dtc/tests/overlay_overlay_manual_fixups.dts   |  112 +
 dtc/tests/overlay_overlay_no_fixups.dts       |   82 +
 dtc/tests/overlay_overlay_nosugar.dts         |   86 +
 dtc/tests/overlay_overlay_simple.dts          |   12 +
 dtc/tests/parent_offset.c                     |   77 +
 dtc/tests/path-references.c                   |   95 +
 dtc/tests/path-references.dts                 |   28 +
 dtc/tests/path_offset.c                       |  124 +
 dtc/tests/path_offset_aliases.c               |   45 +
 dtc/tests/pci-bridge-bad1.dts                 |   16 +
 dtc/tests/pci-bridge-bad2.dts                 |   16 +
 dtc/tests/pci-bridge-ok.dts                   |   25 +
 dtc/tests/phandle_format.c                    |   64 +
 dtc/tests/prop-after-subnode.dts              |    9 +
 dtc/tests/property_iterate.c                  |   84 +
 dtc/tests/property_iterate.dts                |   23 +
 dtc/tests/propname_escapes.c                  |   29 +
 dtc/tests/propname_escapes.dts                |    6 +
 dtc/tests/pylibfdt_tests.py                   |  592 ++++
 dtc/tests/references.c                        |  129 +
 dtc/tests/references.dts                      |   41 +
 dtc/tests/reg-ranges-root.dts                 |    8 +
 dtc/tests/reg-without-unit-addr.dts           |   10 +
 dtc/tests/reuse-label.dts                     |   15 +
 dtc/tests/reuse-label1.dts                    |   10 +
 dtc/tests/reuse-label2.dts                    |    6 +
 dtc/tests/reuse-label3.dts                    |    9 +
 dtc/tests/reuse-label4.dts                    |    5 +
 dtc/tests/reuse-label5.dts                    |    6 +
 dtc/tests/reuse-label6.dts                    |    6 +
 dtc/tests/root_node.c                         |   39 +
 dtc/tests/run_tests.sh                        | 1104 ++++++++
 dtc/tests/rw_oom.c                            |   83 +
 dtc/tests/rw_tree1.c                          |   82 +
 dtc/tests/search_dir/search_test.dtsi         |    4 +
 dtc/tests/search_dir/search_test2.dtsi        |    3 +
 .../search_dir_b/search_paths_subdir.dts      |    6 +
 dtc/tests/search_dir_b/search_test_b.dtsi     |    4 +
 dtc/tests/search_dir_b/search_test_b2.dtsi    |    5 +
 dtc/tests/search_dir_b/search_test_c.dtsi     |    2 +
 dtc/tests/search_paths.dts                    |    6 +
 dtc/tests/search_paths_b.dts                  |    6 +
 dtc/tests/set_name.c                          |   77 +
 dtc/tests/setprop.c                           |   82 +
 dtc/tests/setprop_inplace.c                   |   84 +
 dtc/tests/sized_cells.c                       |   70 +
 dtc/tests/sized_cells.dts                     |   11 +
 dtc/tests/sourceoutput.dts                    |   14 +
 dtc/tests/stacked_overlay_addlabel.dts        |   15 +
 dtc/tests/stacked_overlay_bar.dts             |   13 +
 dtc/tests/stacked_overlay_base.dts            |    6 +
 dtc/tests/stacked_overlay_base_nolabel.dts    |    6 +
 dtc/tests/stacked_overlay_baz.dts             |   13 +
 dtc/tests/string_escapes.c                    |   30 +
 dtc/tests/stringlist.c                        |  142 +
 dtc/tests/stringlist.dts                      |   12 +
 dtc/tests/subnode_iterate.c                   |   77 +
 dtc/tests/subnode_iterate.dts                 |   44 +
 dtc/tests/subnode_offset.c                    |   85 +
 dtc/tests/supernode_atdepth_offset.c          |  132 +
 dtc/tests/sw_states.c                         |  127 +
 dtc/tests/sw_tree1.c                          |  226 ++
 dtc/tests/test01.asm                          |  294 ++
 dtc/tests/test01.dts                          |   57 +
 dtc/tests/test01.stderr                       |    4 +
 dtc/tests/test_kernel_dts                     |   86 +
 dtc/tests/test_label_ref.dts                  |    9 +
 dtc/tests/test_props.dts                      |   11 +
 dtc/tests/test_tree1.dts                      |   46 +
 dtc/tests/test_tree1_delete.dts               |   68 +
 dtc/tests/test_tree1_label_noderef.dts        |   56 +
 dtc/tests/test_tree1_merge.dts                |   51 +
 dtc/tests/test_tree1_merge_labelled.dts       |   49 +
 dtc/tests/test_tree1_merge_path.dts           |   49 +
 dtc/tests/test_tree1_wrong1.dts               |   43 +
 dtc/tests/test_tree1_wrong2.dts               |   43 +
 dtc/tests/test_tree1_wrong3.dts               |   43 +
 dtc/tests/test_tree1_wrong4.dts               |   41 +
 dtc/tests/test_tree1_wrong5.dts               |   44 +
 dtc/tests/test_tree1_wrong6.dts               |   45 +
 dtc/tests/test_tree1_wrong7.dts               |   46 +
 dtc/tests/test_tree1_wrong8.dts               |   44 +
 dtc/tests/test_tree1_wrong9.dts               |   45 +
 dtc/tests/testdata.h                          |   60 +
 dtc/tests/tests.h                             |  130 +
 dtc/tests/testutils.c                         |  351 +++
 dtc/tests/testutils.sh                        |   67 +
 dtc/tests/trees.S                             |  315 +++
 dtc/tests/truncated_memrsv.c                  |   50 +
 dtc/tests/truncated_property.c                |   36 +
 dtc/tests/truncated_string.c                  |   68 +
 dtc/tests/type-preservation.dt.yaml           |   20 +
 dtc/tests/type-preservation.dts               |   28 +
 dtc/tests/unit-addr-leading-0s.dts            |   12 +
 dtc/tests/unit-addr-leading-0x.dts            |   12 +
 dtc/tests/unit-addr-simple-bus-compatible.dts |   18 +
 .../unit-addr-simple-bus-reg-mismatch.dts     |   18 +
 dtc/tests/unit-addr-unique.dts                |   14 +
 dtc/tests/unit-addr-without-reg.dts           |    9 +
 dtc/tests/utilfdt_test.c                      |  114 +
 dtc/tests/value-labels.c                      |  114 +
 dtc/tests/value-labels.dts                    |    8 +
 dtc/tests/zero-phandle.dts                    |    7 +
 dtc/treesource.c                              |  345 +++
 dtc/util.c                                    |  468 ++++
 dtc/util.h                                    |  247 ++
 dtc/version_gen.h.in                          |    1 +
 dtc/yamltree.c                                |  235 ++
 ebpf/ebpf_rss.c                               |    3 +-
 hw/core/numa.c                                |    5 +-
 hw/i386/acpi-build.c                          |    2 +
 hw/i386/multiboot.c                           |   14 +
 hw/i386/pc_q35.c                              |    4 +
 hw/i386/sgx-epc.c                             |    3 +
 hw/i386/sgx-stub.c                            |    4 +
 hw/i386/sgx.c                                 |   95 +-
 hw/i386/x86.c                                 |   30 +-
 hw/nvram/fw_cfg.c                             |   10 +
 hw/pci/pci.c                                  |    4 +
 hw/vfio/cni_fastiov_ioctl.c                   |   21 +
 hw/vfio/cni_fastiov_ioctl.h                   |   16 +
 hw/vfio/cni_logger.c                          |  264 ++
 hw/vfio/cni_logger.h                          |   75 +
 hw/vfio/common.c                              |  129 +-
 hw/vfio/meson.build                           |    2 +
 hw/vfio/pci.c                                 |   22 +
 hw/virtio/vhost-user.c                        |   21 +
 hw/virtio/virtio-pci.c                        |    3 +
 ...qemu_trace-detail-cost-kata200-barrier.png |  Bin 0 -> 36172 bytes
 ...qemu_trace-detail-cost-kata400-barrier.png |  Bin 0 -> 35646 bytes
 include/hw/i386/sgx-epc.h                     |    3 +
 kata.cfg                                      |    1 +
 monitor/hmp-cmds.c                            |    1 +
 qapi/machine.json                             |   10 +-
 qapi/misc-target.json                         |   19 +-
 qemu-options.hx                               |    4 +-
 .../qapi/__pycache__/__init__.cpython-36.pyc  |  Bin 0 -> 126 bytes
 .../qapi/__pycache__/commands.cpython-36.pyc  |  Bin 0 -> 7889 bytes
 .../qapi/__pycache__/common.cpython-36.pyc    |  Bin 0 -> 7688 bytes
 scripts/qapi/__pycache__/error.cpython-36.pyc |  Bin 0 -> 1593 bytes
 .../qapi/__pycache__/events.cpython-36.pyc    |  Bin 0 -> 6106 bytes
 scripts/qapi/__pycache__/expr.cpython-36.pyc  |  Bin 0 -> 19505 bytes
 scripts/qapi/__pycache__/gen.cpython-36.pyc   |  Bin 0 -> 11025 bytes
 .../__pycache__/introspect.cpython-36.pyc     |  Bin 0 -> 12142 bytes
 scripts/qapi/__pycache__/main.cpython-36.pyc  |  Bin 0 -> 2844 bytes
 .../qapi/__pycache__/parser.cpython-36.pyc    |  Bin 0 -> 21330 bytes
 .../qapi/__pycache__/schema.cpython-36.pyc    |  Bin 0 -> 38730 bytes
 .../qapi/__pycache__/source.cpython-36.pyc    |  Bin 0 -> 2175 bytes
 scripts/qapi/__pycache__/types.cpython-36.pyc |  Bin 0 -> 9289 bytes
 scripts/qapi/__pycache__/visit.cpython-36.pyc |  Bin 0 -> 10531 bytes
 .../__pycache__/__init__.cpython-36.pyc       |  Bin 0 -> 14367 bytes
 .../__pycache__/transform.cpython-36.pyc      |  Bin 0 -> 3441 bytes
 .../tracetool/__pycache__/vcpu.cpython-36.pyc |  Bin 0 -> 1884 bytes
 .../__pycache__/__init__.cpython-36.pyc       |  Bin 0 -> 4529 bytes
 .../backend/__pycache__/dtrace.cpython-36.pyc |  Bin 0 -> 1821 bytes
 .../backend/__pycache__/log.cpython-36.pyc    |  Bin 0 -> 2037 bytes
 .../__pycache__/__init__.cpython-36.pyc       |  Bin 0 -> 2359 bytes
 .../format/__pycache__/c.cpython-36.pyc       |  Bin 0 -> 1949 bytes
 .../format/__pycache__/h.cpython-36.pyc       |  Bin 0 -> 2177 bytes
 softmmu/main.c                                |    5 +
 softmmu/memory.c                              |   43 +-
 softmmu/physmem.c                             |   25 +
 softmmu/qdev-monitor.c                        |    8 +
 softmmu/runstate.c                            |    8 +
 softmmu/vl.c                                  |   41 +
 subprojects/libvhost-user/include/atomic.h    |  310 ++-
 .../libvhost-user/standard-headers/linux      |    1 -
 .../standard-headers/linux/const.h            |   36 +
 .../standard-headers/linux/ethtool.h          | 2064 ++++++++++++++
 .../standard-headers/linux/fuse.h             |  970 +++++++
 .../standard-headers/linux/if_ether.h         |    1 +
 .../linux/input-event-codes.h                 |  950 +++++++
 .../standard-headers/linux/input.h            |  511 ++++
 .../standard-headers/linux/kernel.h           |    8 +
 .../standard-headers/linux/pci_regs.h         | 1095 ++++++++
 .../standard-headers/linux/qemu_fw_cfg.h      |   97 +
 .../standard-headers/linux/sysinfo.h          |   25 +
 .../standard-headers/linux/types.h            |    3 +
 .../standard-headers/linux/udmabuf.h          |   32 +
 .../standard-headers/linux/vhost_types.h      |  156 ++
 .../standard-headers/linux/virtio_9p.h        |   44 +
 .../standard-headers/linux/virtio_balloon.h   |  119 +
 .../standard-headers/linux/virtio_blk.h       |  201 ++
 .../standard-headers/linux/virtio_bt.h        |   31 +
 .../standard-headers/linux/virtio_config.h    |   93 +
 .../standard-headers/linux/virtio_console.h   |   78 +
 .../standard-headers/linux/virtio_crypto.h    |  450 ++++
 .../standard-headers/linux/virtio_fs.h        |   22 +
 .../standard-headers/linux/virtio_gpu.h       |  444 +++
 .../standard-headers/linux/virtio_ids.h       |   60 +
 .../standard-headers/linux/virtio_input.h     |   76 +
 .../standard-headers/linux/virtio_iommu.h     |  165 ++
 .../standard-headers/linux/virtio_mem.h       |  211 ++
 .../standard-headers/linux/virtio_mmio.h      |  152 ++
 .../standard-headers/linux/virtio_net.h       |  358 +++
 .../standard-headers/linux/virtio_pci.h       |  208 ++
 .../standard-headers/linux/virtio_pmem.h      |   34 +
 .../standard-headers/linux/virtio_ring.h      |  242 ++
 .../standard-headers/linux/virtio_rng.h       |    8 +
 .../standard-headers/linux/virtio_scsi.h      |  172 ++
 .../standard-headers/linux/virtio_snd.h       |  334 +++
 .../standard-headers/linux/virtio_types.h     |   46 +
 .../standard-headers/linux/virtio_vsock.h     |  103 +
 target/ppc/excp_helper.c                      |   21 +-
 target/ppc/excp_helper.c.orig                 | 1484 ++++++++++
 tools/virtiofsd/build/.hgignore               |    3 +
 .../virtiofsd/build/meson-logs/meson-log.txt  |   13 +
 .../virtiofsd/build/meson-private/meson.lock  |    0
 ui/keycodemapdb/LICENSE.BSD                   |   27 +
 ui/keycodemapdb/LICENSE.GPL2                  |  339 +++
 ui/keycodemapdb/README                        |  115 +
 ui/keycodemapdb/data/README                   |   89 +
 ui/keycodemapdb/data/keymaps.csv              |  539 ++++
 ui/keycodemapdb/meson.build                   |    1 +
 ui/keycodemapdb/tests/Makefile                |  171 ++
 ui/keycodemapdb/tests/javascript              |   53 +
 ui/keycodemapdb/tests/python2                 |    3 +
 ui/keycodemapdb/tests/python3                 |    3 +
 ui/keycodemapdb/tests/rust                    |    5 +
 ui/keycodemapdb/tests/rust-test/Cargo.toml    |   10 +
 ui/keycodemapdb/tests/rust-test/src/main.rs   |   28 +
 ui/keycodemapdb/tests/stdc++.cc               |   40 +
 ui/keycodemapdb/tests/stdc.c                  |   64 +
 ui/keycodemapdb/tests/test.py                 |   30 +
 .../thirdparty/LICENSE-argparse.txt           |   20 +
 ui/keycodemapdb/thirdparty/__init__.py        |    0
 ui/keycodemapdb/thirdparty/argparse.py        | 2392 +++++++++++++++++
 ui/keycodemapdb/tools/keymap-gen              | 1196 +++++++++
 util/oslib-posix.c                            |    2 +
 util/vfio-helpers.c                           |   16 +
 480 files changed, 52861 insertions(+), 40 deletions(-)
 create mode 100644 .cirrus.yml
 create mode 100644 .dir-locals.el
 create mode 100644 .editorconfig
 create mode 100644 .exrc
 create mode 100644 .gdbinit
 create mode 100644 .git-submodule-status
 create mode 100644 .gitattributes
 create mode 100644 .gitlab-ci.d/buildtest-template.yml
 create mode 100644 .gitlab-ci.d/buildtest.yml
 create mode 100755 .gitlab-ci.d/check-dco.py
 create mode 100755 .gitlab-ci.d/check-patch.py
 create mode 100644 .gitlab-ci.d/cirrus.yml
 create mode 100644 .gitlab-ci.d/cirrus/README.rst
 create mode 100644 .gitlab-ci.d/cirrus/build.yml
 create mode 100644 .gitlab-ci.d/cirrus/freebsd-12.vars
 create mode 100644 .gitlab-ci.d/cirrus/freebsd-13.vars
 create mode 100644 .gitlab-ci.d/cirrus/macos-11.vars
 create mode 100644 .gitlab-ci.d/container-core.yml
 create mode 100644 .gitlab-ci.d/container-cross.yml
 create mode 100644 .gitlab-ci.d/container-template.yml
 create mode 100644 .gitlab-ci.d/containers.yml
 create mode 100644 .gitlab-ci.d/crossbuild-template.yml
 create mode 100644 .gitlab-ci.d/crossbuilds.yml
 create mode 100644 .gitlab-ci.d/custom-runners.yml
 create mode 100644 .gitlab-ci.d/custom-runners/centos-stream-8-x86_64.yml
 create mode 100644 .gitlab-ci.d/custom-runners/ubuntu-18.04-s390x.yml
 create mode 100644 .gitlab-ci.d/custom-runners/ubuntu-20.04-aarch64.yml
 create mode 100644 .gitlab-ci.d/edk2.yml
 create mode 100644 .gitlab-ci.d/edk2/Dockerfile
 create mode 100644 .gitlab-ci.d/opensbi.yml
 create mode 100644 .gitlab-ci.d/opensbi/Dockerfile
 create mode 100644 .gitlab-ci.d/qemu-project.yml
 create mode 100644 .gitlab-ci.d/stages.yml
 create mode 100644 .gitlab-ci.d/static_checks.yml
 create mode 100644 .gitlab-ci.yml
 create mode 100644 .gitlab/issue_templates/bug.md
 create mode 100644 .gitlab/issue_templates/feature_request.md
 create mode 100644 .gitmodules
 create mode 100644 .gitpublish
 create mode 100644 .mailmap
 create mode 100644 .patchew.yml
 create mode 100644 .readthedocs.yml
 create mode 100644 .travis.yml
 create mode 100644 .vscode/settings.json
 create mode 100644 GNUmakefile
 create mode 100644 build_qemu.sh
 create mode 100644 dtc/.cirrus.yml
 create mode 100644 dtc/.editorconfig
 create mode 100644 dtc/.travis.yml
 create mode 100644 dtc/BSD-2-Clause
 create mode 100644 dtc/Documentation/dt-object-internal.txt
 create mode 100644 dtc/Documentation/dtc-paper.bib
 create mode 100644 dtc/Documentation/dtc-paper.tex
 create mode 100644 dtc/Documentation/dts-format.txt
 create mode 100644 dtc/Documentation/manual.txt
 create mode 100644 dtc/GPL
 create mode 100644 dtc/Makefile
 create mode 100644 dtc/Makefile.convert-dtsv0
 create mode 100644 dtc/Makefile.dtc
 create mode 100644 dtc/Makefile.utils
 create mode 100644 dtc/README
 create mode 100644 dtc/README.license
 create mode 100644 dtc/TODO
 create mode 100644 dtc/checks.c
 create mode 100644 dtc/convert-dtsv0-lexer.l
 create mode 100644 dtc/data.c
 create mode 100644 dtc/dtc-lexer.l
 create mode 100644 dtc/dtc-parser.y
 create mode 100644 dtc/dtc.c
 create mode 100644 dtc/dtc.h
 create mode 100644 dtc/dtdiff
 create mode 100644 dtc/fdtdump.c
 create mode 100644 dtc/fdtget.c
 create mode 100644 dtc/fdtoverlay.c
 create mode 100644 dtc/fdtput.c
 create mode 100644 dtc/flattree.c
 create mode 100644 dtc/fstree.c
 create mode 100644 dtc/libfdt/Makefile.libfdt
 create mode 100644 dtc/libfdt/TODO
 create mode 100644 dtc/libfdt/fdt.c
 create mode 100644 dtc/libfdt/fdt.h
 create mode 100644 dtc/libfdt/fdt_addresses.c
 create mode 100644 dtc/libfdt/fdt_check.c
 create mode 100644 dtc/libfdt/fdt_empty_tree.c
 create mode 100644 dtc/libfdt/fdt_overlay.c
 create mode 100644 dtc/libfdt/fdt_ro.c
 create mode 100644 dtc/libfdt/fdt_rw.c
 create mode 100644 dtc/libfdt/fdt_strerror.c
 create mode 100644 dtc/libfdt/fdt_sw.c
 create mode 100644 dtc/libfdt/fdt_wip.c
 create mode 100644 dtc/libfdt/libfdt.h
 create mode 100644 dtc/libfdt/libfdt_env.h
 create mode 100644 dtc/libfdt/libfdt_internal.h
 create mode 100644 dtc/libfdt/meson.build
 create mode 100644 dtc/libfdt/version.lds
 create mode 100644 dtc/livetree.c
 create mode 100644 dtc/meson.build
 create mode 100644 dtc/meson_options.txt
 create mode 100644 dtc/pylibfdt/Makefile.pylibfdt
 create mode 100644 dtc/pylibfdt/libfdt.i
 create mode 100644 dtc/pylibfdt/meson.build
 create mode 100755 dtc/pylibfdt/setup.py
 create mode 100755 dtc/scripts/kup-dtc
 create mode 100755 dtc/scripts/setlocalversion
 create mode 100644 dtc/srcpos.c
 create mode 100644 dtc/srcpos.h
 create mode 100644 dtc/tests/Makefile.tests
 create mode 100644 dtc/tests/add_subnode_with_nops.c
 create mode 100644 dtc/tests/addr_size_cells.c
 create mode 100644 dtc/tests/addr_size_cells2.c
 create mode 100644 dtc/tests/addresses.dts
 create mode 100644 dtc/tests/aliases.dts
 create mode 100644 dtc/tests/appendprop.dts
 create mode 100644 dtc/tests/appendprop1.c
 create mode 100644 dtc/tests/appendprop2.c
 create mode 100644 dtc/tests/appendprop_addrrange.c
 create mode 100644 dtc/tests/asm_tree_dump.c
 create mode 100644 dtc/tests/bad-chosen.dts
 create mode 100644 dtc/tests/bad-dma-ranges.dts
 create mode 100644 dtc/tests/bad-empty-ranges.dts
 create mode 100644 dtc/tests/bad-gpio.dts
 create mode 100644 dtc/tests/bad-graph.dts
 create mode 100644 dtc/tests/bad-interrupt-cells.dts
 create mode 100644 dtc/tests/bad-interrupt-controller.dts
 create mode 100644 dtc/tests/bad-name-property.dts
 create mode 100644 dtc/tests/bad-ncells.dts
 create mode 100644 dtc/tests/bad-octal-literal.dts
 create mode 100644 dtc/tests/bad-phandle-cells.dts
 create mode 100644 dtc/tests/bad-reg-ranges.dts
 create mode 100644 dtc/tests/bad-size-cells.dts
 create mode 100644 dtc/tests/bad-string-props.dts
 create mode 100644 dtc/tests/base01.asm
 create mode 100644 dtc/tests/base01.cmd
 create mode 100644 dtc/tests/base01.dts
 create mode 100644 dtc/tests/base01.stderr
 create mode 100644 dtc/tests/boot-cpuid.c
 create mode 100644 dtc/tests/boot-cpuid.dts
 create mode 100644 dtc/tests/char_literal.c
 create mode 100644 dtc/tests/char_literal.dts
 create mode 100644 dtc/tests/check_full.c
 create mode 100644 dtc/tests/check_header.c
 create mode 100644 dtc/tests/check_path.c
 create mode 100644 dtc/tests/comments-cmp.dts
 create mode 100644 dtc/tests/comments.dts
 create mode 100644 dtc/tests/data.S
 create mode 100644 dtc/tests/default-addr-size.dts
 create mode 100644 dtc/tests/del_node.c
 create mode 100644 dtc/tests/del_property.c
 create mode 100644 dtc/tests/delete_reinstate_multilabel.dts
 create mode 100644 dtc/tests/delete_reinstate_multilabel_ref.dts
 create mode 100644 dtc/tests/dependencies.cmp
 create mode 100644 dtc/tests/dependencies.dts
 create mode 100644 dtc/tests/deps_inc1.dtsi
 create mode 100644 dtc/tests/deps_inc2.dtsi
 create mode 100644 dtc/tests/division-by-zero.dts
 create mode 100644 dtc/tests/dtb_reverse.c
 create mode 100644 dtc/tests/dtbs_equal_ordered.c
 create mode 100644 dtc/tests/dtbs_equal_unordered.c
 create mode 100755 dtc/tests/dtc-checkfails.sh
 create mode 100755 dtc/tests/dtc-fails.sh
 create mode 100755 dtc/tests/dtc-fatal.sh
 create mode 100644 dtc/tests/dumptrees.c
 create mode 100644 dtc/tests/dup-nodename.dts
 create mode 100644 dtc/tests/dup-phandle.dts
 create mode 100644 dtc/tests/dup-propname.dts
 create mode 100644 dtc/tests/embedded_nul.dts
 create mode 100644 dtc/tests/embedded_nul_equiv.dts
 create mode 100644 dtc/tests/empty.dts
 create mode 100644 dtc/tests/escapes.dts
 create mode 100644 dtc/tests/extra-terminating-null.c
 create mode 100644 dtc/tests/extra-terminating-null.dts
 create mode 100755 dtc/tests/fdtdump-runtest.sh
 create mode 100644 dtc/tests/fdtdump.dts
 create mode 100755 dtc/tests/fdtget-runtest.sh
 create mode 100755 dtc/tests/fdtoverlay-runtest.sh
 create mode 100755 dtc/tests/fdtput-runtest.sh
 create mode 100644 dtc/tests/find_property.c
 create mode 100644 dtc/tests/fs_tree1.c
 create mode 100644 dtc/tests/get_alias.c
 create mode 100644 dtc/tests/get_mem_rsv.c
 create mode 100644 dtc/tests/get_name.c
 create mode 100644 dtc/tests/get_path.c
 create mode 100644 dtc/tests/get_phandle.c
 create mode 100644 dtc/tests/get_prop_offset.c
 create mode 100644 dtc/tests/getprop.c
 create mode 100644 dtc/tests/good-gpio.dts
 create mode 100644 dtc/tests/incbin.bin
 create mode 100644 dtc/tests/incbin.c
 create mode 100644 dtc/tests/incbin.dts
 create mode 100644 dtc/tests/include0.dts
 create mode 100644 dtc/tests/include1.dts
 create mode 100644 dtc/tests/include2.dts
 create mode 100644 dtc/tests/include3.dts
 create mode 100644 dtc/tests/include4.dts
 create mode 100644 dtc/tests/include5.dts
 create mode 100644 dtc/tests/include5a.dts
 create mode 100644 dtc/tests/include6.dts
 create mode 100644 dtc/tests/include7.dts
 create mode 100644 dtc/tests/include8.dts
 create mode 100644 dtc/tests/integer-expressions.c
 create mode 100644 dtc/tests/label01.dts
 create mode 100644 dtc/tests/label_repeated.dts
 create mode 100644 dtc/tests/line_directives.dts
 create mode 100644 dtc/tests/lorem.txt
 create mode 100644 dtc/tests/mangle-layout.c
 create mode 100644 dtc/tests/meson.build
 create mode 100644 dtc/tests/minusone-phandle.dts
 create mode 100644 dtc/tests/move_and_save.c
 create mode 100644 dtc/tests/multilabel.dts
 create mode 100644 dtc/tests/multilabel_merge.dts
 create mode 100644 dtc/tests/node_check_compatible.c
 create mode 100644 dtc/tests/node_offset_by_compatible.c
 create mode 100644 dtc/tests/node_offset_by_phandle.c
 create mode 100644 dtc/tests/node_offset_by_prop_value.c
 create mode 100644 dtc/tests/nonexist-label-ref.dts
 create mode 100644 dtc/tests/nonexist-node-ref.dts
 create mode 100644 dtc/tests/nonexist-node-ref2.dts
 create mode 100644 dtc/tests/nop_node.c
 create mode 100644 dtc/tests/nop_property.c
 create mode 100644 dtc/tests/nopulate.c
 create mode 100644 dtc/tests/notfound.c
 create mode 100644 dtc/tests/nul-in-escape.dts
 create mode 100644 dtc/tests/nul-in-line-info1.dts
 create mode 100644 dtc/tests/nul-in-line-info2.dts
 create mode 100644 dtc/tests/obsolete-chosen-interrupt-controller.dts
 create mode 100644 dtc/tests/omit-no-ref.dts
 create mode 100644 dtc/tests/open_pack.c
 create mode 100644 dtc/tests/overlay.c
 create mode 100644 dtc/tests/overlay_bad_fixup.c
 create mode 100644 dtc/tests/overlay_bad_fixup_bad_index.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_base.dtsi
 create mode 100644 dtc/tests/overlay_bad_fixup_empty.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_empty_index.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_index_trailing.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_path_empty_prop.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_path_only.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_path_only_sep.dts
 create mode 100644 dtc/tests/overlay_bad_fixup_path_prop.dts
 create mode 100644 dtc/tests/overlay_base.dts
 create mode 100644 dtc/tests/overlay_base_manual_symbols.dts
 create mode 100644 dtc/tests/overlay_overlay.dts
 create mode 100644 dtc/tests/overlay_overlay_bypath.dts
 create mode 100644 dtc/tests/overlay_overlay_local_merge.dts
 create mode 100644 dtc/tests/overlay_overlay_long_path.dts
 create mode 100644 dtc/tests/overlay_overlay_manual_fixups.dts
 create mode 100644 dtc/tests/overlay_overlay_no_fixups.dts
 create mode 100644 dtc/tests/overlay_overlay_nosugar.dts
 create mode 100644 dtc/tests/overlay_overlay_simple.dts
 create mode 100644 dtc/tests/parent_offset.c
 create mode 100644 dtc/tests/path-references.c
 create mode 100644 dtc/tests/path-references.dts
 create mode 100644 dtc/tests/path_offset.c
 create mode 100644 dtc/tests/path_offset_aliases.c
 create mode 100644 dtc/tests/pci-bridge-bad1.dts
 create mode 100644 dtc/tests/pci-bridge-bad2.dts
 create mode 100644 dtc/tests/pci-bridge-ok.dts
 create mode 100644 dtc/tests/phandle_format.c
 create mode 100644 dtc/tests/prop-after-subnode.dts
 create mode 100644 dtc/tests/property_iterate.c
 create mode 100644 dtc/tests/property_iterate.dts
 create mode 100644 dtc/tests/propname_escapes.c
 create mode 100644 dtc/tests/propname_escapes.dts
 create mode 100644 dtc/tests/pylibfdt_tests.py
 create mode 100644 dtc/tests/references.c
 create mode 100644 dtc/tests/references.dts
 create mode 100644 dtc/tests/reg-ranges-root.dts
 create mode 100644 dtc/tests/reg-without-unit-addr.dts
 create mode 100644 dtc/tests/reuse-label.dts
 create mode 100644 dtc/tests/reuse-label1.dts
 create mode 100644 dtc/tests/reuse-label2.dts
 create mode 100644 dtc/tests/reuse-label3.dts
 create mode 100644 dtc/tests/reuse-label4.dts
 create mode 100644 dtc/tests/reuse-label5.dts
 create mode 100644 dtc/tests/reuse-label6.dts
 create mode 100644 dtc/tests/root_node.c
 create mode 100755 dtc/tests/run_tests.sh
 create mode 100644 dtc/tests/rw_oom.c
 create mode 100644 dtc/tests/rw_tree1.c
 create mode 100644 dtc/tests/search_dir/search_test.dtsi
 create mode 100644 dtc/tests/search_dir/search_test2.dtsi
 create mode 100644 dtc/tests/search_dir_b/search_paths_subdir.dts
 create mode 100644 dtc/tests/search_dir_b/search_test_b.dtsi
 create mode 100644 dtc/tests/search_dir_b/search_test_b2.dtsi
 create mode 100644 dtc/tests/search_dir_b/search_test_c.dtsi
 create mode 100644 dtc/tests/search_paths.dts
 create mode 100644 dtc/tests/search_paths_b.dts
 create mode 100644 dtc/tests/set_name.c
 create mode 100644 dtc/tests/setprop.c
 create mode 100644 dtc/tests/setprop_inplace.c
 create mode 100644 dtc/tests/sized_cells.c
 create mode 100644 dtc/tests/sized_cells.dts
 create mode 100644 dtc/tests/sourceoutput.dts
 create mode 100644 dtc/tests/stacked_overlay_addlabel.dts
 create mode 100644 dtc/tests/stacked_overlay_bar.dts
 create mode 100644 dtc/tests/stacked_overlay_base.dts
 create mode 100644 dtc/tests/stacked_overlay_base_nolabel.dts
 create mode 100644 dtc/tests/stacked_overlay_baz.dts
 create mode 100644 dtc/tests/string_escapes.c
 create mode 100644 dtc/tests/stringlist.c
 create mode 100644 dtc/tests/stringlist.dts
 create mode 100644 dtc/tests/subnode_iterate.c
 create mode 100644 dtc/tests/subnode_iterate.dts
 create mode 100644 dtc/tests/subnode_offset.c
 create mode 100644 dtc/tests/supernode_atdepth_offset.c
 create mode 100644 dtc/tests/sw_states.c
 create mode 100644 dtc/tests/sw_tree1.c
 create mode 100644 dtc/tests/test01.asm
 create mode 100644 dtc/tests/test01.dts
 create mode 100644 dtc/tests/test01.stderr
 create mode 100755 dtc/tests/test_kernel_dts
 create mode 100644 dtc/tests/test_label_ref.dts
 create mode 100644 dtc/tests/test_props.dts
 create mode 100644 dtc/tests/test_tree1.dts
 create mode 100644 dtc/tests/test_tree1_delete.dts
 create mode 100644 dtc/tests/test_tree1_label_noderef.dts
 create mode 100644 dtc/tests/test_tree1_merge.dts
 create mode 100644 dtc/tests/test_tree1_merge_labelled.dts
 create mode 100644 dtc/tests/test_tree1_merge_path.dts
 create mode 100644 dtc/tests/test_tree1_wrong1.dts
 create mode 100644 dtc/tests/test_tree1_wrong2.dts
 create mode 100644 dtc/tests/test_tree1_wrong3.dts
 create mode 100644 dtc/tests/test_tree1_wrong4.dts
 create mode 100644 dtc/tests/test_tree1_wrong5.dts
 create mode 100644 dtc/tests/test_tree1_wrong6.dts
 create mode 100644 dtc/tests/test_tree1_wrong7.dts
 create mode 100644 dtc/tests/test_tree1_wrong8.dts
 create mode 100644 dtc/tests/test_tree1_wrong9.dts
 create mode 100644 dtc/tests/testdata.h
 create mode 100644 dtc/tests/tests.h
 create mode 100644 dtc/tests/testutils.c
 create mode 100644 dtc/tests/testutils.sh
 create mode 100644 dtc/tests/trees.S
 create mode 100644 dtc/tests/truncated_memrsv.c
 create mode 100644 dtc/tests/truncated_property.c
 create mode 100644 dtc/tests/truncated_string.c
 create mode 100644 dtc/tests/type-preservation.dt.yaml
 create mode 100644 dtc/tests/type-preservation.dts
 create mode 100644 dtc/tests/unit-addr-leading-0s.dts
 create mode 100644 dtc/tests/unit-addr-leading-0x.dts
 create mode 100644 dtc/tests/unit-addr-simple-bus-compatible.dts
 create mode 100644 dtc/tests/unit-addr-simple-bus-reg-mismatch.dts
 create mode 100644 dtc/tests/unit-addr-unique.dts
 create mode 100644 dtc/tests/unit-addr-without-reg.dts
 create mode 100644 dtc/tests/utilfdt_test.c
 create mode 100644 dtc/tests/value-labels.c
 create mode 100644 dtc/tests/value-labels.dts
 create mode 100644 dtc/tests/zero-phandle.dts
 create mode 100644 dtc/treesource.c
 create mode 100644 dtc/util.c
 create mode 100644 dtc/util.h
 create mode 100644 dtc/version_gen.h.in
 create mode 100644 dtc/yamltree.c
 create mode 100644 hw/vfio/cni_fastiov_ioctl.c
 create mode 100644 hw/vfio/cni_fastiov_ioctl.h
 create mode 100644 hw/vfio/cni_logger.c
 create mode 100644 hw/vfio/cni_logger.h
 create mode 100644 imgs/qemu_trace-detail-cost-kata200-barrier.png
 create mode 100644 imgs/qemu_trace-detail-cost-kata400-barrier.png
 create mode 100644 kata.cfg
 create mode 100644 scripts/qapi/__pycache__/__init__.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/commands.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/common.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/error.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/events.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/expr.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/gen.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/introspect.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/main.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/parser.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/schema.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/source.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/types.cpython-36.pyc
 create mode 100644 scripts/qapi/__pycache__/visit.cpython-36.pyc
 create mode 100644 scripts/tracetool/__pycache__/__init__.cpython-36.pyc
 create mode 100644 scripts/tracetool/__pycache__/transform.cpython-36.pyc
 create mode 100644 scripts/tracetool/__pycache__/vcpu.cpython-36.pyc
 create mode 100644 scripts/tracetool/backend/__pycache__/__init__.cpython-36.pyc
 create mode 100644 scripts/tracetool/backend/__pycache__/dtrace.cpython-36.pyc
 create mode 100644 scripts/tracetool/backend/__pycache__/log.cpython-36.pyc
 create mode 100644 scripts/tracetool/format/__pycache__/__init__.cpython-36.pyc
 create mode 100644 scripts/tracetool/format/__pycache__/c.cpython-36.pyc
 create mode 100644 scripts/tracetool/format/__pycache__/h.cpython-36.pyc
 mode change 120000 => 100644 subprojects/libvhost-user/include/atomic.h
 delete mode 120000 subprojects/libvhost-user/standard-headers/linux
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/const.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/ethtool.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/fuse.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/if_ether.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/input-event-codes.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/input.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/kernel.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/pci_regs.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/qemu_fw_cfg.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/sysinfo.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/types.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/udmabuf.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/vhost_types.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_9p.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_balloon.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_blk.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_bt.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_config.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_console.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_crypto.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_fs.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_gpu.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_ids.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_input.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_iommu.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_mem.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_mmio.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_net.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_pci.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_pmem.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_ring.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_rng.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_scsi.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_snd.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_types.h
 create mode 100644 subprojects/libvhost-user/standard-headers/linux/virtio_vsock.h
 create mode 100644 target/ppc/excp_helper.c.orig
 create mode 100644 tools/virtiofsd/build/.hgignore
 create mode 100644 tools/virtiofsd/build/meson-logs/meson-log.txt
 create mode 100644 tools/virtiofsd/build/meson-private/meson.lock
 create mode 100644 ui/keycodemapdb/LICENSE.BSD
 create mode 100644 ui/keycodemapdb/LICENSE.GPL2
 create mode 100644 ui/keycodemapdb/README
 create mode 100644 ui/keycodemapdb/data/README
 create mode 100644 ui/keycodemapdb/data/keymaps.csv
 create mode 100644 ui/keycodemapdb/meson.build
 create mode 100644 ui/keycodemapdb/tests/Makefile
 create mode 100755 ui/keycodemapdb/tests/javascript
 create mode 100755 ui/keycodemapdb/tests/python2
 create mode 100755 ui/keycodemapdb/tests/python3
 create mode 100755 ui/keycodemapdb/tests/rust
 create mode 100644 ui/keycodemapdb/tests/rust-test/Cargo.toml
 create mode 100644 ui/keycodemapdb/tests/rust-test/src/main.rs
 create mode 100644 ui/keycodemapdb/tests/stdc++.cc
 create mode 100644 ui/keycodemapdb/tests/stdc.c
 create mode 100644 ui/keycodemapdb/tests/test.py
 create mode 100644 ui/keycodemapdb/thirdparty/LICENSE-argparse.txt
 create mode 100644 ui/keycodemapdb/thirdparty/__init__.py
 create mode 100644 ui/keycodemapdb/thirdparty/argparse.py
 create mode 100755 ui/keycodemapdb/tools/keymap-gen

diff --git a/.cirrus.yml b/.cirrus.yml
new file mode 100644
index 0000000..02c43a0
--- /dev/null
+++ b/.cirrus.yml
@@ -0,0 +1,110 @@
+env:
+  CIRRUS_CLONE_DEPTH: 1
+
+windows_msys2_task:
+  timeout_in: 90m
+  windows_container:
+    image: cirrusci/windowsservercore:2019
+    os_version: 2019
+    cpu: 8
+    memory: 8G
+  env:
+    CIRRUS_SHELL: powershell
+    MSYS: winsymlinks:nativestrict
+    MSYSTEM: MINGW64
+    MSYS2_URL: https://github.com/msys2/msys2-installer/releases/download/2021-04-19/msys2-base-x86_64-20210419.sfx.exe
+    MSYS2_FINGERPRINT: 0
+    MSYS2_PACKAGES: "
+      diffutils git grep make pkg-config sed
+      mingw-w64-x86_64-python
+      mingw-w64-x86_64-python-sphinx
+      mingw-w64-x86_64-toolchain
+      mingw-w64-x86_64-SDL2
+      mingw-w64-x86_64-SDL2_image
+      mingw-w64-x86_64-gtk3
+      mingw-w64-x86_64-glib2
+      mingw-w64-x86_64-ninja
+      mingw-w64-x86_64-jemalloc
+      mingw-w64-x86_64-lzo2
+      mingw-w64-x86_64-zstd
+      mingw-w64-x86_64-libjpeg-turbo
+      mingw-w64-x86_64-pixman
+      mingw-w64-x86_64-libgcrypt
+      mingw-w64-x86_64-libpng
+      mingw-w64-x86_64-libssh
+      mingw-w64-x86_64-libxml2
+      mingw-w64-x86_64-snappy
+      mingw-w64-x86_64-libusb
+      mingw-w64-x86_64-usbredir
+      mingw-w64-x86_64-libtasn1
+      mingw-w64-x86_64-nettle
+      mingw-w64-x86_64-cyrus-sasl
+      mingw-w64-x86_64-curl
+      mingw-w64-x86_64-gnutls
+      mingw-w64-x86_64-libnfs
+    "
+    CHERE_INVOKING: 1
+  msys2_cache:
+    folder: C:\tools\archive
+    reupload_on_changes: false
+    # These env variables are used to generate fingerprint to trigger the cache procedure
+    # If wanna to force re-populate msys2, increase MSYS2_FINGERPRINT
+    fingerprint_script:
+      - |
+        echo $env:CIRRUS_TASK_NAME
+        echo $env:MSYS2_URL
+        echo $env:MSYS2_FINGERPRINT
+        echo $env:MSYS2_PACKAGES
+    populate_script:
+      - |
+        md -Force C:\tools\archive\pkg
+        $start_time = Get-Date
+        bitsadmin /transfer msys_download /dynamic /download /priority FOREGROUND $env:MSYS2_URL C:\tools\archive\base.exe
+        Write-Output "Download time taken: $((Get-Date).Subtract($start_time))"
+        cd C:\tools
+        C:\tools\archive\base.exe -y
+        del -Force C:\tools\archive\base.exe
+        Write-Output "Base install time taken: $((Get-Date).Subtract($start_time))"
+        $start_time = Get-Date
+
+        ((Get-Content -path C:\tools\msys64\etc\\post-install\\07-pacman-key.post -Raw) -replace '--refresh-keys', '--version') | Set-Content -Path C:\tools\msys64\etc\\post-install\\07-pacman-key.post
+        C:\tools\msys64\usr\bin\bash.exe -lc "sed -i 's/^CheckSpace/#CheckSpace/g' /etc/pacman.conf"
+        C:\tools\msys64\usr\bin\bash.exe -lc "export"
+        C:\tools\msys64\usr\bin\pacman.exe --noconfirm -Sy
+        echo Y | C:\tools\msys64\usr\bin\pacman.exe --noconfirm -Suu --overwrite=*
+        taskkill /F /FI "MODULES eq msys-2.0.dll"
+        tasklist
+        C:\tools\msys64\usr\bin\bash.exe -lc "mv -f /etc/pacman.conf.pacnew /etc/pacman.conf || true"
+        C:\tools\msys64\usr\bin\bash.exe -lc "pacman --noconfirm -Syuu --overwrite=*"
+        Write-Output "Core install time taken: $((Get-Date).Subtract($start_time))"
+        $start_time = Get-Date
+
+        C:\tools\msys64\usr\bin\bash.exe -lc "pacman --noconfirm -S --needed $env:MSYS2_PACKAGES"
+        Write-Output "Package install time taken: $((Get-Date).Subtract($start_time))"
+        $start_time = Get-Date
+
+        del -Force -ErrorAction SilentlyContinue C:\tools\msys64\etc\mtab
+        del -Force -ErrorAction SilentlyContinue C:\tools\msys64\dev\fd
+        del -Force -ErrorAction SilentlyContinue C:\tools\msys64\dev\stderr
+        del -Force -ErrorAction SilentlyContinue C:\tools\msys64\dev\stdin
+        del -Force -ErrorAction SilentlyContinue C:\tools\msys64\dev\stdout
+        del -Force -Recurse -ErrorAction SilentlyContinue C:\tools\msys64\var\cache\pacman\pkg
+        tar cf C:\tools\archive\msys64.tar -C C:\tools\ msys64
+
+        Write-Output "Package archive time taken: $((Get-Date).Subtract($start_time))"
+        del -Force -Recurse -ErrorAction SilentlyContinue c:\tools\msys64 
+  install_script:
+    - |
+      $start_time = Get-Date
+      cd C:\tools
+      ls C:\tools\archive\msys64.tar
+      tar xf C:\tools\archive\msys64.tar
+      Write-Output "Extract msys2 time taken: $((Get-Date).Subtract($start_time))"
+  script:
+    - C:\tools\msys64\usr\bin\bash.exe -lc "mkdir build"
+    - C:\tools\msys64\usr\bin\bash.exe -lc "cd build && ../configure --python=python3"
+    - C:\tools\msys64\usr\bin\bash.exe -lc "cd build && make -j8"
+    - exit $LastExitCode
+  test_script:
+    - C:\tools\msys64\usr\bin\bash.exe -lc "cd build && make V=1 check"
+    - exit $LastExitCode
diff --git a/.dir-locals.el b/.dir-locals.el
new file mode 100644
index 0000000..3ac0cfc
--- /dev/null
+++ b/.dir-locals.el
@@ -0,0 +1,2 @@
+((c-mode . ((c-file-style . "stroustrup")
+	    (indent-tabs-mode . nil))))
diff --git a/.editorconfig b/.editorconfig
new file mode 100644
index 0000000..7303759
--- /dev/null
+++ b/.editorconfig
@@ -0,0 +1,49 @@
+# EditorConfig is a file format and collection of text editor plugins
+# for maintaining consistent coding styles between different editors
+# and IDEs. Most popular editors support this either natively or via
+# plugin.
+#
+# Check https://editorconfig.org for details.
+#
+# Emacs: you need https://github.com/10sr/editorconfig-custom-majormode-el
+# to automatically enable the appropriate major-mode for your files
+# that aren't already caught by your existing config.
+#
+
+root = true
+
+[*]
+end_of_line = lf
+insert_final_newline = true
+charset = utf-8
+
+[*.mak]
+indent_style = tab
+indent_size = 8
+emacs_mode = makefile
+
+[Makefile*]
+indent_style = tab
+indent_size = 8
+emacs_mode = makefile
+
+[*.{c,h,c.inc,h.inc}]
+indent_style = space
+indent_size = 4
+emacs_mode = c
+
+[*.sh]
+indent_style = space
+indent_size = 4
+
+[*.{s,S}]
+indent_style = tab
+indent_size = 8
+emacs_mode = asm
+
+[*.{vert,frag}]
+emacs_mode = glsl
+
+[*.json]
+indent_style = space
+emacs_mode = python
diff --git a/.exrc b/.exrc
new file mode 100644
index 0000000..37755ed
--- /dev/null
+++ b/.exrc
@@ -0,0 +1,7 @@
+"VIM settings to match QEMU coding style.  They are activated by adding the
+"following settings (without the " symbol) as last two lines in $HOME/.vimrc:
+"set secure
+"set exrc
+set expandtab
+set shiftwidth=4
+set smarttab
diff --git a/.gdbinit b/.gdbinit
new file mode 100644
index 0000000..9d322fc
--- /dev/null
+++ b/.gdbinit
@@ -0,0 +1,8 @@
+# GDB may have ./.gdbinit loading disabled by default.  In that case you can
+# follow the instructions it prints.  They boil down to adding the following to
+# your home directory's ~/.gdbinit file:
+#
+#   add-auto-load-safe-path /path/to/qemu/.gdbinit
+
+# Load QEMU-specific sub-commands and settings
+source scripts/qemu-gdb.py
diff --git a/.git-submodule-status b/.git-submodule-status
new file mode 100644
index 0000000..2cc265a
--- /dev/null
+++ b/.git-submodule-status
@@ -0,0 +1,2 @@
+ b6910bec11614980a21e46fbccc35934b671bd81 dtc (v1.6.1)
+ d21009b1c9f94b740ea66be8e48a1d8ad8124023 ui/keycodemapdb (d21009b)
diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..07f430e
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,3 @@
+*.c.inc         diff=c
+*.h.inc         diff=c
+*.py            diff=python
diff --git a/.gitlab-ci.d/buildtest-template.yml b/.gitlab-ci.d/buildtest-template.yml
new file mode 100644
index 0000000..2c7980a
--- /dev/null
+++ b/.gitlab-ci.d/buildtest-template.yml
@@ -0,0 +1,81 @@
+.native_build_job_template:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/$IMAGE:latest
+  before_script:
+    - JOBS=$(expr $(nproc) + 1)
+  script:
+    - if test -n "$LD_JOBS";
+      then
+        scripts/git-submodule.sh update meson ;
+      fi
+    - mkdir build
+    - cd build
+    - if test -n "$TARGETS";
+      then
+        ../configure --enable-werror --disable-docs ${LD_JOBS:+--meson=git} $CONFIGURE_ARGS --target-list="$TARGETS" ;
+      else
+        ../configure --enable-werror --disable-docs ${LD_JOBS:+--meson=git} $CONFIGURE_ARGS ;
+      fi || { cat config.log meson-logs/meson-log.txt && exit 1; }
+    - if test -n "$LD_JOBS";
+      then
+        ../meson/meson.py configure . -Dbackend_max_links="$LD_JOBS" ;
+      fi || exit 1;
+    - make -j"$JOBS"
+    - if test -n "$MAKE_CHECK_ARGS";
+      then
+        make -j"$JOBS" $MAKE_CHECK_ARGS ;
+      fi
+
+.native_test_job_template:
+  stage: test
+  image: $CI_REGISTRY_IMAGE/qemu/$IMAGE:latest
+  script:
+    - scripts/git-submodule.sh update
+        $(sed -n '/GIT_SUBMODULES=/ s/.*=// p' build/config-host.mak)
+    - cd build
+    - find . -type f -exec touch {} +
+    # Avoid recompiling by hiding ninja with NINJA=":"
+    - make NINJA=":" $MAKE_CHECK_ARGS
+
+.avocado_test_job_template:
+  extends: .native_test_job_template
+  cache:
+    key: "${CI_JOB_NAME}-cache"
+    paths:
+      - ${CI_PROJECT_DIR}/avocado-cache
+    policy: pull-push
+  artifacts:
+    name: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG"
+    when: on_failure
+    expire_in: 7 days
+    paths:
+      - build/tests/results/latest/results.xml
+      - build/tests/results/latest/test-results
+    reports:
+      junit: build/tests/results/latest/results.xml
+  before_script:
+    - mkdir -p ~/.config/avocado
+    - echo "[datadir.paths]" > ~/.config/avocado/avocado.conf
+    - echo "cache_dirs = ['${CI_PROJECT_DIR}/avocado-cache']"
+           >> ~/.config/avocado/avocado.conf
+    - echo -e '[job.output.testlogs]\nstatuses = ["FAIL", "INTERRUPT"]'
+           >> ~/.config/avocado/avocado.conf
+    - if [ -d ${CI_PROJECT_DIR}/avocado-cache ]; then
+        du -chs ${CI_PROJECT_DIR}/avocado-cache ;
+      fi
+    - export AVOCADO_ALLOW_UNTRUSTED_CODE=1
+  after_script:
+    - cd build
+    - du -chs ${CI_PROJECT_DIR}/avocado-cache
+  rules:
+    # Only run these jobs if running on the mainstream namespace,
+    # or if the user set the QEMU_CI_AVOCADO_TESTING variable (either
+    # in its namespace setting or via git-push option, see documentation
+    # in /.gitlab-ci.yml of this repository).
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project"'
+      when: on_success
+    - if: '$QEMU_CI_AVOCADO_TESTING'
+      when: on_success
+    # Otherwise, set to manual (the jobs are created but not run).
+    - when: manual
+      allow_failure: true
diff --git a/.gitlab-ci.d/buildtest.yml b/.gitlab-ci.d/buildtest.yml
new file mode 100644
index 0000000..71d0f40
--- /dev/null
+++ b/.gitlab-ci.d/buildtest.yml
@@ -0,0 +1,649 @@
+include:
+  - local: '/.gitlab-ci.d/buildtest-template.yml'
+
+build-system-alpine:
+  extends: .native_build_job_template
+  needs:
+    - job: amd64-alpine-container
+  variables:
+    IMAGE: alpine
+    TARGETS: aarch64-softmmu alpha-softmmu cris-softmmu hppa-softmmu
+      microblazeel-softmmu mips64el-softmmu
+    MAKE_CHECK_ARGS: check-build
+    CONFIGURE_ARGS: --enable-docs --enable-trace-backends=log,simple,syslog
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - .git-submodule-status
+      - build
+
+check-system-alpine:
+  extends: .native_test_job_template
+  needs:
+    - job: build-system-alpine
+      artifacts: true
+  variables:
+    IMAGE: alpine
+    MAKE_CHECK_ARGS: check
+
+avocado-system-alpine:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-system-alpine
+      artifacts: true
+  variables:
+    IMAGE: alpine
+    MAKE_CHECK_ARGS: check-avocado
+
+build-system-ubuntu:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-ubuntu2004-container
+  variables:
+    IMAGE: ubuntu2004
+    CONFIGURE_ARGS: --enable-docs --enable-fdt=system --enable-slirp=system
+    TARGETS: aarch64-softmmu alpha-softmmu cris-softmmu hppa-softmmu
+      microblazeel-softmmu mips64el-softmmu
+    MAKE_CHECK_ARGS: check-build
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+check-system-ubuntu:
+  extends: .native_test_job_template
+  needs:
+    - job: build-system-ubuntu
+      artifacts: true
+  variables:
+    IMAGE: ubuntu2004
+    MAKE_CHECK_ARGS: check
+
+avocado-system-ubuntu:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-system-ubuntu
+      artifacts: true
+  variables:
+    IMAGE: ubuntu2004
+    MAKE_CHECK_ARGS: check-avocado
+
+build-system-debian:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-container
+  variables:
+    IMAGE: debian-amd64
+    TARGETS: arm-softmmu avr-softmmu i386-softmmu mipsel-softmmu
+      riscv64-softmmu sh4eb-softmmu sparc-softmmu xtensaeb-softmmu
+    MAKE_CHECK_ARGS: check-build
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+check-system-debian:
+  extends: .native_test_job_template
+  needs:
+    - job: build-system-debian
+      artifacts: true
+  variables:
+    IMAGE: debian-amd64
+    MAKE_CHECK_ARGS: check
+
+avocado-system-debian:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-system-debian
+      artifacts: true
+  variables:
+    IMAGE: debian-amd64
+    MAKE_CHECK_ARGS: check-avocado
+
+build-system-fedora:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-fedora-container
+  variables:
+    IMAGE: fedora
+    CONFIGURE_ARGS: --disable-gcrypt --enable-nettle --enable-docs
+             --enable-fdt=system --enable-slirp=system --enable-capstone=system
+    TARGETS: tricore-softmmu microblaze-softmmu mips-softmmu
+      xtensa-softmmu m68k-softmmu riscv32-softmmu ppc-softmmu sparc64-softmmu
+    MAKE_CHECK_ARGS: check-build
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+check-system-fedora:
+  extends: .native_test_job_template
+  needs:
+    - job: build-system-fedora
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check
+
+avocado-system-fedora:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-system-fedora
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check-avocado
+
+build-system-centos:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-centos8-container
+  variables:
+    IMAGE: centos8
+    CONFIGURE_ARGS: --disable-nettle --enable-gcrypt --enable-fdt=system
+                    --enable-modules --enable-trace-backends=dtrace
+    TARGETS: ppc64-softmmu or1k-softmmu s390x-softmmu
+      x86_64-softmmu rx-softmmu sh4-softmmu nios2-softmmu
+    MAKE_CHECK_ARGS: check-build
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+check-system-centos:
+  extends: .native_test_job_template
+  needs:
+    - job: build-system-centos
+      artifacts: true
+  variables:
+    IMAGE: centos8
+    MAKE_CHECK_ARGS: check
+
+avocado-system-centos:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-system-centos
+      artifacts: true
+  variables:
+    IMAGE: centos8
+    MAKE_CHECK_ARGS: check-avocado
+
+build-system-opensuse:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-opensuse-leap-container
+  variables:
+    IMAGE: opensuse-leap
+    CONFIGURE_ARGS: --enable-fdt=system
+    TARGETS: s390x-softmmu x86_64-softmmu aarch64-softmmu
+    MAKE_CHECK_ARGS: check-build
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+check-system-opensuse:
+  extends: .native_test_job_template
+  needs:
+    - job: build-system-opensuse
+      artifacts: true
+  variables:
+    IMAGE: opensuse-leap
+    MAKE_CHECK_ARGS: check
+
+avocado-system-opensuse:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-system-opensuse
+      artifacts: true
+  variables:
+    IMAGE: opensuse-leap
+    MAKE_CHECK_ARGS: check-avocado
+
+
+# This jobs explicitly disable TCG (--disable-tcg), KVM is detected by
+# the configure script. The container doesn't contain Xen headers so
+# Xen accelerator is not detected / selected. As result it build the
+# i386-softmmu and x86_64-softmmu with KVM being the single accelerator
+# available.
+# Also use a different coroutine implementation (which is only really of
+# interest to KVM users, i.e. with TCG disabled)
+build-tcg-disabled:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-centos8-container
+  variables:
+    IMAGE: centos8
+  script:
+    - mkdir build
+    - cd build
+    - ../configure --disable-tcg --audio-drv-list="" --with-coroutine=ucontext
+      || { cat config.log meson-logs/meson-log.txt && exit 1; }
+    - make -j"$JOBS"
+    - make check-unit
+    - make check-qapi-schema
+    - cd tests/qemu-iotests/
+    - ./check -raw 001 002 003 004 005 008 009 010 011 012 021 025 032 033 048
+            052 063 077 086 101 104 106 113 148 150 151 152 157 159 160 163
+            170 171 183 184 192 194 208 221 226 227 236 253 277 image-fleecing
+    - ./check -qcow2 028 051 056 057 058 065 068 082 085 091 095 096 102 122
+            124 132 139 142 144 145 151 152 155 157 165 194 196 200 202
+            208 209 216 218 227 234 246 247 248 250 254 255 257 258
+            260 261 262 263 264 270 272 273 277 279 image-fleecing
+
+build-user:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-user-cross-container
+  variables:
+    IMAGE: debian-all-test-cross
+    CONFIGURE_ARGS: --disable-tools --disable-system
+    MAKE_CHECK_ARGS: check-tcg
+
+build-user-static:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-user-cross-container
+  variables:
+    IMAGE: debian-all-test-cross
+    CONFIGURE_ARGS: --disable-tools --disable-system --static
+    MAKE_CHECK_ARGS: check-tcg
+
+# Because the hexagon cross-compiler takes so long to build we don't rely
+# on the CI system to build it and hence this job has an optional dependency
+# declared. The image is manually uploaded.
+build-user-hexagon:
+  extends: .native_build_job_template
+  needs:
+    job: hexagon-cross-container
+    optional: true
+  variables:
+    IMAGE: debian-hexagon-cross
+    TARGETS: hexagon-linux-user
+    CONFIGURE_ARGS: --disable-tools --disable-docs --enable-debug-tcg
+    MAKE_CHECK_ARGS: check-tcg
+
+# Only build the softmmu targets we have check-tcg tests for
+build-some-softmmu:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-user-cross-container
+  variables:
+    IMAGE: debian-all-test-cross
+    CONFIGURE_ARGS: --disable-tools --enable-debug
+    TARGETS: xtensa-softmmu arm-softmmu aarch64-softmmu alpha-softmmu
+    MAKE_CHECK_ARGS: check-tcg
+
+# We build tricore in a very minimal tricore only container
+build-tricore-softmmu:
+  extends: .native_build_job_template
+  needs:
+    job: tricore-debian-cross-container
+  variables:
+    IMAGE: debian-tricore-cross
+    CONFIGURE_ARGS: --disable-tools --disable-fdt --enable-debug
+    TARGETS: tricore-softmmu
+    MAKE_CHECK_ARGS: check-tcg
+
+clang-system:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-fedora-container
+  variables:
+    IMAGE: fedora
+    CONFIGURE_ARGS: --cc=clang --cxx=clang++
+      --extra-cflags=-fsanitize=undefined --extra-cflags=-fno-sanitize-recover=undefined
+    TARGETS: alpha-softmmu arm-softmmu m68k-softmmu mips64-softmmu
+      ppc-softmmu s390x-softmmu
+    MAKE_CHECK_ARGS: check-qtest check-tcg
+
+clang-user:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-user-cross-container
+  variables:
+    IMAGE: debian-all-test-cross
+    CONFIGURE_ARGS: --cc=clang --cxx=clang++ --disable-system
+      --target-list-exclude=microblazeel-linux-user,aarch64_be-linux-user,i386-linux-user,m68k-linux-user,mipsn32el-linux-user,xtensaeb-linux-user
+      --extra-cflags=-fsanitize=undefined --extra-cflags=-fno-sanitize-recover=undefined
+    MAKE_CHECK_ARGS: check-unit check-tcg
+
+# Set LD_JOBS=1 because this requires LTO and ld consumes a large amount of memory.
+# On gitlab runners, default value sometimes end up calling 2 lds concurrently and
+# triggers an Out-Of-Memory error
+#
+# Since slirp callbacks are used in QEMU Timers, slirp needs to be compiled together
+# with QEMU and linked as a static library to avoid false positives in CFI checks.
+# This can be accomplished by using -enable-slirp=git, which avoids the use of
+# a system-wide version of the library
+#
+# Split in three sets of build/check/avocado to limit the execution time of each
+# job
+build-cfi-aarch64:
+  extends: .native_build_job_template
+  needs:
+  - job: amd64-fedora-container
+  variables:
+    LD_JOBS: 1
+    AR: llvm-ar
+    IMAGE: fedora
+    CONFIGURE_ARGS: --cc=clang --cxx=clang++ --enable-cfi --enable-cfi-debug
+      --enable-safe-stack --enable-slirp=git
+    TARGETS: aarch64-softmmu
+    MAKE_CHECK_ARGS: check-build
+  timeout: 70m
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+  rules:
+    # FIXME: This job is often failing, likely due to out-of-memory problems in
+    # the constrained containers of the shared runners. Thus this is marked as
+    # manual until the situation has been solved.
+    - when: manual
+      allow_failure: true
+
+check-cfi-aarch64:
+  extends: .native_test_job_template
+  needs:
+    - job: build-cfi-aarch64
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check
+
+avocado-cfi-aarch64:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-cfi-aarch64
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check-avocado
+
+build-cfi-ppc64-s390x:
+  extends: .native_build_job_template
+  needs:
+  - job: amd64-fedora-container
+  variables:
+    LD_JOBS: 1
+    AR: llvm-ar
+    IMAGE: fedora
+    CONFIGURE_ARGS: --cc=clang --cxx=clang++ --enable-cfi --enable-cfi-debug
+      --enable-safe-stack --enable-slirp=git
+    TARGETS: ppc64-softmmu s390x-softmmu
+    MAKE_CHECK_ARGS: check-build
+  timeout: 70m
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+  rules:
+    # FIXME: This job is often failing, likely due to out-of-memory problems in
+    # the constrained containers of the shared runners. Thus this is marked as
+    # manual until the situation has been solved.
+    - when: manual
+      allow_failure: true
+
+check-cfi-ppc64-s390x:
+  extends: .native_test_job_template
+  needs:
+    - job: build-cfi-ppc64-s390x
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check
+
+avocado-cfi-ppc64-s390x:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-cfi-ppc64-s390x
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check-avocado
+
+build-cfi-x86_64:
+  extends: .native_build_job_template
+  needs:
+  - job: amd64-fedora-container
+  variables:
+    LD_JOBS: 1
+    AR: llvm-ar
+    IMAGE: fedora
+    CONFIGURE_ARGS: --cc=clang --cxx=clang++ --enable-cfi --enable-cfi-debug
+      --enable-safe-stack --enable-slirp=git
+    TARGETS: x86_64-softmmu
+    MAKE_CHECK_ARGS: check-build
+  timeout: 70m
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+check-cfi-x86_64:
+  extends: .native_test_job_template
+  needs:
+    - job: build-cfi-x86_64
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check
+
+avocado-cfi-x86_64:
+  extends: .avocado_test_job_template
+  needs:
+    - job: build-cfi-x86_64
+      artifacts: true
+  variables:
+    IMAGE: fedora
+    MAKE_CHECK_ARGS: check-avocado
+
+tsan-build:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-ubuntu2004-container
+  variables:
+    IMAGE: ubuntu2004
+    CONFIGURE_ARGS: --enable-tsan --cc=clang-10 --cxx=clang++-10
+          --enable-trace-backends=ust --enable-fdt=system --enable-slirp=system
+    TARGETS: x86_64-softmmu ppc64-softmmu riscv64-softmmu x86_64-linux-user
+    MAKE_CHECK_ARGS: bench V=1
+
+# These targets are on the way out
+build-deprecated:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-user-cross-container
+  variables:
+    IMAGE: debian-all-test-cross
+    CONFIGURE_ARGS: --disable-tools
+    MAKE_CHECK_ARGS: build-tcg
+    TARGETS: ppc64abi32-linux-user
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+# We split the check-tcg step as test failures are expected but we still
+# want to catch the build breaking.
+check-deprecated:
+  extends: .native_test_job_template
+  needs:
+    - job: build-deprecated
+      artifacts: true
+  variables:
+    IMAGE: debian-all-test-cross
+    MAKE_CHECK_ARGS: check-tcg
+  allow_failure: true
+
+# gprof/gcov are GCC features
+build-gprof-gcov:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-ubuntu2004-container
+  variables:
+    IMAGE: ubuntu2004
+    CONFIGURE_ARGS: --enable-gprof --enable-gcov
+    TARGETS: aarch64-softmmu ppc64-softmmu s390x-softmmu x86_64-softmmu
+  artifacts:
+    expire_in: 1 days
+    paths:
+      - build
+
+check-gprof-gcov:
+  extends: .native_test_job_template
+  needs:
+    - job: build-gprof-gcov
+      artifacts: true
+  variables:
+    IMAGE: ubuntu2004
+    MAKE_CHECK_ARGS: check
+  after_script:
+    - ${CI_PROJECT_DIR}/scripts/ci/coverage-summary.sh
+
+build-oss-fuzz:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-fedora-container
+  variables:
+    IMAGE: fedora
+  script:
+    - mkdir build-oss-fuzz
+    - CC="clang" CXX="clang++" CFLAGS="-fsanitize=address"
+      ./scripts/oss-fuzz/build.sh
+    - export ASAN_OPTIONS="fast_unwind_on_malloc=0"
+    - for fuzzer in $(find ./build-oss-fuzz/DEST_DIR/ -executable -type f
+                      | grep -v slirp); do
+        grep "LLVMFuzzerTestOneInput" ${fuzzer} > /dev/null 2>&1 || continue ;
+        echo Testing ${fuzzer} ... ;
+        "${fuzzer}" -runs=1 -seed=1 || exit 1 ;
+      done
+    # Unrelated to fuzzer: run some tests with -fsanitize=address
+    - cd build-oss-fuzz && make check-qtest-i386 check-unit
+
+build-tci:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-user-cross-container
+  variables:
+    IMAGE: debian-all-test-cross
+  script:
+    - TARGETS="aarch64 alpha arm hppa m68k microblaze ppc64 s390x x86_64"
+    - mkdir build
+    - cd build
+    - ../configure --enable-tcg-interpreter
+        --target-list="$(for tg in $TARGETS; do echo -n ${tg}'-softmmu '; done)" || { cat config.log meson-logs/meson-log.txt && exit 1; }
+    - make -j"$JOBS"
+    - make tests/qtest/boot-serial-test tests/qtest/cdrom-test tests/qtest/pxe-test
+    - for tg in $TARGETS ; do
+        export QTEST_QEMU_BINARY="./qemu-system-${tg}" ;
+        ./tests/qtest/boot-serial-test || exit 1 ;
+        ./tests/qtest/cdrom-test || exit 1 ;
+      done
+    - QTEST_QEMU_BINARY="./qemu-system-x86_64" ./tests/qtest/pxe-test
+    - QTEST_QEMU_BINARY="./qemu-system-s390x" ./tests/qtest/pxe-test -m slow
+    - make check-tcg
+
+# Alternate coroutines implementations are only really of interest to KVM users
+# However we can't test against KVM on Gitlab-CI so we can only run unit tests
+build-coroutine-sigaltstack:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-ubuntu2004-container
+  variables:
+    IMAGE: ubuntu2004
+    CONFIGURE_ARGS: --with-coroutine=sigaltstack --disable-tcg
+                    --enable-trace-backends=ftrace
+    MAKE_CHECK_ARGS: check-unit
+
+# Check our reduced build configurations
+build-without-default-devices:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-centos8-container
+  variables:
+    IMAGE: centos8
+    CONFIGURE_ARGS: --without-default-devices --disable-user
+
+build-without-default-features:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-fedora-container
+  variables:
+    IMAGE: fedora
+    CONFIGURE_ARGS:
+      --without-default-features
+      --disable-capstone
+      --disable-pie
+      --disable-qom-cast-debug
+      --disable-slirp
+      --disable-strip
+    TARGETS: avr-softmmu i386-softmmu mips64-softmmu s390x-softmmu sh4-softmmu
+      sparc64-softmmu hexagon-linux-user i386-linux-user s390x-linux-user
+    MAKE_CHECK_ARGS: check-unit check-qtest SPEED=slow
+
+build-libvhost-user:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/fedora:latest
+  needs:
+    job: amd64-fedora-container
+  script:
+    - mkdir subprojects/libvhost-user/build
+    - cd subprojects/libvhost-user/build
+    - meson
+    - ninja
+
+# No targets are built here, just tools, docs, and unit tests. This
+# also feeds into the eventual documentation deployment steps later
+build-tools-and-docs-debian:
+  extends: .native_build_job_template
+  needs:
+    job: amd64-debian-container
+  variables:
+    IMAGE: debian-amd64
+    MAKE_CHECK_ARGS: check-unit check-softfloat ctags TAGS cscope
+    CONFIGURE_ARGS: --disable-system --disable-user --enable-docs --enable-tools
+  artifacts:
+    expire_in: 2 days
+    paths:
+      - build
+
+# Prepare for GitLab pages deployment. Anything copied into the
+# "public" directory will be deployed to $USER.gitlab.io/$PROJECT
+#
+# GitLab publishes from any branch that triggers a CI pipeline
+#
+# For the main repo we don't want to publish from 'staging'
+# since that content may not be pushed, nor do we wish to
+# publish from 'stable-NNN' branches as that content is outdated.
+# Thus we restrict to just the default branch
+#
+# For contributor forks we want to publish from any repo so
+# that users can see the results of their commits, regardless
+# of what topic branch they're currently using
+pages:
+  image: $CI_REGISTRY_IMAGE/qemu/debian-amd64:latest
+  stage: test
+  needs:
+    - job: build-tools-and-docs-debian
+  script:
+    - mkdir -p public
+    # HTML-ised source tree
+    - make gtags
+    - htags -anT --tree-view=filetree -m qemu_init
+        -t "Welcome to the QEMU sourcecode"
+    - mv HTML public/src
+    # Project documentation
+    - make -C build install DESTDIR=$(pwd)/temp-install
+    - mv temp-install/usr/local/share/doc/qemu/* public/
+  artifacts:
+    paths:
+      - public
+  rules:
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
+      when: on_success
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project"'
+      when: never
+    - if: '$CI_PROJECT_NAMESPACE != "qemu-project"'
+      when: on_success
diff --git a/.gitlab-ci.d/check-dco.py b/.gitlab-ci.d/check-dco.py
new file mode 100755
index 0000000..632c8bc
--- /dev/null
+++ b/.gitlab-ci.d/check-dco.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python3
+#
+# check-dco.py: validate all commits are signed off
+#
+# Copyright (C) 2020 Red Hat, Inc.
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+import os
+import os.path
+import sys
+import subprocess
+
+namespace = "qemu-project"
+if len(sys.argv) >= 2:
+    namespace = sys.argv[1]
+
+cwd = os.getcwd()
+reponame = os.path.basename(cwd)
+repourl = "https://gitlab.com/%s/%s.git" % (namespace, reponame)
+
+subprocess.check_call(["git", "remote", "add", "check-dco", repourl])
+subprocess.check_call(["git", "fetch", "check-dco", "master"],
+                      stdout=subprocess.DEVNULL,
+                      stderr=subprocess.DEVNULL)
+
+ancestor = subprocess.check_output(["git", "merge-base",
+                                    "check-dco/master", "HEAD"],
+                                   universal_newlines=True)
+
+ancestor = ancestor.strip()
+
+subprocess.check_call(["git", "remote", "rm", "check-dco"])
+
+errors = False
+
+print("\nChecking for 'Signed-off-by: NAME <EMAIL>' " +
+      "on all commits since %s...\n" % ancestor)
+
+log = subprocess.check_output(["git", "log", "--format=%H %s",
+                               ancestor + "..."],
+                              universal_newlines=True)
+
+if log == "":
+    commits = []
+else:
+    commits = [[c[0:40], c[41:]] for c in log.strip().split("\n")]
+
+for sha, subject in commits:
+
+    msg = subprocess.check_output(["git", "show", "-s", sha],
+                                  universal_newlines=True)
+    lines = msg.strip().split("\n")
+
+    print(" %s %s" % (sha, subject))
+    sob = False
+    for line in lines:
+        if "Signed-off-by:" in line:
+            sob = True
+            if "localhost" in line:
+                print("     FAIL: bad email in %s" % line)
+                errors = True
+
+    if not sob:
+        print("     FAIL missing Signed-off-by tag")
+        errors = True
+
+if errors:
+    print("""
+
+ ERROR: One or more commits are missing a valid Signed-off-By tag.
+
+
+This project requires all contributors to assert that their contributions
+are provided in compliance with the terms of the Developer's Certificate
+of Origin 1.1 (DCO):
+
+  https://developercertificate.org/
+
+To indicate acceptance of the DCO every commit must have a tag
+
+  Signed-off-by: REAL NAME <EMAIL>
+
+This can be achieved by passing the "-s" flag to the "git commit" command.
+
+To bulk update all commits on current branch "git rebase" can be used:
+
+  git rebase -i master -x 'git commit --amend --no-edit -s'
+
+""")
+
+    sys.exit(1)
+
+sys.exit(0)
diff --git a/.gitlab-ci.d/check-patch.py b/.gitlab-ci.d/check-patch.py
new file mode 100755
index 0000000..39e2b40
--- /dev/null
+++ b/.gitlab-ci.d/check-patch.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+#
+# check-patch.py: run checkpatch.pl across all commits in a branch
+#
+# Copyright (C) 2020 Red Hat, Inc.
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+import os
+import os.path
+import sys
+import subprocess
+
+namespace = "qemu-project"
+if len(sys.argv) >= 2:
+    namespace = sys.argv[1]
+
+cwd = os.getcwd()
+reponame = os.path.basename(cwd)
+repourl = "https://gitlab.com/%s/%s.git" % (namespace, reponame)
+
+# GitLab CI environment does not give us any direct info about the
+# base for the user's branch. We thus need to figure out a common
+# ancestor between the user's branch and current git master.
+subprocess.check_call(["git", "remote", "add", "check-patch", repourl])
+subprocess.check_call(["git", "fetch", "check-patch", "master"],
+                      stdout=subprocess.DEVNULL,
+                      stderr=subprocess.DEVNULL)
+
+ancestor = subprocess.check_output(["git", "merge-base",
+                                    "check-patch/master", "HEAD"],
+                                   universal_newlines=True)
+
+ancestor = ancestor.strip()
+
+log = subprocess.check_output(["git", "log", "--format=%H %s",
+                               ancestor + "..."],
+                              universal_newlines=True)
+
+subprocess.check_call(["git", "remote", "rm", "check-patch"])
+
+if log == "":
+    print("\nNo commits since %s, skipping checks\n" % ancestor)
+    sys.exit(0)
+
+errors = False
+
+print("\nChecking all commits since %s...\n" % ancestor, flush=True)
+
+ret = subprocess.run(["scripts/checkpatch.pl", "--terse", ancestor + "..."])
+
+if ret.returncode != 0:
+    print("     FAIL one or more commits failed scripts/checkpatch.pl")
+    sys.exit(1)
+
+sys.exit(0)
diff --git a/.gitlab-ci.d/cirrus.yml b/.gitlab-ci.d/cirrus.yml
new file mode 100644
index 0000000..d273a9e
--- /dev/null
+++ b/.gitlab-ci.d/cirrus.yml
@@ -0,0 +1,91 @@
+# Jobs that we delegate to Cirrus CI because they require an operating
+# system other than Linux. These jobs will only run if the required
+# setup has been performed on the GitLab account.
+#
+# The Cirrus CI configuration is generated by replacing target-specific
+# variables in a generic template: some of these variables are provided
+# when the GitLab CI job is defined, others are taken from a shell
+# snippet generated using lcitool.
+#
+# Note that the $PATH environment variable has to be treated with
+# special care, because we can't just override it at the GitLab CI job
+# definition level or we risk breaking it completely.
+.cirrus_build_job:
+  stage: build
+  image: registry.gitlab.com/libvirt/libvirt-ci/cirrus-run:master
+  needs: []
+  timeout: 80m
+  allow_failure: true
+  script:
+    - source .gitlab-ci.d/cirrus/$NAME.vars
+    - sed -e "s|[@]CI_REPOSITORY_URL@|$CI_REPOSITORY_URL|g"
+          -e "s|[@]CI_COMMIT_REF_NAME@|$CI_COMMIT_REF_NAME|g"
+          -e "s|[@]CI_COMMIT_SHA@|$CI_COMMIT_SHA|g"
+          -e "s|[@]CIRRUS_VM_INSTANCE_TYPE@|$CIRRUS_VM_INSTANCE_TYPE|g"
+          -e "s|[@]CIRRUS_VM_IMAGE_SELECTOR@|$CIRRUS_VM_IMAGE_SELECTOR|g"
+          -e "s|[@]CIRRUS_VM_IMAGE_NAME@|$CIRRUS_VM_IMAGE_NAME|g"
+          -e "s|[@]CIRRUS_VM_CPUS@|$CIRRUS_VM_CPUS|g"
+          -e "s|[@]CIRRUS_VM_RAM@|$CIRRUS_VM_RAM|g"
+          -e "s|[@]UPDATE_COMMAND@|$UPDATE_COMMAND|g"
+          -e "s|[@]INSTALL_COMMAND@|$INSTALL_COMMAND|g"
+          -e "s|[@]PATH@|$PATH_EXTRA${PATH_EXTRA:+:}\$PATH|g"
+          -e "s|[@]PKG_CONFIG_PATH@|$PKG_CONFIG_PATH|g"
+          -e "s|[@]PKGS@|$PKGS|g"
+          -e "s|[@]MAKE@|$MAKE|g"
+          -e "s|[@]PYTHON@|$PYTHON|g"
+          -e "s|[@]PIP3@|$PIP3|g"
+          -e "s|[@]PYPI_PKGS@|$PYPI_PKGS|g"
+          -e "s|[@]CONFIGURE_ARGS@|$CONFIGURE_ARGS|g"
+          -e "s|[@]TEST_TARGETS@|$TEST_TARGETS|g"
+      <.gitlab-ci.d/cirrus/build.yml >.gitlab-ci.d/cirrus/$NAME.yml
+    - cat .gitlab-ci.d/cirrus/$NAME.yml
+    - cirrus-run -v --show-build-log always .gitlab-ci.d/cirrus/$NAME.yml
+  rules:
+    # Allow on 'staging' branch and 'stable-X.Y-staging' branches only
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH !~ /staging/'
+      when: never
+    - if: "$CIRRUS_GITHUB_REPO && $CIRRUS_API_TOKEN"
+
+x64-freebsd-12-build:
+  extends: .cirrus_build_job
+  variables:
+    NAME: freebsd-12
+    CIRRUS_VM_INSTANCE_TYPE: freebsd_instance
+    CIRRUS_VM_IMAGE_SELECTOR: image_family
+    CIRRUS_VM_IMAGE_NAME: freebsd-12-2
+    CIRRUS_VM_CPUS: 8
+    CIRRUS_VM_RAM: 8G
+    UPDATE_COMMAND: pkg update
+    INSTALL_COMMAND: pkg install -y
+    # TODO: Enable gnutls again once FreeBSD's libtasn1 got fixed
+    # See: https://gitlab.com/gnutls/libtasn1/-/merge_requests/71
+    CONFIGURE_ARGS: --disable-gnutls
+    TEST_TARGETS: check
+
+x64-freebsd-13-build:
+  extends: .cirrus_build_job
+  variables:
+    NAME: freebsd-13
+    CIRRUS_VM_INSTANCE_TYPE: freebsd_instance
+    CIRRUS_VM_IMAGE_SELECTOR: image_family
+    CIRRUS_VM_IMAGE_NAME: freebsd-13-0
+    CIRRUS_VM_CPUS: 8
+    CIRRUS_VM_RAM: 8G
+    UPDATE_COMMAND: pkg update
+    INSTALL_COMMAND: pkg install -y
+    TEST_TARGETS: check
+
+x64-macos-11-base-build:
+  extends: .cirrus_build_job
+  variables:
+    NAME: macos-11
+    CIRRUS_VM_INSTANCE_TYPE: osx_instance
+    CIRRUS_VM_IMAGE_SELECTOR: image
+    CIRRUS_VM_IMAGE_NAME: big-sur-base
+    CIRRUS_VM_CPUS: 12
+    CIRRUS_VM_RAM: 24G
+    UPDATE_COMMAND: brew update
+    INSTALL_COMMAND: brew install
+    PATH_EXTRA: /usr/local/opt/ccache/libexec:/usr/local/opt/gettext/bin
+    PKG_CONFIG_PATH: /usr/local/opt/curl/lib/pkgconfig:/usr/local/opt/ncurses/lib/pkgconfig:/usr/local/opt/readline/lib/pkgconfig
+    TEST_TARGETS: check-unit check-block check-qapi-schema check-softfloat check-qtest-x86_64
diff --git a/.gitlab-ci.d/cirrus/README.rst b/.gitlab-ci.d/cirrus/README.rst
new file mode 100644
index 0000000..657b070
--- /dev/null
+++ b/.gitlab-ci.d/cirrus/README.rst
@@ -0,0 +1,54 @@
+Cirrus CI integration
+=====================
+
+GitLab CI shared runners only provide a docker environment running on Linux.
+While it is possible to provide private runners for non-Linux platforms this
+is not something most contributors/maintainers will wish to do.
+
+To work around this limitation, we take advantage of `Cirrus CI`_'s free
+offering: more specifically, we use the `cirrus-run`_ script to trigger Cirrus
+CI jobs from GitLab CI jobs so that Cirrus CI job output is integrated into
+the main GitLab CI pipeline dashboard.
+
+There is, however, some one-time setup required. If you want FreeBSD and macOS
+builds to happen when you push to your GitLab repository, you need to
+
+* set up a GitHub repository for the project, eg. ``yourusername/qemu``.
+  This repository needs to exist for cirrus-run to work, but it doesn't need to
+  be kept up to date, so you can create it and then forget about it;
+
+* enable the `Cirrus CI GitHub app`_  for your GitHub account;
+
+* sign up for Cirrus CI. It's enough to log into the website using your GitHub
+  account;
+
+* grab an API token from the `Cirrus CI settings`_ page;
+
+* it may be necessary to push an empty ``.cirrus.yml`` file to your github fork
+  for Cirrus CI to properly recognize the project. You can check whether
+  Cirrus CI knows about your project by navigating to:
+
+  ``https://cirrus-ci.com/yourusername/qemu``
+
+* in the *CI/CD / Variables* section of the settings page for your GitLab
+  repository, create two new variables:
+
+  * ``CIRRUS_GITHUB_REPO``, containing the name of the GitHub repository
+    created earlier, eg. ``yourusername/qemu``;
+
+  * ``CIRRUS_API_TOKEN``, containing the Cirrus CI API token generated earlier.
+    This variable **must** be marked as *Masked*, because anyone with knowledge
+    of it can impersonate you as far as Cirrus CI is concerned.
+
+  Neither of these variables should be marked as *Protected*, because in
+  general you'll want to be able to trigger Cirrus CI builds from non-protected
+  branches.
+
+Once this one-time setup is complete, you can just keep pushing to your GitLab
+repository as usual and you'll automatically get the additional CI coverage.
+
+
+.. _Cirrus CI GitHub app: https://github.com/marketplace/cirrus-ci
+.. _Cirrus CI settings: https://cirrus-ci.com/settings/profile/
+.. _Cirrus CI: https://cirrus-ci.com/
+.. _cirrus-run: https://github.com/sio/cirrus-run/
diff --git a/.gitlab-ci.d/cirrus/build.yml b/.gitlab-ci.d/cirrus/build.yml
new file mode 100644
index 0000000..c555f5d
--- /dev/null
+++ b/.gitlab-ci.d/cirrus/build.yml
@@ -0,0 +1,36 @@
+@CIRRUS_VM_INSTANCE_TYPE@:
+  @CIRRUS_VM_IMAGE_SELECTOR@: @CIRRUS_VM_IMAGE_NAME@
+  cpu: @CIRRUS_VM_CPUS@
+  memory: @CIRRUS_VM_RAM@
+
+env:
+  CIRRUS_CLONE_DEPTH: 1
+  CI_REPOSITORY_URL: "@CI_REPOSITORY_URL@"
+  CI_COMMIT_REF_NAME: "@CI_COMMIT_REF_NAME@"
+  CI_COMMIT_SHA: "@CI_COMMIT_SHA@"
+  PATH: "@PATH@"
+  PKG_CONFIG_PATH: "@PKG_CONFIG_PATH@"
+  PYTHON: "@PYTHON@"
+  MAKE: "@MAKE@"
+  CONFIGURE_ARGS: "@CONFIGURE_ARGS@"
+  TEST_TARGETS: "@TEST_TARGETS@"
+
+build_task:
+  install_script:
+    - @UPDATE_COMMAND@
+    - @INSTALL_COMMAND@ @PKGS@
+    - if test -n "@PYPI_PKGS@" ; then @PIP3@ install @PYPI_PKGS@ ; fi
+  clone_script:
+    - git clone --depth 100 "$CI_REPOSITORY_URL" .
+    - git fetch origin "$CI_COMMIT_REF_NAME"
+    - git reset --hard "$CI_COMMIT_SHA"
+  build_script:
+    - mkdir build
+    - cd build
+    - ../configure --enable-werror $CONFIGURE_ARGS
+      || { cat config.log meson-logs/meson-log.txt; exit 1; }
+    - $MAKE -j$(sysctl -n hw.ncpu)
+    - for TARGET in $TEST_TARGETS ;
+      do
+        $MAKE -j$(sysctl -n hw.ncpu) $TARGET V=1 ;
+      done
diff --git a/.gitlab-ci.d/cirrus/freebsd-12.vars b/.gitlab-ci.d/cirrus/freebsd-12.vars
new file mode 100644
index 0000000..2099b21
--- /dev/null
+++ b/.gitlab-ci.d/cirrus/freebsd-12.vars
@@ -0,0 +1,13 @@
+# THIS FILE WAS AUTO-GENERATED
+#
+#  $ lcitool variables freebsd-12 qemu
+#
+# https://gitlab.com/libvirt/libvirt-ci/-/commit/c7e275ab27ac0dcd09da290817b9adeea1fd1eb1
+
+PACKAGING_COMMAND='pkg'
+CCACHE='/usr/local/bin/ccache'
+MAKE='/usr/local/bin/gmake'
+NINJA='/usr/local/bin/ninja'
+PYTHON='/usr/local/bin/python3'
+PIP3='/usr/local/bin/pip-3.8'
+PKGS='alsa-lib bash bzip2 ca_root_nss capstone4 ccache cdrkit-genisoimage ctags curl cyrus-sasl dbus diffutils gettext git glib gmake gnutls gsed gtk3 libepoxy libffi libgcrypt libjpeg-turbo libnfs libspice-server libssh libtasn1 libxml2 llvm lttng-ust lzo2 meson ncurses nettle ninja opencv p5-Test-Harness perl5 pixman pkgconf png py38-numpy py38-pillow py38-pip py38-sphinx py38-sphinx_rtd_theme py38-virtualenv py38-yaml python3 rpm2cpio sdl2 sdl2_image snappy spice-protocol tesseract texinfo usbredir virglrenderer vte3 zstd'
diff --git a/.gitlab-ci.d/cirrus/freebsd-13.vars b/.gitlab-ci.d/cirrus/freebsd-13.vars
new file mode 100644
index 0000000..323fe80
--- /dev/null
+++ b/.gitlab-ci.d/cirrus/freebsd-13.vars
@@ -0,0 +1,13 @@
+# THIS FILE WAS AUTO-GENERATED
+#
+#  $ lcitool variables freebsd-13 qemu
+#
+# https://gitlab.com/libvirt/libvirt-ci/-/commit/c7e275ab27ac0dcd09da290817b9adeea1fd1eb1
+
+PACKAGING_COMMAND='pkg'
+CCACHE='/usr/local/bin/ccache'
+MAKE='/usr/local/bin/gmake'
+NINJA='/usr/local/bin/ninja'
+PYTHON='/usr/local/bin/python3'
+PIP3='/usr/local/bin/pip-3.8'
+PKGS='alsa-lib bash bzip2 ca_root_nss capstone4 ccache cdrkit-genisoimage ctags curl cyrus-sasl dbus diffutils gettext git glib gmake gnutls gsed gtk3 libepoxy libffi libgcrypt libjpeg-turbo libnfs libspice-server libssh libtasn1 libxml2 llvm lttng-ust lzo2 meson ncurses nettle ninja opencv p5-Test-Harness perl5 pixman pkgconf png py38-numpy py38-pillow py38-pip py38-sphinx py38-sphinx_rtd_theme py38-virtualenv py38-yaml python3 rpm2cpio sdl2 sdl2_image snappy spice-protocol tesseract texinfo usbredir virglrenderer vte3 zstd'
diff --git a/.gitlab-ci.d/cirrus/macos-11.vars b/.gitlab-ci.d/cirrus/macos-11.vars
new file mode 100644
index 0000000..cbec8a4
--- /dev/null
+++ b/.gitlab-ci.d/cirrus/macos-11.vars
@@ -0,0 +1,15 @@
+# THIS FILE WAS AUTO-GENERATED
+#
+#  $ lcitool variables macos-11 qemu
+#
+# https://gitlab.com/libvirt/libvirt-ci/-/commit/c7e275ab27ac0dcd09da290817b9adeea1fd1eb1
+
+PACKAGING_COMMAND='brew'
+CCACHE='/usr/local/bin/ccache'
+MAKE='/usr/local/bin/gmake'
+NINJA='/usr/local/bin/ninja'
+PYTHON='/usr/local/bin/python3'
+PIP3='/usr/local/bin/pip3'
+PKGS='bash bc bzip2 capstone ccache cpanminus ctags curl dbus diffutils gcovr gettext git glib gnu-sed gnutls gtk+3 jemalloc jpeg-turbo libepoxy libffi libgcrypt libiscsi libnfs libpng libslirp libssh libtasn1 libusb libxml2 llvm lzo make meson ncurses nettle ninja perl pixman pkg-config python3 rpm2cpio sdl2 sdl2_image snappy sparse spice-protocol tesseract texinfo usbredir vde vte3 zlib zstd'
+PYPI_PKGS='PyYAML numpy pillow sphinx sphinx-rtd-theme virtualenv'
+CPAN_PKGS='Test::Harness'
diff --git a/.gitlab-ci.d/container-core.yml b/.gitlab-ci.d/container-core.yml
new file mode 100644
index 0000000..e8dd1f4
--- /dev/null
+++ b/.gitlab-ci.d/container-core.yml
@@ -0,0 +1,17 @@
+include:
+  - local: '/.gitlab-ci.d/container-template.yml'
+
+amd64-centos8-container:
+  extends: .container_job_template
+  variables:
+    NAME: centos8
+
+amd64-fedora-container:
+  extends: .container_job_template
+  variables:
+    NAME: fedora
+
+amd64-debian10-container:
+  extends: .container_job_template
+  variables:
+    NAME: debian10
diff --git a/.gitlab-ci.d/container-cross.yml b/.gitlab-ci.d/container-cross.yml
new file mode 100644
index 0000000..a3b5b90
--- /dev/null
+++ b/.gitlab-ci.d/container-cross.yml
@@ -0,0 +1,193 @@
+alpha-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-alpha-cross
+
+amd64-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-amd64-cross
+
+amd64-debian-user-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-all-test-cross
+
+arm64-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-arm64-cross
+
+arm64-test-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian11-container']
+  variables:
+    NAME: debian-arm64-test-cross
+
+armel-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-armel-cross
+
+armhf-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-armhf-cross
+
+# We never want to build hexagon in the CI system and by default we
+# always want to refer to the master registry where it lives.
+hexagon-cross-container:
+  image: docker:stable
+  stage: containers
+  rules:
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project"'
+      when: never
+    - when: always
+  variables:
+    NAME: debian-hexagon-cross
+    GIT_DEPTH: 1
+  services:
+    - docker:dind
+  before_script:
+    - export TAG="$CI_REGISTRY_IMAGE/qemu/$NAME:latest"
+    - export COMMON_TAG="$CI_REGISTRY/qemu-project/qemu/qemu/$NAME:latest"
+    - docker info
+    - docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
+  script:
+    - echo "TAG:$TAG"
+    - echo "COMMON_TAG:$COMMON_TAG"
+    - docker pull $COMMON_TAG
+    - docker tag $COMMON_TAG $TAG
+    - docker push "$TAG"
+  after_script:
+    - docker logout
+
+hppa-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-hppa-cross
+
+m68k-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-m68k-cross
+
+mips64-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-mips64-cross
+
+mips64el-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-mips64el-cross
+
+mips-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-mips-cross
+
+mipsel-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-mipsel-cross
+
+powerpc-test-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian11-container']
+  variables:
+    NAME: debian-powerpc-test-cross
+
+ppc64el-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-ppc64el-cross
+
+riscv64-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  # as we are currently based on 'sid/unstable' we may break so...
+  allow_failure: true
+  variables:
+    NAME: debian-riscv64-cross
+
+s390x-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-s390x-cross
+
+sh4-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-sh4-cross
+
+sparc64-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-sparc64-cross
+
+tricore-debian-cross-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-tricore-cross
+
+xtensa-debian-cross-container:
+  extends: .container_job_template
+  variables:
+    NAME: debian-xtensa-cross
+
+cris-fedora-cross-container:
+  extends: .container_job_template
+  variables:
+    NAME: fedora-cris-cross
+
+i386-fedora-cross-container:
+  extends: .container_job_template
+  variables:
+    NAME: fedora-i386-cross
+
+win32-fedora-cross-container:
+  extends: .container_job_template
+  variables:
+    NAME: fedora-win32-cross
+
+win64-fedora-cross-container:
+  extends: .container_job_template
+  variables:
+    NAME: fedora-win64-cross
diff --git a/.gitlab-ci.d/container-template.yml b/.gitlab-ci.d/container-template.yml
new file mode 100644
index 0000000..1baecd9
--- /dev/null
+++ b/.gitlab-ci.d/container-template.yml
@@ -0,0 +1,21 @@
+.container_job_template:
+  image: docker:stable
+  stage: containers
+  services:
+    - docker:dind
+  before_script:
+    - export TAG="$CI_REGISTRY_IMAGE/qemu/$NAME:latest"
+    - export COMMON_TAG="$CI_REGISTRY/qemu-project/qemu/$NAME:latest"
+    - apk add python3
+    - docker info
+    - docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
+  script:
+    - echo "TAG:$TAG"
+    - echo "COMMON_TAG:$COMMON_TAG"
+    - ./tests/docker/docker.py --engine docker build
+          -t "qemu/$NAME" -f "tests/docker/dockerfiles/$NAME.docker"
+          -r $CI_REGISTRY/qemu-project/qemu
+    - docker tag "qemu/$NAME" "$TAG"
+    - docker push "$TAG"
+  after_script:
+    - docker logout
diff --git a/.gitlab-ci.d/containers.yml b/.gitlab-ci.d/containers.yml
new file mode 100644
index 0000000..cd06d3f
--- /dev/null
+++ b/.gitlab-ci.d/containers.yml
@@ -0,0 +1,45 @@
+include:
+  - local: '/.gitlab-ci.d/container-core.yml'
+  - local: '/.gitlab-ci.d/container-cross.yml'
+
+amd64-alpine-container:
+  extends: .container_job_template
+  variables:
+    NAME: alpine
+
+amd64-debian11-container:
+  extends: .container_job_template
+  variables:
+    NAME: debian11
+
+amd64-debian-container:
+  extends: .container_job_template
+  stage: containers-layer2
+  needs: ['amd64-debian10-container']
+  variables:
+    NAME: debian-amd64
+
+amd64-ubuntu1804-container:
+  extends: .container_job_template
+  variables:
+    NAME: ubuntu1804
+
+amd64-ubuntu2004-container:
+  extends: .container_job_template
+  variables:
+    NAME: ubuntu2004
+
+amd64-ubuntu-container:
+  extends: .container_job_template
+  variables:
+    NAME: ubuntu
+
+amd64-opensuse-leap-container:
+  extends: .container_job_template
+  variables:
+    NAME: opensuse-leap
+
+python-container:
+  extends: .container_job_template
+  variables:
+    NAME: python
diff --git a/.gitlab-ci.d/crossbuild-template.yml b/.gitlab-ci.d/crossbuild-template.yml
new file mode 100644
index 0000000..10d22dc
--- /dev/null
+++ b/.gitlab-ci.d/crossbuild-template.yml
@@ -0,0 +1,47 @@
+.cross_system_build_job:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/$IMAGE:latest
+  timeout: 80m
+  script:
+    - mkdir build
+    - cd build
+    - PKG_CONFIG_PATH=$PKG_CONFIG_PATH
+      ../configure --enable-werror --disable-docs $QEMU_CONFIGURE_OPTS
+        --disable-user --target-list-exclude="arm-softmmu cris-softmmu
+          i386-softmmu microblaze-softmmu mips-softmmu mipsel-softmmu
+          mips64-softmmu ppc-softmmu riscv32-softmmu sh4-softmmu
+          sparc-softmmu xtensa-softmmu $CROSS_SKIP_TARGETS"
+    - make -j$(expr $(nproc) + 1) all check-build $MAKE_CHECK_ARGS
+    - if grep -q "EXESUF=.exe" config-host.mak;
+      then make installer;
+      version="$(git describe --match v[0-9]*)";
+      mv -v qemu-setup*.exe qemu-setup-${version}.exe;
+      fi
+
+# Job to cross-build specific accelerators.
+#
+# Set the $ACCEL variable to select the specific accelerator (default to
+# KVM), and set extra options (such disabling other accelerators) via the
+# $EXTRA_CONFIGURE_OPTS variable.
+.cross_accel_build_job:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/$IMAGE:latest
+  timeout: 30m
+  script:
+    - mkdir build
+    - cd build
+    - PKG_CONFIG_PATH=$PKG_CONFIG_PATH
+      ../configure --enable-werror --disable-docs $QEMU_CONFIGURE_OPTS
+        --disable-tools --enable-${ACCEL:-kvm} $EXTRA_CONFIGURE_OPTS
+    - make -j$(expr $(nproc) + 1) all check-build $MAKE_CHECK_ARGS
+
+.cross_user_build_job:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/$IMAGE:latest
+  script:
+    - mkdir build
+    - cd build
+    - PKG_CONFIG_PATH=$PKG_CONFIG_PATH
+      ../configure --enable-werror --disable-docs $QEMU_CONFIGURE_OPTS
+        --disable-system
+    - make -j$(expr $(nproc) + 1) all check-build $MAKE_CHECK_ARGS
diff --git a/.gitlab-ci.d/crossbuilds.yml b/.gitlab-ci.d/crossbuilds.yml
new file mode 100644
index 0000000..17d6cb3
--- /dev/null
+++ b/.gitlab-ci.d/crossbuilds.yml
@@ -0,0 +1,216 @@
+include:
+  - local: '/.gitlab-ci.d/crossbuild-template.yml'
+
+cross-armel-system:
+  extends: .cross_system_build_job
+  needs:
+    job: armel-debian-cross-container
+  variables:
+    IMAGE: debian-armel-cross
+
+cross-armel-user:
+  extends: .cross_user_build_job
+  needs:
+    job: armel-debian-cross-container
+  variables:
+    IMAGE: debian-armel-cross
+
+cross-armhf-system:
+  extends: .cross_system_build_job
+  needs:
+    job: armhf-debian-cross-container
+  variables:
+    IMAGE: debian-armhf-cross
+
+cross-armhf-user:
+  extends: .cross_user_build_job
+  needs:
+    job: armhf-debian-cross-container
+  variables:
+    IMAGE: debian-armhf-cross
+
+cross-arm64-system:
+  extends: .cross_system_build_job
+  needs:
+    job: arm64-debian-cross-container
+  variables:
+    IMAGE: debian-arm64-cross
+
+cross-arm64-user:
+  extends: .cross_user_build_job
+  needs:
+    job: arm64-debian-cross-container
+  variables:
+    IMAGE: debian-arm64-cross
+
+cross-i386-system:
+  extends: .cross_system_build_job
+  needs:
+    job: i386-fedora-cross-container
+  variables:
+    IMAGE: fedora-i386-cross
+    MAKE_CHECK_ARGS: check-qtest
+
+cross-i386-user:
+  extends: .cross_user_build_job
+  needs:
+    job: i386-fedora-cross-container
+  variables:
+    IMAGE: fedora-i386-cross
+    MAKE_CHECK_ARGS: check
+
+cross-i386-tci:
+  extends: .cross_accel_build_job
+  timeout: 60m
+  variables:
+    IMAGE: fedora-i386-cross
+    ACCEL: tcg-interpreter
+    EXTRA_CONFIGURE_OPTS: --target-list=i386-softmmu,i386-linux-user,aarch64-softmmu,aarch64-linux-user,ppc-softmmu,ppc-linux-user
+    MAKE_CHECK_ARGS: check check-tcg
+
+cross-mips-system:
+  extends: .cross_system_build_job
+  needs:
+    job: mips-debian-cross-container
+  variables:
+    IMAGE: debian-mips-cross
+
+cross-mips-user:
+  extends: .cross_user_build_job
+  needs:
+    job: mips-debian-cross-container
+  variables:
+    IMAGE: debian-mips-cross
+
+cross-mipsel-system:
+  extends: .cross_system_build_job
+  needs:
+    job: mipsel-debian-cross-container
+  variables:
+    IMAGE: debian-mipsel-cross
+
+cross-mipsel-user:
+  extends: .cross_user_build_job
+  needs:
+    job: mipsel-debian-cross-container
+  variables:
+    IMAGE: debian-mipsel-cross
+
+cross-mips64el-system:
+  extends: .cross_system_build_job
+  needs:
+    job: mips64el-debian-cross-container
+  variables:
+    IMAGE: debian-mips64el-cross
+
+cross-mips64el-user:
+  extends: .cross_user_build_job
+  needs:
+    job: mips64el-debian-cross-container
+  variables:
+    IMAGE: debian-mips64el-cross
+
+cross-ppc64el-system:
+  extends: .cross_system_build_job
+  needs:
+    job: ppc64el-debian-cross-container
+  variables:
+    IMAGE: debian-ppc64el-cross
+
+cross-ppc64el-user:
+  extends: .cross_user_build_job
+  needs:
+    job: ppc64el-debian-cross-container
+  variables:
+    IMAGE: debian-ppc64el-cross
+
+# The riscv64 cross-builds currently use a 'sid' container to get
+# compilers and libraries. Until something more stable is found we
+# allow_failure so as not to block CI.
+cross-riscv64-system:
+  extends: .cross_system_build_job
+  allow_failure: true
+  needs:
+    job: riscv64-debian-cross-container
+  variables:
+    IMAGE: debian-riscv64-cross
+
+cross-riscv64-user:
+  extends: .cross_user_build_job
+  allow_failure: true
+  needs:
+    job: riscv64-debian-cross-container
+  variables:
+    IMAGE: debian-riscv64-cross
+
+cross-s390x-system:
+  extends: .cross_system_build_job
+  needs:
+    job: s390x-debian-cross-container
+  variables:
+    IMAGE: debian-s390x-cross
+
+cross-s390x-user:
+  extends: .cross_user_build_job
+  needs:
+    job: s390x-debian-cross-container
+  variables:
+    IMAGE: debian-s390x-cross
+
+cross-s390x-kvm-only:
+  extends: .cross_accel_build_job
+  needs:
+    job: s390x-debian-cross-container
+  variables:
+    IMAGE: debian-s390x-cross
+    EXTRA_CONFIGURE_OPTS: --disable-tcg
+
+cross-mips64el-kvm-only:
+  extends: .cross_accel_build_job
+  needs:
+    job: mips64el-debian-cross-container
+  variables:
+    IMAGE: debian-mips64el-cross
+    EXTRA_CONFIGURE_OPTS: --disable-tcg --target-list=mips64el-softmmu
+
+cross-win32-system:
+  extends: .cross_system_build_job
+  needs:
+    job: win32-fedora-cross-container
+  variables:
+    IMAGE: fedora-win32-cross
+    CROSS_SKIP_TARGETS: alpha-softmmu avr-softmmu hppa-softmmu m68k-softmmu
+                        microblazeel-softmmu mips64el-softmmu nios2-softmmu
+  artifacts:
+    paths:
+      - build/qemu-setup*.exe
+
+cross-win64-system:
+  extends: .cross_system_build_job
+  needs:
+    job: win64-fedora-cross-container
+  variables:
+    IMAGE: fedora-win64-cross
+    CROSS_SKIP_TARGETS: or1k-softmmu rx-softmmu sh4eb-softmmu sparc64-softmmu
+                        tricore-softmmu xtensaeb-softmmu
+  artifacts:
+    paths:
+      - build/qemu-setup*.exe
+
+cross-amd64-xen-only:
+  extends: .cross_accel_build_job
+  needs:
+    job: amd64-debian-cross-container
+  variables:
+    IMAGE: debian-amd64-cross
+    ACCEL: xen
+    EXTRA_CONFIGURE_OPTS: --disable-tcg --disable-kvm
+
+cross-arm64-xen-only:
+  extends: .cross_accel_build_job
+  needs:
+    job: arm64-debian-cross-container
+  variables:
+    IMAGE: debian-arm64-cross
+    ACCEL: xen
+    EXTRA_CONFIGURE_OPTS: --disable-tcg --disable-kvm
diff --git a/.gitlab-ci.d/custom-runners.yml b/.gitlab-ci.d/custom-runners.yml
new file mode 100644
index 0000000..056c374
--- /dev/null
+++ b/.gitlab-ci.d/custom-runners.yml
@@ -0,0 +1,19 @@
+# The CI jobs defined here require GitLab runners installed and
+# registered on machines that match their operating system names,
+# versions and architectures.  This is in contrast to the other CI
+# jobs that are intended to run on GitLab's "shared" runners.
+
+# Different than the default approach on "shared" runners, based on
+# containers, the custom runners have no such *requirement*, as those
+# jobs should be capable of running on operating systems with no
+# compatible container implementation, or no support from
+# gitlab-runner.  To avoid problems that gitlab-runner can cause while
+# reusing the GIT repository, let's enable the clone strategy, which
+# guarantees a fresh repository on each job run.
+variables:
+  GIT_STRATEGY: clone
+
+include:
+  - local: '/.gitlab-ci.d/custom-runners/ubuntu-18.04-s390x.yml'
+  - local: '/.gitlab-ci.d/custom-runners/ubuntu-20.04-aarch64.yml'
+  - local: '/.gitlab-ci.d/custom-runners/centos-stream-8-x86_64.yml'
diff --git a/.gitlab-ci.d/custom-runners/centos-stream-8-x86_64.yml b/.gitlab-ci.d/custom-runners/centos-stream-8-x86_64.yml
new file mode 100644
index 0000000..49aa703
--- /dev/null
+++ b/.gitlab-ci.d/custom-runners/centos-stream-8-x86_64.yml
@@ -0,0 +1,28 @@
+centos-stream-8-x86_64:
+ allow_failure: true
+ needs: []
+ stage: build
+ tags:
+ - centos_stream_8
+ - x86_64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+ - if: "$CENTOS_STREAM_8_x86_64_RUNNER_AVAILABLE"
+ artifacts:
+   name: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG"
+   when: on_failure
+   expire_in: 7 days
+   paths:
+     - build/tests/results/latest/results.xml
+     - build/tests/results/latest/test-results
+   reports:
+     junit: build/tests/results/latest/results.xml
+ before_script:
+ - JOBS=$(expr $(nproc) + 1)
+ script:
+ - mkdir build
+ - cd build
+ - ../scripts/ci/org.centos/stream/8/x86_64/configure
+ - make -j"$JOBS"
+ - make NINJA=":" check
+ - ../scripts/ci/org.centos/stream/8/x86_64/test-avocado
diff --git a/.gitlab-ci.d/custom-runners/ubuntu-18.04-s390x.yml b/.gitlab-ci.d/custom-runners/ubuntu-18.04-s390x.yml
new file mode 100644
index 0000000..f39d874
--- /dev/null
+++ b/.gitlab-ci.d/custom-runners/ubuntu-18.04-s390x.yml
@@ -0,0 +1,118 @@
+# All ubuntu-18.04 jobs should run successfully in an environment
+# setup by the scripts/ci/setup/build-environment.yml task
+# "Install basic packages to build QEMU on Ubuntu 18.04/20.04"
+
+ubuntu-18.04-s390x-all-linux-static:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_18.04
+ - s390x
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+ - if: "$S390X_RUNNER_AVAILABLE"
+ script:
+ # --disable-libssh is needed because of https://bugs.launchpad.net/qemu/+bug/1838763
+ # --disable-glusterfs is needed because there's no static version of those libs in distro supplied packages
+ - mkdir build
+ - cd build
+ - ../configure --enable-debug --static --disable-system --disable-glusterfs --disable-libssh
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+ - make --output-sync -j`nproc` check-tcg V=1
+
+ubuntu-18.04-s390x-all:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_18.04
+ - s390x
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+ - if: "$S390X_RUNNER_AVAILABLE"
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+
+ubuntu-18.04-s390x-alldbg:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_18.04
+ - s390x
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$S390X_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --enable-debug --disable-libssh
+ - make clean
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+
+ubuntu-18.04-s390x-clang:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_18.04
+ - s390x
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$S390X_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh --cc=clang --cxx=clang++ --enable-sanitizers
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+
+ubuntu-18.04-s390x-tci:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_18.04
+ - s390x
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$S390X_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh --enable-tcg-interpreter
+ - make --output-sync -j`nproc`
+
+ubuntu-18.04-s390x-notcg:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_18.04
+ - s390x
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$S390X_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh --disable-tcg
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
diff --git a/.gitlab-ci.d/custom-runners/ubuntu-20.04-aarch64.yml b/.gitlab-ci.d/custom-runners/ubuntu-20.04-aarch64.yml
new file mode 100644
index 0000000..920e388
--- /dev/null
+++ b/.gitlab-ci.d/custom-runners/ubuntu-20.04-aarch64.yml
@@ -0,0 +1,118 @@
+# All ubuntu-20.04 jobs should run successfully in an environment
+# setup by the scripts/ci/setup/qemu/build-environment.yml task
+# "Install basic packages to build QEMU on Ubuntu 18.04/20.04"
+
+ubuntu-20.04-aarch64-all-linux-static:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_20.04
+ - aarch64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+ - if: "$AARCH64_RUNNER_AVAILABLE"
+ script:
+ # --disable-libssh is needed because of https://bugs.launchpad.net/qemu/+bug/1838763
+ # --disable-glusterfs is needed because there's no static version of those libs in distro supplied packages
+ - mkdir build
+ - cd build
+ - ../configure --enable-debug --static --disable-system --disable-glusterfs --disable-libssh
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+ - make --output-sync -j`nproc` check-tcg V=1
+
+ubuntu-20.04-aarch64-all:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_20.04
+ - aarch64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$AARCH64_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+
+ubuntu-20.04-aarch64-alldbg:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_20.04
+ - aarch64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+ - if: "$AARCH64_RUNNER_AVAILABLE"
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --enable-debug --disable-libssh
+ - make clean
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+
+ubuntu-20.04-aarch64-clang:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_20.04
+ - aarch64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$AARCH64_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh --cc=clang-10 --cxx=clang++-10 --enable-sanitizers
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
+
+ubuntu-20.04-aarch64-tci:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_20.04
+ - aarch64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$AARCH64_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh --enable-tcg-interpreter
+ - make --output-sync -j`nproc`
+
+ubuntu-20.04-aarch64-notcg:
+ needs: []
+ stage: build
+ tags:
+ - ubuntu_20.04
+ - aarch64
+ rules:
+ - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH =~ /^staging/'
+   when: manual
+   allow_failure: true
+ - if: "$AARCH64_RUNNER_AVAILABLE"
+   when: manual
+   allow_failure: true
+ script:
+ - mkdir build
+ - cd build
+ - ../configure --disable-libssh --disable-tcg
+ - make --output-sync -j`nproc`
+ - make --output-sync -j`nproc` check V=1
diff --git a/.gitlab-ci.d/edk2.yml b/.gitlab-ci.d/edk2.yml
new file mode 100644
index 0000000..13d0f8b
--- /dev/null
+++ b/.gitlab-ci.d/edk2.yml
@@ -0,0 +1,60 @@
+# All jobs needing docker-edk2 must use the same rules it uses.
+.edk2_job_rules:
+ rules: # Only run this job when ...
+ - changes:
+   # this file is modified
+   - .gitlab-ci.d/edk2.yml
+   # or the Dockerfile is modified
+   - .gitlab-ci.d/edk2/Dockerfile
+   # or roms/edk2/ is modified (submodule updated)
+   - roms/edk2/*
+   when: on_success
+ - if: '$CI_COMMIT_REF_NAME =~ /^edk2/' # or the branch/tag starts with 'edk2'
+   when: on_success
+ - if: '$CI_COMMIT_MESSAGE =~ /edk2/i' # or last commit description contains 'EDK2'
+   when: on_success
+
+docker-edk2:
+ extends: .edk2_job_rules
+ stage: containers
+ image: docker:19.03.1
+ services:
+ - docker:19.03.1-dind
+ variables:
+  GIT_DEPTH: 3
+  IMAGE_TAG: $CI_REGISTRY_IMAGE:edk2-cross-build
+  # We don't use TLS
+  DOCKER_HOST: tcp://docker:2375
+  DOCKER_TLS_CERTDIR: ""
+ before_script:
+ - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
+ script:
+ - docker pull $IMAGE_TAG || true
+ - docker build --cache-from $IMAGE_TAG --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
+                                        --tag $IMAGE_TAG .gitlab-ci.d/edk2
+ - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
+ - docker push $IMAGE_TAG
+
+build-edk2:
+ extends: .edk2_job_rules
+ stage: build
+ needs: ['docker-edk2']
+ artifacts:
+   paths: # 'artifacts.zip' will contains the following files:
+   - pc-bios/edk2*bz2
+   - pc-bios/edk2-licenses.txt
+   - edk2-stdout.log
+   - edk2-stderr.log
+ image: $CI_REGISTRY_IMAGE:edk2-cross-build
+ variables:
+   GIT_DEPTH: 3
+ script: # Clone the required submodules and build EDK2
+ - git submodule update --init roms/edk2
+ - git -C roms/edk2 submodule update --init --
+     ArmPkg/Library/ArmSoftFloatLib/berkeley-softfloat-3
+     BaseTools/Source/C/BrotliCompress/brotli
+     CryptoPkg/Library/OpensslLib/openssl
+     MdeModulePkg/Library/BrotliCustomDecompressLib/brotli
+ - export JOBS=$(($(getconf _NPROCESSORS_ONLN) + 1))
+ - echo "=== Using ${JOBS} simultaneous jobs ==="
+ - make -j${JOBS} -C roms efi 2>&1 1>edk2-stdout.log | tee -a edk2-stderr.log >&2
diff --git a/.gitlab-ci.d/edk2/Dockerfile b/.gitlab-ci.d/edk2/Dockerfile
new file mode 100644
index 0000000..b4584d1
--- /dev/null
+++ b/.gitlab-ci.d/edk2/Dockerfile
@@ -0,0 +1,27 @@
+#
+# Docker image to cross-compile EDK2 firmware binaries
+#
+FROM ubuntu:16.04
+
+MAINTAINER Philippe Mathieu-Daud <philmd@redhat.com>
+
+# Install packages required to build EDK2
+RUN apt update \
+    && \
+    \
+    DEBIAN_FRONTEND=noninteractive \
+    apt install --assume-yes --no-install-recommends \
+        build-essential \
+        ca-certificates \
+        dos2unix \
+        gcc-aarch64-linux-gnu \
+        gcc-arm-linux-gnueabi \
+        git \
+        iasl \
+        make \
+        nasm \
+        python \
+        uuid-dev \
+    && \
+    \
+    rm -rf /var/lib/apt/lists/*
diff --git a/.gitlab-ci.d/opensbi.yml b/.gitlab-ci.d/opensbi.yml
new file mode 100644
index 0000000..5e0a247
--- /dev/null
+++ b/.gitlab-ci.d/opensbi.yml
@@ -0,0 +1,63 @@
+# All jobs needing docker-opensbi must use the same rules it uses.
+.opensbi_job_rules:
+ rules: # Only run this job when ...
+ - changes:
+   # this file is modified
+   - .gitlab-ci.d/opensbi.yml
+   # or the Dockerfile is modified
+   - .gitlab-ci.d/opensbi/Dockerfile
+   when: on_success
+ - changes: # or roms/opensbi/ is modified (submodule updated)
+   - roms/opensbi/*
+   when: on_success
+ - if: '$CI_COMMIT_REF_NAME =~ /^opensbi/' # or the branch/tag starts with 'opensbi'
+   when: on_success
+ - if: '$CI_COMMIT_MESSAGE =~ /opensbi/i' # or last commit description contains 'OpenSBI'
+   when: on_success
+
+docker-opensbi:
+ extends: .opensbi_job_rules
+ stage: containers
+ image: docker:19.03.1
+ services:
+ - docker:19.03.1-dind
+ variables:
+  GIT_DEPTH: 3
+  IMAGE_TAG: $CI_REGISTRY_IMAGE:opensbi-cross-build
+  # We don't use TLS
+  DOCKER_HOST: tcp://docker:2375
+  DOCKER_TLS_CERTDIR: ""
+ before_script:
+ - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
+ script:
+ - docker pull $IMAGE_TAG || true
+ - docker build --cache-from $IMAGE_TAG --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
+                                        --tag $IMAGE_TAG .gitlab-ci.d/opensbi
+ - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
+ - docker push $IMAGE_TAG
+
+build-opensbi:
+ extends: .opensbi_job_rules
+ stage: build
+ needs: ['docker-opensbi']
+ artifacts:
+   paths: # 'artifacts.zip' will contains the following files:
+   - pc-bios/opensbi-riscv32-generic-fw_dynamic.bin
+   - pc-bios/opensbi-riscv32-generic-fw_dynamic.elf
+   - pc-bios/opensbi-riscv64-generic-fw_dynamic.bin
+   - pc-bios/opensbi-riscv64-generic-fw_dynamic.elf
+   - opensbi32-generic-stdout.log
+   - opensbi32-generic-stderr.log
+   - opensbi64-generic-stdout.log
+   - opensbi64-generic-stderr.log
+ image: $CI_REGISTRY_IMAGE:opensbi-cross-build
+ variables:
+   GIT_DEPTH: 3
+ script: # Clone the required submodules and build OpenSBI
+ - git submodule update --init roms/opensbi
+ - export JOBS=$(($(getconf _NPROCESSORS_ONLN) + 1))
+ - echo "=== Using ${JOBS} simultaneous jobs ==="
+ - make -j${JOBS} -C roms/opensbi clean
+ - make -j${JOBS} -C roms opensbi32-generic 2>&1 1>opensbi32-generic-stdout.log | tee -a opensbi32-generic-stderr.log >&2
+ - make -j${JOBS} -C roms/opensbi clean
+ - make -j${JOBS} -C roms opensbi64-generic 2>&1 1>opensbi64-generic-stdout.log | tee -a opensbi64-generic-stderr.log >&2
diff --git a/.gitlab-ci.d/opensbi/Dockerfile b/.gitlab-ci.d/opensbi/Dockerfile
new file mode 100644
index 0000000..4ba8a4d
--- /dev/null
+++ b/.gitlab-ci.d/opensbi/Dockerfile
@@ -0,0 +1,33 @@
+#
+# Docker image to cross-compile OpenSBI firmware binaries
+#
+FROM ubuntu:18.04
+
+MAINTAINER Bin Meng <bmeng.cn@gmail.com>
+
+# Install packages required to build OpenSBI
+RUN apt update \
+    && \
+    \
+    DEBIAN_FRONTEND=noninteractive \
+    apt install --assume-yes --no-install-recommends \
+        build-essential \
+        ca-certificates \
+        git \
+        make \
+        wget \
+    && \
+    \
+    rm -rf /var/lib/apt/lists/*
+
+# Manually install the kernel.org "Crosstool" based toolchains for gcc-8.3
+RUN wget -O - \
+    https://mirrors.edge.kernel.org/pub/tools/crosstool/files/bin/x86_64/8.3.0/x86_64-gcc-8.3.0-nolibc-riscv32-linux.tar.xz \
+    | tar -C /opt -xJ
+RUN wget -O - \
+    https://mirrors.edge.kernel.org/pub/tools/crosstool/files/bin/x86_64/8.3.0/x86_64-gcc-8.3.0-nolibc-riscv64-linux.tar.xz \
+    | tar -C /opt -xJ
+
+# Export the toolchains to the system path
+ENV PATH="/opt/gcc-8.3.0-nolibc/riscv32-linux/bin:${PATH}"
+ENV PATH="/opt/gcc-8.3.0-nolibc/riscv64-linux/bin:${PATH}"
diff --git a/.gitlab-ci.d/qemu-project.yml b/.gitlab-ci.d/qemu-project.yml
new file mode 100644
index 0000000..b3d79bc
--- /dev/null
+++ b/.gitlab-ci.d/qemu-project.yml
@@ -0,0 +1,13 @@
+# This file contains the set of jobs run by the QEMU project:
+# https://gitlab.com/qemu-project/qemu/-/pipelines
+
+include:
+  - local: '/.gitlab-ci.d/stages.yml'
+  - local: '/.gitlab-ci.d/edk2.yml'
+  - local: '/.gitlab-ci.d/opensbi.yml'
+  - local: '/.gitlab-ci.d/containers.yml'
+  - local: '/.gitlab-ci.d/crossbuilds.yml'
+  - local: '/.gitlab-ci.d/buildtest.yml'
+  - local: '/.gitlab-ci.d/static_checks.yml'
+  - local: '/.gitlab-ci.d/custom-runners.yml'
+  - local: '/.gitlab-ci.d/cirrus.yml'
diff --git a/.gitlab-ci.d/stages.yml b/.gitlab-ci.d/stages.yml
new file mode 100644
index 0000000..f508260
--- /dev/null
+++ b/.gitlab-ci.d/stages.yml
@@ -0,0 +1,8 @@
+# Currently we have two build stages after our containers are built:
+#  - build (for traditional build and test or first stage build)
+#  - test (for test stages, using build artefacts from a build stage)
+stages:
+  - containers
+  - containers-layer2
+  - build
+  - test
diff --git a/.gitlab-ci.d/static_checks.yml b/.gitlab-ci.d/static_checks.yml
new file mode 100644
index 0000000..902843f
--- /dev/null
+++ b/.gitlab-ci.d/static_checks.yml
@@ -0,0 +1,49 @@
+check-patch:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/centos8:latest
+  needs:
+    job: amd64-centos8-container
+  script:
+    - .gitlab-ci.d/check-patch.py
+  variables:
+    GIT_DEPTH: 1000
+  rules:
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project"'
+      when: never
+    - when: on_success
+      allow_failure: true
+
+check-dco:
+  stage: build
+  image: $CI_REGISTRY_IMAGE/qemu/centos8:latest
+  needs:
+    job: amd64-centos8-container
+  script: .gitlab-ci.d/check-dco.py
+  variables:
+    GIT_DEPTH: 1000
+  rules:
+    - if: '$CI_PROJECT_NAMESPACE == "qemu-project" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
+      when: never
+    - when: on_success
+
+check-python-pipenv:
+  stage: test
+  image: $CI_REGISTRY_IMAGE/qemu/python:latest
+  script:
+    - make -C python check-pipenv
+  variables:
+    GIT_DEPTH: 1
+  needs:
+    job: python-container
+
+check-python-tox:
+  stage: test
+  image: $CI_REGISTRY_IMAGE/qemu/python:latest
+  script:
+    - make -C python check-tox
+  variables:
+    GIT_DEPTH: 1
+    QEMU_TOX_EXTRA_ARGS: --skip-missing-interpreters=false
+  needs:
+    job: python-container
+  allow_failure: true
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
new file mode 100644
index 0000000..9762dda
--- /dev/null
+++ b/.gitlab-ci.yml
@@ -0,0 +1,24 @@
+#
+# This is the GitLab CI configuration file for the mainstream QEMU
+# project: https://gitlab.com/qemu-project/qemu/-/pipelines
+#
+# !!! DO NOT ADD ANY NEW CONFIGURATION TO THIS FILE !!!
+#
+# Only documentation or comments is accepted.
+#
+# To use a different set of jobs than the mainstream QEMU project,
+# you need to set the location of your custom yml file at "custom CI/CD
+# configuration path", on your GitLab CI namespace:
+# https://docs.gitlab.com/ee/ci/pipelines/settings.html#custom-cicd-configuration-path
+#
+# ----------------------------------------------------------------------
+#
+# QEMU CI jobs are based on templates. Some templates provide
+# user-configurable options, modifiable via configuration variables.
+#
+# See https://qemu-project.gitlab.io/qemu/devel/ci.html#custom-ci-cd-variables
+# for more information.
+#
+
+include:
+  - local: '/.gitlab-ci.d/qemu-project.yml'
diff --git a/.gitlab/issue_templates/bug.md b/.gitlab/issue_templates/bug.md
new file mode 100644
index 0000000..e910f7b
--- /dev/null
+++ b/.gitlab/issue_templates/bug.md
@@ -0,0 +1,64 @@
+<!--
+This is the upstream QEMU issue tracker.
+
+If you are able to, it will greatly facilitate bug triage if you attempt
+to reproduce the problem with the latest qemu.git master built from
+source. See https://www.qemu.org/download/#source for instructions on
+how to do this.
+
+QEMU generally supports the last two releases advertised on
+https://www.qemu.org/. Problems with distro-packaged versions of QEMU
+older than this should be reported to the distribution instead.
+
+See https://www.qemu.org/contribute/report-a-bug/ for additional
+guidance.
+
+If this is a security issue, please consult
+https://www.qemu.org/contribute/security-process/
+-->
+
+## Host environment
+ - Operating system: (Windows 10 21H1, Fedora 34, etc.)
+ - OS/kernel version: (For POSIX hosts, use `uname -a`)
+ - Architecture: (x86, ARM, s390x, etc.)
+ - QEMU flavor: (qemu-system-x86_64, qemu-aarch64, qemu-img, etc.)
+ - QEMU version: (e.g. `qemu-system-x86_64 --version`)
+ - QEMU command line:
+   <!--
+   Give the smallest, complete command line that exhibits the problem.
+
+   If you are using libvirt, virsh, or vmm, you can likely find the QEMU
+   command line arguments in /var/log/libvirt/qemu/$GUEST.log.
+   -->
+   ```
+   ./qemu-system-x86_64 -M q35 -m 4096 -enable-kvm -hda fedora32.qcow2
+   ```
+
+## Emulated/Virtualized environment
+ - Operating system: (Windows 10 21H1, Fedora 34, etc.)
+ - OS/kernel version: (For POSIX guests, use `uname -a`.)
+ - Architecture: (x86, ARM, s390x, etc.)
+
+
+## Description of problem
+<!-- Describe the problem, including any error/crash messages seen. -->
+
+
+## Steps to reproduce
+1.
+2.
+3.
+
+
+## Additional information
+
+<!--
+Attach logs, stack traces, screenshots, etc. Compress the files if necessary.
+If using libvirt, libvirt logs and XML domain information may be relevant.
+-->
+
+<!--
+The line below ensures that proper tags are added to the issue.
+Please do not remove it.
+-->
+/label ~"kind::Bug"
diff --git a/.gitlab/issue_templates/feature_request.md b/.gitlab/issue_templates/feature_request.md
new file mode 100644
index 0000000..7de02dc
--- /dev/null
+++ b/.gitlab/issue_templates/feature_request.md
@@ -0,0 +1,32 @@
+<!--
+This is the upstream QEMU issue tracker.
+
+Please note that QEMU, like most open source projects, relies on
+contributors who have motivation, skills and available time to work on
+implementing particular features.
+
+Feature requests can be helpful for determining demand and interest, but
+they are not a guarantee that a contributor will volunteer to implement
+it. We welcome and encourage even draft patches to implement a feature
+be sent to the mailing list where it can be discussed and developed
+further by the community.
+
+Thank you for your interest in helping us to make QEMU better!
+-->
+
+## Goal
+<!-- Describe the final result you want to achieve. Avoid design specifics. -->
+
+
+## Technical details
+<!-- Describe technical details, design specifics, suggestions, versions, etc. -->
+
+
+## Additional information
+<!-- Patch or branch references, any other useful information -->
+
+<!--
+The line below ensures that proper tags are added to the issue.
+Please do not remove it.
+-->
+/label ~"kind::Feature Request"
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..08b1b48
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,66 @@
+[submodule "roms/seabios"]
+	path = roms/seabios
+	url = https://gitlab.com/qemu-project/seabios.git/
+[submodule "roms/SLOF"]
+	path = roms/SLOF
+	url = https://gitlab.com/qemu-project/SLOF.git
+[submodule "roms/ipxe"]
+	path = roms/ipxe
+	url = https://gitlab.com/qemu-project/ipxe.git
+[submodule "roms/openbios"]
+	path = roms/openbios
+	url = https://gitlab.com/qemu-project/openbios.git
+[submodule "roms/qemu-palcode"]
+	path = roms/qemu-palcode
+	url = https://gitlab.com/qemu-project/qemu-palcode.git
+[submodule "roms/sgabios"]
+	path = roms/sgabios
+	url = https://gitlab.com/qemu-project/sgabios.git
+[submodule "dtc"]
+	path = dtc
+	url = https://gitlab.com/qemu-project/dtc.git
+[submodule "roms/u-boot"]
+	path = roms/u-boot
+	url = https://gitlab.com/qemu-project/u-boot.git
+[submodule "roms/skiboot"]
+	path = roms/skiboot
+	url = https://gitlab.com/qemu-project/skiboot.git
+[submodule "roms/QemuMacDrivers"]
+	path = roms/QemuMacDrivers
+	url = https://gitlab.com/qemu-project/QemuMacDrivers.git
+[submodule "ui/keycodemapdb"]
+	path = ui/keycodemapdb
+	url = https://gitlab.com/qemu-project/keycodemapdb.git
+[submodule "capstone"]
+	path = capstone
+	url = https://gitlab.com/qemu-project/capstone.git
+[submodule "roms/seabios-hppa"]
+	path = roms/seabios-hppa
+	url = https://gitlab.com/qemu-project/seabios-hppa.git
+[submodule "roms/u-boot-sam460ex"]
+	path = roms/u-boot-sam460ex
+	url = https://gitlab.com/qemu-project/u-boot-sam460ex.git
+[submodule "tests/fp/berkeley-testfloat-3"]
+	path = tests/fp/berkeley-testfloat-3
+	url = https://gitlab.com/qemu-project/berkeley-testfloat-3.git
+[submodule "tests/fp/berkeley-softfloat-3"]
+	path = tests/fp/berkeley-softfloat-3
+	url = https://gitlab.com/qemu-project/berkeley-softfloat-3.git
+[submodule "roms/edk2"]
+	path = roms/edk2
+	url = https://gitlab.com/qemu-project/edk2.git
+[submodule "slirp"]
+	path = slirp
+	url = https://gitlab.com/qemu-project/libslirp.git
+[submodule "roms/opensbi"]
+	path = roms/opensbi
+	url = 	https://gitlab.com/qemu-project/opensbi.git
+[submodule "roms/qboot"]
+	path = roms/qboot
+	url = https://gitlab.com/qemu-project/qboot.git
+[submodule "meson"]
+	path = meson
+	url = https://gitlab.com/qemu-project/meson.git
+[submodule "roms/vbootrom"]
+	path = roms/vbootrom
+	url = https://gitlab.com/qemu-project/vbootrom.git
diff --git a/.gitpublish b/.gitpublish
new file mode 100644
index 0000000..a13f8c7
--- /dev/null
+++ b/.gitpublish
@@ -0,0 +1,51 @@
+#
+# Common git-publish profiles that can be used to send patches to QEMU upstream.
+#
+# See https://github.com/stefanha/git-publish for more information
+#
+[gitpublishprofile "default"]
+base = master
+to = qemu-devel@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "rfc"]
+base = master
+prefix = RFC PATCH
+to = qemu-devel@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "stable"]
+base = master
+to = qemu-devel@nongnu.org
+cc = qemu-stable@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "trivial"]
+base = master
+to = qemu-devel@nongnu.org
+cc = qemu-trivial@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "block"]
+base = master
+to = qemu-devel@nongnu.org
+cc = qemu-block@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "arm"]
+base = master
+to = qemu-devel@nongnu.org
+cc = qemu-arm@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "s390"]
+base = master
+to = qemu-devel@nongnu.org
+cc = qemu-s390@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
+
+[gitpublishprofile "ppc"]
+base = master
+to = qemu-devel@nongnu.org
+cc = qemu-ppc@nongnu.org
+cccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null
diff --git a/.mailmap b/.mailmap
new file mode 100644
index 0000000..8beb2f9
--- /dev/null
+++ b/.mailmap
@@ -0,0 +1,184 @@
+# This mailmap fixes up author names/addresses.
+#
+# If you are adding to this file consider if a similar change needs to
+# be made to contrib/gitdm/aliases. They are not however completely
+# analogous. .mailmap is concerned with fixing up damaged author
+# fields where as the gitdm equivalent is more concerned with making
+# sure multiple email addresses get mapped onto the same author.
+#
+# From man git-shortlog the forms are:
+#
+#  Proper Name <commit@email.xx>
+#  <proper@email.xx> <commit@email.xx>
+#  Proper Name <proper@email.xx> <commit@email.xx>
+#  Proper Name <proper@email.xx> Commit Name <commit@email.xx>
+#
+
+# The first section translates weird addresses from the original git import
+# into proper addresses so that they are counted properly by git shortlog.
+Andrzej Zaborowski <balrogg@gmail.com> balrog <balrog@c046a42c-6fe2-441c-8c8c-71466251a162>
+Anthony Liguori <anthony@codemonkey.ws> aliguori <aliguori@c046a42c-6fe2-441c-8c8c-71466251a162>
+Aurelien Jarno <aurelien@aurel32.net> aurel32 <aurel32@c046a42c-6fe2-441c-8c8c-71466251a162>
+Blue Swirl <blauwirbel@gmail.com> blueswir1 <blueswir1@c046a42c-6fe2-441c-8c8c-71466251a162>
+Edgar E. Iglesias <edgar.iglesias@gmail.com> edgar_igl <edgar_igl@c046a42c-6fe2-441c-8c8c-71466251a162>
+Fabrice Bellard <fabrice@bellard.org> bellard <bellard@c046a42c-6fe2-441c-8c8c-71466251a162>
+Jocelyn Mayer <l_indien@magic.fr> j_mayer <j_mayer@c046a42c-6fe2-441c-8c8c-71466251a162>
+Paul Brook <paul@codesourcery.com> pbrook <pbrook@c046a42c-6fe2-441c-8c8c-71466251a162>
+Thiemo Seufer <ths@networkno.de> ths <ths@c046a42c-6fe2-441c-8c8c-71466251a162>
+malc <av1474@comtv.ru> malc <malc@c046a42c-6fe2-441c-8c8c-71466251a162>
+
+# Corrupted Author fields
+Marek Dolata <mkdolata@us.ibm.com> mkdolata@us.ibm.com <mkdolata@us.ibm.com>
+Nick Hudson <hnick@vmware.com> hnick@vmware.com <hnick@vmware.com>
+
+# There is also a:
+#    (no author) <(no author)@c046a42c-6fe2-441c-8c8c-71466251a162>
+# for the cvs2svn initialization commit e63c3dc74bf.
+
+# Next, translate a few commits where mailman rewrote the From: line due
+# to strict SPF, although we prefer to avoid adding more entries like that.
+Ed Swierk <eswierk@skyportsystems.com> Ed Swierk via Qemu-devel <qemu-devel@nongnu.org>
+Ian McKellar <ianloic@google.com> Ian McKellar via Qemu-devel <qemu-devel@nongnu.org>
+Julia Suvorova <jusual@mail.ru> Julia Suvorova via Qemu-devel <qemu-devel@nongnu.org>
+Justin Terry (VM) <juterry@microsoft.com> Justin Terry (VM) via Qemu-devel <qemu-devel@nongnu.org>
+
+# Next, replace old addresses by a more recent one.
+Aleksandar Markovic <aleksandar.qemu.devel@gmail.com> <aleksandar.markovic@mips.com>
+Aleksandar Markovic <aleksandar.qemu.devel@gmail.com> <aleksandar.markovic@imgtec.com>
+Aleksandar Markovic <aleksandar.qemu.devel@gmail.com> <amarkovic@wavecomp.com>
+Aleksandar Rikalo <aleksandar.rikalo@syrmia.com> <arikalo@wavecomp.com>
+Aleksandar Rikalo <aleksandar.rikalo@syrmia.com> <aleksandar.rikalo@rt-rk.com>
+Alexander Graf <agraf@csgraf.de> <agraf@suse.de>
+Anthony Liguori <anthony@codemonkey.ws> Anthony Liguori <aliguori@us.ibm.com>
+Filip Bozuta <filip.bozuta@syrmia.com> <filip.bozuta@rt-rk.com.com>
+Frederic Konrad <konrad@adacore.com> <fred.konrad@greensocs.com>
+Greg Kurz <groug@kaod.org> <gkurz@linux.vnet.ibm.com>
+Huacai Chen <chenhuacai@kernel.org> <chenhc@lemote.com>
+Huacai Chen <chenhuacai@kernel.org> <chenhuacai@loongson.cn>
+James Hogan <jhogan@kernel.org> <james.hogan@imgtec.com>
+Leif Lindholm <leif@nuviainc.com> <leif.lindholm@linaro.org>
+Radoslaw Biernacki <rad@semihalf.com> <radoslaw.biernacki@linaro.org>
+Paul Burton <paulburton@kernel.org> <paul.burton@mips.com>
+Paul Burton <paulburton@kernel.org> <paul.burton@imgtec.com>
+Paul Burton <paulburton@kernel.org> <paul@archlinuxmips.org>
+Paul Burton <paulburton@kernel.org> <pburton@wavecomp.com>
+Stefan Brankovic <stefan.brankovic@syrmia.com> <stefan.brankovic@rt-rk.com.com>
+Yongbok Kim <yongbok.kim@mips.com> <yongbok.kim@imgtec.com>
+
+# Also list preferred name forms where people have changed their
+# git author config, or had utf8/latin1 encoding issues.
+Aaron Lindsay <aaron@os.amperecomputing.com>
+Alexey Gerasimenko <x1917x@gmail.com>
+Alex Chen <alex.chen@huawei.com>
+Alex Ivanov <void@aleksoft.net>
+Andreas Frber <afaerber@suse.de>
+Bandan Das <bsd@redhat.com>
+Benjamin MARSILI <mlspirat42@gmail.com>
+Benot Canet <benoit.canet@gmail.com>
+Benot Canet <benoit.canet@irqsave.net>
+Benot Canet <benoit.canet@nodalink.com>
+Boqun Feng <boqun.feng@gmail.com>
+Boqun Feng <boqun.feng@intel.com>
+Brad Smith <brad@comstyle.com>
+Brijesh Singh <brijesh.singh@amd.com>
+Brilly Wu <brillywu@viatech.com.cn>
+Cdric Vincent <cedric.vincent@st.com>
+CheneyLin <linzc@zju.edu.cn>
+Chen Gang <chengang@emindsoft.com.cn>
+Chen Gang <gang.chen.5i5j@gmail.com>
+Chen Gang <gang.chen@sunrus.com.cn>
+Chen Wei-Ren <chenwj@iis.sinica.edu.tw>
+Christophe Lyon <christophe.lyon@st.com>
+Collin L. Walling <walling@linux.ibm.com>
+Daniel P. Berrang <berrange@redhat.com>
+Eduardo Otubo <otubo@redhat.com>
+Erik Smit <erik.lucas.smit@gmail.com>
+Fabrice Desclaux <fabrice.desclaux@cea.fr>
+Fernando Luis Vzquez Cao <fernando_b1@lab.ntt.co.jp>
+Fernando Luis Vzquez Cao <fernando@oss.ntt.co.jp>
+Gautham R. Shenoy <ego@in.ibm.com>
+Gautham R. Shenoy <ego@linux.vnet.ibm.com>
+Gonglei (Arei) <arei.gonglei@huawei.com>
+Guang Wang <wang.guang55@zte.com.cn>
+Haibin Zhang <haibinzhang@tencent.com>
+Hailiang Zhang <zhang.zhanghailiang@huawei.com>
+Hanna Reitz <hreitz@redhat.com> <mreitz@redhat.com>
+Herv Poussineau <hpoussin@reactos.org>
+Hyman Huang <huangy81@chinatelecom.cn>
+Jakub Jerm <jakub@jermar.eu>
+Jakub Jerm <jakub.jermar@kernkonzept.com>
+Jean-Christophe Dubois <jcd@tribudubois.net>
+Jindich Makovika <makovick@gmail.com>
+John Arbuckle <programmingkidx@gmail.com>
+Juha Riihimki <juha.riihimaki@nokia.com>
+Juha Riihimki <Juha.Riihimaki@nokia.com>
+Jun Li <junmuzi@gmail.com>
+Laurent Vivier <Laurent@lvivier.info>
+Leandro Lupori <leandro.lupori@gmail.com>
+Li Guang <lig.fnst@cn.fujitsu.com>
+Liming Wang <walimisdev@gmail.com>
+linzhecheng <linzc@zju.edu.cn>
+Liran Schour <lirans@il.ibm.com>
+Liu Yu <yu.liu@freescale.com>
+Liu Yu <Yu.Liu@freescale.com>
+Li Zhang <zhlcindy@gmail.com>
+Li Zhang <zhlcindy@linux.vnet.ibm.com>
+Llus Vilanova <vilanova@ac.upc.edu>
+Llus Vilanova <xscript@gmx.net>
+Longpeng (Mike) <longpeng2@huawei.com>
+Luc Michel <luc.michel@git.antfield.fr>
+Luc Michel <luc.michel@greensocs.com>
+Marc Mar <marc.mari.barcelo@gmail.com>
+Marc Mar <markmb@redhat.com>
+Michael Avdienko <whitearchey@gmail.com>
+Michael S. Tsirkin <mst@redhat.com>
+Munkyu Im <munkyu.im@samsung.com>
+Nicholas Bellinger <nab@linux-iscsi.org>
+Nicholas Thomas <nick@bytemark.co.uk>
+Nikunj A Dadhania <nikunj@linux.vnet.ibm.com>
+Orit Wasserman <owasserm@redhat.com>
+Paolo Bonzini <pbonzini@redhat.com>
+Pan Nengyuan <pannengyuan@huawei.com>
+Pavel Dovgaluk <dovgaluk@ispras.ru>
+Pavel Dovgaluk <pavel.dovgaluk@gmail.com>
+Pavel Dovgaluk <Pavel.Dovgaluk@ispras.ru>
+Peter Crosthwaite <crosthwaite.peter@gmail.com>
+Peter Crosthwaite <peter.crosthwaite@petalogix.com>
+Peter Crosthwaite <peter.crosthwaite@xilinx.com>
+Prasad J Pandit <pjp@fedoraproject.org>
+Prasad J Pandit <ppandit@redhat.com>
+Qiao Nuohan <qiaonuohan@cn.fujitsu.com>
+Reimar Dffinger <Reimar.Doeffinger@gmx.de>
+Remy Noel <remy.noel@blade-group.com>
+Roger Pau Monn <roger.pau@citrix.com>
+Shin'ichiro Kawasaki <kawasaki@juno.dti.ne.jp>
+Shin'ichiro Kawasaki <shinichiro.kawasaki@wdc.com>
+Sochin Jiang <sochin.jiang@huawei.com>
+Stefan Berger <stefanb@linux.vnet.ibm.com> <stefanb@linux.ibm.com>
+Takashi Yoshii <takasi-y@ops.dti.ne.jp>
+Thomas Huth <thuth@redhat.com>
+Thomas Knych <thomaswk@google.com>
+Timothy Baldwin <T.E.Baldwin99@members.leeds.ac.uk>
+Tony Nguyen <tony.nguyen@bt.com>
+Venkateswararao Jujjuri <jvrao@linux.vnet.ibm.com>
+Vibi Sreenivasan <vibi_sreenivasan@cms.com>
+Vijaya Kumar K <vijayak@cavium.com>
+Vijaya Kumar K <Vijaya.Kumar@cavium.com>
+Vijay Kumar <vijaykumar@bravegnu.org>
+Vijay Kumar <vijaykumar@zilogic.com>
+Wang Guang <wang.guang55@zte.com.cn>
+Wenchao Xia <xiawenc@linux.vnet.ibm.com>
+Wenshuang Ma <kevinnma@tencent.com>
+Xiaoqiang Zhao <zxq_yx_007@163.com>
+Xinhua Cao <caoxinhua@huawei.com>
+Xiong Zhang <xiong.y.zhang@intel.com>
+Yin Yin <yin.yin@cs2c.com.cn>
+Yu-Chen Lin <npes87184@gmail.com>
+Yu-Chen Lin <npes87184@gmail.com> <yuchenlin@synology.com>
+YunQiang Su <syq@debian.org>
+YunQiang Su <ysu@wavecomp.com>
+Yuri Pudgorodskiy <yur@virtuozzo.com>
+Zhengui Li <lizhengui@huawei.com>
+Zhenwei Pi <pizhenwei@bytedance.com>
+Zhenwei Pi <zhenwei.pi@youruncloud.com>
+Zhuang Yanying <ann.zhuangyanying@huawei.com>
diff --git a/.patchew.yml b/.patchew.yml
new file mode 100644
index 0000000..1b78262
--- /dev/null
+++ b/.patchew.yml
@@ -0,0 +1,299 @@
+---
+# Note: this file is still unused.  It serves as a documentation for the
+# Patchew configuration in case patchew.org disappears or has to be
+# reinstalled.
+#
+# Patchew configuration is available to project administrators at
+# https://patchew.org/api/v1/projects/1/config/ and can be configured
+# to YAML using the following Python script:
+#
+#     import json
+#     import sys
+#     import ruamel.yaml
+#
+#     json_str = sys.stdin.read()
+#     yaml = ruamel.yaml.YAML()
+#     yaml.explicit_start = True
+#     data = json.loads(json_str, object_pairs_hook=ruamel.yaml.comments.CommentedMap)
+#     ruamel.yaml.scalarstring.walk_tree(data)
+#     yaml.dump(data, sys.stdout)
+
+email:
+  notifications:
+    timeouts:
+      event: TestingReport
+      enabled: true
+      to_user: false
+      reply_subject: true
+      set_reply_to: true
+      in_reply_to: true
+      reply_to_all: false
+      subject_template: none
+      to: fam@euphon.net
+      cc: ''
+      body_template: |
+        {% if not is_timeout %} {{ cancel }} {% endif %}
+
+        Test '{{ test }}' timeout, log:
+
+        {{ log }}
+    ENOSPC:
+      event: TestingReport
+      enabled: true
+      to_user: false
+      reply_subject: false
+      set_reply_to: false
+      in_reply_to: true
+      reply_to_all: false
+      subject_template: Out of space error
+      to: fam@euphon.net
+      cc: ''
+      body_template: |
+        {% if passed %}
+          {{ cancel }}
+        {% endif %}
+
+        {% if 'No space left on device' in log %}
+        Tester {{ tester }} out of space when running {{ test }}
+
+          {{ log }}
+        {% else %}
+          {{ cancel }}
+        {% endif %}
+    FailureShort:
+      event: TestingReport
+      enabled: true
+      to_user: false
+      reply_subject: true
+      set_reply_to: true
+      in_reply_to: true
+      reply_to_all: true
+      subject_template: Testing failed
+      to: ''
+      cc: ''
+      body_template: |
+        {% if passed or not obj.message_id or is_timeout %}
+          {{ cancel }}
+        {% endif %}
+        {% if 'No space left on device' in log %}
+          {{ cancel }}
+        {% endif %}
+        Patchew URL: https://patchew.org/QEMU/{{ obj.message_id }}/
+
+        {% ansi2text log as logtext %}
+        {% if test == "checkpatch" %}
+        Hi,
+
+        This series seems to have some coding style problems. See output below for
+        more information:
+
+        {{ logtext }}
+        {% elif test == "docker-mingw@fedora" or test == "docker-quick@centos8" or test == "asan" %}
+        Hi,
+
+        This series failed the {{ test }} build test. Please find the testing commands and
+        their output below. If you have Docker installed, you can probably reproduce it
+        locally.
+
+        {% lines_between logtext start="^=== TEST SCRIPT BEGIN ===$" stop="^=== TEST SCRIPT END ===$" %}
+        {% lines_between logtext start="^=== OUTPUT BEGIN ===$" stop="=== OUTPUT END ===$" as output %}
+        {% grep_C output regex="\b(FAIL|XPASS|ERROR|WARN|error:|warning:)" n=3 %}
+        {% elif test == "s390x" or test == "FreeBSD" or test == "ppcle" or test == "ppcbe" %}
+        Hi,
+
+        This series failed build test on {{test}} host. Please find the details below.
+
+        {% lines_between logtext start="^=== TEST SCRIPT BEGIN ===$" stop="^=== TEST SCRIPT END ===$" %}
+        {% lines_between logtext start="^=== OUTPUT BEGIN ===$" stop="=== OUTPUT END ===$" as output %}
+        {% grep_C output regex="\b(FAIL|XPASS|ERROR|WARN|error:|warning:)" n=3 %}
+        {% else %}
+        {{ cancel }}
+        {% endif %}
+
+        The full log is available at
+        {{ log_url }}.
+        ---
+        Email generated automatically by Patchew [https://patchew.org/].
+        Please send your feedback to patchew-devel@redhat.com
+testing:
+  tests:
+    asan:
+      enabled: true
+      requirements: docker
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        time make docker-test-debug@fedora TARGET_LIST=x86_64-softmmu J=14 NETWORK=1
+    docker-quick@centos8:
+      enabled: false
+      requirements: docker,x86_64
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        time make docker-test-quick@centos8 SHOW_ENV=1 J=14 NETWORK=1
+    checkpatch:
+      enabled: true
+      requirements: ''
+      timeout: 600
+      script: |
+        #!/bin/bash
+        git rev-parse base > /dev/null || exit 0
+        ./scripts/checkpatch.pl --mailback base..
+    docker-mingw@fedora:
+      enabled: true
+      requirements: docker,x86_64
+      timeout: 3600
+      script: |
+        #! /bin/bash
+        test "$(uname -m)" = "x86_64"
+    ppcle:
+      enabled: false
+      requirements: ppcle
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        # Testing script will be invoked under the git checkout with
+        # HEAD pointing to a commit that has the patches applied on top of "base"
+        # branch
+        set -e
+        CC=$HOME/bin/cc
+        INSTALL=$PWD/install
+        BUILD=$PWD/build
+        mkdir -p $BUILD $INSTALL
+        SRC=$PWD
+        cd $BUILD
+        $SRC/configure --cc=$CC --prefix=$INSTALL
+        make -j4
+        # XXX: we need reliable clean up
+        # make check -j4 V=1
+        make install
+
+        echo
+        echo "=== ENV ==="
+        env
+
+        echo
+        echo "=== PACKAGES ==="
+        rpm -qa
+    ppcbe:
+      enabled: false
+      requirements: ppcbe
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        # Testing script will be invoked under the git checkout with
+        # HEAD pointing to a commit that has the patches applied on top of "base"
+        # branch
+        set -e
+        CC=$HOME/bin/cc
+        INSTALL=$PWD/install
+        BUILD=$PWD/build
+        mkdir -p $BUILD $INSTALL
+        SRC=$PWD
+        cd $BUILD
+        $SRC/configure --cc=$CC --prefix=$INSTALL
+        make -j4
+        # XXX: we need reliable clean up
+        # make check -j4 V=1
+        make install
+
+        echo
+        echo "=== ENV ==="
+        env
+
+        echo
+        echo "=== PACKAGES ==="
+        rpm -qa
+    FreeBSD:
+      enabled: true
+      requirements: qemu-x86,x86_64,git
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        # Testing script will be invoked under the git checkout with
+        # HEAD pointing to a commit that has the patches applied on top of "base"
+        # branch
+        if qemu-system-x86_64 --help >/dev/null 2>&1; then
+          QEMU=qemu-system-x86_64
+        elif /usr/libexec/qemu-kvm --help >/dev/null 2>&1; then
+          QEMU=/usr/libexec/qemu-kvm
+        else
+          exit 1
+        fi
+        make vm-build-freebsd J=21 QEMU=$QEMU
+        exit 0
+    docker-clang@ubuntu:
+      enabled: true
+      requirements: docker,x86_64
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        time make docker-test-clang@ubuntu SHOW_ENV=1 J=14 NETWORK=1
+    s390x:
+      enabled: true
+      requirements: s390x
+      timeout: 3600
+      script: |
+        #!/bin/bash
+        # Testing script will be invoked under the git checkout with
+        # HEAD pointing to a commit that has the patches applied on top of "base"
+        # branch
+        set -e
+        CC=$HOME/bin/cc
+        INSTALL=$PWD/install
+        BUILD=$PWD/build
+        mkdir -p $BUILD $INSTALL
+        SRC=$PWD
+        cd $BUILD
+        $SRC/configure --cc=$CC --prefix=$INSTALL
+        make -j4
+        # XXX: we need reliable clean up
+        # make check -j4 V=1
+        make install
+
+        echo
+        echo "=== ENV ==="
+        env
+
+        echo
+        echo "=== PACKAGES ==="
+        rpm -qa
+  requirements:
+    x86_64:
+      script: |
+        #! /bin/bash
+        test "$(uname -m)" = "x86_64"
+    qemu-x86:
+      script: |
+        #!/bin/bash
+        if qemu-system-x86_64 --help >/dev/null 2>&1; then
+          :
+        elif /usr/libexec/qemu-kvm --help >/dev/null 2>&1; then
+          :
+        else
+          exit 1
+        fi
+    ppcle:
+      script: |
+        #!/bin/bash
+        test "$(uname -m)" = "ppc64le"
+    ppcbe:
+      script: |
+        #!/bin/bash
+        test "$(uname -m)" = "ppc64"
+    git:
+      script: |
+        #! /bin/bash
+        git config user.name > /dev/null 2>&1
+    docker:
+      script: |
+        #!/bin/bash
+        docker ps || sudo -n docker ps
+    s390x:
+      script: |
+        #!/bin/bash
+        test "$(uname -m)" = "s390x"
+git:
+  push_to: git@github.com:patchew-project/qemu
+  public_repo: https://github.com/patchew-project/qemu
+  url_template: https://github.com/patchew-project/qemu/tree/%t
diff --git a/.readthedocs.yml b/.readthedocs.yml
new file mode 100644
index 0000000..7fb7b8d
--- /dev/null
+++ b/.readthedocs.yml
@@ -0,0 +1,20 @@
+# .readthedocs.yml
+# Read the Docs configuration file
+# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details
+
+# Required
+version: 2
+
+# Build documentation in the docs/ directory with Sphinx
+sphinx:
+  configuration: docs/conf.py
+
+# We want all the document formats
+formats: all
+
+# For consistency, we require that QEMU's Sphinx extensions
+# run with at least the same minimum version of Python that
+# we require for other Python in our codebase (our conf.py
+# enforces this, and some code needs it.)
+python:
+  version: 3.6
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..41010eb
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,307 @@
+# The current Travis default is a VM based 16.04 Xenial on GCE
+# Additional builds with specific requirements for a full VM need to
+# be added as additional matrix: entries later on
+os: linux
+dist: focal
+language: c
+compiler:
+  - gcc
+cache:
+  # There is one cache per branch and compiler version.
+  # characteristics of each job are used to identify the cache:
+  # - OS name (currently only linux)
+  # - OS distribution (for Linux, bionic or focal)
+  # - Names and values of visible environment variables set in .travis.yml or Settings panel
+  timeout: 1200
+  ccache: true
+  pip: true
+  directories:
+  - $HOME/avocado/data/cache
+
+
+addons:
+  apt:
+    packages:
+      # Build dependencies
+      - libaio-dev
+      - libattr1-dev
+      - libbrlapi-dev
+      - libcap-ng-dev
+      - libcacard-dev
+      - libgcc-7-dev
+      - libgnutls28-dev
+      - libgtk-3-dev
+      - libiscsi-dev
+      - liblttng-ust-dev
+      - libncurses5-dev
+      - libnfs-dev
+      - libpixman-1-dev
+      - libpng-dev
+      - librados-dev
+      - libsdl2-dev
+      - libsdl2-image-dev
+      - libseccomp-dev
+      - libspice-protocol-dev
+      - libspice-server-dev
+      - libssh-dev
+      - liburcu-dev
+      - libusb-1.0-0-dev
+      - libvdeplug-dev
+      - libvte-2.91-dev
+      - libzstd-dev
+      - ninja-build
+      - sparse
+      - uuid-dev
+      # Tests dependencies
+      - genisoimage
+
+
+# The channel name "irc.oftc.net#qemu" is encrypted against qemu/qemu
+# to prevent IRC notifications from forks. This was created using:
+# $ travis encrypt -r "qemu/qemu" "irc.oftc.net#qemu"
+notifications:
+  irc:
+    channels:
+      - secure: "F7GDRgjuOo5IUyRLqSkmDL7kvdU4UcH3Lm/W2db2JnDHTGCqgEdaYEYKciyCLZ57vOTsTsOgesN8iUT7hNHBd1KWKjZe9KDTZWppWRYVwAwQMzVeSOsbbU4tRoJ6Pp+3qhH1Z0eGYR9ZgKYAoTumDFgSAYRp4IscKS8jkoedOqM="
+    on_success: change
+    on_failure: always
+
+
+env:
+  global:
+    - SRC_DIR=".."
+    - BUILD_DIR="build"
+    - BASE_CONFIG="--disable-docs --disable-tools"
+    - TEST_BUILD_CMD=""
+    - TEST_CMD="make check V=1"
+    # This is broadly a list of "mainline" softmmu targets which have support across the major distros
+    - MAIN_SOFTMMU_TARGETS="aarch64-softmmu,mips64-softmmu,ppc64-softmmu,riscv64-softmmu,s390x-softmmu,x86_64-softmmu"
+    - CCACHE_SLOPPINESS="include_file_ctime,include_file_mtime"
+    - CCACHE_MAXSIZE=1G
+    - G_MESSAGES_DEBUG=error
+
+
+git:
+  # we want to do this ourselves
+  submodules: false
+
+# Common first phase for all steps
+# We no longer use nproc to calculate jobs:
+# https://travis-ci.community/t/nproc-reports-32-cores-on-arm64/5851
+before_install:
+  - if command -v ccache ; then ccache --zero-stats ; fi
+  - export JOBS=3
+  - echo "=== Using ${JOBS} simultaneous jobs ==="
+
+# Configure step - may be overridden
+before_script:
+  - mkdir -p ${BUILD_DIR} && cd ${BUILD_DIR}
+  - ${SRC_DIR}/configure ${BASE_CONFIG} ${CONFIG} || { cat config.log meson-logs/meson-log.txt && exit 1; }
+
+# Main build & test - rarely overridden - controlled by TEST_CMD
+script:
+  - BUILD_RC=0 && make -j${JOBS} || BUILD_RC=$?
+  - |
+    if [ "$BUILD_RC" -eq 0 ] && [ -n "$TEST_BUILD_CMD" ]; then
+        ${TEST_BUILD_CMD} || BUILD_RC=$?
+    else
+        $(exit $BUILD_RC);
+    fi
+  - |
+    if [ "$BUILD_RC" -eq 0 ] ; then
+        ${TEST_CMD} ;
+    else
+        $(exit $BUILD_RC);
+    fi
+after_script:
+  - df -h
+  - if command -v ccache ; then ccache --show-stats ; fi
+
+
+jobs:
+  include:
+
+    - name: "[aarch64] GCC check-tcg"
+      arch: arm64
+      dist: focal
+      addons:
+        apt_packages:
+          - libaio-dev
+          - libattr1-dev
+          - libbrlapi-dev
+          - libcacard-dev
+          - libcap-ng-dev
+          - libgcrypt20-dev
+          - libgnutls28-dev
+          - libgtk-3-dev
+          - libiscsi-dev
+          - liblttng-ust-dev
+          - libncurses5-dev
+          - libnfs-dev
+          - libpixman-1-dev
+          - libpng-dev
+          - librados-dev
+          - libsdl2-dev
+          - libseccomp-dev
+          - liburcu-dev
+          - libusb-1.0-0-dev
+          - libvdeplug-dev
+          - libvte-2.91-dev
+          - ninja-build
+          # Tests dependencies
+          - genisoimage
+      env:
+        - TEST_CMD="make check check-tcg V=1"
+        - CONFIG="--disable-containers --target-list=${MAIN_SOFTMMU_TARGETS} --cxx=/bin/false"
+        - UNRELIABLE=true
+
+    - name: "[ppc64] GCC check-tcg"
+      arch: ppc64le
+      dist: focal
+      addons:
+        apt_packages:
+          - libaio-dev
+          - libattr1-dev
+          - libbrlapi-dev
+          - libcacard-dev
+          - libcap-ng-dev
+          - libgcrypt20-dev
+          - libgnutls28-dev
+          - libgtk-3-dev
+          - libiscsi-dev
+          - liblttng-ust-dev
+          - libncurses5-dev
+          - libnfs-dev
+          - libpixman-1-dev
+          - libpng-dev
+          - librados-dev
+          - libsdl2-dev
+          - libseccomp-dev
+          - liburcu-dev
+          - libusb-1.0-0-dev
+          - libvdeplug-dev
+          - libvte-2.91-dev
+          - ninja-build
+          # Tests dependencies
+          - genisoimage
+      env:
+        - TEST_CMD="make check check-tcg V=1"
+        - CONFIG="--disable-containers --target-list=ppc64-softmmu,ppc64le-linux-user"
+
+    - name: "[s390x] GCC check-tcg"
+      arch: s390x
+      dist: bionic
+      addons:
+        apt_packages:
+          - libaio-dev
+          - libattr1-dev
+          - libbrlapi-dev
+          - libcacard-dev
+          - libcap-ng-dev
+          - libgcrypt20-dev
+          - libgnutls28-dev
+          - libgtk-3-dev
+          - libiscsi-dev
+          - liblttng-ust-dev
+          - libncurses5-dev
+          - libnfs-dev
+          - libpixman-1-dev
+          - libpng-dev
+          - librados-dev
+          - libsdl2-dev
+          - libseccomp-dev
+          - liburcu-dev
+          - libusb-1.0-0-dev
+          - libvdeplug-dev
+          - libvte-2.91-dev
+          - ninja-build
+          # Tests dependencies
+          - genisoimage
+      env:
+        - TEST_CMD="make check check-tcg V=1"
+        - CONFIG="--disable-containers --target-list=${MAIN_SOFTMMU_TARGETS},s390x-linux-user"
+        - UNRELIABLE=true
+      script:
+        - BUILD_RC=0 && make -j${JOBS} || BUILD_RC=$?
+        - |
+          if [ "$BUILD_RC" -eq 0 ] ; then
+              mv pc-bios/s390-ccw/*.img pc-bios/ ;
+              ${TEST_CMD} ;
+          else
+              $(exit $BUILD_RC);
+          fi
+
+    - name: "[s390x] GCC (other-softmmu)"
+      arch: s390x
+      dist: bionic
+      addons:
+        apt_packages:
+          - libaio-dev
+          - libattr1-dev
+          - libcacard-dev
+          - libcap-ng-dev
+          - libgnutls28-dev
+          - libiscsi-dev
+          - liblttng-ust-dev
+          - liblzo2-dev
+          - libncurses-dev
+          - libnfs-dev
+          - libpixman-1-dev
+          - libsdl2-dev
+          - libsdl2-image-dev
+          - libseccomp-dev
+          - libsnappy-dev
+          - libzstd-dev
+          - nettle-dev
+          - xfslibs-dev
+          - ninja-build
+          # Tests dependencies
+          - genisoimage
+      env:
+        - CONFIG="--disable-containers --audio-drv-list=sdl --disable-user
+                  --target-list-exclude=${MAIN_SOFTMMU_TARGETS}"
+
+    - name: "[s390x] GCC (user)"
+      arch: s390x
+      dist: bionic
+      addons:
+        apt_packages:
+          - libgcrypt20-dev
+          - libgnutls28-dev
+          - ninja-build
+      env:
+        - CONFIG="--disable-containers --disable-system"
+
+    - name: "[s390x] Clang (disable-tcg)"
+      arch: s390x
+      dist: bionic
+      compiler: clang
+      addons:
+        apt_packages:
+          - libaio-dev
+          - libattr1-dev
+          - libbrlapi-dev
+          - libcacard-dev
+          - libcap-ng-dev
+          - libgcrypt20-dev
+          - libgnutls28-dev
+          - libgtk-3-dev
+          - libiscsi-dev
+          - liblttng-ust-dev
+          - libncurses5-dev
+          - libnfs-dev
+          - libpixman-1-dev
+          - libpng-dev
+          - librados-dev
+          - libsdl2-dev
+          - libseccomp-dev
+          - liburcu-dev
+          - libusb-1.0-0-dev
+          - libvdeplug-dev
+          - libvte-2.91-dev
+          - ninja-build
+      env:
+        - TEST_CMD="make check-unit"
+        - CONFIG="--disable-containers --disable-tcg --enable-kvm
+                  --disable-tools --host-cc=clang --cxx=clang++"
+        - UNRELIABLE=true
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..2b07dc1
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,10 @@
+{
+    "files.associations": {
+        "cni_logger.h": "c",
+        "array": "c",
+        "string_view": "c",
+        "initializer_list": "c",
+        "utility": "c",
+        "osdep.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/GNUmakefile b/GNUmakefile
new file mode 100644
index 0000000..622fd9f
--- /dev/null
+++ b/GNUmakefile
@@ -0,0 +1,20 @@
+# This file is auto-generated by configure to support in-source tree
+# 'make' command invocation
+
+ifeq ($(MAKECMDGOALS),)
+recurse: all
+endif
+
+.NOTPARALLEL: %
+%: force
+	@echo 'changing dir to build for $(MAKE) "$(MAKECMDGOALS)"...'
+	@$(MAKE) -C build -f Makefile $(MAKECMDGOALS)
+	@if test "$(MAKECMDGOALS)" = "distclean" && \
+	    test -e build/auto-created-by-configure ; \
+	then \
+	    rm -rf build GNUmakefile ; \
+	fi
+force: ;
+.PHONY: force
+GNUmakefile: ;
+
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index eecd803..42c4557 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -16,6 +16,7 @@
 #include "qemu/osdep.h"
 #include <sys/ioctl.h>
 #include <poll.h>
+#include <unistd.h>
 
 #include <linux/kvm.h>
 
@@ -45,9 +46,11 @@
 #include "qemu/guest-random.h"
 #include "sysemu/hw_accel.h"
 #include "kvm-cpus.h"
-
 #include "hw/boards.h"
 
+#include "hw/vfio/cni_logger.h"
+
+
 /* This check must be after config-host.h is included */
 #ifdef CONFIG_EVENTFD
 #include <sys/eventfd.h>
@@ -355,11 +358,14 @@ static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, boo
     struct kvm_userspace_memory_region mem;
     int ret;
 
+    
+
     mem.slot = slot->slot | (kml->as_id << 16);
     mem.guest_phys_addr = slot->start_addr;
     mem.userspace_addr = (unsigned long)slot->ram;
     mem.flags = slot->flags;
 
+
     if (slot->memory_size && !new && (mem.flags ^ slot->old_flags) & KVM_MEM_READONLY) {
         /* Set the slot size to 0 before setting the slot to the desired
          * value. This is needed based on KVM commit 75d61fbc. */
@@ -372,6 +378,26 @@ static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, boo
     mem.memory_size = slot->memory_size;
     ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
     slot->old_flags = mem.flags;
+
+    char msg[256];
+    sprintf(msg, "kvm-setMem: pid: %d, GPA: 0x%llx, HVA: 0x%llx, size: 0x%llx", getpid(), mem.guest_phys_addr, mem.userspace_addr, mem.memory_size);
+    cni_log_info(msg);
+
+    // //[lyz] register
+    // int fastiov_fd = get_fastiov_fd();
+    // int cur_pid = getpid();
+    // int cur_tid = (int)syscall(SYS_gettid);
+    // if (fastiov_fd > 0 && mem.guest_phys_addr == 0 && mem.memory_size == 0x20000000 && cur_pid == cur_tid) {
+    //     struct fastiov_user_params params;
+    //     params.pid = cur_pid;
+    //     params.hva_start = mem.userspace_addr;
+    //     if (ioctl(fastiov_fd, FASTIOV_REGISTER_PID, &params) < 0) {
+    //         cni_log_info2(false, "ioctl FASTIOV_REGISTER_PID for pid %d error", cur_pid);
+    //     } else {
+    //         cni_log_info2(false, "ioctl FASTIOV_REGISTER_PID for pid %d ok", cur_pid);
+    //     }
+    // }
+
 err:
     trace_kvm_set_user_memory(mem.slot, mem.flags, mem.guest_phys_addr,
                               mem.memory_size, mem.userspace_addr, ret);
@@ -2913,6 +2939,7 @@ int kvm_cpu_exec(CPUState *cpu)
             break;
         case KVM_EXIT_SHUTDOWN:
             DPRINTF("shutdown\n");
+            cni_log_info("kvm_shutdown");
             qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);
             ret = EXCP_INTERRUPT;
             break;
@@ -2942,6 +2969,7 @@ int kvm_cpu_exec(CPUState *cpu)
                 ret = EXCP_INTERRUPT;
                 break;
             case KVM_SYSTEM_EVENT_RESET:
+                cni_log_info("kvm_system_shutdown");
                 qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);
                 ret = EXCP_INTERRUPT;
                 break;
diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index cd03802..37a87f2 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -18,6 +18,9 @@
 #include "qom/object_interfaces.h"
 #include "qom/object.h"
 
+#include "hw/vfio/cni_logger.h"
+#include "exec/ramblock.h"
+
 OBJECT_DECLARE_SIMPLE_TYPE(HostMemoryBackendFile, MEMORY_BACKEND_FILE)
 
 
@@ -58,6 +61,11 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), name,
                                      backend->size, fb->align, ram_flags,
                                      fb->mem_path, fb->readonly, errp);
+
+    char msg[256];
+    sprintf(msg, "ramblock-filealloc: host: %p, size: %jx", ((backend->mr).ram_block)->host, backend->size);
+    cni_log_info(msg);
+
     g_free(name);
 #endif
 }
diff --git a/backends/hostmem-memfd.c b/backends/hostmem-memfd.c
index 3fc85c3..244c2e4 100644
--- a/backends/hostmem-memfd.c
+++ b/backends/hostmem-memfd.c
@@ -18,6 +18,9 @@
 #include "qapi/error.h"
 #include "qom/object.h"
 
+#include "hw/vfio/cni_logger.h"
+#include "exec/ramblock.h"
+
 #define TYPE_MEMORY_BACKEND_MEMFD "memory-backend-memfd"
 
 OBJECT_DECLARE_SIMPLE_TYPE(HostMemoryBackendMemfd, MEMORY_BACKEND_MEMFD)
@@ -57,6 +60,11 @@ memfd_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
     memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend), name,
                                    backend->size, ram_flags, fd, 0, errp);
+
+    char msg[256];
+    sprintf(msg, "ramblock-memfdalloc: host: %p, size: %jx", ((backend->mr).ram_block)->host, backend->size);
+    cni_log_info(msg);
+
     g_free(name);
 }
 
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index b8e55cd..35bb1c9 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -16,6 +16,9 @@
 #include "qemu/module.h"
 #include "qom/object_interfaces.h"
 
+#include "hw/vfio/cni_logger.h"
+#include "exec/ramblock.h"
+
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
@@ -32,6 +35,11 @@ ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
     memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend), name,
                                            backend->size, ram_flags, errp);
+
+    char msg[256];
+    sprintf(msg, "ramblock-ramalloc: host: %p, size: %jx", ((backend->mr).ram_block)->host, backend->size);
+    cni_log_info(msg);
+
     g_free(name);
 }
 
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 4c05862..8b9b50b 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -10,6 +10,10 @@
  * See the COPYING file in the top-level directory.
  */
 
+#include <sys/ioctl.h>
+#include "hw/vfio/cni_fastiov_ioctl.h"
+#include "hw/vfio/cni_logger.h"
+
 #include "qemu/osdep.h"
 #include "sysemu/hostmem.h"
 #include "hw/boards.h"
@@ -19,6 +23,7 @@
 #include "qemu/config-file.h"
 #include "qom/object_interfaces.h"
 #include "qemu/mmap-alloc.h"
+#include "exec/ramblock.h"
 
 #ifdef CONFIG_NUMA
 #include <numaif.h>
@@ -330,6 +335,7 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
     Error *local_err = NULL;
     void *ptr;
     uint64_t sz;
+    
 
     if (bc->alloc) {
         bc->alloc(backend, &local_err);
@@ -340,6 +346,10 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
         ptr = memory_region_get_ram_ptr(&backend->mr);
         sz = memory_region_size(&backend->mr);
 
+        char msg[256];
+        sprintf(msg, "ramblock: %p, host: %p", ptr, ((backend->mr).ram_block)->host);
+        cni_log_info(msg);
+
         if (backend->merge) {
             qemu_madvise(ptr, sz, QEMU_MADV_MERGEABLE);
         }
@@ -392,6 +402,23 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
          * specified NUMA policy in place.
          */
         if (backend->prealloc) {
+            /*************************** fastiov begin *****************************/
+            cni_log_info("touch all hugepages! qemu is now registering for fastiov");
+
+            int fastiov_fd = get_fastiov_fd();
+            if (fastiov_fd > 0) {
+                int cur_pid = getpid();
+                struct fastiov_user_params params;
+                params.pid = cur_pid;
+                params.hva_start = (unsigned long long)ptr;
+                if (ioctl(fastiov_fd, FASTIOV_REGISTER_PID, &params) < 0) {
+                    cni_log_info2(false, "ioctl FASTIOV_REGISTER_PID for pid %d hva 0x%llx, error", cur_pid, params.hva_start);
+                } else {
+                    cni_log_info2(false, "ioctl FASTIOV_REGISTER_PID for pid %d hva 0x%llx, ok", cur_pid, params.hva_start);
+                }
+            }
+            /*************************** fastiov end *****************************/
+
             os_mem_prealloc(memory_region_get_fd(&backend->mr), ptr, sz,
                             backend->prealloc_threads, &local_err);
             if (local_err) {
diff --git a/build_qemu.sh b/build_qemu.sh
new file mode 100644
index 0000000..321d239
--- /dev/null
+++ b/build_qemu.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+make -j4
diff --git a/docs/system/i386/sgx.rst b/docs/system/i386/sgx.rst
index f8fade5..0f0a73f 100644
--- a/docs/system/i386/sgx.rst
+++ b/docs/system/i386/sgx.rst
@@ -141,8 +141,7 @@ To launch a SGX guest:
   |qemu_system_x86| \\
    -cpu host,+sgx-provisionkey \\
    -object memory-backend-epc,id=mem1,size=64M,prealloc=on \\
-   -object memory-backend-epc,id=mem2,size=28M \\
-   -M sgx-epc.0.memdev=mem1,sgx-epc.1.memdev=mem2
+   -M sgx-epc.0.memdev=mem1,sgx-epc.0.node=0
 
 Utilizing SGX in the guest requires a kernel/OS with SGX support.
 The support can be determined in guest by::
@@ -152,8 +151,32 @@ The support can be determined in guest by::
 and SGX epc info by::
 
   $ dmesg | grep sgx
-  [    1.242142] sgx: EPC section 0x180000000-0x181bfffff
-  [    1.242319] sgx: EPC section 0x181c00000-0x1837fffff
+  [    0.182807] sgx: EPC section 0x140000000-0x143ffffff
+  [    0.183695] sgx: [Firmware Bug]: Unable to map EPC section to online node. Fallback to the NUMA node 0.
+
+To launch a SGX numa guest:
+
+.. parsed-literal::
+
+  |qemu_system_x86| \\
+   -cpu host,+sgx-provisionkey \\
+   -object memory-backend-ram,size=2G,host-nodes=0,policy=bind,id=node0 \\
+   -object memory-backend-epc,id=mem0,size=64M,prealloc=on,host-nodes=0,policy=bind \\
+   -numa node,nodeid=0,cpus=0-1,memdev=node0 \\
+   -object memory-backend-ram,size=2G,host-nodes=1,policy=bind,id=node1 \\
+   -object memory-backend-epc,id=mem1,size=28M,prealloc=on,host-nodes=1,policy=bind \\
+   -numa node,nodeid=1,cpus=2-3,memdev=node1 \\
+   -M sgx-epc.0.memdev=mem0,sgx-epc.0.node=0,sgx-epc.1.memdev=mem1,sgx-epc.1.node=1
+
+and SGX epc numa info by::
+
+  $ dmesg | grep sgx
+  [    0.369937] sgx: EPC section 0x180000000-0x183ffffff
+  [    0.370259] sgx: EPC section 0x184000000-0x185bfffff
+
+  $ dmesg | grep SRAT
+  [    0.009981] ACPI: SRAT: Node 0 PXM 0 [mem 0x180000000-0x183ffffff]
+  [    0.009982] ACPI: SRAT: Node 1 PXM 1 [mem 0x184000000-0x185bfffff]
 
 References
 ----------
diff --git a/dtc/.cirrus.yml b/dtc/.cirrus.yml
new file mode 100644
index 0000000..c270a09
--- /dev/null
+++ b/dtc/.cirrus.yml
@@ -0,0 +1,23 @@
+env:
+  CIRRUS_CLONE_DEPTH: 1
+
+freebsd_12_task:
+  freebsd_instance:
+    image: freebsd-12-1-release-amd64
+  install_script:
+    pkg install -y bison gmake pkgconf
+  build_script:
+    gmake
+  test_script:
+    gmake check
+
+linux_gcc_task:
+  container:
+    image: gcc:latest
+  install_script:
+    - apt-get update
+    - apt-get -y install bison flex
+  build_script:
+    - make
+  test_script:
+    - make check
diff --git a/dtc/.editorconfig b/dtc/.editorconfig
new file mode 100644
index 0000000..d7e68fb
--- /dev/null
+++ b/dtc/.editorconfig
@@ -0,0 +1,30 @@
+# EditorConfig is a file format and collection of text editor plugins
+# for maintaining consistent coding styles between different editors
+# and IDEs. Most popular editors support this either natively or via
+# plugin.
+#
+# Check https://editorconfig.org for details.
+
+root = true
+
+[*]
+end_of_line = lf
+insert_final_newline = true
+charset = utf-8
+indent_style = space
+
+[Makefile*]
+indent_style = tab
+indent_size = 8
+file_type_emacs = makefile
+
+[*.[ch]]
+indent_style = tab
+indent_size = 8
+
+[*.py]
+indent_size = 4
+
+[meson.build]
+indent_style = space
+indent_size = 2
diff --git a/dtc/.travis.yml b/dtc/.travis.yml
new file mode 100644
index 0000000..a5163de
--- /dev/null
+++ b/dtc/.travis.yml
@@ -0,0 +1,65 @@
+language: c
+
+# Coverity Scan uploads
+env:
+  global:
+  # COVERITY_SCAN_TOKEN (dgibson/dtc)
+  - secure: "vlHvXe618//IM9LQaKzqsrUbjs7ng0L9UCST4kJbJnFQDXvVe5JiSmJGd4ef7mm0NUv5bMRl2W3xCiu6BYAu/NvU3tMNHoLG+JgCJs0+wLJXbWOwji/NmH7olqgJG+CmpaCMXjARF6+nrTnBYHJL6cYyf4KVoV4B0I/hLUW91+s="
+
+matrix:
+  include:
+    - addons:
+        apt:
+          packages:
+            - swig
+            - python-dev
+            - valgrind
+            - libyaml-0-2
+        coverity_scan:
+          project:
+            name: dtc
+            description: Device Tree Compiler
+          notification_email: david@gibson.dropbear.id.au
+          build_command: make
+          branch_pattern: coverity_scan
+      script:
+        - make
+        - make check && make checkm
+
+    # Check it builds properly without optional packages:
+    #     python, valgrind, libyaml
+    - script:
+        - make
+        - make check
+
+    - arch: arm64
+      addons:
+        apt_packages:
+          - swig
+          - python-dev
+          - valgrind
+          - libyaml-0-2
+      script:
+        - make
+        - make check checkm
+
+    - arch: ppc64le
+      addons:
+        apt_packages:
+          - swig
+          - python-dev
+          - libyaml-0-2
+      script:
+        - make
+        - make check
+
+    - arch: s390x
+      addons:
+        apt_packages:
+          - swig
+          - python-dev
+          - valgrind
+          - libyaml-0-2
+      script:
+        - make
+        - make check checkm
diff --git a/dtc/BSD-2-Clause b/dtc/BSD-2-Clause
new file mode 100644
index 0000000..da366e2
--- /dev/null
+++ b/dtc/BSD-2-Clause
@@ -0,0 +1,32 @@
+Valid-License-Identifier: BSD-2-Clause
+SPDX-URL: https://spdx.org/licenses/BSD-2-Clause.html
+Usage-Guide:
+  To use the BSD 2-clause "Simplified" License put the following SPDX
+  tag/value pair into a comment according to the placement guidelines in
+  the licensing rules documentation:
+    SPDX-License-Identifier: BSD-2-Clause
+License-Text:
+
+Copyright (c) <year> <owner> . All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice,
+   this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
diff --git a/dtc/Documentation/dt-object-internal.txt b/dtc/Documentation/dt-object-internal.txt
new file mode 100644
index 0000000..51d68ab
--- /dev/null
+++ b/dtc/Documentation/dt-object-internal.txt
@@ -0,0 +1,310 @@
+Device Tree Dynamic Object format internals
+-------------------------------------------
+
+The Device Tree for most platforms is a static representation of
+the hardware capabilities. This is insufficient for platforms
+that need to dynamically insert Device Tree fragments into the
+live tree.
+
+This document explains the the Device Tree object format and
+modifications made to the Device Tree compiler, which make it possible.
+
+1. Simplified Problem Definition
+--------------------------------
+
+Assume we have a platform which boots using following simplified Device Tree.
+
+---- foo.dts -----------------------------------------------------------------
+	/* FOO platform */
+	/ {
+		compatible = "corp,foo";
+
+		/* shared resources */
+		res: res {
+		};
+
+		/* On chip peripherals */
+		ocp: ocp {
+			/* peripherals that are always instantiated */
+			peripheral1 { ... };
+		};
+	};
+---- foo.dts -----------------------------------------------------------------
+
+We have a number of peripherals that after probing (using some undefined method)
+should result in different Device Tree configuration.
+
+We cannot boot with this static tree because due to the configuration of the
+foo platform there exist multiple conficting peripherals DT fragments.
+
+So for the bar peripheral we would have this:
+
+---- foo+bar.dts -------------------------------------------------------------
+	/* FOO platform + bar peripheral */
+	/ {
+		compatible = "corp,foo";
+
+		/* shared resources */
+		res: res {
+		};
+
+		/* On chip peripherals */
+		ocp: ocp {
+			/* peripherals that are always instantiated */
+			peripheral1 { ... };
+
+			/* bar peripheral */
+			bar {
+				compatible = "corp,bar";
+				... /* various properties and child nodes */
+			};
+		};
+	};
+---- foo+bar.dts -------------------------------------------------------------
+
+While for the baz peripheral we would have this:
+
+---- foo+baz.dts -------------------------------------------------------------
+	/* FOO platform + baz peripheral */
+	/ {
+		compatible = "corp,foo";
+
+		/* shared resources */
+		res: res {
+			/* baz resources */
+			baz_res: res_baz { ... };
+		};
+
+		/* On chip peripherals */
+		ocp: ocp {
+			/* peripherals that are always instantiated */
+			peripheral1 { ... };
+
+			/* baz peripheral */
+			baz {
+				compatible = "corp,baz";
+				/* reference to another point in the tree */
+				ref-to-res = <&baz_res>;
+				... /* various properties and child nodes */
+			};
+		};
+	};
+---- foo+baz.dts -------------------------------------------------------------
+
+We note that the baz case is more complicated, since the baz peripheral needs to
+reference another node in the DT tree.
+
+2. Device Tree Object Format Requirements
+-----------------------------------------
+
+Since the Device Tree is used for booting a number of very different hardware
+platforms it is imperative that we tread very carefully.
+
+2.a) No changes to the Device Tree binary format for the base tree. We cannot
+modify the tree format at all and all the information we require should be
+encoded using Device Tree itself. We can add nodes that can be safely ignored
+by both bootloaders and the kernel. The plugin dtbs are optionally tagged
+with a different magic number in the header but otherwise they're simple
+blobs.
+
+2.b) Changes to the DTS source format should be absolutely minimal, and should
+only be needed for the DT fragment definitions, and not the base boot DT.
+
+2.c) An explicit option should be used to instruct DTC to generate the required
+information needed for object resolution. Platforms that don't use the
+dynamic object format can safely ignore it.
+
+2.d) Finally, DT syntax changes should be kept to a minimum. It should be
+possible to express everything using the existing DT syntax.
+
+3. Implementation
+-----------------
+
+The basic unit of addressing in Device Tree is the phandle. Turns out it's
+relatively simple to extend the way phandles are generated and referenced
+so that it's possible to dynamically convert symbolic references (labels)
+to phandle values. This is a valid assumption as long as the author uses
+reference syntax and does not assign phandle values manually (which might
+be a problem with decompiled source files).
+
+We can roughly divide the operation into two steps.
+
+3.a) Compilation of the base board DTS file using the '-@' option
+generates a valid DT blob with an added __symbols__ node at the root node,
+containing a list of all nodes that are marked with a label.
+
+Using the foo.dts file above the following node will be generated;
+
+$ dtc -@ -O dtb -o foo.dtb -b 0 foo.dts
+$ fdtdump foo.dtb
+...
+/ {
+	...
+	res {
+		...
+		phandle = <0x00000001>;
+		...
+	};
+	ocp {
+		...
+		phandle = <0x00000002>;
+		...
+	};
+	__symbols__ {
+		res="/res";
+		ocp="/ocp";
+	};
+};
+
+Notice that all the nodes that had a label have been recorded, and that
+phandles have been generated for them.
+
+This blob can be used to boot the board normally, the __symbols__ node will
+be safely ignored both by the bootloader and the kernel (the only loss will
+be a few bytes of memory and disk space).
+
+We generate a __symbols__ node to record nodes that had labels in the base
+tree (or subsequent loaded overlays) so that they can be matched up with
+references made to them in Device Tree objects.
+
+3.b) The Device Tree fragments must be compiled with the same option but they
+must also have a tag (/plugin/) that allows undefined references to nodes
+that are not present at compilation time to be recorded so that the runtime
+loader can fix them.
+
+So the bar peripheral's DTS format would be of the form:
+
+/dts-v1/;
+/plugin/;	/* allow undefined references and record them */
+/ {
+	....	/* various properties for loader use; i.e. part id etc. */
+	fragment@0 {
+		target = <&ocp>;
+		__overlay__ {
+			/* bar peripheral */
+			bar {
+				compatible = "corp,bar";
+				... /* various properties and child nodes */
+			}
+		};
+	};
+};
+
+Note that there's a target property that specifies the location where the
+contents of the overlay node will be placed, and it references the node
+in the foo.dts file.
+
+$ dtc -@ -O dtb -o bar.dtbo -b 0 bar.dts
+$ fdtdump bar.dtbo
+...
+/ {
+	... /* properties */
+	fragment@0 {
+		target = <0xffffffff>;
+		__overlay__ {
+			bar {
+				compatible = "corp,bar";
+				... /* various properties and child nodes */
+			}
+		};
+	};
+	__fixups__ {
+	    ocp = "/fragment@0:target:0";
+	};
+};
+
+No __symbols__ node has been generated (no label in bar.dts).
+Note that the target's ocp label is undefined, so the phandle
+value is filled with the illegal value '0xffffffff', while a __fixups__
+node has been generated, which marks the location in the tree where
+the label lookup should store the runtime phandle value of the ocp node.
+
+The format of the __fixups__ node entry is
+
+  <label> = "<local-full-path>:<property-name>:<offset>" 
+	    [, "<local-full-path>:<property-name>:<offset>"...];
+
+  <label> 		Is the label we're referring
+  <local-full-path>	Is the full path of the node the reference is
+  <property-name>	Is the name of the property containing the
+			reference
+  <offset>		The offset (in bytes) of where the property's
+			phandle value is located.
+
+Doing the same with the baz peripheral's DTS format is a little bit more
+involved, since baz contains references to local labels which require
+local fixups.
+
+/dts-v1/;
+/plugin/;	/* allow undefined label references and record them */
+/ {
+	....	/* various properties for loader use; i.e. part id etc. */
+	fragment@0 {
+		target = <&res>;
+		__overlay__ {
+			/* baz resources */
+			baz_res: res_baz { ... };
+		};
+	};
+	fragment@1 {
+		target = <&ocp>;
+		__overlay__ {
+			/* baz peripheral */
+			baz {
+				compatible = "corp,baz";
+				/* reference to another point in the tree */
+				ref-to-res = <&baz_res>;
+				... /* various properties and child nodes */
+			}
+		};
+	};
+};
+
+Note that &bar_res reference.
+
+$ dtc -@ -O dtb -o baz.dtbo -b 0 baz.dts
+$ fdtdump baz.dtbo
+...
+/ {
+	... /* properties */
+	fragment@0 {
+		target = <0xffffffff>;
+		__overlay__ {
+			res_baz {
+				....
+				phandle = <0x00000001>;
+			};
+		};
+	};
+	fragment@1 {
+		target = <0xffffffff>;
+		__overlay__ {
+			baz {
+				compatible = "corp,baz";
+				... /* various properties and child nodes */
+				ref-to-res = <0x00000001>;
+			}
+		};
+	};
+	__fixups__ {
+		res = "/fragment@0:target:0";
+		ocp = "/fragment@1:target:0";
+	};
+	__local_fixups__ {
+		fragment@1 {
+			__overlay__ {
+				baz {
+					ref-to-res = <0>;
+				};
+			};
+		};
+	};
+};
+
+This is similar to the bar case, but the reference of a local label by the
+baz node generates a __local_fixups__ entry that records the place that the
+local reference is being made. No matter how phandles are allocated from dtc
+the run time loader must apply an offset to each phandle in every dynamic
+DT object loaded. The __local_fixups__ node records the offset relative to the
+start of every local reference within that property so that the loader can apply
+the offset.
diff --git a/dtc/Documentation/dtc-paper.bib b/dtc/Documentation/dtc-paper.bib
new file mode 100644
index 0000000..d01e2ff
--- /dev/null
+++ b/dtc/Documentation/dtc-paper.bib
@@ -0,0 +1,43 @@
+@STRING{pub-IEEE = "IEEE Computer Society"}
+@STRING{pub-IEEE:adr = "345 E. 47th St, New York, NY 10017, USA"}
+
+@BOOK{IEEE1275,
+	key = "IEEE1275",
+	title = "{IEEE} {S}tandard for {B}oot ({I}nitialization {C}onfiguration) {F}irmware: {C}ore {R}equirements and {P}ractices",
+	publisher =    pub-IEEE,
+	address =      pub-IEEE:adr,
+	series = "IEEE Std 1275-1994",
+	year = 1994,
+}
+
+@BOOK{IEEE1275-pci,
+	key = "IEEE1275-pci",
+	title = "{PCI} {B}us {B}inding to: {IEEE} {S}td 1275-1994 {S}tandard for {B}oot ({I}nitialization {C}onfiguration) {F}irmware",
+	publisher =    pub-IEEE,
+	address =      pub-IEEE:adr,
+	note = "Revision 2.1",
+	year = 1998,
+}
+
+@MISC{noof1,
+	author = "Benjamin Herrenschmidt",
+	title = "Booting the {L}inux/ppc kernel without {O}pen {F}irmware",
+	month = may,
+	year = 2005,
+	note = "v0.1, \url{http://ozlabs.org/pipermail/linuxppc64-dev/2005-May/004073.html}",
+}
+
+@MISC{noof5,
+	author = "Benjamin Herrenschmidt",
+	title = "Booting the {L}inux/ppc kernel without {O}pen {F}irmware",
+	month = nov,
+	year = 2005,
+	note = "v0.5, \url{http://ozlabs.org/pipermail/linuxppc64-dev/2005-December/006994.html}",
+}
+
+@MISC{dtcgit,
+	author = "David Gibson et al.",
+	title = "\dtc{}",
+	howpublished = "git tree",
+	note = "\url{http://ozlabs.org/~dgibson/dtc/dtc.git}",
+}
diff --git a/dtc/Documentation/dtc-paper.tex b/dtc/Documentation/dtc-paper.tex
new file mode 100644
index 0000000..4494226
--- /dev/null
+++ b/dtc/Documentation/dtc-paper.tex
@@ -0,0 +1,597 @@
+\documentclass[a4paper,twocolumn]{article}
+
+\usepackage{abstract}
+\usepackage{xspace}
+\usepackage{amssymb}
+\usepackage{latexsym}
+\usepackage{tabularx}
+\usepackage[T1]{fontenc}
+\usepackage{calc}
+\usepackage{listings}
+\usepackage{color}
+\usepackage{url}
+
+\title{Device trees everywhere}
+
+\author{David Gibson \texttt{<{dwg}{@}{au1.ibm.com}>}\\
+  Benjamin Herrenschmidt \texttt{<{benh}{@}{kernel.crashing.org}>}\\
+  \emph{OzLabs, IBM Linux Technology Center}}
+
+\newcommand{\R}{\textsuperscript{\textregistered}\xspace}
+\newcommand{\tm}{\textsuperscript{\texttrademark}\xspace}
+\newcommand{\tge}{$\geqslant$}
+%\newcommand{\ditto}{\textquotedbl\xspace}
+
+\newcommand{\fixme}[1]{$\bigstar$\emph{\textbf{\large #1}}$\bigstar$\xspace}
+
+\newcommand{\ppc}{\mbox{PowerPC}\xspace}
+\newcommand{\of}{Open Firmware\xspace}
+\newcommand{\benh}{Ben Herrenschmidt\xspace}
+\newcommand{\kexec}{\texttt{kexec()}\xspace}
+\newcommand{\dtbeginnode}{\texttt{OF\_DT\_BEGIN\_NODE\xspace}}
+\newcommand{\dtendnode}{\texttt{OF\_DT\_END\_NODE\xspace}}
+\newcommand{\dtprop}{\texttt{OF\_DT\_PROP\xspace}}
+\newcommand{\dtend}{\texttt{OF\_DT\_END\xspace}}
+\newcommand{\dtc}{\texttt{dtc}\xspace}
+\newcommand{\phandle}{\texttt{linux,phandle}\xspace}
+\begin{document}
+
+\maketitle
+
+\begin{abstract}
+  We present a method for booting a \ppc{}\R Linux\R kernel on an
+  embedded machine.  To do this, we supply the kernel with a compact
+  flattened-tree representation of the system's hardware based on the
+  device tree supplied by Open Firmware on IBM\R servers and Apple\R
+  Power Macintosh\R machines.
+
+  The ``blob'' representing the device tree can be created using \dtc
+  --- the Device Tree Compiler --- that turns a simple text
+  representation of the tree into the compact representation used by
+  the kernel.  The compiler can produce either a binary ``blob'' or an
+  assembler file ready to be built into a firmware or bootwrapper
+  image.
+
+  This flattened-tree approach is now the only supported method of
+  booting a \texttt{ppc64} kernel without Open Firmware, and we plan
+  to make it the only supported method for all \texttt{powerpc}
+  kernels in the future.
+\end{abstract}
+
+\section{Introduction}
+
+\subsection{OF and the device tree}
+
+Historically, ``everyday'' \ppc machines have booted with the help of
+\of (OF), a firmware environment defined by IEEE1275 \cite{IEEE1275}.
+Among other boot-time services, OF maintains a device tree that
+describes all of the system's hardware devices and how they're
+connected.  During boot, before taking control of memory management,
+the Linux kernel uses OF calls to scan the device tree and transfer it
+to an internal representation that is used at run time to look up
+various device information.
+
+The device tree consists of nodes representing devices or
+buses\footnote{Well, mostly.  There are a few special exceptions.}.
+Each node contains \emph{properties}, name--value pairs that give
+information about the device.  The values are arbitrary byte strings,
+and for some properties, they contain tables or other structured
+information.
+
+\subsection{The bad old days}
+
+Embedded systems, by contrast, usually have a minimal firmware that
+might supply a few vital system parameters (size of RAM and the like),
+but nothing as detailed or complete as the OF device tree.  This has
+meant that the various 32-bit \ppc embedded ports have required a
+variety of hacks spread across the kernel to deal with the lack of
+device tree.  These vary from specialised boot wrappers to parse
+parameters (which are at least reasonably localised) to
+CONFIG-dependent hacks in drivers to override normal probe logic with
+hardcoded addresses for a particular board.  As well as being ugly of
+itself, such CONFIG-dependent hacks make it hard to build a single
+kernel image that supports multiple embedded machines.
+
+Until relatively recently, the only 64-bit \ppc machines without OF
+were legacy (pre-POWER5\R) iSeries\R machines.  iSeries machines often
+only have virtual IO devices, which makes it quite simple to work
+around the lack of a device tree.  Even so, the lack means the iSeries
+boot sequence must be quite different from the pSeries or Macintosh,
+which is not ideal.
+
+The device tree also presents a problem for implementing \kexec.  When
+the kernel boots, it takes over full control of the system from OF,
+even re-using OF's memory.  So, when \kexec comes to boot another
+kernel, OF is no longer around for the second kernel to query.
+
+\section{The Flattened Tree}
+
+In May 2005 \benh implemented a new approach to handling the device
+tree that addresses all these problems.  When booting on OF systems,
+the first thing the kernel runs is a small piece of code in
+\texttt{prom\_init.c}, which executes in the context of OF.  This code
+walks the device tree using OF calls, and transcribes it into a
+compact, flattened format.  The resulting device tree ``blob'' is then
+passed to the kernel proper, which eventually unflattens the tree into
+its runtime form.  This blob is the only data communicated between the
+\texttt{prom\_init.c} bootstrap and the rest of the kernel.
+
+When OF isn't available, either because the machine doesn't have it at
+all or because \kexec has been used, the kernel instead starts
+directly from the entry point taking a flattened device tree.  The
+device tree blob must be passed in from outside, rather than generated
+by part of the kernel from OF.  For \kexec, the userland
+\texttt{kexec} tools build the blob from the runtime device tree
+before invoking the new kernel.  For embedded systems the blob can
+come either from the embedded bootloader, or from a specialised
+version of the \texttt{zImage} wrapper for the system in question.
+
+\subsection{Properties of the flattened tree}
+
+The flattened tree format should be easy to handle, both for the
+kernel that parses it and the bootloader that generates it.  In
+particular, the following properties are desirable:
+
+\begin{itemize}
+\item \emph{relocatable}: the bootloader or kernel should be able to
+  move the blob around as a whole, without needing to parse or adjust
+  its internals.  In practice that means we must not use pointers
+  within the blob.
+\item \emph{insert and delete}: sometimes the bootloader might want to
+  make tweaks to the flattened tree, such as deleting or inserting a
+  node (or whole subtree).  It should be possible to do this without
+  having to effectively regenerate the whole flattened tree.  In
+  practice this means limiting the use of internal offsets in the blob
+  that need recalculation if a section is inserted or removed with
+  \texttt{memmove()}.
+\item \emph{compact}: embedded systems are frequently short of
+  resources, particularly RAM and flash memory space.  Thus, the tree
+  representation should be kept as small as conveniently possible.
+\end{itemize}
+
+\subsection{Format of the device tree blob}
+\label{sec:format}
+
+\begin{figure}[htb!]
+  \centering
+  \footnotesize
+  \begin{tabular}{r|c|l}
+    \multicolumn{1}{r}{\textbf{Offset}}& \multicolumn{1}{c}{\textbf{Contents}} \\\cline{2-2}
+    \texttt{0x00} & \texttt{0xd00dfeed} & magic number \\\cline{2-2}
+    \texttt{0x04} & \emph{totalsize} \\\cline{2-2}
+    \texttt{0x08} & \emph{off\_struct} & \\\cline{2-2}
+    \texttt{0x0C} & \emph{off\_strs} & \\\cline{2-2}
+    \texttt{0x10} & \emph{off\_rsvmap} & \\\cline{2-2}
+    \texttt{0x14} & \emph{version} \\\cline{2-2}
+    \texttt{0x18} & \emph{last\_comp\_ver} & \\\cline{2-2}
+    \texttt{0x1C} & \emph{boot\_cpu\_id} & \tge v2 only\\\cline{2-2}
+    \texttt{0x20} & \emph{size\_strs} & \tge v3 only\\\cline{2-2}
+    \multicolumn{1}{r}{\vdots} & \multicolumn{1}{c}{\vdots} & \\\cline{2-2}
+    \emph{off\_rsvmap} & \emph{address0} & memory reserve \\
+    + \texttt{0x04} & ...& table \\\cline{2-2}
+    + \texttt{0x08} & \emph{len0} & \\
+    + \texttt{0x0C} & ...& \\\cline{2-2}
+    \vdots & \multicolumn{1}{c|}{\vdots} & \\\cline{2-2}
+    & \texttt{0x00000000}- & end marker\\
+    & \texttt{00000000} & \\\cline{2-2}
+    & \texttt{0x00000000}- & \\
+    & \texttt{00000000} & \\\cline{2-2}
+    \multicolumn{1}{r}{\vdots} & \multicolumn{1}{c}{\vdots} & \\\cline{2-2}
+    \emph{off\_strs} & \texttt{'n' 'a' 'm' 'e'} & strings block \\
+    + \texttt{0x04} & \texttt{~0~ 'm' 'o' 'd'} & \\
+    + \texttt{0x08} & \texttt{'e' 'l' ~0~ \makebox[\widthof{~~~}]{\textrm{...}}} & \\
+    \vdots & \multicolumn{1}{c|}{\vdots} & \\\cline{2-2}
+    \multicolumn{1}{r}{+ \emph{size\_strs}} \\
+    \multicolumn{1}{r}{\vdots} & \multicolumn{1}{c}{\vdots} & \\\cline{2-2}
+    \emph{off\_struct} & \dtbeginnode & structure block \\\cline{2-2}
+    + \texttt{0x04} & \texttt{'/' ~0~ ~0~ ~0~}  & root node\\\cline{2-2}
+    + \texttt{0x08} & \dtprop & \\\cline{2-2}
+    + \texttt{0x0C} & \texttt{0x00000005} & ``\texttt{model}''\\\cline{2-2}
+    + \texttt{0x10} & \texttt{0x00000008} & \\\cline{2-2}
+    + \texttt{0x14} & \texttt{'M' 'y' 'B' 'o'} & \\
+    + \texttt{0x18} & \texttt{'a' 'r' 'd' ~0~} & \\\cline{2-2}
+    \vdots & \multicolumn{1}{c|}{\vdots} & \\\cline{2-2}
+    & \texttt{\dtendnode} \\\cline{2-2}
+    & \texttt{\dtend} \\\cline{2-2}
+    \multicolumn{1}{r}{\vdots} & \multicolumn{1}{c}{\vdots} & \\\cline{2-2}
+    \multicolumn{1}{r}{\emph{totalsize}} \\
+  \end{tabular}
+  \caption{Device tree blob layout}
+  \label{fig:blob-layout}
+\end{figure}
+
+The format for the blob we devised, was first described on the
+\texttt{linuxppc64-dev} mailing list in \cite{noof1}.  The format has
+since evolved through various revisions, and the current version is
+included as part of the \dtc (see \S\ref{sec:dtc}) git tree,
+\cite{dtcgit}.
+
+Figure \ref{fig:blob-layout} shows the layout of the blob of data
+containing the device tree.  It has three sections of variable size:
+the \emph{memory reserve table}, the \emph{structure block} and the
+\emph{strings block}.  A small header gives the blob's size and
+version and the locations of the three sections, plus a handful of
+vital parameters used during early boot.
+
+The memory reserve map section gives a list of regions of memory that
+the kernel must not use\footnote{Usually such ranges contain some data
+structure initialised by the firmware that must be preserved by the
+kernel.}.  The list is represented as a simple array of (address,
+size) pairs of 64 bit values, terminated by a zero size entry.  The
+strings block is similarly simple, consisting of a number of
+null-terminated strings appended together, which are referenced from
+the structure block as described below.
+
+The structure block contains the device tree proper.  Each node is
+introduced with a 32-bit \dtbeginnode tag, followed by the node's name
+as a null-terminated string, padded to a 32-bit boundary.  Then
+follows all of the properties of the node, each introduced with a
+\dtprop tag, then all of the node's subnodes, each introduced with
+their own \dtbeginnode tag.  The node ends with an \dtendnode tag, and
+after the \dtendnode for the root node is an \dtend tag, indicating
+the end of the whole tree\footnote{This is redundant, but included for
+ease of parsing.}.  The structure block starts with the \dtbeginnode
+introducing the description of the root node (named \texttt{/}).
+
+Each property, after the \dtprop, has a 32-bit value giving an offset
+from the beginning of the strings block at which the property name is
+stored.  Because it's common for many nodes to have properties with
+the same name, this approach can substantially reduce the total size
+of the blob.  The name offset is followed by the length of the
+property value (as a 32-bit value) and then the data itself padded to
+a 32-bit boundary.
+
+\subsection{Contents of the tree}
+\label{sec:treecontents}
+
+Having seen how to represent the device tree structure as a flattened
+blob, what actually goes into the tree?  The short answer is ``the
+same as an OF tree''.  On OF systems, the flattened tree is
+transcribed directly from the OF device tree, so for simplicity we
+also use OF conventions for the tree on other systems.
+
+In many cases a flat tree can be simpler than a typical OF provided
+device tree.  The flattened tree need only provide those nodes and
+properties that the kernel actually requires; the flattened tree
+generally need not include devices that the kernel can probe itself.
+For example, an OF device tree would normally include nodes for each
+PCI device on the system.  A flattened tree need only include nodes
+for the PCI host bridges; the kernel will scan the buses thus
+described to find the subsidiary devices.  The device tree can include
+nodes for devices where the kernel needs extra information, though:
+for example, for ISA devices on a subsidiary PCI/ISA bridge, or for
+devices with unusual interrupt routing.
+
+Where they exist, we follow the IEEE1275 bindings that specify how to
+describe various buses in the device tree (for example,
+\cite{IEEE1275-pci} describe how to represent PCI devices).  The
+standard has not been updated for a long time, however, and lacks
+bindings for many modern buses and devices.  In particular, embedded
+specific devices such as the various System-on-Chip buses are not
+covered.  We intend to create new bindings for such buses, in keeping
+with the general conventions of IEEE1275 (a simple such binding for a
+System-on-Chip bus was included in \cite{noof5} a revision of
+\cite{noof1}).
+
+One complication arises for representing ``phandles'' in the flattened
+tree.  In OF, each node in the tree has an associated phandle, a
+32-bit integer that uniquely identifies the node\footnote{In practice
+usually implemented as a pointer or offset within OF memory.}.  This
+handle is used by the various OF calls to query and traverse the tree.
+Sometimes phandles are also used within the tree to refer to other
+nodes in the tree.  For example, devices that produce interrupts
+generally have an \texttt{interrupt-parent} property giving the
+phandle of the interrupt controller that handles interrupts from this
+device.  Parsing these and other interrupt related properties allows
+the kernel to build a complete representation of the system's
+interrupt tree, which can be quite different from the tree of bus
+connections.
+
+In the flattened tree, a node's phandle is represented by a special
+\phandle property.  When the kernel generates a flattened tree from
+OF, it adds a \phandle property to each node, containing the phandle
+retrieved from OF.  When the tree is generated without OF, however,
+only nodes that are actually referred to by phandle need to have this
+property.
+
+Another complication arises because nodes in an OF tree have two
+names.  First they have the ``unit name'', which is how the node is
+referred to in an OF path.  The unit name generally consists of a
+device type followed by an \texttt{@} followed by a \emph{unit
+address}.  For example \texttt{/memory@0} is the full path of a memory
+node at address 0, \texttt{/ht@0,f2000000/pci@1} is the path of a PCI
+bus node, which is under a HyperTransport\tm bus node.  The form of
+the unit address is bus dependent, but is generally derived from the
+node's \texttt{reg} property.  In addition, nodes have a property,
+\texttt{name}, whose value is usually equal to the first path of the
+unit name. For example, the nodes in the previous example would have
+\texttt{name} properties equal to \texttt{memory} and \texttt{pci},
+respectively.  To save space in the blob, the current version of the
+flattened tree format only requires the unit names to be present.
+When the kernel unflattens the tree, it automatically generates a
+\texttt{name} property from the node's path name.
+
+\section{The Device Tree Compiler}
+\label{sec:dtc}
+
+\begin{figure}[htb!]
+  \centering
+  \begin{lstlisting}[frame=single,basicstyle=\footnotesize\ttfamily,
+    tabsize=3,numbers=left,xleftmargin=2em]
+/memreserve/ 0x20000000-0x21FFFFFF;
+
+/ {
+	model = "MyBoard";
+	compatible = "MyBoardFamily";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		PowerPC,970@0 {
+			device_type = "cpu";
+			reg = <0>;
+			clock-frequency = <5f5e1000>;
+			timebase-frequency = <1FCA055>;
+			linux,boot-cpu;
+			i-cache-size = <10000>;
+			d-cache-size = <8000>;
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		memreg: reg = <00000000 00000000
+		               00000000 20000000>;
+	};
+
+	mpic@0x3fffdd08400 {
+		/* Interrupt controller */
+		/* ... */
+	};
+
+	pci@40000000000000 {
+		/* PCI host bridge */
+		/* ... */
+	};
+
+	chosen {
+		bootargs = "root=/dev/sda2";
+		linux,platform = <00000600>;
+		interrupt-controller =
+			< &/mpic@0x3fffdd08400 >;
+	};
+};
+\end{lstlisting}
+  \caption{Example \dtc source}
+  \label{fig:dts}
+\end{figure}
+
+As we've seen, the flattened device tree format provides a convenient
+way of communicating device tree information to the kernel.  It's
+simple for the kernel to parse, and simple for bootloaders to
+manipulate.  On OF systems, it's easy to generate the flattened tree
+by walking the OF maintained tree.  However, for embedded systems, the
+flattened tree must be generated from scratch.
+
+Embedded bootloaders are generally built for a particular board.  So,
+it's usually possible to build the device tree blob at compile time
+and include it in the bootloader image.  For minor revisions of the
+board, the bootloader can contain code to make the necessary tweaks to
+the tree before passing it to the booted kernel.
+
+The device trees for embedded boards are usually quite simple, and
+it's possible to hand construct the necessary blob by hand, but doing
+so is tedious.  The ``device tree compiler'', \dtc{}\footnote{\dtc can
+be obtained from \cite{dtcgit}.}, is designed to make creating device
+tree blobs easier by converting a text representation of the tree
+into the necessary blob.
+
+\subsection{Input and output formats}
+
+As well as the normal mode of compiling a device tree blob from text
+source, \dtc can convert a device tree between a number of
+representations.  It can take its input in one of three different
+formats:
+\begin{itemize}
+\item source, the normal case.  The device tree is described in a text
+  form, described in \S\ref{sec:dts}.
+\item blob (\texttt{dtb}), the flattened tree format described in
+  \S\ref{sec:format}.  This mode is useful for checking a pre-existing
+  device tree blob.
+\item filesystem (\texttt{fs}), input is a directory tree in the
+  layout of \texttt{/proc/device-tree} (roughly, a directory for each
+  node in the device tree, a file for each property).  This is useful
+  for building a blob for the device tree in use by the currently
+  running kernel.
+\end{itemize}
+
+In addition, \dtc can output the tree in one of three different
+formats:
+\begin{itemize}
+\item blob (\texttt{dtb}), as in \S\ref{sec:format}.  The most
+  straightforward use of \dtc is to compile from ``source'' to
+  ``blob'' format.
+\item source (\texttt{dts}), as in \S\ref{sec:dts}.  If used with blob
+  input, this allows \dtc to act as a ``decompiler''.
+\item assembler source (\texttt{asm}).  \dtc can produce an assembler
+  file, which will assemble into a \texttt{.o} file containing the
+  device tree blob, with symbols giving the beginning of the blob and
+  its various subsections.  This can then be linked directly into a
+  bootloader or firmware image.
+\end{itemize}
+
+For maximum applicability, \dtc can both read and write any of the
+existing revisions of the blob format.  When reading, \dtc takes the
+version from the blob header, and when writing it takes a command line
+option specifying the desired version.  It automatically makes any
+necessary adjustments to the tree that are necessary for the specified
+version.  For example, formats before 0x10 require each node to have
+an explicit \texttt{name} property.  When \dtc creates such a blob, it
+will automatically generate \texttt{name} properties from the unit
+names.
+
+\subsection{Source format}
+\label{sec:dts}
+
+The ``source'' format for \dtc is a text description of the device
+tree in a vaguely C-like form.  Figure \ref{fig:dts} shows an
+example.  The file starts with \texttt{/memreserve/} directives, which
+gives address ranges to add to the output blob's memory reserve table,
+then the device tree proper is described.
+
+Nodes of the tree are introduced with the node name, followed by a
+\texttt{\{} ... \texttt{\};} block containing the node's properties
+and subnodes.  Properties are given as just {\emph{name} \texttt{=}
+  \emph{value}\texttt{;}}.  The property values can be given in any
+of three forms:
+\begin{itemize}
+\item \emph{string} (for example, \texttt{"MyBoard"}).  The property
+  value is the given string, including terminating NULL.  C-style
+  escapes (\verb+\t+, \verb+\n+, \verb+\0+ and so forth) are allowed.
+\item \emph{cells} (for example, \texttt{<0 8000 f0000000>}).  The
+  property value is made up of a list of 32-bit ``cells'', each given
+  as a hex value.
+\item \emph{bytestring} (for example, \texttt{[1234abcdef]}).  The
+  property value is given as a hex bytestring.
+\end{itemize}
+
+Cell properties can also contain \emph{references}.  Instead of a hex
+number, the source can give an ampersand (\texttt{\&}) followed by the
+full path to some node in the tree.  For example, in Figure
+\ref{fig:dts}, the \texttt{/chosen} node has an
+\texttt{interrupt-controller} property referring to the interrupt
+controller described by the node \texttt{/mpic@0x3fffdd08400}.  In the
+output tree, the value of the referenced node's phandle is included in
+the property.  If that node doesn't have an explicit phandle property,
+\dtc will automatically create a unique phandle for it.  This approach
+makes it easy to create interrupt trees without having to explicitly
+assign and remember phandles for the various interrupt controller
+nodes.
+
+The \dtc source can also include ``labels'', which are placed on a
+particular node or property.  For example, Figure \ref{fig:dts} has a
+label ``\texttt{memreg}'' on the \texttt{reg} property of the node
+\texttt{/memory@0}.  When using assembler output, corresponding labels
+in the output are generated, which will assemble into symbols
+addressing the part of the blob with the node or property in question.
+This is useful for the common case where an embedded board has an
+essentially fixed device tree with a few variable properties, such as
+the size of memory.  The bootloader for such a board can have a device
+tree linked in, including a symbol referring to the right place in the
+blob to update the parameter with the correct value determined at
+runtime.
+
+\subsection{Tree checking}
+
+Between reading in the device tree and writing it out in the new
+format, \dtc performs a number of checks on the tree:
+\begin{itemize}
+\item \emph{syntactic structure}:  \dtc checks that node and property
+  names contain only allowed characters and meet length restrictions.
+  It checks that a node does not have multiple properties or subnodes
+  with the same name.
+\item \emph{semantic structure}: In some cases, \dtc checks that
+  properties whose contents are defined by convention have appropriate
+  values.  For example, it checks that \texttt{reg} properties have a
+  length that makes sense given the address forms specified by the
+  \texttt{\#address-cells} and \texttt{\#size-cells} properties.  It
+  checks that properties such as \texttt{interrupt-parent} contain a
+  valid phandle.
+\item \emph{Linux requirements}:  \dtc checks that the device tree
+  contains those nodes and properties that are required by the Linux
+  kernel to boot correctly.
+\end{itemize}
+
+These checks are useful to catch simple problems with the device tree,
+rather than having to debug the results on an embedded kernel.  With
+the blob input mode, it can also be used for diagnosing problems with
+an existing blob.
+
+\section{Future Work}
+
+\subsection{Board ports}
+
+The flattened device tree has always been the only supported way to
+boot a \texttt{ppc64} kernel on an embedded system.  With the merge of
+\texttt{ppc32} and \texttt{ppc64} code it has also become the only
+supported way to boot any merged \texttt{powerpc} kernel, 32-bit or
+64-bit.  In fact, the old \texttt{ppc} architecture exists mainly just
+to support the old ppc32 embedded ports that have not been migrated
+to the flattened device tree approach.  We plan to remove the
+\texttt{ppc} architecture eventually, which will mean porting all the
+various embedded boards to use the flattened device tree.
+
+\subsection{\dtc features}
+
+While it is already quite usable, there are a number of extra features
+that \dtc could include to make creating device trees more convenient:
+\begin{itemize}
+\item \emph{better tree checking}: Although \dtc already performs a
+  number of checks on the device tree, they are rather haphazard.  In
+  many cases \dtc will give up after detecting a minor error early and
+  won't pick up more interesting errors later on.  There is a
+  \texttt{-f} parameter that forces \dtc to generate an output tree
+  even if there are errors.  At present, this needs to be used more
+  often than one might hope, because \dtc is bad at deciding which
+  errors should really be fatal, and which rate mere warnings.
+\item \emph{binary include}: Occasionally, it is useful for the device
+  tree to incorporate as a property a block of binary data for some
+  board-specific purpose.  For example, many of Apple's device trees
+  incorporate bytecode drivers for certain platform devices.  \dtc's
+  source format ought to allow this by letting a property's value be
+  read directly from a binary file.
+\item \emph{macros}: it might be useful for \dtc to implement some
+  sort of macros so that a tree containing a number of similar devices
+  (for example, multiple identical ethernet controllers or PCI buses)
+  can be written more quickly.  At present, this can be accomplished
+  in part by running the source file through CPP before compiling with
+  \dtc.  It's not clear whether ``native'' support for macros would be
+  more useful.
+\end{itemize}
+
+\bibliographystyle{amsplain}
+\bibliography{dtc-paper}
+
+\section*{About the authors}
+
+David Gibson has been a member of the IBM Linux Technology Center,
+working from Canberra, Australia, since 2001.  Recently he has worked
+on Linux hugepage support and performance counter support for ppc64,
+as well as the device tree compiler.  In the past, he has worked on
+bringup for various ppc and ppc64 embedded systems, the orinoco
+wireless driver, ramfs, and a userspace checkpointing system
+(\texttt{esky}).
+
+Benjamin Herrenschmidt was a MacOS developer for about 10 years, but
+ultimately saw the light and installed Linux on his Apple PowerPC
+machine.  After writing a bootloader, BootX, for it in 1998, he
+started contributing to the PowerPC Linux port in various areas,
+mostly around the support for Apple machines. He became official
+PowerMac maintainer in 2001. In 2003, he joined the IBM Linux
+Technology Center in Canberra, Australia, where he ported the 64 bit
+PowerPC kernel to Apple G5 machines and the Maple embedded board,
+among others things.  He's a member of the ppc64 development ``team''
+and one of his current goals is to make the integration of embedded
+platforms smoother and more maintainable than in the 32-bit PowerPC
+kernel.
+
+\section*{Legal Statement}
+
+This work represents the view of the author and does not necessarily
+represent the view of IBM.
+
+IBM, \ppc, \ppc Architecture, POWER5, pSeries and iSeries are
+trademarks or registered trademarks of International Business Machines
+Corporation in the United States and/or other countries.
+
+Apple and Power Macintosh are a registered trademarks of Apple
+Computer Inc. in the United States, other countries, or both.
+
+Linux is a registered trademark of Linus Torvalds.
+
+Other company, product, and service names may be trademarks or service
+marks of others.
+
+\end{document}
diff --git a/dtc/Documentation/dts-format.txt b/dtc/Documentation/dts-format.txt
new file mode 100644
index 0000000..41741df
--- /dev/null
+++ b/dtc/Documentation/dts-format.txt
@@ -0,0 +1,122 @@
+Device Tree Source Format (version 1)
+=====================================
+
+The Device Tree Source (DTS) format is a textual representation of a
+device tree in a form that can be processed by dtc into a binary
+device tree in the form expected by the kernel.  The description below
+is not a formal syntax definition of DTS, but describes the basic
+constructs used to represent device trees.
+
+Node and property definitions
+-----------------------------
+
+Device tree nodes are defined with a node name and unit address with
+braces marking the start and end of the node definition.  They may be
+preceded by a label.
+
+	[label:] node-name[@unit-address] {
+		[properties definitions]
+		[child nodes]
+	}
+
+Nodes may contain property definitions and/or child node
+definitions. If both are present, properties must come before child
+nodes.
+
+Property definitions are name value pairs in the form:
+	[label:] property-name = value;
+except for properties with empty (zero length) value which have the
+form:
+	[label:] property-name;
+
+Property values may be defined as an array of 8, 16, 32, or 64-bit integer
+elements, as NUL-terminated strings, as bytestrings or a combination of these.
+
+* Arrays are represented by angle brackets surrounding a space separated list
+  of C-style integers or character literals.  Array elements default to 32-bits
+  in size.  An array of 32-bit elements is also known as a cell list or a list
+  of cells.  A cell being an unsigned 32-bit integer.
+
+	e.g. interrupts = <17 0xc>;
+
+* A 64-bit value can be represented with two 32-bit elements.
+
+	e.g. clock-frequency = <0x00000001 0x00000000>;
+
+* The storage size of an element can be changed using the /bits/ prefix.  The
+  /bits/ prefix allows for the creation of 8, 16, 32, and 64-bit elements.
+  The resulting array will not be padded to a multiple of the default 32-bit
+  element size.
+
+	e.g. interrupts = /bits/ 8 <17 0xc>;
+	e.g. clock-frequency = /bits/ 64 <0x0000000100000000>;
+
+* A NUL-terminated string value is represented using double quotes
+  (the property value is considered to include the terminating NUL
+  character).
+
+	e.g. compatible = "simple-bus";
+
+* A bytestring is enclosed in square brackets [] with each byte
+  represented by two hexadecimal digits.  Spaces between each byte are
+  optional.
+
+	e.g. local-mac-address = [00 00 12 34 56 78]; or equivalently
+	     local-mac-address = [000012345678];
+
+* Values may have several comma-separated components, which are
+  concatenated together.
+	e.g. compatible = "ns16550", "ns8250";
+	     example = <0xf00f0000 19>, "a strange property format";
+
+* In an array a reference to another node will be expanded to that node's
+  phandle.  References may by '&' followed by a node's label:
+	e.g. interrupt-parent = < &mpic >;
+  or they may be '&' followed by a node's full path in braces:
+	e.g. interrupt-parent = < &{/soc/interrupt-controller@40000} >;
+  References are only permitted in arrays that have an element size of
+  32-bits.
+
+* Outside an array, a reference to another node will be expanded to that
+  node's full path.
+	e.g. ethernet0 = &EMAC0;
+
+* Labels may also appear before or after any component of a property
+  value, or between elements of an array, or between bytes of a bytestring.
+	e.g. reg = reglabel: <0 sizelabel: 0x1000000>;
+	e.g. prop = [ab cd ef byte4: 00 ff fe];
+	e.g. str = start: "string value" end: ;
+
+
+File layout
+-----------
+
+Version 1 DTS files have the overall layout:
+	/dts-v1/;
+
+	[memory reservations]
+
+	/ {
+		[property definitions]
+		[child nodes]
+	};
+
+* The "/dts-v1/;" must be present to identify the file as a version 1
+  DTS (dts files without this tag will be treated by dtc as being in
+  the obsolete "version 0", which uses a different format for integers
+  amongst other small but incompatible changes).
+
+* Memory reservations define an entry for the device tree blob's
+  memory reservation table.  They have the form:
+	e.g. /memreserve/ <address> <length>;
+  Where <address> and <length> are 64-bit C-style integers.
+
+* The / { ... }; section defines the root node of the device tree.
+
+* C style (/* ... */) and C++ style (// ...) comments are supported.
+
+
+
+	-- David Gibson <david@gibson.dropbear.id.au>
+	-- Yoder Stuart <stuart.yoder@freescale.com>
+	-- Anton Staaf <robotboy@chromium.org>
diff --git a/dtc/Documentation/manual.txt b/dtc/Documentation/manual.txt
new file mode 100644
index 0000000..97e53b9
--- /dev/null
+++ b/dtc/Documentation/manual.txt
@@ -0,0 +1,762 @@
+Device Tree Compiler Manual
+===========================
+
+I - "dtc", the device tree compiler
+    1) Obtaining Sources
+    1.1) Submitting Patches
+    2) Description
+    3) Command Line
+    4) Source File
+    4.1) Overview
+    4.2) Properties
+    4.3) Labels and References
+
+II - The DT block format
+    1) Header
+    2) Device tree generalities
+    3) Device tree "structure" block
+    4) Device tree "strings" block
+
+
+III - libfdt
+
+IV - Utility Tools
+    1) convert-dtsv0 -- Conversion to Version 1
+    1) fdtdump
+
+
+I - "dtc", the device tree compiler
+===================================
+
+1) Sources
+
+Source code for the Device Tree Compiler can be found at git.kernel.org.
+
+The upstream repository is here:
+
+    git://git.kernel.org/pub/scm/utils/dtc/dtc.git
+    https://git.kernel.org/pub/scm/utils/dtc/dtc.git
+
+The gitweb interface for the upstream repository is:
+
+    https://git.kernel.org/cgit/utils/dtc/dtc.git/
+
+1.1) Submitting Patches
+
+Patches should be sent to the maintainers:
+	David Gibson <david@gibson.dropbear.id.au>
+	Jon Loeliger <loeliger@gmail.com>
+and CCed to <devicetree-compiler@vger.kernel.org>.
+
+2) Description
+
+The Device Tree Compiler, dtc, takes as input a device-tree in
+a given format and outputs a device-tree in another format.
+Typically, the input format is "dts", a human readable source
+format, and creates a "dtb", or binary format as output.
+
+The currently supported Input Formats are:
+
+    - "dtb": "blob" format.  A flattened device-tree block with
+        header in one binary blob.
+
+    - "dts": "source" format.  A text file containing a "source"
+        for a device-tree.
+
+    - "fs" format.  A representation equivalent to the output of
+        /proc/device-tree  where nodes are directories and
+	properties are files.
+
+The currently supported Output Formats are:
+
+     - "dtb": "blob" format
+
+     - "dts": "source" format
+
+     - "asm": assembly language file.  A file that can be sourced
+        by gas to generate a device-tree "blob".  That file can
+        then simply be added to your Makefile.  Additionally, the
+        assembly file exports some symbols that can be used.
+
+     - "yaml": DT encoded in YAML format. This representation is an
+       intermediate format used for validation tools.
+
+
+3) Command Line
+
+The syntax of the dtc command line is:
+
+    dtc [options] [<input_filename>]
+
+Options:
+
+    <input_filename>
+	The name of the input source file.  If no <input_filename>
+	or "-" is given, stdin is used.
+
+    -b <number>
+	Set the physical boot cpu.
+
+    -f
+	Force.  Try to produce output even if the input tree has errors.
+
+    -h
+	Emit a brief usage and help message.
+
+    -I <input_format>
+	The source input format, as listed above.
+
+    -o <output_filename>
+	The name of the generated output file.  Use "-" for stdout.
+
+    -O <output_format>
+	The generated output format, as listed above.
+
+    -d <dependency_filename>
+	Generate a dependency file during compilation.
+
+    -q
+	Quiet: -q suppress warnings, -qq errors, -qqq all
+
+    -R <number>
+	Make space for <number> reserve map entries
+	Relevant for dtb and asm output only.
+
+    -@
+	Generates a __symbols__ node at the root node of the resulting blob
+	for any node labels used, and for any local references using phandles
+	it also generates a __local_fixups__ node that tracks them.
+
+	When using the /plugin/ tag all unresolved label references to
+	be tracked in the __fixups__ node, making dynamic resolution possible.
+
+    -A
+	Generate automatically aliases for all node labels. This is similar to
+	the -@ option (the __symbols__ node contain identical information) but
+	the semantics are slightly different since no phandles are automatically
+	generated for labeled nodes.
+
+    -S <bytes>
+	Ensure the blob at least <bytes> long, adding additional
+	space if needed.
+
+    -v
+	Print DTC version and exit.
+
+    -V <output_version>
+	Generate output conforming to the given <output_version>.
+	By default the most recent version is generated.
+	Relevant for dtb and asm output only.
+
+
+The <output_version> defines what version of the "blob" format will be
+generated.  Supported versions are 1, 2, 3, 16 and 17.  The default is
+always the most recent version and is likely the highest number.
+
+Additionally, dtc performs various sanity checks on the tree.
+
+
+4) Device Tree Source file
+
+4.1) Overview
+
+Here is a very rough overview of the layout of a DTS source file:
+
+
+    sourcefile:   versioninfo plugindecl list_of_memreserve devicetree
+
+    memreserve:   label 'memreserve' ADDR ADDR ';'
+		| label 'memreserve' ADDR '-' ADDR ';'
+
+    devicetree:   '/' nodedef
+
+    versioninfo:  '/' 'dts-v1' '/' ';'
+
+    plugindecl:   '/' 'plugin' '/' ';'
+                | /* empty */
+
+    nodedef:      '{' list_of_property list_of_subnode '}' ';'
+
+    property:     label PROPNAME '=' propdata ';'
+
+    propdata:     STRING
+		| '<' list_of_cells '>'
+		| '[' list_of_bytes ']'
+
+    subnode:      label nodename nodedef
+
+That structure forms a hierarchical layout of nodes and properties
+rooted at an initial node as:
+
+    / {
+    }
+
+Both classic C style and C++ style comments are supported.
+
+Source files may be directly included using the syntax:
+
+    /include/ "filename"
+
+
+4.2) Properties
+
+Properties are named, possibly labeled, values.  Each value
+is one of:
+
+    - A null-teminated C-like string,
+    - A numeric value fitting in 32 bits,
+    - A list of 32-bit values
+    - A byte sequence
+
+Here are some example property definitions:
+
+    - A property containing a 0 terminated string
+
+	property1 = "string_value";
+
+    - A property containing a numerical 32-bit hexadecimal value
+
+	property2 = <1234abcd>;
+
+    - A property containing 3 numerical 32-bit hexadecimal values
+
+	property3 = <12345678 12345678 deadbeef>;
+
+    - A property whose content is an arbitrary array of bytes
+
+	property4 = [0a 0b 0c 0d de ea ad be ef];
+
+
+Node may contain sub-nodes to obtain a hierarchical structure.
+For example:
+
+    - A child node named "childnode" whose unit name is
+      "childnode at address".  It in turn has a string property
+      called "childprop".
+
+	childnode@address {
+	    childprop = "hello\n";
+	};
+
+
+By default, all numeric values are hexadecimal.  Alternate bases
+may be specified using a prefix "d#" for decimal, "b#" for binary,
+and "o#" for octal.
+
+Strings support common escape sequences from C: "\n", "\t", "\r",
+"\(octal value)", "\x(hex value)".
+
+
+4.3) Labels and References
+
+Labels may be applied to nodes or properties.  Labels appear
+before a node name, and are referenced using an ampersand: &label.
+Absolute node path names are also allowed in node references.
+
+In this example, a node is labeled "mpic" and then referenced:
+
+    mpic:  interrupt-controller@40000 {
+	...
+    };
+
+    ethernet-phy@3 {
+	interrupt-parent = <&mpic>;
+	...
+    };
+
+And used in properties, labels may appear before or after any value:
+
+    randomnode {
+	prop: string = data: "mystring\n" data_end: ;
+	...
+    };
+
+
+
+II - The DT block format
+========================
+
+This chapter defines the format of the flattened device-tree
+passed to the kernel. The actual content of the device tree
+are described in the kernel documentation in the file
+
+    linux-2.6/Documentation/powerpc/booting-without-of.txt
+
+You can find example of code manipulating that format within
+the kernel.  For example, the file:
+
+	including arch/powerpc/kernel/prom_init.c
+
+will generate a flattened device-tree from the Open Firmware
+representation.  Other utilities such as fs2dt, which is part of
+the kexec tools, will generate one from a filesystem representation.
+Some bootloaders such as U-Boot provide a bit more support by
+using the libfdt code.
+
+For booting the kernel, the device tree block has to be in main memory.
+It has to be accessible in both real mode and virtual mode with no
+mapping other than main memory.  If you are writing a simple flash
+bootloader, it should copy the block to RAM before passing it to
+the kernel.
+
+
+1) Header
+---------
+
+The kernel is entered with r3 pointing to an area of memory that is
+roughly described in include/asm-powerpc/prom.h by the structure
+boot_param_header:
+
+    struct boot_param_header {
+        u32     magic;                  /* magic word OF_DT_HEADER */
+        u32     totalsize;              /* total size of DT block */
+        u32     off_dt_struct;          /* offset to structure */
+        u32     off_dt_strings;         /* offset to strings */
+        u32     off_mem_rsvmap;         /* offset to memory reserve map */
+        u32     version;                /* format version */
+        u32     last_comp_version;      /* last compatible version */
+
+        /* version 2 fields below */
+        u32     boot_cpuid_phys;        /* Which physical CPU id we're
+                                           booting on */
+        /* version 3 fields below */
+        u32     size_dt_strings;        /* size of the strings block */
+
+        /* version 17 fields below */
+        u32	size_dt_struct;		/* size of the DT structure block */
+    };
+
+Along with the constants:
+
+    /* Definitions used by the flattened device tree */
+    #define OF_DT_HEADER            0xd00dfeed      /* 4: version,
+						       4: total size */
+    #define OF_DT_BEGIN_NODE        0x1             /* Start node: full name
+						       */
+    #define OF_DT_END_NODE          0x2             /* End node */
+    #define OF_DT_PROP              0x3             /* Property: name off,
+						       size, content */
+    #define OF_DT_END               0x9
+
+All values in this header are in big endian format, the various
+fields in this header are defined more precisely below.  All "offset"
+values are in bytes from the start of the header; that is from the
+value of r3.
+
+   - magic
+
+     This is a magic value that "marks" the beginning of the
+     device-tree block header. It contains the value 0xd00dfeed and is
+     defined by the constant OF_DT_HEADER
+
+   - totalsize
+
+     This is the total size of the DT block including the header. The
+     "DT" block should enclose all data structures defined in this
+     chapter (who are pointed to by offsets in this header). That is,
+     the device-tree structure, strings, and the memory reserve map.
+
+   - off_dt_struct
+
+     This is an offset from the beginning of the header to the start
+     of the "structure" part the device tree. (see 2) device tree)
+
+   - off_dt_strings
+
+     This is an offset from the beginning of the header to the start
+     of the "strings" part of the device-tree
+
+   - off_mem_rsvmap
+
+     This is an offset from the beginning of the header to the start
+     of the reserved memory map. This map is a list of pairs of 64-
+     bit integers. Each pair is a physical address and a size. The
+     list is terminated by an entry of size 0. This map provides the
+     kernel with a list of physical memory areas that are "reserved"
+     and thus not to be used for memory allocations, especially during
+     early initialization. The kernel needs to allocate memory during
+     boot for things like un-flattening the device-tree, allocating an
+     MMU hash table, etc... Those allocations must be done in such a
+     way to avoid overriding critical things like, on Open Firmware
+     capable machines, the RTAS instance, or on some pSeries, the TCE
+     tables used for the iommu. Typically, the reserve map should
+     contain _at least_ this DT block itself (header,total_size). If
+     you are passing an initrd to the kernel, you should reserve it as
+     well. You do not need to reserve the kernel image itself. The map
+     should be 64-bit aligned.
+
+   - version
+
+     This is the version of this structure. Version 1 stops
+     here. Version 2 adds an additional field boot_cpuid_phys.
+     Version 3 adds the size of the strings block, allowing the kernel
+     to reallocate it easily at boot and free up the unused flattened
+     structure after expansion. Version 16 introduces a new more
+     "compact" format for the tree itself that is however not backward
+     compatible. Version 17 adds an additional field, size_dt_struct,
+     allowing it to be reallocated or moved more easily (this is
+     particularly useful for bootloaders which need to make
+     adjustments to a device tree based on probed information). You
+     should always generate a structure of the highest version defined
+     at the time of your implementation. Currently that is version 17,
+     unless you explicitly aim at being backward compatible.
+
+   - last_comp_version
+
+     Last compatible version. This indicates down to what version of
+     the DT block you are backward compatible. For example, version 2
+     is backward compatible with version 1 (that is, a kernel build
+     for version 1 will be able to boot with a version 2 format). You
+     should put a 1 in this field if you generate a device tree of
+     version 1 to 3, or 16 if you generate a tree of version 16 or 17
+     using the new unit name format.
+
+   - boot_cpuid_phys
+
+     This field only exist on version 2 headers. It indicate which
+     physical CPU ID is calling the kernel entry point. This is used,
+     among others, by kexec. If you are on an SMP system, this value
+     should match the content of the "reg" property of the CPU node in
+     the device-tree corresponding to the CPU calling the kernel entry
+     point (see further chapters for more information on the required
+     device-tree contents)
+
+   - size_dt_strings
+
+     This field only exists on version 3 and later headers.  It
+     gives the size of the "strings" section of the device tree (which
+     starts at the offset given by off_dt_strings).
+
+   - size_dt_struct
+
+     This field only exists on version 17 and later headers.  It gives
+     the size of the "structure" section of the device tree (which
+     starts at the offset given by off_dt_struct).
+
+So the typical layout of a DT block (though the various parts don't
+need to be in that order) looks like this (addresses go from top to
+bottom):
+
+             ------------------------------
+       r3 -> |  struct boot_param_header  |
+             ------------------------------
+             |      (alignment gap) (*)   |
+             ------------------------------
+             |      memory reserve map    |
+             ------------------------------
+             |      (alignment gap)       |
+             ------------------------------
+             |                            |
+             |    device-tree structure   |
+             |                            |
+             ------------------------------
+             |      (alignment gap)       |
+             ------------------------------
+             |                            |
+             |     device-tree strings    |
+             |                            |
+      -----> ------------------------------
+      |
+      |
+      --- (r3 + totalsize)
+
+  (*) The alignment gaps are not necessarily present; their presence
+      and size are dependent on the various alignment requirements of
+      the individual data blocks.
+
+
+2) Device tree generalities
+---------------------------
+
+This device-tree itself is separated in two different blocks, a
+structure block and a strings block. Both need to be aligned to a 4
+byte boundary.
+
+First, let's quickly describe the device-tree concept before detailing
+the storage format. This chapter does _not_ describe the detail of the
+required types of nodes & properties for the kernel, this is done
+later in chapter III.
+
+The device-tree layout is strongly inherited from the definition of
+the Open Firmware IEEE 1275 device-tree. It's basically a tree of
+nodes, each node having two or more named properties. A property can
+have a value or not.
+
+It is a tree, so each node has one and only one parent except for the
+root node who has no parent.
+
+A node has 2 names. The actual node name is generally contained in a
+property of type "name" in the node property list whose value is a
+zero terminated string and is mandatory for version 1 to 3 of the
+format definition (as it is in Open Firmware). Version 16 makes it
+optional as it can generate it from the unit name defined below.
+
+There is also a "unit name" that is used to differentiate nodes with
+the same name at the same level, it is usually made of the node
+names, the "@" sign, and a "unit address", which definition is
+specific to the bus type the node sits on.
+
+The unit name doesn't exist as a property per-se but is included in
+the device-tree structure. It is typically used to represent "path" in
+the device-tree. More details about the actual format of these will be
+below.
+
+The kernel powerpc generic code does not make any formal use of the
+unit address (though some board support code may do) so the only real
+requirement here for the unit address is to ensure uniqueness of
+the node unit name at a given level of the tree. Nodes with no notion
+of address and no possible sibling of the same name (like /memory or
+/cpus) may omit the unit address in the context of this specification,
+or use the "@0" default unit address. The unit name is used to define
+a node "full path", which is the concatenation of all parent node
+unit names separated with "/".
+
+The root node doesn't have a defined name, and isn't required to have
+a name property either if you are using version 3 or earlier of the
+format. It also has no unit address (no @ symbol followed by a unit
+address). The root node unit name is thus an empty string. The full
+path to the root node is "/".
+
+Every node which actually represents an actual device (that is, a node
+which isn't only a virtual "container" for more nodes, like "/cpus"
+is) is also required to have a "device_type" property indicating the
+type of node .
+
+Finally, every node that can be referenced from a property in another
+node is required to have a "linux,phandle" property. Real open
+firmware implementations provide a unique "phandle" value for every
+node that the "prom_init()" trampoline code turns into
+"linux,phandle" properties. However, this is made optional if the
+flattened device tree is used directly. An example of a node
+referencing another node via "phandle" is when laying out the
+interrupt tree which will be described in a further version of this
+document.
+
+This "linux, phandle" property is a 32-bit value that uniquely
+identifies a node. You are free to use whatever values or system of
+values, internal pointers, or whatever to generate these, the only
+requirement is that every node for which you provide that property has
+a unique value for it.
+
+Here is an example of a simple device-tree. In this example, an "o"
+designates a node followed by the node unit name. Properties are
+presented with their name followed by their content. "content"
+represents an ASCII string (zero terminated) value, while <content>
+represents a 32-bit hexadecimal value. The various nodes in this
+example will be discussed in a later chapter. At this point, it is
+only meant to give you a idea of what a device-tree looks like. I have
+purposefully kept the "name" and "linux,phandle" properties which
+aren't necessary in order to give you a better idea of what the tree
+looks like in practice.
+
+  / o device-tree
+      |- name = "device-tree"
+      |- model = "MyBoardName"
+      |- compatible = "MyBoardFamilyName"
+      |- #address-cells = <2>
+      |- #size-cells = <2>
+      |- linux,phandle = <0>
+      |
+      o cpus
+      | | - name = "cpus"
+      | | - linux,phandle = <1>
+      | | - #address-cells = <1>
+      | | - #size-cells = <0>
+      | |
+      | o PowerPC,970@0
+      |   |- name = "PowerPC,970"
+      |   |- device_type = "cpu"
+      |   |- reg = <0>
+      |   |- clock-frequency = <5f5e1000>
+      |   |- 64-bit
+      |   |- linux,phandle = <2>
+      |
+      o memory@0
+      | |- name = "memory"
+      | |- device_type = "memory"
+      | |- reg = <00000000 00000000 00000000 20000000>
+      | |- linux,phandle = <3>
+      |
+      o chosen
+        |- name = "chosen"
+        |- bootargs = "root=/dev/sda2"
+        |- linux,phandle = <4>
+
+This tree is almost a minimal tree. It pretty much contains the
+minimal set of required nodes and properties to boot a linux kernel;
+that is, some basic model information at the root, the CPUs, and the
+physical memory layout.  It also includes misc information passed
+through /chosen, like in this example, the platform type (mandatory)
+and the kernel command line arguments (optional).
+
+The /cpus/PowerPC,970@0/64-bit property is an example of a
+property without a value. All other properties have a value. The
+significance of the #address-cells and #size-cells properties will be
+explained in chapter IV which defines precisely the required nodes and
+properties and their content.
+
+
+3) Device tree "structure" block
+
+The structure of the device tree is a linearized tree structure. The
+"OF_DT_BEGIN_NODE" token starts a new node, and the "OF_DT_END_NODE"
+ends that node definition. Child nodes are simply defined before
+"OF_DT_END_NODE" (that is nodes within the node). A 'token' is a 32
+bit value. The tree has to be "finished" with a OF_DT_END token
+
+Here's the basic structure of a single node:
+
+     * token OF_DT_BEGIN_NODE (that is 0x00000001)
+     * for version 1 to 3, this is the node full path as a zero
+       terminated string, starting with "/". For version 16 and later,
+       this is the node unit name only (or an empty string for the
+       root node)
+     * [align gap to next 4 bytes boundary]
+     * for each property:
+        * token OF_DT_PROP (that is 0x00000003)
+        * 32-bit value of property value size in bytes (or 0 if no
+          value)
+        * 32-bit value of offset in string block of property name
+        * property value data if any
+        * [align gap to next 4 bytes boundary]
+     * [child nodes if any]
+     * token OF_DT_END_NODE (that is 0x00000002)
+
+So the node content can be summarized as a start token, a full path,
+a list of properties, a list of child nodes, and an end token. Every
+child node is a full node structure itself as defined above.
+
+NOTE: The above definition requires that all property definitions for
+a particular node MUST precede any subnode definitions for that node.
+Although the structure would not be ambiguous if properties and
+subnodes were intermingled, the kernel parser requires that the
+properties come first (up until at least 2.6.22).  Any tools
+manipulating a flattened tree must take care to preserve this
+constraint.
+
+4) Device tree "strings" block
+
+In order to save space, property names, which are generally redundant,
+are stored separately in the "strings" block. This block is simply the
+whole bunch of zero terminated strings for all property names
+concatenated together. The device-tree property definitions in the
+structure block will contain offset values from the beginning of the
+strings block.
+
+
+III - libfdt
+============
+
+This library should be merged into dtc proper.
+This library should likely be worked into U-Boot and the kernel.
+
+
+IV - Utility Tools
+==================
+
+1) convert-dtsv0 -- Conversion to Version 1
+
+convert-dtsv0 is a small utility program which converts (DTS)
+Device Tree Source from the obsolete version 0 to version 1.
+
+Version 1 DTS files are marked by line "/dts-v1/;" at the top of the file.
+
+The syntax of the convert-dtsv0 command line is:
+
+    convert-dtsv0 [<input_filename ... >]
+
+Each file passed will be converted to the new /dts-v1/ version by creating
+a new file with a "v1" appended the filename.
+
+Comments, empty lines, etc. are preserved.
+
+
+2) fdtdump -- Flat Device Tree dumping utility
+
+The fdtdump program prints a readable version of a flat device tree file.
+
+The syntax of the fdtdump command line is:
+
+    fdtdump [options] <DTB-file-name>
+
+Where options are:
+    -d,--debug          Dump debug information while decoding the file
+    -s,--scan           Scan for an embedded fdt in given file
+
+3) fdtoverlay -- Flat Device Tree overlay applicator
+
+The fdtoverlay applies an arbitrary number of FDT overlays to a base FDT blob
+to a given output file.
+
+The syntax of the fdtoverlay command line is:
+
+    fdtoverlay -i <base-blob> -o <output-blob> <overlay-blob0> [<overlay-blob1> ...]
+
+Where options are:
+    -i, --input         Input base DT blob
+    -o, --output        Output DT blob
+    -v, --verbose       Verbose message output
+
+4 ) fdtget -- Read properties from device tree
+
+This command can be used to obtain individual values from the device tree in a
+nicely formatted way. You can specify multiple nodes to display (when using -p)
+or multiple node/property pairs (when not using -p). For the latter, each
+property is displayed on its own line, with a space between each cell within
+the property.
+
+The syntax of the fdtget command is:
+
+    fdtget <options> <dt file> [<node> <property>]...
+    fdtget -p <options> <dt file> [<node> ]...
+
+where options are:
+
+    <type>    s=string, i=int, u=unsigned, x=hex
+        Optional modifier prefix:
+            hh or b=byte, h=2 byte, l=4 byte (default)
+
+    Options: -[t:pld:hV]
+    -t, --type <arg>    Type of data
+    -p, --properties    List properties for each node
+    -l, --list          List subnodes for each node
+    -d, --default <arg> Default value to display when the property is missing
+    -h, --help          Print this help and exit
+    -V, --version       Print version and exit
+
+If -t is not provided, fdtget will try to figure out the type, trying to detect
+strings, string lists and the size of each value in the property. This is
+similar to how fdtdump works, and uses the same heuristics.
+
+
+5 ) fdtput - Write properties to a device tree
+
+The syntax of the fdtput command is:
+
+    fdtput <options> <dt file> <node> <property> [<value>...]
+    fdtput -c <options> <dt file> [<node>...]
+    fdtput -r <options> <dt file> [<node>...]
+    fdtput -d <options> <dt file> <node> [<property>...]
+
+Options are:
+
+    <type>    s=string, i=int, u=unsigned, x=hex
+        Optional modifier prefix:
+            hh or b=byte, h=2 byte, l=4 byte (default)
+
+    -c, --create     Create nodes if they don't already exist
+    -r, --remove     Delete nodes (and any subnodes) if they already exist
+    -d, --delete     Delete properties if they already exist
+    -p, --auto-path  Automatically create nodes as needed for the node path
+    -t, --type <arg> Type of data
+    -v, --verbose    Display each value decoded from command line
+    -h, --help       Print this help and exit
+    -V, --version    Print version and exit
+
+The option determines which usage is selected and therefore the operation that
+is performed. The first usage adds or updates properties; the rest are used to
+create/delete nodes and delete properties.
+
+For the first usage, the command line arguments are joined together into a
+single value which is written to the property. The -t option is required so
+that fdtput knows how to decode its arguments.
diff --git a/dtc/GPL b/dtc/GPL
new file mode 100644
index 0000000..d159169
--- /dev/null
+++ b/dtc/GPL
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/dtc/Makefile b/dtc/Makefile
new file mode 100644
index 0000000..ea8c659
--- /dev/null
+++ b/dtc/Makefile
@@ -0,0 +1,384 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Device Tree Compiler
+#
+
+#
+# Version information will be constructed in this order:
+# EXTRAVERSION might be "-rc", for example.
+# LOCAL_VERSION is likely from command line.
+# CONFIG_LOCALVERSION from some future config system.
+#
+VERSION = 1
+PATCHLEVEL = 6
+SUBLEVEL = 1
+EXTRAVERSION =
+LOCAL_VERSION =
+CONFIG_LOCALVERSION =
+
+# Control the assumptions made (e.g. risking security issues) in the code.
+# See libfdt_internal.h for details
+ASSUME_MASK ?= 0
+
+CPPFLAGS = -I libfdt -I . -DFDT_ASSUME_MASK=$(ASSUME_MASK)
+WARNINGS = -Wall -Wpointer-arith -Wcast-qual -Wnested-externs \
+	-Wstrict-prototypes -Wmissing-prototypes -Wredundant-decls -Wshadow
+CFLAGS = -g -Os $(SHAREDLIB_CFLAGS) -Werror $(WARNINGS) $(EXTRA_CFLAGS)
+
+BISON = bison
+LEX = flex
+SWIG = swig
+PKG_CONFIG ?= pkg-config
+PYTHON ?= python3
+
+INSTALL = /usr/bin/install
+INSTALL_PROGRAM = $(INSTALL)
+INSTALL_LIB = $(INSTALL)
+INSTALL_DATA = $(INSTALL) -m 644
+INSTALL_SCRIPT = $(INSTALL)
+DESTDIR =
+PREFIX = $(HOME)
+BINDIR = $(PREFIX)/bin
+LIBDIR = $(PREFIX)/lib
+INCLUDEDIR = $(PREFIX)/include
+
+HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
+	    sed -e 's/\(cygwin\|msys\).*/\1/')
+
+NO_PYTHON ?= 0
+
+NO_VALGRIND := $(shell $(PKG_CONFIG) --exists valgrind; echo $$?)
+ifeq ($(NO_VALGRIND),1)
+	CPPFLAGS += -DNO_VALGRIND
+else
+	CFLAGS += $(shell $(PKG_CONFIG) --cflags valgrind)
+endif
+
+NO_YAML := $(shell $(PKG_CONFIG) --exists yaml-0.1; echo $$?)
+ifeq ($(NO_YAML),1)
+	CFLAGS += -DNO_YAML
+else
+	LDLIBS_dtc += $(shell $(PKG_CONFIG) --libs yaml-0.1)
+	CFLAGS += $(shell $(PKG_CONFIG) --cflags yaml-0.1)
+endif
+
+ifeq ($(HOSTOS),darwin)
+SHAREDLIB_EXT     = dylib
+SHAREDLIB_CFLAGS  = -fPIC
+SHAREDLIB_LDFLAGS = -fPIC -dynamiclib -Wl,-install_name -Wl,
+else ifeq ($(HOSTOS),$(filter $(HOSTOS),msys cygwin))
+SHAREDLIB_EXT     = so
+SHAREDLIB_CFLAGS  =
+SHAREDLIB_LDFLAGS = -shared -Wl,--version-script=$(LIBFDT_version) -Wl,-soname,
+else
+SHAREDLIB_EXT     = so
+SHAREDLIB_CFLAGS  = -fPIC
+SHAREDLIB_LDFLAGS = -fPIC -shared -Wl,--version-script=$(LIBFDT_version) -Wl,-soname,
+endif
+
+#
+# Overall rules
+#
+ifdef V
+VECHO = :
+else
+VECHO = echo "	"
+ARFLAGS = rc
+.SILENT:
+endif
+
+NODEPTARGETS = clean
+ifeq ($(MAKECMDGOALS),)
+DEPTARGETS = all
+else
+DEPTARGETS = $(filter-out $(NODEPTARGETS),$(MAKECMDGOALS))
+endif
+
+#
+# Rules for versioning
+#
+
+DTC_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+VERSION_FILE = version_gen.h
+
+CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
+	  else if [ -x /bin/bash ]; then echo /bin/bash; \
+	  else echo sh; fi ; fi)
+
+nullstring :=
+space	:= $(nullstring) # end of line
+
+localver_config = $(subst $(space),, $(string) \
+			      $(patsubst "%",%,$(CONFIG_LOCALVERSION)))
+
+localver_cmd = $(subst $(space),, $(string) \
+			      $(patsubst "%",%,$(LOCALVERSION)))
+
+localver_scm = $(shell $(CONFIG_SHELL) ./scripts/setlocalversion)
+localver_full  = $(localver_config)$(localver_cmd)$(localver_scm)
+
+dtc_version = $(DTC_VERSION)$(localver_full)
+
+# Contents of the generated version file.
+define filechk_version
+	(echo "#define DTC_VERSION \"DTC $(dtc_version)\""; )
+endef
+
+define filechk
+	set -e;					\
+	echo '	CHK $@';			\
+	mkdir -p $(dir $@);			\
+	$(filechk_$(1)) < $< > $@.tmp;		\
+	if [ -r $@ ] && cmp -s $@ $@.tmp; then	\
+		rm -f $@.tmp;			\
+	else					\
+		echo '	UPD $@';		\
+		mv -f $@.tmp $@;		\
+	fi;
+endef
+
+
+include Makefile.convert-dtsv0
+include Makefile.dtc
+include Makefile.utils
+
+BIN += convert-dtsv0
+BIN += dtc
+BIN += fdtdump
+BIN += fdtget
+BIN += fdtput
+BIN += fdtoverlay
+
+SCRIPTS = dtdiff
+
+all: $(BIN) libfdt
+
+# We need both Python and swig to build/install pylibfdt.
+# This builds the given make ${target} if those deps are found.
+check_python_deps = \
+	if $(PKG_CONFIG) --cflags $(PYTHON) >/dev/null 2>&1; then \
+		if which swig >/dev/null 2>&1; then \
+			can_build=yes; \
+		fi; \
+	fi; \
+	if [ "$${can_build}" = "yes" ]; then \
+		$(MAKE) $${target}; \
+	else \
+		echo "\#\# Skipping pylibfdt (install python dev and swig to build)"; \
+	fi ;
+
+.PHONY: maybe_pylibfdt
+maybe_pylibfdt: FORCE
+	target=pylibfdt; $(check_python_deps)
+
+ifeq ($(NO_PYTHON),0)
+all: maybe_pylibfdt
+endif
+
+
+ifneq ($(DEPTARGETS),)
+ifneq ($(MAKECMDGOALS),libfdt)
+-include $(DTC_OBJS:%.o=%.d)
+-include $(CONVERT_OBJS:%.o=%.d)
+-include $(FDTDUMP_OBJS:%.o=%.d)
+-include $(FDTGET_OBJS:%.o=%.d)
+-include $(FDTPUT_OBJS:%.o=%.d)
+-include $(FDTOVERLAY_OBJS:%.o=%.d)
+endif
+endif
+
+
+
+#
+# Rules for libfdt
+#
+LIBFDT_dir = libfdt
+LIBFDT_archive = $(LIBFDT_dir)/libfdt.a
+LIBFDT_lib = $(LIBFDT_dir)/$(LIBFDT_LIB)
+LIBFDT_include = $(addprefix $(LIBFDT_dir)/,$(LIBFDT_INCLUDES))
+LIBFDT_version = $(addprefix $(LIBFDT_dir)/,$(LIBFDT_VERSION))
+
+include $(LIBFDT_dir)/Makefile.libfdt
+
+.PHONY: libfdt
+libfdt: $(LIBFDT_archive) $(LIBFDT_lib)
+
+$(LIBFDT_archive): $(addprefix $(LIBFDT_dir)/,$(LIBFDT_OBJS))
+
+$(LIBFDT_lib): $(addprefix $(LIBFDT_dir)/,$(LIBFDT_OBJS)) $(LIBFDT_version)
+	@$(VECHO) LD $@
+	$(CC) $(LDFLAGS) $(SHAREDLIB_LDFLAGS)$(LIBFDT_soname) -o $(LIBFDT_lib) \
+		$(addprefix $(LIBFDT_dir)/,$(LIBFDT_OBJS))
+	ln -sf $(LIBFDT_LIB) $(LIBFDT_dir)/$(LIBFDT_soname)
+
+ifneq ($(DEPTARGETS),)
+-include $(LIBFDT_OBJS:%.o=$(LIBFDT_dir)/%.d)
+endif
+
+# This stops make from generating the lex and bison output during
+# auto-dependency computation, but throwing them away as an
+# intermediate target and building them again "for real"
+.SECONDARY: $(DTC_GEN_SRCS) $(CONVERT_GEN_SRCS)
+
+install-bin: all $(SCRIPTS)
+	@$(VECHO) INSTALL-BIN
+	$(INSTALL) -d $(DESTDIR)$(BINDIR)
+	$(INSTALL_PROGRAM) $(BIN) $(DESTDIR)$(BINDIR)
+	$(INSTALL_SCRIPT) $(SCRIPTS) $(DESTDIR)$(BINDIR)
+
+install-lib: all
+	@$(VECHO) INSTALL-LIB
+	$(INSTALL) -d $(DESTDIR)$(LIBDIR)
+	$(INSTALL_LIB) $(LIBFDT_lib) $(DESTDIR)$(LIBDIR)
+	ln -sf $(notdir $(LIBFDT_lib)) $(DESTDIR)$(LIBDIR)/$(LIBFDT_soname)
+	ln -sf $(LIBFDT_soname) $(DESTDIR)$(LIBDIR)/libfdt.$(SHAREDLIB_EXT)
+	$(INSTALL_DATA) $(LIBFDT_archive) $(DESTDIR)$(LIBDIR)
+
+install-includes:
+	@$(VECHO) INSTALL-INC
+	$(INSTALL) -d $(DESTDIR)$(INCLUDEDIR)
+	$(INSTALL_DATA) $(LIBFDT_include) $(DESTDIR)$(INCLUDEDIR)
+
+install: install-bin install-lib install-includes
+
+.PHONY: maybe_install_pylibfdt
+maybe_install_pylibfdt: FORCE
+	target=install_pylibfdt; $(check_python_deps)
+
+ifeq ($(NO_PYTHON),0)
+install: maybe_install_pylibfdt
+endif
+
+$(VERSION_FILE): Makefile FORCE
+	$(call filechk,version)
+
+
+dtc: $(DTC_OBJS)
+
+convert-dtsv0: $(CONVERT_OBJS)
+	@$(VECHO) LD $@
+	$(LINK.c) -o $@ $^
+
+fdtdump:	$(FDTDUMP_OBJS)
+
+fdtget:	$(FDTGET_OBJS) $(LIBFDT_lib)
+
+fdtput:	$(FDTPUT_OBJS) $(LIBFDT_lib)
+
+fdtoverlay: $(FDTOVERLAY_OBJS) $(LIBFDT_lib)
+
+dist:
+	git archive --format=tar --prefix=dtc-$(dtc_version)/ HEAD \
+		> ../dtc-$(dtc_version).tar
+	cat ../dtc-$(dtc_version).tar | \
+		gzip -9 > ../dtc-$(dtc_version).tar.gz
+
+
+#
+# Rules for pylibfdt
+#
+PYLIBFDT_dir = pylibfdt
+
+include $(PYLIBFDT_dir)/Makefile.pylibfdt
+
+.PHONY: pylibfdt
+pylibfdt: $(PYLIBFDT_dir)/_libfdt.so
+
+#
+# Release signing and uploading
+# This is for maintainer convenience, don't try this at home.
+#
+ifeq ($(MAINTAINER),y)
+GPG = gpg2
+KUP = kup
+KUPDIR = /pub/software/utils/dtc
+
+kup: dist
+	$(GPG) --detach-sign --armor -o ../dtc-$(dtc_version).tar.sign \
+		../dtc-$(dtc_version).tar
+	$(KUP) put ../dtc-$(dtc_version).tar.gz ../dtc-$(dtc_version).tar.sign \
+		$(KUPDIR)/dtc-$(dtc_version).tar.gz
+endif
+
+tags: FORCE
+	rm -f tags
+	find . \( -name tests -type d -prune \) -o \
+	       \( ! -name '*.tab.[ch]' ! -name '*.lex.c' \
+	       -name '*.[chly]' -type f -print \) | xargs ctags -a
+
+#
+# Testsuite rules
+#
+TESTS_PREFIX=tests/
+
+TESTS_BIN += dtc
+TESTS_BIN += convert-dtsv0
+TESTS_BIN += fdtput
+TESTS_BIN += fdtget
+TESTS_BIN += fdtdump
+TESTS_BIN += fdtoverlay
+ifeq ($(NO_PYTHON),0)
+TESTS_PYLIBFDT += maybe_pylibfdt
+endif
+
+ifneq ($(MAKECMDGOALS),libfdt)
+include tests/Makefile.tests
+endif
+
+#
+# Clean rules
+#
+STD_CLEANFILES = *~ *.o *.$(SHAREDLIB_EXT) *.d *.a *.i *.s core a.out vgcore.* \
+	*.tab.[ch] *.lex.c *.output
+
+clean: libfdt_clean pylibfdt_clean tests_clean
+	@$(VECHO) CLEAN
+	rm -f $(STD_CLEANFILES)
+	rm -f $(VERSION_FILE)
+	rm -f $(BIN)
+	rm -f dtc-*.tar dtc-*.tar.sign dtc-*.tar.asc
+
+#
+# Generic compile rules
+#
+%: %.o
+	@$(VECHO) LD $@
+	$(LINK.c) -o $@ $^ $(LDLIBS_$*)
+
+%.o: %.c
+	@$(VECHO) CC $@
+	$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $<
+
+%.o: %.S
+	@$(VECHO) AS $@
+	$(CC) $(CPPFLAGS) $(AFLAGS) -D__ASSEMBLY__ -o $@ -c $<
+
+%.d: %.c
+	@$(VECHO) DEP $<
+	$(CC) $(CPPFLAGS) $(CFLAGS) -MM -MG -MT "$*.o $@" $< > $@
+
+%.d: %.S
+	@$(VECHO) DEP $<
+	$(CC) $(CPPFLAGS) -MM -MG -MT "$*.o $@" $< > $@
+
+%.i:	%.c
+	@$(VECHO) CPP $@
+	$(CC) $(CPPFLAGS) -E $< > $@
+
+%.s:	%.c
+	@$(VECHO) CC -S $@
+	$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -S $<
+
+%.a:
+	@$(VECHO) AR $@
+	$(AR) $(ARFLAGS) $@ $^
+
+%.lex.c: %.l
+	@$(VECHO) LEX $@
+	$(LEX) -o$@ $<
+
+%.tab.c %.tab.h %.output: %.y
+	@$(VECHO) BISON $@
+	$(BISON) -b $(basename $(basename $@)) -d $<
+
+FORCE:
diff --git a/dtc/Makefile.convert-dtsv0 b/dtc/Makefile.convert-dtsv0
new file mode 100644
index 0000000..c12ed40
--- /dev/null
+++ b/dtc/Makefile.convert-dtsv0
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# This is not a complete Makefile of itself.
+# Instead, it is designed to be easily embeddable
+# into other systems of Makefiles.
+#
+
+CONVERT_SRCS = \
+	srcpos.c \
+	util.c
+
+CONVERT_GEN_SRCS = convert-dtsv0-lexer.lex.c
+
+CONVERT_OBJS = $(CONVERT_SRCS:%.c=%.o) $(CONVERT_GEN_SRCS:%.c=%.o)
diff --git a/dtc/Makefile.dtc b/dtc/Makefile.dtc
new file mode 100644
index 0000000..9c467b0
--- /dev/null
+++ b/dtc/Makefile.dtc
@@ -0,0 +1,23 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Makefile.dtc
+#
+# This is not a complete Makefile of itself.  Instead, it is designed to
+# be easily embeddable into other systems of Makefiles.
+#
+DTC_SRCS = \
+	checks.c \
+	data.c \
+	dtc.c \
+	flattree.c \
+	fstree.c \
+	livetree.c \
+	srcpos.c \
+	treesource.c \
+	util.c
+
+ifneq ($(NO_YAML),1)
+DTC_SRCS += yamltree.c
+endif
+
+DTC_GEN_SRCS = dtc-lexer.lex.c dtc-parser.tab.c
+DTC_OBJS = $(DTC_SRCS:%.c=%.o) $(DTC_GEN_SRCS:%.c=%.o)
diff --git a/dtc/Makefile.utils b/dtc/Makefile.utils
new file mode 100644
index 0000000..9436b34
--- /dev/null
+++ b/dtc/Makefile.utils
@@ -0,0 +1,31 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# This is not a complete Makefile of itself.  Instead, it is designed to
+# be easily embeddable into other systems of Makefiles.
+#
+
+FDTDUMP_SRCS = \
+	fdtdump.c \
+	util.c
+
+FDTDUMP_OBJS = $(FDTDUMP_SRCS:%.c=%.o)
+
+
+FDTGET_SRCS = \
+	fdtget.c \
+	util.c
+
+FDTGET_OBJS = $(FDTGET_SRCS:%.c=%.o)
+
+
+FDTPUT_SRCS = \
+	fdtput.c \
+	util.c
+
+FDTPUT_OBJS = $(FDTPUT_SRCS:%.c=%.o)
+
+FDTOVERLAY_SRCS = \
+	fdtoverlay.c \
+	util.c
+
+FDTOVERLAY_OBJS = $(FDTOVERLAY_SRCS:%.c=%.o)
diff --git a/dtc/README b/dtc/README
new file mode 100644
index 0000000..d9bf850
--- /dev/null
+++ b/dtc/README
@@ -0,0 +1,91 @@
+The source tree contains the Device Tree Compiler (dtc) toolchain for
+working with device tree source and binary files and also libfdt, a
+utility library for reading and manipulating the binary format.
+
+DTC and LIBFDT are maintained by:
+
+David Gibson <david@gibson.dropbear.id.au>
+Jon Loeliger <loeliger@gmail.com>
+
+
+Python library
+--------------
+
+A Python library is also available. To build this you will need to install
+swig and Python development files. On Debian distributions:
+
+   sudo apt-get install swig python3-dev
+
+The library provides an Fdt class which you can use like this:
+
+$ PYTHONPATH=../pylibfdt python3
+>>> import libfdt
+>>> fdt = libfdt.Fdt(open('test_tree1.dtb', mode='rb').read())
+>>> node = fdt.path_offset('/subnode@1')
+>>> print(node)
+124
+>>> prop_offset = fdt.first_property_offset(node)
+>>> prop = fdt.get_property_by_offset(prop_offset)
+>>> print('%s=%s' % (prop.name, prop.as_str()))
+compatible=subnode1
+>>> node2 = fdt.path_offset('/')
+>>> print(fdt.getprop(node2, 'compatible').as_str())
+test_tree1
+
+You will find tests in tests/pylibfdt_tests.py showing how to use each
+method. Help is available using the Python help command, e.g.:
+
+    $ cd pylibfdt
+    $ python3 -c "import libfdt; help(libfdt)"
+
+If you add new features, please check code coverage:
+
+    $ sudo apt-get install python3-coverage
+    $ cd tests
+    # It's just 'coverage' on most other distributions
+    $ python3-coverage run pylibfdt_tests.py
+    $ python3-coverage html
+    # Open 'htmlcov/index.html' in your browser
+
+
+To install the library via the normal setup.py method, use:
+
+    ./pylibfdt/setup.py install [--prefix=/path/to/install_dir]
+
+If --prefix is not provided, the default prefix is used, typically '/usr'
+or '/usr/local'. See Python's distutils documentation for details. You can
+also install via the Makefile if you like, but the above is more common.
+
+To install both libfdt and pylibfdt you can use:
+
+    make install [SETUP_PREFIX=/path/to/install_dir] \
+            [PREFIX=/path/to/install_dir]
+
+To disable building the python library, even if swig and Python are available,
+use:
+
+    make NO_PYTHON=1
+
+
+More work remains to support all of libfdt, including access to numeric
+values.
+
+
+Tests
+-----
+
+Test files are kept in the tests/ directory. Use 'make check' to build and run
+all tests.
+
+If you want to adjust a test file, be aware that tree_tree1.dts is compiled
+and checked against a binary tree from assembler macros in trees.S. So
+if you change that file you must change tree.S also.
+
+
+Mailing list
+------------
+The following list is for discussion about dtc and libfdt implementation
+mailto:devicetree-compiler@vger.kernel.org
+
+Core device tree bindings are discussed on the devicetree-spec list:
+mailto:devicetree-spec@vger.kernel.org
diff --git a/dtc/README.license b/dtc/README.license
new file mode 100644
index 0000000..102b004
--- /dev/null
+++ b/dtc/README.license
@@ -0,0 +1,56 @@
+Licensing and contribution policy of dtc and libfdt
+===================================================
+
+This dtc package contains two pieces of software: dtc itself, and
+libfdt which comprises the files in the libfdt/ subdirectory.  These
+two pieces of software, although closely related, are quite distinct.
+dtc does not incorporate or rely on libfdt for its operation, nor vice
+versa.  It is important that these two pieces of software have
+different license conditions.
+
+As SPDX license tags in each source file attest, dtc is licensed
+under the GNU GPL.  The full text of the GPL can be found in the file
+entitled 'GPL' which should be included in this package.  dtc code,
+therefore, may not be incorporated into works which do not have a GPL
+compatible license.
+
+libfdt, however, is GPL/BSD dual-licensed.  That is, it may be used
+either under the terms of the GPL, or under the terms of the 2-clause
+BSD license (aka the ISC license).  The full terms of that license can
+be found are in the file entitled 'BSD-2-Clause'. This is, in
+practice, equivalent to being BSD licensed, since the terms of the BSD
+license are strictly more permissive than the GPL.
+
+I made the decision to license libfdt in this way because I want to
+encourage widespread and correct usage of flattened device trees,
+including by proprietary or otherwise GPL-incompatible firmware or
+tools.  Allowing libfdt to be used under the terms of the BSD license
+makes that it easier for vendors or authors of such software to do so.
+
+This does mean that libfdt code could be "stolen" - say, included in a
+proprietary fimware and extended without contributing those extensions
+back to the libfdt mainline.  While I hope that doesn't happen, I
+believe the goal of allowing libfdt to be widely used is more
+important than avoiding that.  libfdt is quite small, and hardly
+rocket science; so the incentive for such impolite behaviour is small,
+and the inconvenience caused thereby is not dire.
+
+Licenses such as the LGPL which would allow code to be used in non-GPL
+software, but also require contributions to be returned were
+considered.  However, libfdt is designed to be used in firmwares and
+other environments with unusual technical constraints.  It's difficult
+to anticipate all possible changes which might be needed to meld
+libfdt into such environments and so difficult to suitably word a
+license that puts the boundary between what is and isn't permitted in
+the intended place.  Again, I judged encouraging widespread use of
+libfdt by keeping the license terms simple and familiar to be the more
+important goal.
+
+**IMPORTANT** It's intended that all of libfdt as released remain
+permissively licensed this way.  Therefore only contributions which
+are released under these terms can be merged into the libfdt mainline.
+
+
+David Gibson <david@gibson.dropbear.id.au>
+(principal original author of dtc and libfdt)
+2 November 2007
diff --git a/dtc/TODO b/dtc/TODO
new file mode 100644
index 0000000..a3e7182
--- /dev/null
+++ b/dtc/TODO
@@ -0,0 +1,8 @@
+- Bugfixes:
+	* Proper handling of boot cpu information
+- Generate mem reserve map
+	* linux,reserve-map property
+	* generating reserve entry for device tree itself
+	* generating reserve entries from tce, rtas etc. properties
+- Expression support
+- Macro system
diff --git a/dtc/checks.c b/dtc/checks.c
new file mode 100644
index 0000000..e6c7c3e
--- /dev/null
+++ b/dtc/checks.c
@@ -0,0 +1,1981 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2007.
+ */
+
+#include "dtc.h"
+#include "srcpos.h"
+
+#ifdef TRACE_CHECKS
+#define TRACE(c, ...) \
+	do { \
+		fprintf(stderr, "=== %s: ", (c)->name); \
+		fprintf(stderr, __VA_ARGS__); \
+		fprintf(stderr, "\n"); \
+	} while (0)
+#else
+#define TRACE(c, fmt, ...)	do { } while (0)
+#endif
+
+enum checkstatus {
+	UNCHECKED = 0,
+	PREREQ,
+	PASSED,
+	FAILED,
+};
+
+struct check;
+
+typedef void (*check_fn)(struct check *c, struct dt_info *dti, struct node *node);
+
+struct check {
+	const char *name;
+	check_fn fn;
+	void *data;
+	bool warn, error;
+	enum checkstatus status;
+	bool inprogress;
+	int num_prereqs;
+	struct check **prereq;
+};
+
+#define CHECK_ENTRY(nm_, fn_, d_, w_, e_, ...)	       \
+	static struct check *nm_##_prereqs[] = { __VA_ARGS__ }; \
+	static struct check nm_ = { \
+		.name = #nm_, \
+		.fn = (fn_), \
+		.data = (d_), \
+		.warn = (w_), \
+		.error = (e_), \
+		.status = UNCHECKED, \
+		.num_prereqs = ARRAY_SIZE(nm_##_prereqs), \
+		.prereq = nm_##_prereqs, \
+	};
+#define WARNING(nm_, fn_, d_, ...) \
+	CHECK_ENTRY(nm_, fn_, d_, true, false, __VA_ARGS__)
+#define ERROR(nm_, fn_, d_, ...) \
+	CHECK_ENTRY(nm_, fn_, d_, false, true, __VA_ARGS__)
+#define CHECK(nm_, fn_, d_, ...) \
+	CHECK_ENTRY(nm_, fn_, d_, false, false, __VA_ARGS__)
+
+static inline void  PRINTF(5, 6) check_msg(struct check *c, struct dt_info *dti,
+					   struct node *node,
+					   struct property *prop,
+					   const char *fmt, ...)
+{
+	va_list ap;
+	char *str = NULL;
+	struct srcpos *pos = NULL;
+	char *file_str;
+
+	if (!(c->warn && (quiet < 1)) && !(c->error && (quiet < 2)))
+		return;
+
+	if (prop && prop->srcpos)
+		pos = prop->srcpos;
+	else if (node && node->srcpos)
+		pos = node->srcpos;
+
+	if (pos) {
+		file_str = srcpos_string(pos);
+		xasprintf(&str, "%s", file_str);
+		free(file_str);
+	} else if (streq(dti->outname, "-")) {
+		xasprintf(&str, "<stdout>");
+	} else {
+		xasprintf(&str, "%s", dti->outname);
+	}
+
+	xasprintf_append(&str, ": %s (%s): ",
+			(c->error) ? "ERROR" : "Warning", c->name);
+
+	if (node) {
+		if (prop)
+			xasprintf_append(&str, "%s:%s: ", node->fullpath, prop->name);
+		else
+			xasprintf_append(&str, "%s: ", node->fullpath);
+	}
+
+	va_start(ap, fmt);
+	xavsprintf_append(&str, fmt, ap);
+	va_end(ap);
+
+	xasprintf_append(&str, "\n");
+
+	if (!prop && pos) {
+		pos = node->srcpos;
+		while (pos->next) {
+			pos = pos->next;
+
+			file_str = srcpos_string(pos);
+			xasprintf_append(&str, "  also defined at %s\n", file_str);
+			free(file_str);
+		}
+	}
+
+	fputs(str, stderr);
+}
+
+#define FAIL(c, dti, node, ...)						\
+	do {								\
+		TRACE((c), "\t\tFAILED at %s:%d", __FILE__, __LINE__);	\
+		(c)->status = FAILED;					\
+		check_msg((c), dti, node, NULL, __VA_ARGS__);		\
+	} while (0)
+
+#define FAIL_PROP(c, dti, node, prop, ...)				\
+	do {								\
+		TRACE((c), "\t\tFAILED at %s:%d", __FILE__, __LINE__);	\
+		(c)->status = FAILED;					\
+		check_msg((c), dti, node, prop, __VA_ARGS__);		\
+	} while (0)
+
+
+static void check_nodes_props(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct node *child;
+
+	TRACE(c, "%s", node->fullpath);
+	if (c->fn)
+		c->fn(c, dti, node);
+
+	for_each_child(node, child)
+		check_nodes_props(c, dti, child);
+}
+
+static bool is_multiple_of(int multiple, int divisor)
+{
+	if (divisor == 0)
+		return multiple == 0;
+	else
+		return (multiple % divisor) == 0;
+}
+
+static bool run_check(struct check *c, struct dt_info *dti)
+{
+	struct node *dt = dti->dt;
+	bool error = false;
+	int i;
+
+	assert(!c->inprogress);
+
+	if (c->status != UNCHECKED)
+		goto out;
+
+	c->inprogress = true;
+
+	for (i = 0; i < c->num_prereqs; i++) {
+		struct check *prq = c->prereq[i];
+		error = error || run_check(prq, dti);
+		if (prq->status != PASSED) {
+			c->status = PREREQ;
+			check_msg(c, dti, NULL, NULL, "Failed prerequisite '%s'",
+				  c->prereq[i]->name);
+		}
+	}
+
+	if (c->status != UNCHECKED)
+		goto out;
+
+	check_nodes_props(c, dti, dt);
+
+	if (c->status == UNCHECKED)
+		c->status = PASSED;
+
+	TRACE(c, "\tCompleted, status %d", c->status);
+
+out:
+	c->inprogress = false;
+	if ((c->status != PASSED) && (c->error))
+		error = true;
+	return error;
+}
+
+/*
+ * Utility check functions
+ */
+
+/* A check which always fails, for testing purposes only */
+static inline void check_always_fail(struct check *c, struct dt_info *dti,
+				     struct node *node)
+{
+	FAIL(c, dti, node, "always_fail check");
+}
+CHECK(always_fail, check_always_fail, NULL);
+
+static void check_is_string(struct check *c, struct dt_info *dti,
+			    struct node *node)
+{
+	struct property *prop;
+	char *propname = c->data;
+
+	prop = get_property(node, propname);
+	if (!prop)
+		return; /* Not present, assumed ok */
+
+	if (!data_is_one_string(prop->val))
+		FAIL_PROP(c, dti, node, prop, "property is not a string");
+}
+#define WARNING_IF_NOT_STRING(nm, propname) \
+	WARNING(nm, check_is_string, (propname))
+#define ERROR_IF_NOT_STRING(nm, propname) \
+	ERROR(nm, check_is_string, (propname))
+
+static void check_is_string_list(struct check *c, struct dt_info *dti,
+				 struct node *node)
+{
+	int rem, l;
+	struct property *prop;
+	char *propname = c->data;
+	char *str;
+
+	prop = get_property(node, propname);
+	if (!prop)
+		return; /* Not present, assumed ok */
+
+	str = prop->val.val;
+	rem = prop->val.len;
+	while (rem > 0) {
+		l = strnlen(str, rem);
+		if (l == rem) {
+			FAIL_PROP(c, dti, node, prop, "property is not a string list");
+			break;
+		}
+		rem -= l + 1;
+		str += l + 1;
+	}
+}
+#define WARNING_IF_NOT_STRING_LIST(nm, propname) \
+	WARNING(nm, check_is_string_list, (propname))
+#define ERROR_IF_NOT_STRING_LIST(nm, propname) \
+	ERROR(nm, check_is_string_list, (propname))
+
+static void check_is_cell(struct check *c, struct dt_info *dti,
+			  struct node *node)
+{
+	struct property *prop;
+	char *propname = c->data;
+
+	prop = get_property(node, propname);
+	if (!prop)
+		return; /* Not present, assumed ok */
+
+	if (prop->val.len != sizeof(cell_t))
+		FAIL_PROP(c, dti, node, prop, "property is not a single cell");
+}
+#define WARNING_IF_NOT_CELL(nm, propname) \
+	WARNING(nm, check_is_cell, (propname))
+#define ERROR_IF_NOT_CELL(nm, propname) \
+	ERROR(nm, check_is_cell, (propname))
+
+/*
+ * Structural check functions
+ */
+
+static void check_duplicate_node_names(struct check *c, struct dt_info *dti,
+				       struct node *node)
+{
+	struct node *child, *child2;
+
+	for_each_child(node, child)
+		for (child2 = child->next_sibling;
+		     child2;
+		     child2 = child2->next_sibling)
+			if (streq(child->name, child2->name))
+				FAIL(c, dti, child2, "Duplicate node name");
+}
+ERROR(duplicate_node_names, check_duplicate_node_names, NULL);
+
+static void check_duplicate_property_names(struct check *c, struct dt_info *dti,
+					   struct node *node)
+{
+	struct property *prop, *prop2;
+
+	for_each_property(node, prop) {
+		for (prop2 = prop->next; prop2; prop2 = prop2->next) {
+			if (prop2->deleted)
+				continue;
+			if (streq(prop->name, prop2->name))
+				FAIL_PROP(c, dti, node, prop, "Duplicate property name");
+		}
+	}
+}
+ERROR(duplicate_property_names, check_duplicate_property_names, NULL);
+
+#define LOWERCASE	"abcdefghijklmnopqrstuvwxyz"
+#define UPPERCASE	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+#define DIGITS		"0123456789"
+#define NODECHARS	LOWERCASE UPPERCASE DIGITS ",._+-@"
+#define PROPCHARS	LOWERCASE UPPERCASE DIGITS ",._+*#?-"
+#define PROPNODECHARSSTRICT	LOWERCASE UPPERCASE DIGITS ",-"
+
+static void check_node_name_chars(struct check *c, struct dt_info *dti,
+				  struct node *node)
+{
+	int n = strspn(node->name, c->data);
+
+	if (n < strlen(node->name))
+		FAIL(c, dti, node, "Bad character '%c' in node name",
+		     node->name[n]);
+}
+ERROR(node_name_chars, check_node_name_chars, NODECHARS);
+
+static void check_node_name_chars_strict(struct check *c, struct dt_info *dti,
+					 struct node *node)
+{
+	int n = strspn(node->name, c->data);
+
+	if (n < node->basenamelen)
+		FAIL(c, dti, node, "Character '%c' not recommended in node name",
+		     node->name[n]);
+}
+CHECK(node_name_chars_strict, check_node_name_chars_strict, PROPNODECHARSSTRICT);
+
+static void check_node_name_format(struct check *c, struct dt_info *dti,
+				   struct node *node)
+{
+	if (strchr(get_unitname(node), '@'))
+		FAIL(c, dti, node, "multiple '@' characters in node name");
+}
+ERROR(node_name_format, check_node_name_format, NULL, &node_name_chars);
+
+static void check_node_name_vs_property_name(struct check *c,
+					     struct dt_info *dti,
+					     struct node *node)
+{
+	if (!node->parent)
+		return;
+
+	if (get_property(node->parent, node->name)) {
+		FAIL(c, dti, node, "node name and property name conflict");
+	}
+}
+WARNING(node_name_vs_property_name, check_node_name_vs_property_name,
+	NULL, &node_name_chars);
+
+static void check_unit_address_vs_reg(struct check *c, struct dt_info *dti,
+				      struct node *node)
+{
+	const char *unitname = get_unitname(node);
+	struct property *prop = get_property(node, "reg");
+
+	if (get_subnode(node, "__overlay__")) {
+		/* HACK: Overlay fragments are a special case */
+		return;
+	}
+
+	if (!prop) {
+		prop = get_property(node, "ranges");
+		if (prop && !prop->val.len)
+			prop = NULL;
+	}
+
+	if (prop) {
+		if (!unitname[0])
+			FAIL(c, dti, node, "node has a reg or ranges property, but no unit name");
+	} else {
+		if (unitname[0])
+			FAIL(c, dti, node, "node has a unit name, but no reg or ranges property");
+	}
+}
+WARNING(unit_address_vs_reg, check_unit_address_vs_reg, NULL);
+
+static void check_property_name_chars(struct check *c, struct dt_info *dti,
+				      struct node *node)
+{
+	struct property *prop;
+
+	for_each_property(node, prop) {
+		int n = strspn(prop->name, c->data);
+
+		if (n < strlen(prop->name))
+			FAIL_PROP(c, dti, node, prop, "Bad character '%c' in property name",
+				  prop->name[n]);
+	}
+}
+ERROR(property_name_chars, check_property_name_chars, PROPCHARS);
+
+static void check_property_name_chars_strict(struct check *c,
+					     struct dt_info *dti,
+					     struct node *node)
+{
+	struct property *prop;
+
+	for_each_property(node, prop) {
+		const char *name = prop->name;
+		int n = strspn(name, c->data);
+
+		if (n == strlen(prop->name))
+			continue;
+
+		/* Certain names are whitelisted */
+		if (streq(name, "device_type"))
+			continue;
+
+		/*
+		 * # is only allowed at the beginning of property names not counting
+		 * the vendor prefix.
+		 */
+		if (name[n] == '#' && ((n == 0) || (name[n-1] == ','))) {
+			name += n + 1;
+			n = strspn(name, c->data);
+		}
+		if (n < strlen(name))
+			FAIL_PROP(c, dti, node, prop, "Character '%c' not recommended in property name",
+				  name[n]);
+	}
+}
+CHECK(property_name_chars_strict, check_property_name_chars_strict, PROPNODECHARSSTRICT);
+
+#define DESCLABEL_FMT	"%s%s%s%s%s"
+#define DESCLABEL_ARGS(node,prop,mark)		\
+	((mark) ? "value of " : ""),		\
+	((prop) ? "'" : ""), \
+	((prop) ? (prop)->name : ""), \
+	((prop) ? "' in " : ""), (node)->fullpath
+
+static void check_duplicate_label(struct check *c, struct dt_info *dti,
+				  const char *label, struct node *node,
+				  struct property *prop, struct marker *mark)
+{
+	struct node *dt = dti->dt;
+	struct node *othernode = NULL;
+	struct property *otherprop = NULL;
+	struct marker *othermark = NULL;
+
+	othernode = get_node_by_label(dt, label);
+
+	if (!othernode)
+		otherprop = get_property_by_label(dt, label, &othernode);
+	if (!othernode)
+		othermark = get_marker_label(dt, label, &othernode,
+					       &otherprop);
+
+	if (!othernode)
+		return;
+
+	if ((othernode != node) || (otherprop != prop) || (othermark != mark))
+		FAIL(c, dti, node, "Duplicate label '%s' on " DESCLABEL_FMT
+		     " and " DESCLABEL_FMT,
+		     label, DESCLABEL_ARGS(node, prop, mark),
+		     DESCLABEL_ARGS(othernode, otherprop, othermark));
+}
+
+static void check_duplicate_label_node(struct check *c, struct dt_info *dti,
+				       struct node *node)
+{
+	struct label *l;
+	struct property *prop;
+
+	for_each_label(node->labels, l)
+		check_duplicate_label(c, dti, l->label, node, NULL, NULL);
+
+	for_each_property(node, prop) {
+		struct marker *m = prop->val.markers;
+
+		for_each_label(prop->labels, l)
+			check_duplicate_label(c, dti, l->label, node, prop, NULL);
+
+		for_each_marker_of_type(m, LABEL)
+			check_duplicate_label(c, dti, m->ref, node, prop, m);
+	}
+}
+ERROR(duplicate_label, check_duplicate_label_node, NULL);
+
+static cell_t check_phandle_prop(struct check *c, struct dt_info *dti,
+				 struct node *node, const char *propname)
+{
+	struct node *root = dti->dt;
+	struct property *prop;
+	struct marker *m;
+	cell_t phandle;
+
+	prop = get_property(node, propname);
+	if (!prop)
+		return 0;
+
+	if (prop->val.len != sizeof(cell_t)) {
+		FAIL_PROP(c, dti, node, prop, "bad length (%d) %s property",
+			  prop->val.len, prop->name);
+		return 0;
+	}
+
+	m = prop->val.markers;
+	for_each_marker_of_type(m, REF_PHANDLE) {
+		assert(m->offset == 0);
+		if (node != get_node_by_ref(root, m->ref))
+			/* "Set this node's phandle equal to some
+			 * other node's phandle".  That's nonsensical
+			 * by construction. */ {
+			FAIL(c, dti, node, "%s is a reference to another node",
+			     prop->name);
+		}
+		/* But setting this node's phandle equal to its own
+		 * phandle is allowed - that means allocate a unique
+		 * phandle for this node, even if it's not otherwise
+		 * referenced.  The value will be filled in later, so
+		 * we treat it as having no phandle data for now. */
+		return 0;
+	}
+
+	phandle = propval_cell(prop);
+
+	if ((phandle == 0) || (phandle == -1)) {
+		FAIL_PROP(c, dti, node, prop, "bad value (0x%x) in %s property",
+		     phandle, prop->name);
+		return 0;
+	}
+
+	return phandle;
+}
+
+static void check_explicit_phandles(struct check *c, struct dt_info *dti,
+				    struct node *node)
+{
+	struct node *root = dti->dt;
+	struct node *other;
+	cell_t phandle, linux_phandle;
+
+	/* Nothing should have assigned phandles yet */
+	assert(!node->phandle);
+
+	phandle = check_phandle_prop(c, dti, node, "phandle");
+
+	linux_phandle = check_phandle_prop(c, dti, node, "linux,phandle");
+
+	if (!phandle && !linux_phandle)
+		/* No valid phandles; nothing further to check */
+		return;
+
+	if (linux_phandle && phandle && (phandle != linux_phandle))
+		FAIL(c, dti, node, "mismatching 'phandle' and 'linux,phandle'"
+		     " properties");
+
+	if (linux_phandle && !phandle)
+		phandle = linux_phandle;
+
+	other = get_node_by_phandle(root, phandle);
+	if (other && (other != node)) {
+		FAIL(c, dti, node, "duplicated phandle 0x%x (seen before at %s)",
+		     phandle, other->fullpath);
+		return;
+	}
+
+	node->phandle = phandle;
+}
+ERROR(explicit_phandles, check_explicit_phandles, NULL);
+
+static void check_name_properties(struct check *c, struct dt_info *dti,
+				  struct node *node)
+{
+	struct property **pp, *prop = NULL;
+
+	for (pp = &node->proplist; *pp; pp = &((*pp)->next))
+		if (streq((*pp)->name, "name")) {
+			prop = *pp;
+			break;
+		}
+
+	if (!prop)
+		return; /* No name property, that's fine */
+
+	if ((prop->val.len != node->basenamelen+1)
+	    || (memcmp(prop->val.val, node->name, node->basenamelen) != 0)) {
+		FAIL(c, dti, node, "\"name\" property is incorrect (\"%s\" instead"
+		     " of base node name)", prop->val.val);
+	} else {
+		/* The name property is correct, and therefore redundant.
+		 * Delete it */
+		*pp = prop->next;
+		free(prop->name);
+		data_free(prop->val);
+		free(prop);
+	}
+}
+ERROR_IF_NOT_STRING(name_is_string, "name");
+ERROR(name_properties, check_name_properties, NULL, &name_is_string);
+
+/*
+ * Reference fixup functions
+ */
+
+static void fixup_phandle_references(struct check *c, struct dt_info *dti,
+				     struct node *node)
+{
+	struct node *dt = dti->dt;
+	struct property *prop;
+
+	for_each_property(node, prop) {
+		struct marker *m = prop->val.markers;
+		struct node *refnode;
+		cell_t phandle;
+
+		for_each_marker_of_type(m, REF_PHANDLE) {
+			assert(m->offset + sizeof(cell_t) <= prop->val.len);
+
+			refnode = get_node_by_ref(dt, m->ref);
+			if (! refnode) {
+				if (!(dti->dtsflags & DTSF_PLUGIN))
+					FAIL(c, dti, node, "Reference to non-existent node or "
+							"label \"%s\"\n", m->ref);
+				else /* mark the entry as unresolved */
+					*((fdt32_t *)(prop->val.val + m->offset)) =
+						cpu_to_fdt32(0xffffffff);
+				continue;
+			}
+
+			phandle = get_node_phandle(dt, refnode);
+			*((fdt32_t *)(prop->val.val + m->offset)) = cpu_to_fdt32(phandle);
+
+			reference_node(refnode);
+		}
+	}
+}
+ERROR(phandle_references, fixup_phandle_references, NULL,
+      &duplicate_node_names, &explicit_phandles);
+
+static void fixup_path_references(struct check *c, struct dt_info *dti,
+				  struct node *node)
+{
+	struct node *dt = dti->dt;
+	struct property *prop;
+
+	for_each_property(node, prop) {
+		struct marker *m = prop->val.markers;
+		struct node *refnode;
+		char *path;
+
+		for_each_marker_of_type(m, REF_PATH) {
+			assert(m->offset <= prop->val.len);
+
+			refnode = get_node_by_ref(dt, m->ref);
+			if (!refnode) {
+				FAIL(c, dti, node, "Reference to non-existent node or label \"%s\"\n",
+				     m->ref);
+				continue;
+			}
+
+			path = refnode->fullpath;
+			prop->val = data_insert_at_marker(prop->val, m, path,
+							  strlen(path) + 1);
+
+			reference_node(refnode);
+		}
+	}
+}
+ERROR(path_references, fixup_path_references, NULL, &duplicate_node_names);
+
+static void fixup_omit_unused_nodes(struct check *c, struct dt_info *dti,
+				    struct node *node)
+{
+	if (generate_symbols && node->labels)
+		return;
+	if (node->omit_if_unused && !node->is_referenced)
+		delete_node(node);
+}
+ERROR(omit_unused_nodes, fixup_omit_unused_nodes, NULL, &phandle_references, &path_references);
+
+/*
+ * Semantic checks
+ */
+WARNING_IF_NOT_CELL(address_cells_is_cell, "#address-cells");
+WARNING_IF_NOT_CELL(size_cells_is_cell, "#size-cells");
+
+WARNING_IF_NOT_STRING(device_type_is_string, "device_type");
+WARNING_IF_NOT_STRING(model_is_string, "model");
+WARNING_IF_NOT_STRING(status_is_string, "status");
+WARNING_IF_NOT_STRING(label_is_string, "label");
+
+WARNING_IF_NOT_STRING_LIST(compatible_is_string_list, "compatible");
+
+static void check_names_is_string_list(struct check *c, struct dt_info *dti,
+				       struct node *node)
+{
+	struct property *prop;
+
+	for_each_property(node, prop) {
+		if (!strends(prop->name, "-names"))
+			continue;
+
+		c->data = prop->name;
+		check_is_string_list(c, dti, node);
+	}
+}
+WARNING(names_is_string_list, check_names_is_string_list, NULL);
+
+static void check_alias_paths(struct check *c, struct dt_info *dti,
+				    struct node *node)
+{
+	struct property *prop;
+
+	if (!streq(node->name, "aliases"))
+		return;
+
+	for_each_property(node, prop) {
+		if (streq(prop->name, "phandle")
+		    || streq(prop->name, "linux,phandle")) {
+			continue;
+		}
+
+		if (!prop->val.val || !get_node_by_path(dti->dt, prop->val.val)) {
+			FAIL_PROP(c, dti, node, prop, "aliases property is not a valid node (%s)",
+				  prop->val.val);
+			continue;
+		}
+		if (strspn(prop->name, LOWERCASE DIGITS "-") != strlen(prop->name))
+			FAIL(c, dti, node, "aliases property name must include only lowercase and '-'");
+	}
+}
+WARNING(alias_paths, check_alias_paths, NULL);
+
+static void fixup_addr_size_cells(struct check *c, struct dt_info *dti,
+				  struct node *node)
+{
+	struct property *prop;
+
+	node->addr_cells = -1;
+	node->size_cells = -1;
+
+	prop = get_property(node, "#address-cells");
+	if (prop)
+		node->addr_cells = propval_cell(prop);
+
+	prop = get_property(node, "#size-cells");
+	if (prop)
+		node->size_cells = propval_cell(prop);
+}
+WARNING(addr_size_cells, fixup_addr_size_cells, NULL,
+	&address_cells_is_cell, &size_cells_is_cell);
+
+#define node_addr_cells(n) \
+	(((n)->addr_cells == -1) ? 2 : (n)->addr_cells)
+#define node_size_cells(n) \
+	(((n)->size_cells == -1) ? 1 : (n)->size_cells)
+
+static void check_reg_format(struct check *c, struct dt_info *dti,
+			     struct node *node)
+{
+	struct property *prop;
+	int addr_cells, size_cells, entrylen;
+
+	prop = get_property(node, "reg");
+	if (!prop)
+		return; /* No "reg", that's fine */
+
+	if (!node->parent) {
+		FAIL(c, dti, node, "Root node has a \"reg\" property");
+		return;
+	}
+
+	if (prop->val.len == 0)
+		FAIL_PROP(c, dti, node, prop, "property is empty");
+
+	addr_cells = node_addr_cells(node->parent);
+	size_cells = node_size_cells(node->parent);
+	entrylen = (addr_cells + size_cells) * sizeof(cell_t);
+
+	if (!is_multiple_of(prop->val.len, entrylen))
+		FAIL_PROP(c, dti, node, prop, "property has invalid length (%d bytes) "
+			  "(#address-cells == %d, #size-cells == %d)",
+			  prop->val.len, addr_cells, size_cells);
+}
+WARNING(reg_format, check_reg_format, NULL, &addr_size_cells);
+
+static void check_ranges_format(struct check *c, struct dt_info *dti,
+				struct node *node)
+{
+	struct property *prop;
+	int c_addr_cells, p_addr_cells, c_size_cells, p_size_cells, entrylen;
+	const char *ranges = c->data;
+
+	prop = get_property(node, ranges);
+	if (!prop)
+		return;
+
+	if (!node->parent) {
+		FAIL_PROP(c, dti, node, prop, "Root node has a \"%s\" property",
+			  ranges);
+		return;
+	}
+
+	p_addr_cells = node_addr_cells(node->parent);
+	p_size_cells = node_size_cells(node->parent);
+	c_addr_cells = node_addr_cells(node);
+	c_size_cells = node_size_cells(node);
+	entrylen = (p_addr_cells + c_addr_cells + c_size_cells) * sizeof(cell_t);
+
+	if (prop->val.len == 0) {
+		if (p_addr_cells != c_addr_cells)
+			FAIL_PROP(c, dti, node, prop, "empty \"%s\" property but its "
+				  "#address-cells (%d) differs from %s (%d)",
+				  ranges, c_addr_cells, node->parent->fullpath,
+				  p_addr_cells);
+		if (p_size_cells != c_size_cells)
+			FAIL_PROP(c, dti, node, prop, "empty \"%s\" property but its "
+				  "#size-cells (%d) differs from %s (%d)",
+				  ranges, c_size_cells, node->parent->fullpath,
+				  p_size_cells);
+	} else if (!is_multiple_of(prop->val.len, entrylen)) {
+		FAIL_PROP(c, dti, node, prop, "\"%s\" property has invalid length (%d bytes) "
+			  "(parent #address-cells == %d, child #address-cells == %d, "
+			  "#size-cells == %d)", ranges, prop->val.len,
+			  p_addr_cells, c_addr_cells, c_size_cells);
+	}
+}
+WARNING(ranges_format, check_ranges_format, "ranges", &addr_size_cells);
+WARNING(dma_ranges_format, check_ranges_format, "dma-ranges", &addr_size_cells);
+
+static const struct bus_type pci_bus = {
+	.name = "PCI",
+};
+
+static void check_pci_bridge(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct property *prop;
+	cell_t *cells;
+
+	prop = get_property(node, "device_type");
+	if (!prop || !streq(prop->val.val, "pci"))
+		return;
+
+	node->bus = &pci_bus;
+
+	if (!strprefixeq(node->name, node->basenamelen, "pci") &&
+	    !strprefixeq(node->name, node->basenamelen, "pcie"))
+		FAIL(c, dti, node, "node name is not \"pci\" or \"pcie\"");
+
+	prop = get_property(node, "ranges");
+	if (!prop)
+		FAIL(c, dti, node, "missing ranges for PCI bridge (or not a bridge)");
+
+	if (node_addr_cells(node) != 3)
+		FAIL(c, dti, node, "incorrect #address-cells for PCI bridge");
+	if (node_size_cells(node) != 2)
+		FAIL(c, dti, node, "incorrect #size-cells for PCI bridge");
+
+	prop = get_property(node, "bus-range");
+	if (!prop)
+		return;
+
+	if (prop->val.len != (sizeof(cell_t) * 2)) {
+		FAIL_PROP(c, dti, node, prop, "value must be 2 cells");
+		return;
+	}
+	cells = (cell_t *)prop->val.val;
+	if (fdt32_to_cpu(cells[0]) > fdt32_to_cpu(cells[1]))
+		FAIL_PROP(c, dti, node, prop, "1st cell must be less than or equal to 2nd cell");
+	if (fdt32_to_cpu(cells[1]) > 0xff)
+		FAIL_PROP(c, dti, node, prop, "maximum bus number must be less than 256");
+}
+WARNING(pci_bridge, check_pci_bridge, NULL,
+	&device_type_is_string, &addr_size_cells);
+
+static void check_pci_device_bus_num(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct property *prop;
+	unsigned int bus_num, min_bus, max_bus;
+	cell_t *cells;
+
+	if (!node->parent || (node->parent->bus != &pci_bus))
+		return;
+
+	prop = get_property(node, "reg");
+	if (!prop)
+		return;
+
+	cells = (cell_t *)prop->val.val;
+	bus_num = (fdt32_to_cpu(cells[0]) & 0x00ff0000) >> 16;
+
+	prop = get_property(node->parent, "bus-range");
+	if (!prop) {
+		min_bus = max_bus = 0;
+	} else {
+		cells = (cell_t *)prop->val.val;
+		min_bus = fdt32_to_cpu(cells[0]);
+		max_bus = fdt32_to_cpu(cells[0]);
+	}
+	if ((bus_num < min_bus) || (bus_num > max_bus))
+		FAIL_PROP(c, dti, node, prop, "PCI bus number %d out of range, expected (%d - %d)",
+			  bus_num, min_bus, max_bus);
+}
+WARNING(pci_device_bus_num, check_pci_device_bus_num, NULL, &reg_format, &pci_bridge);
+
+static void check_pci_device_reg(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct property *prop;
+	const char *unitname = get_unitname(node);
+	char unit_addr[5];
+	unsigned int dev, func, reg;
+	cell_t *cells;
+
+	if (!node->parent || (node->parent->bus != &pci_bus))
+		return;
+
+	prop = get_property(node, "reg");
+	if (!prop)
+		return;
+
+	cells = (cell_t *)prop->val.val;
+	if (cells[1] || cells[2])
+		FAIL_PROP(c, dti, node, prop, "PCI reg config space address cells 2 and 3 must be 0");
+
+	reg = fdt32_to_cpu(cells[0]);
+	dev = (reg & 0xf800) >> 11;
+	func = (reg & 0x700) >> 8;
+
+	if (reg & 0xff000000)
+		FAIL_PROP(c, dti, node, prop, "PCI reg address is not configuration space");
+	if (reg & 0x000000ff)
+		FAIL_PROP(c, dti, node, prop, "PCI reg config space address register number must be 0");
+
+	if (func == 0) {
+		snprintf(unit_addr, sizeof(unit_addr), "%x", dev);
+		if (streq(unitname, unit_addr))
+			return;
+	}
+
+	snprintf(unit_addr, sizeof(unit_addr), "%x,%x", dev, func);
+	if (streq(unitname, unit_addr))
+		return;
+
+	FAIL(c, dti, node, "PCI unit address format error, expected \"%s\"",
+	     unit_addr);
+}
+WARNING(pci_device_reg, check_pci_device_reg, NULL, &reg_format, &pci_bridge);
+
+static const struct bus_type simple_bus = {
+	.name = "simple-bus",
+};
+
+static bool node_is_compatible(struct node *node, const char *compat)
+{
+	struct property *prop;
+	const char *str, *end;
+
+	prop = get_property(node, "compatible");
+	if (!prop)
+		return false;
+
+	for (str = prop->val.val, end = str + prop->val.len; str < end;
+	     str += strnlen(str, end - str) + 1) {
+		if (streq(str, compat))
+			return true;
+	}
+	return false;
+}
+
+static void check_simple_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)
+{
+	if (node_is_compatible(node, "simple-bus"))
+		node->bus = &simple_bus;
+}
+WARNING(simple_bus_bridge, check_simple_bus_bridge, NULL,
+	&addr_size_cells, &compatible_is_string_list);
+
+static void check_simple_bus_reg(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct property *prop;
+	const char *unitname = get_unitname(node);
+	char unit_addr[17];
+	unsigned int size;
+	uint64_t reg = 0;
+	cell_t *cells = NULL;
+
+	if (!node->parent || (node->parent->bus != &simple_bus))
+		return;
+
+	prop = get_property(node, "reg");
+	if (prop)
+		cells = (cell_t *)prop->val.val;
+	else {
+		prop = get_property(node, "ranges");
+		if (prop && prop->val.len)
+			/* skip of child address */
+			cells = ((cell_t *)prop->val.val) + node_addr_cells(node);
+	}
+
+	if (!cells) {
+		if (node->parent->parent && !(node->bus == &simple_bus))
+			FAIL(c, dti, node, "missing or empty reg/ranges property");
+		return;
+	}
+
+	size = node_addr_cells(node->parent);
+	while (size--)
+		reg = (reg << 32) | fdt32_to_cpu(*(cells++));
+
+	snprintf(unit_addr, sizeof(unit_addr), "%"PRIx64, reg);
+	if (!streq(unitname, unit_addr))
+		FAIL(c, dti, node, "simple-bus unit address format error, expected \"%s\"",
+		     unit_addr);
+}
+WARNING(simple_bus_reg, check_simple_bus_reg, NULL, &reg_format, &simple_bus_bridge);
+
+static const struct bus_type i2c_bus = {
+	.name = "i2c-bus",
+};
+
+static void check_i2c_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)
+{
+	if (strprefixeq(node->name, node->basenamelen, "i2c-bus") ||
+	    strprefixeq(node->name, node->basenamelen, "i2c-arb")) {
+		node->bus = &i2c_bus;
+	} else if (strprefixeq(node->name, node->basenamelen, "i2c")) {
+		struct node *child;
+		for_each_child(node, child) {
+			if (strprefixeq(child->name, node->basenamelen, "i2c-bus"))
+				return;
+		}
+		node->bus = &i2c_bus;
+	} else
+		return;
+
+	if (!node->children)
+		return;
+
+	if (node_addr_cells(node) != 1)
+		FAIL(c, dti, node, "incorrect #address-cells for I2C bus");
+	if (node_size_cells(node) != 0)
+		FAIL(c, dti, node, "incorrect #size-cells for I2C bus");
+
+}
+WARNING(i2c_bus_bridge, check_i2c_bus_bridge, NULL, &addr_size_cells);
+
+#define I2C_OWN_SLAVE_ADDRESS	(1U << 30)
+#define I2C_TEN_BIT_ADDRESS	(1U << 31)
+
+static void check_i2c_bus_reg(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct property *prop;
+	const char *unitname = get_unitname(node);
+	char unit_addr[17];
+	uint32_t reg = 0;
+	int len;
+	cell_t *cells = NULL;
+
+	if (!node->parent || (node->parent->bus != &i2c_bus))
+		return;
+
+	prop = get_property(node, "reg");
+	if (prop)
+		cells = (cell_t *)prop->val.val;
+
+	if (!cells) {
+		FAIL(c, dti, node, "missing or empty reg property");
+		return;
+	}
+
+	reg = fdt32_to_cpu(*cells);
+	/* Ignore I2C_OWN_SLAVE_ADDRESS */
+	reg &= ~I2C_OWN_SLAVE_ADDRESS;
+	snprintf(unit_addr, sizeof(unit_addr), "%x", reg);
+	if (!streq(unitname, unit_addr))
+		FAIL(c, dti, node, "I2C bus unit address format error, expected \"%s\"",
+		     unit_addr);
+
+	for (len = prop->val.len; len > 0; len -= 4) {
+		reg = fdt32_to_cpu(*(cells++));
+		/* Ignore I2C_OWN_SLAVE_ADDRESS */
+		reg &= ~I2C_OWN_SLAVE_ADDRESS;
+
+		if ((reg & I2C_TEN_BIT_ADDRESS) && ((reg & ~I2C_TEN_BIT_ADDRESS) > 0x3ff))
+			FAIL_PROP(c, dti, node, prop, "I2C address must be less than 10-bits, got \"0x%x\"",
+				  reg);
+		else if (reg > 0x7f)
+			FAIL_PROP(c, dti, node, prop, "I2C address must be less than 7-bits, got \"0x%x\". Set I2C_TEN_BIT_ADDRESS for 10 bit addresses or fix the property",
+				  reg);
+	}
+}
+WARNING(i2c_bus_reg, check_i2c_bus_reg, NULL, &reg_format, &i2c_bus_bridge);
+
+static const struct bus_type spi_bus = {
+	.name = "spi-bus",
+};
+
+static void check_spi_bus_bridge(struct check *c, struct dt_info *dti, struct node *node)
+{
+	int spi_addr_cells = 1;
+
+	if (strprefixeq(node->name, node->basenamelen, "spi")) {
+		node->bus = &spi_bus;
+	} else {
+		/* Try to detect SPI buses which don't have proper node name */
+		struct node *child;
+
+		if (node_addr_cells(node) != 1 || node_size_cells(node) != 0)
+			return;
+
+		for_each_child(node, child) {
+			struct property *prop;
+			for_each_property(child, prop) {
+				if (strprefixeq(prop->name, 4, "spi-")) {
+					node->bus = &spi_bus;
+					break;
+				}
+			}
+			if (node->bus == &spi_bus)
+				break;
+		}
+
+		if (node->bus == &spi_bus && get_property(node, "reg"))
+			FAIL(c, dti, node, "node name for SPI buses should be 'spi'");
+	}
+	if (node->bus != &spi_bus || !node->children)
+		return;
+
+	if (get_property(node, "spi-slave"))
+		spi_addr_cells = 0;
+	if (node_addr_cells(node) != spi_addr_cells)
+		FAIL(c, dti, node, "incorrect #address-cells for SPI bus");
+	if (node_size_cells(node) != 0)
+		FAIL(c, dti, node, "incorrect #size-cells for SPI bus");
+
+}
+WARNING(spi_bus_bridge, check_spi_bus_bridge, NULL, &addr_size_cells);
+
+static void check_spi_bus_reg(struct check *c, struct dt_info *dti, struct node *node)
+{
+	struct property *prop;
+	const char *unitname = get_unitname(node);
+	char unit_addr[9];
+	uint32_t reg = 0;
+	cell_t *cells = NULL;
+
+	if (!node->parent || (node->parent->bus != &spi_bus))
+		return;
+
+	if (get_property(node->parent, "spi-slave"))
+		return;
+
+	prop = get_property(node, "reg");
+	if (prop)
+		cells = (cell_t *)prop->val.val;
+
+	if (!cells) {
+		FAIL(c, dti, node, "missing or empty reg property");
+		return;
+	}
+
+	reg = fdt32_to_cpu(*cells);
+	snprintf(unit_addr, sizeof(unit_addr), "%x", reg);
+	if (!streq(unitname, unit_addr))
+		FAIL(c, dti, node, "SPI bus unit address format error, expected \"%s\"",
+		     unit_addr);
+}
+WARNING(spi_bus_reg, check_spi_bus_reg, NULL, &reg_format, &spi_bus_bridge);
+
+static void check_unit_address_format(struct check *c, struct dt_info *dti,
+				      struct node *node)
+{
+	const char *unitname = get_unitname(node);
+
+	if (node->parent && node->parent->bus)
+		return;
+
+	if (!unitname[0])
+		return;
+
+	if (!strncmp(unitname, "0x", 2)) {
+		FAIL(c, dti, node, "unit name should not have leading \"0x\"");
+		/* skip over 0x for next test */
+		unitname += 2;
+	}
+	if (unitname[0] == '0' && isxdigit(unitname[1]))
+		FAIL(c, dti, node, "unit name should not have leading 0s");
+}
+WARNING(unit_address_format, check_unit_address_format, NULL,
+	&node_name_format, &pci_bridge, &simple_bus_bridge);
+
+/*
+ * Style checks
+ */
+static void check_avoid_default_addr_size(struct check *c, struct dt_info *dti,
+					  struct node *node)
+{
+	struct property *reg, *ranges;
+
+	if (!node->parent)
+		return; /* Ignore root node */
+
+	reg = get_property(node, "reg");
+	ranges = get_property(node, "ranges");
+
+	if (!reg && !ranges)
+		return;
+
+	if (node->parent->addr_cells == -1)
+		FAIL(c, dti, node, "Relying on default #address-cells value");
+
+	if (node->parent->size_cells == -1)
+		FAIL(c, dti, node, "Relying on default #size-cells value");
+}
+WARNING(avoid_default_addr_size, check_avoid_default_addr_size, NULL,
+	&addr_size_cells);
+
+static void check_avoid_unnecessary_addr_size(struct check *c, struct dt_info *dti,
+					      struct node *node)
+{
+	struct property *prop;
+	struct node *child;
+	bool has_reg = false;
+
+	if (!node->parent || node->addr_cells < 0 || node->size_cells < 0)
+		return;
+
+	if (get_property(node, "ranges") || !node->children)
+		return;
+
+	for_each_child(node, child) {
+		prop = get_property(child, "reg");
+		if (prop)
+			has_reg = true;
+	}
+
+	if (!has_reg)
+		FAIL(c, dti, node, "unnecessary #address-cells/#size-cells without \"ranges\" or child \"reg\" property");
+}
+WARNING(avoid_unnecessary_addr_size, check_avoid_unnecessary_addr_size, NULL, &avoid_default_addr_size);
+
+static bool node_is_disabled(struct node *node)
+{
+	struct property *prop;
+
+	prop = get_property(node, "status");
+	if (prop) {
+		char *str = prop->val.val;
+		if (streq("disabled", str))
+			return true;
+	}
+
+	return false;
+}
+
+static void check_unique_unit_address_common(struct check *c,
+						struct dt_info *dti,
+						struct node *node,
+						bool disable_check)
+{
+	struct node *childa;
+
+	if (node->addr_cells < 0 || node->size_cells < 0)
+		return;
+
+	if (!node->children)
+		return;
+
+	for_each_child(node, childa) {
+		struct node *childb;
+		const char *addr_a = get_unitname(childa);
+
+		if (!strlen(addr_a))
+			continue;
+
+		if (disable_check && node_is_disabled(childa))
+			continue;
+
+		for_each_child(node, childb) {
+			const char *addr_b = get_unitname(childb);
+			if (childa == childb)
+				break;
+
+			if (disable_check && node_is_disabled(childb))
+				continue;
+
+			if (streq(addr_a, addr_b))
+				FAIL(c, dti, childb, "duplicate unit-address (also used in node %s)", childa->fullpath);
+		}
+	}
+}
+
+static void check_unique_unit_address(struct check *c, struct dt_info *dti,
+					      struct node *node)
+{
+	check_unique_unit_address_common(c, dti, node, false);
+}
+WARNING(unique_unit_address, check_unique_unit_address, NULL, &avoid_default_addr_size);
+
+static void check_unique_unit_address_if_enabled(struct check *c, struct dt_info *dti,
+					      struct node *node)
+{
+	check_unique_unit_address_common(c, dti, node, true);
+}
+CHECK_ENTRY(unique_unit_address_if_enabled, check_unique_unit_address_if_enabled,
+	    NULL, false, false, &avoid_default_addr_size);
+
+static void check_obsolete_chosen_interrupt_controller(struct check *c,
+						       struct dt_info *dti,
+						       struct node *node)
+{
+	struct node *dt = dti->dt;
+	struct node *chosen;
+	struct property *prop;
+
+	if (node != dt)
+		return;
+
+
+	chosen = get_node_by_path(dt, "/chosen");
+	if (!chosen)
+		return;
+
+	prop = get_property(chosen, "interrupt-controller");
+	if (prop)
+		FAIL_PROP(c, dti, node, prop,
+			  "/chosen has obsolete \"interrupt-controller\" property");
+}
+WARNING(obsolete_chosen_interrupt_controller,
+	check_obsolete_chosen_interrupt_controller, NULL);
+
+static void check_chosen_node_is_root(struct check *c, struct dt_info *dti,
+				      struct node *node)
+{
+	if (!streq(node->name, "chosen"))
+		return;
+
+	if (node->parent != dti->dt)
+		FAIL(c, dti, node, "chosen node must be at root node");
+}
+WARNING(chosen_node_is_root, check_chosen_node_is_root, NULL);
+
+static void check_chosen_node_bootargs(struct check *c, struct dt_info *dti,
+				       struct node *node)
+{
+	struct property *prop;
+
+	if (!streq(node->name, "chosen"))
+		return;
+
+	prop = get_property(node, "bootargs");
+	if (!prop)
+		return;
+
+	c->data = prop->name;
+	check_is_string(c, dti, node);
+}
+WARNING(chosen_node_bootargs, check_chosen_node_bootargs, NULL);
+
+static void check_chosen_node_stdout_path(struct check *c, struct dt_info *dti,
+					  struct node *node)
+{
+	struct property *prop;
+
+	if (!streq(node->name, "chosen"))
+		return;
+
+	prop = get_property(node, "stdout-path");
+	if (!prop) {
+		prop = get_property(node, "linux,stdout-path");
+		if (!prop)
+			return;
+		FAIL_PROP(c, dti, node, prop, "Use 'stdout-path' instead");
+	}
+
+	c->data = prop->name;
+	check_is_string(c, dti, node);
+}
+WARNING(chosen_node_stdout_path, check_chosen_node_stdout_path, NULL);
+
+struct provider {
+	const char *prop_name;
+	const char *cell_name;
+	bool optional;
+};
+
+static void check_property_phandle_args(struct check *c,
+					  struct dt_info *dti,
+				          struct node *node,
+				          struct property *prop,
+				          const struct provider *provider)
+{
+	struct node *root = dti->dt;
+	int cell, cellsize = 0;
+
+	if (!is_multiple_of(prop->val.len, sizeof(cell_t))) {
+		FAIL_PROP(c, dti, node, prop,
+			  "property size (%d) is invalid, expected multiple of %zu",
+			  prop->val.len, sizeof(cell_t));
+		return;
+	}
+
+	for (cell = 0; cell < prop->val.len / sizeof(cell_t); cell += cellsize + 1) {
+		struct node *provider_node;
+		struct property *cellprop;
+		int phandle;
+
+		phandle = propval_cell_n(prop, cell);
+		/*
+		 * Some bindings use a cell value 0 or -1 to skip over optional
+		 * entries when each index position has a specific definition.
+		 */
+		if (phandle == 0 || phandle == -1) {
+			/* Give up if this is an overlay with external references */
+			if (dti->dtsflags & DTSF_PLUGIN)
+				break;
+
+			cellsize = 0;
+			continue;
+		}
+
+		/* If we have markers, verify the current cell is a phandle */
+		if (prop->val.markers) {
+			struct marker *m = prop->val.markers;
+			for_each_marker_of_type(m, REF_PHANDLE) {
+				if (m->offset == (cell * sizeof(cell_t)))
+					break;
+			}
+			if (!m)
+				FAIL_PROP(c, dti, node, prop,
+					  "cell %d is not a phandle reference",
+					  cell);
+		}
+
+		provider_node = get_node_by_phandle(root, phandle);
+		if (!provider_node) {
+			FAIL_PROP(c, dti, node, prop,
+				  "Could not get phandle node for (cell %d)",
+				  cell);
+			break;
+		}
+
+		cellprop = get_property(provider_node, provider->cell_name);
+		if (cellprop) {
+			cellsize = propval_cell(cellprop);
+		} else if (provider->optional) {
+			cellsize = 0;
+		} else {
+			FAIL(c, dti, node, "Missing property '%s' in node %s or bad phandle (referred from %s[%d])",
+			     provider->cell_name,
+			     provider_node->fullpath,
+			     prop->name, cell);
+			break;
+		}
+
+		if (prop->val.len < ((cell + cellsize + 1) * sizeof(cell_t))) {
+			FAIL_PROP(c, dti, node, prop,
+				  "property size (%d) too small for cell size %d",
+				  prop->val.len, cellsize);
+		}
+	}
+}
+
+static void check_provider_cells_property(struct check *c,
+					  struct dt_info *dti,
+				          struct node *node)
+{
+	struct provider *provider = c->data;
+	struct property *prop;
+
+	prop = get_property(node, provider->prop_name);
+	if (!prop)
+		return;
+
+	check_property_phandle_args(c, dti, node, prop, provider);
+}
+#define WARNING_PROPERTY_PHANDLE_CELLS(nm, propname, cells_name, ...) \
+	static struct provider nm##_provider = { (propname), (cells_name), __VA_ARGS__ }; \
+	WARNING_IF_NOT_CELL(nm##_is_cell, cells_name); \
+	WARNING(nm##_property, check_provider_cells_property, &nm##_provider, &nm##_is_cell, &phandle_references);
+
+WARNING_PROPERTY_PHANDLE_CELLS(clocks, "clocks", "#clock-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(cooling_device, "cooling-device", "#cooling-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(dmas, "dmas", "#dma-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(hwlocks, "hwlocks", "#hwlock-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(interrupts_extended, "interrupts-extended", "#interrupt-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(io_channels, "io-channels", "#io-channel-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(iommus, "iommus", "#iommu-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(mboxes, "mboxes", "#mbox-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(msi_parent, "msi-parent", "#msi-cells", true);
+WARNING_PROPERTY_PHANDLE_CELLS(mux_controls, "mux-controls", "#mux-control-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(phys, "phys", "#phy-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(power_domains, "power-domains", "#power-domain-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(pwms, "pwms", "#pwm-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(resets, "resets", "#reset-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(sound_dai, "sound-dai", "#sound-dai-cells");
+WARNING_PROPERTY_PHANDLE_CELLS(thermal_sensors, "thermal-sensors", "#thermal-sensor-cells");
+
+static bool prop_is_gpio(struct property *prop)
+{
+	/*
+	 * *-gpios and *-gpio can appear in property names,
+	 * so skip over any false matches (only one known ATM)
+	 */
+	if (strends(prop->name, ",nr-gpios"))
+		return false;
+
+	return strends(prop->name, "-gpios") ||
+		streq(prop->name, "gpios") ||
+		strends(prop->name, "-gpio") ||
+		streq(prop->name, "gpio");
+}
+
+static void check_gpios_property(struct check *c,
+					  struct dt_info *dti,
+				          struct node *node)
+{
+	struct property *prop;
+
+	/* Skip GPIO hog nodes which have 'gpios' property */
+	if (get_property(node, "gpio-hog"))
+		return;
+
+	for_each_property(node, prop) {
+		struct provider provider;
+
+		if (!prop_is_gpio(prop))
+			continue;
+
+		provider.prop_name = prop->name;
+		provider.cell_name = "#gpio-cells";
+		provider.optional = false;
+		check_property_phandle_args(c, dti, node, prop, &provider);
+	}
+
+}
+WARNING(gpios_property, check_gpios_property, NULL, &phandle_references);
+
+static void check_deprecated_gpio_property(struct check *c,
+					   struct dt_info *dti,
+				           struct node *node)
+{
+	struct property *prop;
+
+	for_each_property(node, prop) {
+		if (!prop_is_gpio(prop))
+			continue;
+
+		if (!strends(prop->name, "gpio"))
+			continue;
+
+		FAIL_PROP(c, dti, node, prop,
+			  "'[*-]gpio' is deprecated, use '[*-]gpios' instead");
+	}
+
+}
+CHECK(deprecated_gpio_property, check_deprecated_gpio_property, NULL);
+
+static bool node_is_interrupt_provider(struct node *node)
+{
+	struct property *prop;
+
+	prop = get_property(node, "interrupt-controller");
+	if (prop)
+		return true;
+
+	prop = get_property(node, "interrupt-map");
+	if (prop)
+		return true;
+
+	return false;
+}
+
+static void check_interrupt_provider(struct check *c,
+				     struct dt_info *dti,
+				     struct node *node)
+{
+	struct property *prop;
+
+	if (!node_is_interrupt_provider(node))
+		return;
+
+	prop = get_property(node, "#interrupt-cells");
+	if (!prop)
+		FAIL(c, dti, node,
+		     "Missing #interrupt-cells in interrupt provider");
+
+	prop = get_property(node, "#address-cells");
+	if (!prop)
+		FAIL(c, dti, node,
+		     "Missing #address-cells in interrupt provider");
+}
+WARNING(interrupt_provider, check_interrupt_provider, NULL);
+
+static void check_interrupts_property(struct check *c,
+				      struct dt_info *dti,
+				      struct node *node)
+{
+	struct node *root = dti->dt;
+	struct node *irq_node = NULL, *parent = node;
+	struct property *irq_prop, *prop = NULL;
+	int irq_cells, phandle;
+
+	irq_prop = get_property(node, "interrupts");
+	if (!irq_prop)
+		return;
+
+	if (!is_multiple_of(irq_prop->val.len, sizeof(cell_t)))
+		FAIL_PROP(c, dti, node, irq_prop, "size (%d) is invalid, expected multiple of %zu",
+		     irq_prop->val.len, sizeof(cell_t));
+
+	while (parent && !prop) {
+		if (parent != node && node_is_interrupt_provider(parent)) {
+			irq_node = parent;
+			break;
+		}
+
+		prop = get_property(parent, "interrupt-parent");
+		if (prop) {
+			phandle = propval_cell(prop);
+			if ((phandle == 0) || (phandle == -1)) {
+				/* Give up if this is an overlay with
+				 * external references */
+				if (dti->dtsflags & DTSF_PLUGIN)
+					return;
+				FAIL_PROP(c, dti, parent, prop, "Invalid phandle");
+				continue;
+			}
+
+			irq_node = get_node_by_phandle(root, phandle);
+			if (!irq_node) {
+				FAIL_PROP(c, dti, parent, prop, "Bad phandle");
+				return;
+			}
+			if (!node_is_interrupt_provider(irq_node))
+				FAIL(c, dti, irq_node,
+				     "Missing interrupt-controller or interrupt-map property");
+
+			break;
+		}
+
+		parent = parent->parent;
+	}
+
+	if (!irq_node) {
+		FAIL(c, dti, node, "Missing interrupt-parent");
+		return;
+	}
+
+	prop = get_property(irq_node, "#interrupt-cells");
+	if (!prop) {
+		/* We warn about that already in another test. */
+		return;
+	}
+
+	irq_cells = propval_cell(prop);
+	if (!is_multiple_of(irq_prop->val.len, irq_cells * sizeof(cell_t))) {
+		FAIL_PROP(c, dti, node, prop,
+			  "size is (%d), expected multiple of %d",
+			  irq_prop->val.len, (int)(irq_cells * sizeof(cell_t)));
+	}
+}
+WARNING(interrupts_property, check_interrupts_property, &phandle_references);
+
+static const struct bus_type graph_port_bus = {
+	.name = "graph-port",
+};
+
+static const struct bus_type graph_ports_bus = {
+	.name = "graph-ports",
+};
+
+static void check_graph_nodes(struct check *c, struct dt_info *dti,
+			      struct node *node)
+{
+	struct node *child;
+
+	for_each_child(node, child) {
+		if (!(strprefixeq(child->name, child->basenamelen, "endpoint") ||
+		      get_property(child, "remote-endpoint")))
+			continue;
+
+		node->bus = &graph_port_bus;
+
+		/* The parent of 'port' nodes can be either 'ports' or a device */
+		if (!node->parent->bus &&
+		    (streq(node->parent->name, "ports") || get_property(node, "reg")))
+			node->parent->bus = &graph_ports_bus;
+
+		break;
+	}
+
+}
+WARNING(graph_nodes, check_graph_nodes, NULL);
+
+static void check_graph_child_address(struct check *c, struct dt_info *dti,
+				      struct node *node)
+{
+	int cnt = 0;
+	struct node *child;
+
+	if (node->bus != &graph_ports_bus && node->bus != &graph_port_bus)
+		return;
+
+	for_each_child(node, child) {
+		struct property *prop = get_property(child, "reg");
+
+		/* No error if we have any non-zero unit address */
+		if (prop && propval_cell(prop) != 0)
+			return;
+
+		cnt++;
+	}
+
+	if (cnt == 1 && node->addr_cells != -1)
+		FAIL(c, dti, node, "graph node has single child node '%s', #address-cells/#size-cells are not necessary",
+		     node->children->name);
+}
+WARNING(graph_child_address, check_graph_child_address, NULL, &graph_nodes);
+
+static void check_graph_reg(struct check *c, struct dt_info *dti,
+			    struct node *node)
+{
+	char unit_addr[9];
+	const char *unitname = get_unitname(node);
+	struct property *prop;
+
+	prop = get_property(node, "reg");
+	if (!prop || !unitname)
+		return;
+
+	if (!(prop->val.val && prop->val.len == sizeof(cell_t))) {
+		FAIL(c, dti, node, "graph node malformed 'reg' property");
+		return;
+	}
+
+	snprintf(unit_addr, sizeof(unit_addr), "%x", propval_cell(prop));
+	if (!streq(unitname, unit_addr))
+		FAIL(c, dti, node, "graph node unit address error, expected \"%s\"",
+		     unit_addr);
+
+	if (node->parent->addr_cells != 1)
+		FAIL_PROP(c, dti, node, get_property(node, "#address-cells"),
+			  "graph node '#address-cells' is %d, must be 1",
+			  node->parent->addr_cells);
+	if (node->parent->size_cells != 0)
+		FAIL_PROP(c, dti, node, get_property(node, "#size-cells"),
+			  "graph node '#size-cells' is %d, must be 0",
+			  node->parent->size_cells);
+}
+
+static void check_graph_port(struct check *c, struct dt_info *dti,
+			     struct node *node)
+{
+	if (node->bus != &graph_port_bus)
+		return;
+
+	if (!strprefixeq(node->name, node->basenamelen, "port"))
+		FAIL(c, dti, node, "graph port node name should be 'port'");
+
+	check_graph_reg(c, dti, node);
+}
+WARNING(graph_port, check_graph_port, NULL, &graph_nodes);
+
+static struct node *get_remote_endpoint(struct check *c, struct dt_info *dti,
+					struct node *endpoint)
+{
+	int phandle;
+	struct node *node;
+	struct property *prop;
+
+	prop = get_property(endpoint, "remote-endpoint");
+	if (!prop)
+		return NULL;
+
+	phandle = propval_cell(prop);
+	/* Give up if this is an overlay with external references */
+	if (phandle == 0 || phandle == -1)
+		return NULL;
+
+	node = get_node_by_phandle(dti->dt, phandle);
+	if (!node)
+		FAIL_PROP(c, dti, endpoint, prop, "graph phandle is not valid");
+
+	return node;
+}
+
+static void check_graph_endpoint(struct check *c, struct dt_info *dti,
+				 struct node *node)
+{
+	struct node *remote_node;
+
+	if (!node->parent || node->parent->bus != &graph_port_bus)
+		return;
+
+	if (!strprefixeq(node->name, node->basenamelen, "endpoint"))
+		FAIL(c, dti, node, "graph endpoint node name should be 'endpoint'");
+
+	check_graph_reg(c, dti, node);
+
+	remote_node = get_remote_endpoint(c, dti, node);
+	if (!remote_node)
+		return;
+
+	if (get_remote_endpoint(c, dti, remote_node) != node)
+		FAIL(c, dti, node, "graph connection to node '%s' is not bidirectional",
+		     remote_node->fullpath);
+}
+WARNING(graph_endpoint, check_graph_endpoint, NULL, &graph_nodes);
+
+static struct check *check_table[] = {
+	&duplicate_node_names, &duplicate_property_names,
+	&node_name_chars, &node_name_format, &property_name_chars,
+	&name_is_string, &name_properties, &node_name_vs_property_name,
+
+	&duplicate_label,
+
+	&explicit_phandles,
+	&phandle_references, &path_references,
+	&omit_unused_nodes,
+
+	&address_cells_is_cell, &size_cells_is_cell,
+	&device_type_is_string, &model_is_string, &status_is_string,
+	&label_is_string,
+
+	&compatible_is_string_list, &names_is_string_list,
+
+	&property_name_chars_strict,
+	&node_name_chars_strict,
+
+	&addr_size_cells, &reg_format, &ranges_format, &dma_ranges_format,
+
+	&unit_address_vs_reg,
+	&unit_address_format,
+
+	&pci_bridge,
+	&pci_device_reg,
+	&pci_device_bus_num,
+
+	&simple_bus_bridge,
+	&simple_bus_reg,
+
+	&i2c_bus_bridge,
+	&i2c_bus_reg,
+
+	&spi_bus_bridge,
+	&spi_bus_reg,
+
+	&avoid_default_addr_size,
+	&avoid_unnecessary_addr_size,
+	&unique_unit_address,
+	&unique_unit_address_if_enabled,
+	&obsolete_chosen_interrupt_controller,
+	&chosen_node_is_root, &chosen_node_bootargs, &chosen_node_stdout_path,
+
+	&clocks_property,
+	&clocks_is_cell,
+	&cooling_device_property,
+	&cooling_device_is_cell,
+	&dmas_property,
+	&dmas_is_cell,
+	&hwlocks_property,
+	&hwlocks_is_cell,
+	&interrupts_extended_property,
+	&interrupts_extended_is_cell,
+	&io_channels_property,
+	&io_channels_is_cell,
+	&iommus_property,
+	&iommus_is_cell,
+	&mboxes_property,
+	&mboxes_is_cell,
+	&msi_parent_property,
+	&msi_parent_is_cell,
+	&mux_controls_property,
+	&mux_controls_is_cell,
+	&phys_property,
+	&phys_is_cell,
+	&power_domains_property,
+	&power_domains_is_cell,
+	&pwms_property,
+	&pwms_is_cell,
+	&resets_property,
+	&resets_is_cell,
+	&sound_dai_property,
+	&sound_dai_is_cell,
+	&thermal_sensors_property,
+	&thermal_sensors_is_cell,
+
+	&deprecated_gpio_property,
+	&gpios_property,
+	&interrupts_property,
+	&interrupt_provider,
+
+	&alias_paths,
+
+	&graph_nodes, &graph_child_address, &graph_port, &graph_endpoint,
+
+	&always_fail,
+};
+
+static void enable_warning_error(struct check *c, bool warn, bool error)
+{
+	int i;
+
+	/* Raising level, also raise it for prereqs */
+	if ((warn && !c->warn) || (error && !c->error))
+		for (i = 0; i < c->num_prereqs; i++)
+			enable_warning_error(c->prereq[i], warn, error);
+
+	c->warn = c->warn || warn;
+	c->error = c->error || error;
+}
+
+static void disable_warning_error(struct check *c, bool warn, bool error)
+{
+	int i;
+
+	/* Lowering level, also lower it for things this is the prereq
+	 * for */
+	if ((warn && c->warn) || (error && c->error)) {
+		for (i = 0; i < ARRAY_SIZE(check_table); i++) {
+			struct check *cc = check_table[i];
+			int j;
+
+			for (j = 0; j < cc->num_prereqs; j++)
+				if (cc->prereq[j] == c)
+					disable_warning_error(cc, warn, error);
+		}
+	}
+
+	c->warn = c->warn && !warn;
+	c->error = c->error && !error;
+}
+
+void parse_checks_option(bool warn, bool error, const char *arg)
+{
+	int i;
+	const char *name = arg;
+	bool enable = true;
+
+	if ((strncmp(arg, "no-", 3) == 0)
+	    || (strncmp(arg, "no_", 3) == 0)) {
+		name = arg + 3;
+		enable = false;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(check_table); i++) {
+		struct check *c = check_table[i];
+
+		if (streq(c->name, name)) {
+			if (enable)
+				enable_warning_error(c, warn, error);
+			else
+				disable_warning_error(c, warn, error);
+			return;
+		}
+	}
+
+	die("Unrecognized check name \"%s\"\n", name);
+}
+
+void process_checks(bool force, struct dt_info *dti)
+{
+	int i;
+	int error = 0;
+
+	for (i = 0; i < ARRAY_SIZE(check_table); i++) {
+		struct check *c = check_table[i];
+
+		if (c->warn || c->error)
+			error = error || run_check(c, dti);
+	}
+
+	if (error) {
+		if (!force) {
+			fprintf(stderr, "ERROR: Input tree has errors, aborting "
+				"(use -f to force output)\n");
+			exit(2);
+		} else if (quiet < 3) {
+			fprintf(stderr, "Warning: Input tree has errors, "
+				"output forced\n");
+		}
+	}
+}
diff --git a/dtc/convert-dtsv0-lexer.l b/dtc/convert-dtsv0-lexer.l
new file mode 100644
index 0000000..7a66f57
--- /dev/null
+++ b/dtc/convert-dtsv0-lexer.l
@@ -0,0 +1,235 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005, 2008.
+ */
+
+%option noyywrap nounput noinput never-interactive
+
+%x BYTESTRING
+%x PROPNODENAME
+
+PROPNODECHAR	[a-zA-Z0-9,._+*#?@-]
+PATHCHAR	({PROPNODECHAR}|[/])
+LABEL		[a-zA-Z_][a-zA-Z0-9_]*
+STRING		\"([^\\"]|\\.)*\"
+WS		[[:space:]]
+COMMENT		"/*"([^*]|\*+[^*/])*\*+"/"
+LINECOMMENT	"//".*\n
+GAP		({WS}|{COMMENT}|{LINECOMMENT})*
+
+%{
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include <errno.h>
+#include <assert.h>
+#include <fnmatch.h>
+
+#include "srcpos.h"
+#include "util.h"
+
+static int v1_tagged; /* = 0 */
+static int cbase = 16;
+static int saw_hyphen; /* = 0 */
+static unsigned long long last_val;
+static char *last_name; /* = NULL */
+
+static const struct {
+	const char *pattern;
+	int obase, width;
+} guess_table[] = {
+	{ "*-frequency", 10, 0 },
+	{ "num-*", 10, 0 },
+	{ "#*-cells", 10, 0 },
+	{ "*cache-line-size", 10, 0 },
+	{ "*cache-block-size", 10, 0 },
+	{ "*cache-size", 10, 0 },
+	{ "*cache-sets", 10, 0 },
+	{ "cell-index", 10, 0 },
+	{ "bank-width", 10, 0 },
+	{ "*-fifo-size", 10, 0 },
+	{ "*-frame-size", 10, 0 },
+	{ "*-channel", 10, 0 },
+	{ "current-speed", 10, 0 },
+	{ "phy-map", 16, 8 },
+	{ "dcr-reg", 16, 3 },
+	{ "reg", 16, 8 },
+	{ "ranges", 16, 8},
+};
+%}
+
+%%
+<*>"/include/"{GAP}{STRING}	ECHO;
+
+<*>\"([^\\"]|\\.)*\"	ECHO;
+
+<*>"/dts-v1/"	{
+			die("Input dts file is already version 1\n");
+		}
+
+<*>"/memreserve/"	{
+			if (!v1_tagged) {
+				fprintf(yyout, "/dts-v1/;\n\n");
+				v1_tagged = 1;
+			}
+
+			ECHO;
+			BEGIN(INITIAL);
+		}
+
+<*>{LABEL}:		ECHO;
+
+<INITIAL>[bodh]# {
+			if (*yytext == 'b')
+				cbase = 2;
+			else if (*yytext == 'o')
+				cbase = 8;
+			else if (*yytext == 'd')
+				cbase = 10;
+			else
+				cbase = 16;
+		}
+
+<INITIAL>[0-9a-fA-F]+	{
+			unsigned long long val;
+			int obase = 16, width = 0;
+			unsigned int i;
+
+			val = strtoull(yytext, NULL, cbase);
+
+			if (saw_hyphen)
+				val = val - last_val + 1;
+
+			if (last_name) {
+				for (i = 0; i < ARRAY_SIZE(guess_table); i++)
+					if (fnmatch(guess_table[i].pattern,
+					    last_name, 0) == 0) {
+						obase = guess_table[i].obase;
+						width = guess_table[i].width;
+					}
+			} else {
+				obase = 16;
+				width = 16;
+			}
+
+			if (cbase != 16)
+				obase = cbase;
+
+			switch (obase) {
+			case 2:
+			case 16:
+				fprintf(yyout, "0x%0*llx", width, val);
+				break;
+			case 8:
+				fprintf(yyout, "0%0*llo", width, val);
+				break;
+			case 10:
+				fprintf(yyout, "%*llu", width, val);
+				break;
+			}
+
+			cbase = 16;
+			last_val = val;
+			saw_hyphen = 0;
+		}
+
+\&{LABEL}		ECHO;
+
+"&{/"{PATHCHAR}+\}	ECHO;
+
+<INITIAL>"&/"{PATHCHAR}+ fprintf(yyout, "&{/%s}", yytext + 2);
+
+<BYTESTRING>[0-9a-fA-F]{2} ECHO;
+
+<BYTESTRING>"]"	{
+			ECHO;
+			BEGIN(INITIAL);
+		}
+
+<PROPNODENAME>{PROPNODECHAR}+ {
+			ECHO;
+			last_name = xstrdup(yytext);
+			BEGIN(INITIAL);
+		}
+
+<*>{GAP}	ECHO;
+
+<*>-		{	/* Hack to convert old style memreserves */
+			saw_hyphen = 1;
+			fprintf(yyout, " ");
+		}
+
+<*>.		{
+			if (!v1_tagged) {
+				fprintf(yyout, "/dts-v1/;\n\n");
+				v1_tagged = 1;
+			}
+
+			ECHO;
+			if (yytext[0] == '[') {
+				BEGIN(BYTESTRING);
+			}
+			if ((yytext[0] == '{')
+			    || (yytext[0] == ';')) {
+				BEGIN(PROPNODENAME);
+			}
+		}
+
+%%
+/* Usage related data. */
+static const char usage_synopsis[] = "convert-dtsv0 [options] <v0 dts file>...";
+static const char usage_short_opts[] = "" USAGE_COMMON_SHORT_OPTS;
+static struct option const usage_long_opts[] = {
+	USAGE_COMMON_LONG_OPTS
+};
+static const char * const usage_opts_help[] = {
+	USAGE_COMMON_OPTS_HELP
+};
+
+static void convert_file(const char *fname)
+{
+	const char suffix[] = "v1";
+	int len = strlen(fname);
+	char *newname;
+
+	newname = xmalloc(len + sizeof(suffix));
+	memcpy(newname, fname, len);
+	memcpy(newname + len, suffix, sizeof(suffix));
+
+	yyin = fopen(fname, "r");
+	if (!yyin)
+		die("Couldn't open input file %s: %s\n",
+		    fname, strerror(errno));
+
+	yyout = fopen(newname, "w");
+	if (!yyout)
+		die("Couldn't open output file %s: %s\n",
+		    newname, strerror(errno));
+
+	while(yylex())
+		;
+
+	free(newname);
+}
+
+int main(int argc, char *argv[])
+{
+	int opt;
+	int i;
+
+	while ((opt = util_getopt_long()) != EOF) {
+		switch (opt) {
+		case_USAGE_COMMON_FLAGS
+		}
+	}
+	if (argc < 2)
+		usage("missing filename");
+
+	for (i = 1; i < argc; i++) {
+		fprintf(stderr, "Converting %s from dts v0 to dts v1\n", argv[i]);
+		convert_file(argv[i]);
+	}
+
+	exit(0);
+}
diff --git a/dtc/data.c b/dtc/data.c
new file mode 100644
index 0000000..1473423
--- /dev/null
+++ b/dtc/data.c
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include "dtc.h"
+
+void data_free(struct data d)
+{
+	struct marker *m, *nm;
+
+	m = d.markers;
+	while (m) {
+		nm = m->next;
+		free(m->ref);
+		free(m);
+		m = nm;
+	}
+
+	if (d.val)
+		free(d.val);
+}
+
+struct data data_grow_for(struct data d, unsigned int xlen)
+{
+	struct data nd;
+	unsigned int newsize;
+
+	if (xlen == 0)
+		return d;
+
+	nd = d;
+
+	newsize = xlen;
+
+	while ((d.len + xlen) > newsize)
+		newsize *= 2;
+
+	nd.val = xrealloc(d.val, newsize);
+
+	return nd;
+}
+
+struct data data_copy_mem(const char *mem, int len)
+{
+	struct data d;
+
+	d = data_grow_for(empty_data, len);
+
+	d.len = len;
+	memcpy(d.val, mem, len);
+
+	return d;
+}
+
+struct data data_copy_escape_string(const char *s, int len)
+{
+	int i = 0;
+	struct data d;
+	char *q;
+
+	d = data_add_marker(empty_data, TYPE_STRING, NULL);
+	d = data_grow_for(d, len + 1);
+
+	q = d.val;
+	while (i < len) {
+		char c = s[i++];
+
+		if (c == '\\')
+			c = get_escape_char(s, &i);
+
+		q[d.len++] = c;
+	}
+
+	q[d.len++] = '\0';
+	return d;
+}
+
+struct data data_copy_file(FILE *f, size_t maxlen)
+{
+	struct data d = empty_data;
+
+	d = data_add_marker(d, TYPE_NONE, NULL);
+	while (!feof(f) && (d.len < maxlen)) {
+		size_t chunksize, ret;
+
+		if (maxlen == (size_t)-1)
+			chunksize = 4096;
+		else
+			chunksize = maxlen - d.len;
+
+		d = data_grow_for(d, chunksize);
+		ret = fread(d.val + d.len, 1, chunksize, f);
+
+		if (ferror(f))
+			die("Error reading file into data: %s", strerror(errno));
+
+		if (d.len + ret < d.len)
+			die("Overflow reading file into data\n");
+
+		d.len += ret;
+	}
+
+	return d;
+}
+
+struct data data_append_data(struct data d, const void *p, int len)
+{
+	d = data_grow_for(d, len);
+	memcpy(d.val + d.len, p, len);
+	d.len += len;
+	return d;
+}
+
+struct data data_insert_at_marker(struct data d, struct marker *m,
+				  const void *p, int len)
+{
+	d = data_grow_for(d, len);
+	memmove(d.val + m->offset + len, d.val + m->offset, d.len - m->offset);
+	memcpy(d.val + m->offset, p, len);
+	d.len += len;
+
+	/* Adjust all markers after the one we're inserting at */
+	m = m->next;
+	for_each_marker(m)
+		m->offset += len;
+	return d;
+}
+
+static struct data data_append_markers(struct data d, struct marker *m)
+{
+	struct marker **mp = &d.markers;
+
+	/* Find the end of the markerlist */
+	while (*mp)
+		mp = &((*mp)->next);
+	*mp = m;
+	return d;
+}
+
+struct data data_merge(struct data d1, struct data d2)
+{
+	struct data d;
+	struct marker *m2 = d2.markers;
+
+	d = data_append_markers(data_append_data(d1, d2.val, d2.len), m2);
+
+	/* Adjust for the length of d1 */
+	for_each_marker(m2)
+		m2->offset += d1.len;
+
+	d2.markers = NULL; /* So data_free() doesn't clobber them */
+	data_free(d2);
+
+	return d;
+}
+
+struct data data_append_integer(struct data d, uint64_t value, int bits)
+{
+	uint8_t value_8;
+	fdt16_t value_16;
+	fdt32_t value_32;
+	fdt64_t value_64;
+
+	switch (bits) {
+	case 8:
+		value_8 = value;
+		return data_append_data(d, &value_8, 1);
+
+	case 16:
+		value_16 = cpu_to_fdt16(value);
+		return data_append_data(d, &value_16, 2);
+
+	case 32:
+		value_32 = cpu_to_fdt32(value);
+		return data_append_data(d, &value_32, 4);
+
+	case 64:
+		value_64 = cpu_to_fdt64(value);
+		return data_append_data(d, &value_64, 8);
+
+	default:
+		die("Invalid literal size (%d)\n", bits);
+	}
+}
+
+struct data data_append_re(struct data d, uint64_t address, uint64_t size)
+{
+	struct fdt_reserve_entry re;
+
+	re.address = cpu_to_fdt64(address);
+	re.size = cpu_to_fdt64(size);
+
+	return data_append_data(d, &re, sizeof(re));
+}
+
+struct data data_append_cell(struct data d, cell_t word)
+{
+	return data_append_integer(d, word, sizeof(word) * 8);
+}
+
+struct data data_append_addr(struct data d, uint64_t addr)
+{
+	return data_append_integer(d, addr, sizeof(addr) * 8);
+}
+
+struct data data_append_byte(struct data d, uint8_t byte)
+{
+	return data_append_data(d, &byte, 1);
+}
+
+struct data data_append_zeroes(struct data d, int len)
+{
+	d = data_grow_for(d, len);
+
+	memset(d.val + d.len, 0, len);
+	d.len += len;
+	return d;
+}
+
+struct data data_append_align(struct data d, int align)
+{
+	int newlen = ALIGN(d.len, align);
+	return data_append_zeroes(d, newlen - d.len);
+}
+
+struct data data_add_marker(struct data d, enum markertype type, char *ref)
+{
+	struct marker *m;
+
+	m = xmalloc(sizeof(*m));
+	m->offset = d.len;
+	m->type = type;
+	m->ref = ref;
+	m->next = NULL;
+
+	return data_append_markers(d, m);
+}
+
+bool data_is_one_string(struct data d)
+{
+	int i;
+	int len = d.len;
+
+	if (len == 0)
+		return false;
+
+	for (i = 0; i < len-1; i++)
+		if (d.val[i] == '\0')
+			return false;
+
+	if (d.val[len-1] != '\0')
+		return false;
+
+	return true;
+}
diff --git a/dtc/dtc-lexer.l b/dtc/dtc-lexer.l
new file mode 100644
index 0000000..5568b4a
--- /dev/null
+++ b/dtc/dtc-lexer.l
@@ -0,0 +1,297 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+%option noyywrap nounput noinput never-interactive
+
+%x BYTESTRING
+%x PROPNODENAME
+%s V1
+
+PROPNODECHAR	[a-zA-Z0-9,._+*#?@-]
+PATHCHAR	({PROPNODECHAR}|[/])
+LABEL		[a-zA-Z_][a-zA-Z0-9_]*
+STRING		\"([^\\"]|\\.)*\"
+CHAR_LITERAL	'([^']|\\')*'
+WS		[[:space:]]
+COMMENT		"/*"([^*]|\*+[^*/])*\*+"/"
+LINECOMMENT	"//".*\n
+
+%{
+#include "dtc.h"
+#include "srcpos.h"
+#include "dtc-parser.tab.h"
+
+extern bool treesource_error;
+
+/* CAUTION: this will stop working if we ever use yyless() or yyunput() */
+#define	YY_USER_ACTION \
+	{ \
+		srcpos_update(&yylloc, yytext, yyleng); \
+	}
+
+/*#define LEXDEBUG	1*/
+
+#ifdef LEXDEBUG
+#define DPRINT(fmt, ...)	fprintf(stderr, fmt, ##__VA_ARGS__)
+#else
+#define DPRINT(fmt, ...)	do { } while (0)
+#endif
+
+static int dts_version = 1;
+
+#define BEGIN_DEFAULT()		DPRINT("<V1>\n"); \
+				BEGIN(V1); \
+
+static void push_input_file(const char *filename);
+static bool pop_input_file(void);
+static void PRINTF(1, 2) lexical_error(const char *fmt, ...);
+
+%}
+
+%%
+<*>"/include/"{WS}*{STRING} {
+			char *name = strchr(yytext, '\"') + 1;
+			yytext[yyleng-1] = '\0';
+			push_input_file(name);
+		}
+
+<*>^"#"(line)?[ \t]+[0-9]+[ \t]+{STRING}([ \t]+[0-9]+)* {
+			char *line, *fnstart, *fnend;
+			struct data fn;
+			/* skip text before line # */
+			line = yytext;
+			while (!isdigit((unsigned char)*line))
+				line++;
+
+			/* regexp ensures that first and list "
+			 * in the whole yytext are those at
+			 * beginning and end of the filename string */
+			fnstart = memchr(yytext, '"', yyleng);
+			for (fnend = yytext + yyleng - 1;
+			     *fnend != '"'; fnend--)
+				;
+			assert(fnstart && fnend && (fnend > fnstart));
+
+			fn = data_copy_escape_string(fnstart + 1,
+						     fnend - fnstart - 1);
+
+			/* Don't allow nuls in filenames */
+			if (memchr(fn.val, '\0', fn.len - 1))
+				lexical_error("nul in line number directive");
+
+			/* -1 since #line is the number of the next line */
+			srcpos_set_line(xstrdup(fn.val), atoi(line) - 1);
+			data_free(fn);
+		}
+
+<*><<EOF>>		{
+			if (!pop_input_file()) {
+				yyterminate();
+			}
+		}
+
+<*>{STRING}	{
+			DPRINT("String: %s\n", yytext);
+			yylval.data = data_copy_escape_string(yytext+1,
+					yyleng-2);
+			return DT_STRING;
+		}
+
+<*>"/dts-v1/"	{
+			DPRINT("Keyword: /dts-v1/\n");
+			dts_version = 1;
+			BEGIN_DEFAULT();
+			return DT_V1;
+		}
+
+<*>"/plugin/"	{
+			DPRINT("Keyword: /plugin/\n");
+			return DT_PLUGIN;
+		}
+
+<*>"/memreserve/"	{
+			DPRINT("Keyword: /memreserve/\n");
+			BEGIN_DEFAULT();
+			return DT_MEMRESERVE;
+		}
+
+<*>"/bits/"	{
+			DPRINT("Keyword: /bits/\n");
+			BEGIN_DEFAULT();
+			return DT_BITS;
+		}
+
+<*>"/delete-property/"	{
+			DPRINT("Keyword: /delete-property/\n");
+			DPRINT("<PROPNODENAME>\n");
+			BEGIN(PROPNODENAME);
+			return DT_DEL_PROP;
+		}
+
+<*>"/delete-node/"	{
+			DPRINT("Keyword: /delete-node/\n");
+			DPRINT("<PROPNODENAME>\n");
+			BEGIN(PROPNODENAME);
+			return DT_DEL_NODE;
+		}
+
+<*>"/omit-if-no-ref/"	{
+			DPRINT("Keyword: /omit-if-no-ref/\n");
+			DPRINT("<PROPNODENAME>\n");
+			BEGIN(PROPNODENAME);
+			return DT_OMIT_NO_REF;
+		}
+
+<*>{LABEL}:	{
+			DPRINT("Label: %s\n", yytext);
+			yylval.labelref = xstrdup(yytext);
+			yylval.labelref[yyleng-1] = '\0';
+			return DT_LABEL;
+		}
+
+<V1>([0-9]+|0[xX][0-9a-fA-F]+)(U|L|UL|LL|ULL)? {
+			char *e;
+			DPRINT("Integer Literal: '%s'\n", yytext);
+
+			errno = 0;
+			yylval.integer = strtoull(yytext, &e, 0);
+
+			if (*e && e[strspn(e, "UL")]) {
+				lexical_error("Bad integer literal '%s'",
+					      yytext);
+			}
+
+			if (errno == ERANGE)
+				lexical_error("Integer literal '%s' out of range",
+					      yytext);
+			else
+				/* ERANGE is the only strtoull error triggerable
+				 *  by strings matching the pattern */
+				assert(errno == 0);
+			return DT_LITERAL;
+		}
+
+<*>{CHAR_LITERAL}	{
+			struct data d;
+			DPRINT("Character literal: %s\n", yytext);
+
+			d = data_copy_escape_string(yytext+1, yyleng-2);
+			if (d.len == 1) {
+				lexical_error("Empty character literal");
+				yylval.integer = 0;
+			} else {
+				yylval.integer = (unsigned char)d.val[0];
+
+				if (d.len > 2)
+					lexical_error("Character literal has %d"
+						      " characters instead of 1",
+						      d.len - 1);
+			}
+
+			data_free(d);
+			return DT_CHAR_LITERAL;
+		}
+
+<*>\&{LABEL}	{	/* label reference */
+			DPRINT("Ref: %s\n", yytext+1);
+			yylval.labelref = xstrdup(yytext+1);
+			return DT_LABEL_REF;
+		}
+
+<*>"&{/"{PATHCHAR}*\}	{	/* new-style path reference */
+			yytext[yyleng-1] = '\0';
+			DPRINT("Ref: %s\n", yytext+2);
+			yylval.labelref = xstrdup(yytext+2);
+			return DT_PATH_REF;
+		}
+
+<BYTESTRING>[0-9a-fA-F]{2} {
+			yylval.byte = strtol(yytext, NULL, 16);
+			DPRINT("Byte: %02x\n", (int)yylval.byte);
+			return DT_BYTE;
+		}
+
+<BYTESTRING>"]"	{
+			DPRINT("/BYTESTRING\n");
+			BEGIN_DEFAULT();
+			return ']';
+		}
+
+<PROPNODENAME>\\?{PROPNODECHAR}+ {
+			DPRINT("PropNodeName: %s\n", yytext);
+			yylval.propnodename = xstrdup((yytext[0] == '\\') ?
+							yytext + 1 : yytext);
+			BEGIN_DEFAULT();
+			return DT_PROPNODENAME;
+		}
+
+"/incbin/"	{
+			DPRINT("Binary Include\n");
+			return DT_INCBIN;
+		}
+
+<*>{WS}+	/* eat whitespace */
+<*>{COMMENT}+	/* eat C-style comments */
+<*>{LINECOMMENT}+ /* eat C++-style comments */
+
+<*>"<<"		{ return DT_LSHIFT; };
+<*>">>"		{ return DT_RSHIFT; };
+<*>"<="		{ return DT_LE; };
+<*>">="		{ return DT_GE; };
+<*>"=="		{ return DT_EQ; };
+<*>"!="		{ return DT_NE; };
+<*>"&&"		{ return DT_AND; };
+<*>"||"		{ return DT_OR; };
+
+<*>.		{
+			DPRINT("Char: %c (\\x%02x)\n", yytext[0],
+				(unsigned)yytext[0]);
+			if (yytext[0] == '[') {
+				DPRINT("<BYTESTRING>\n");
+				BEGIN(BYTESTRING);
+			}
+			if ((yytext[0] == '{')
+			    || (yytext[0] == ';')) {
+				DPRINT("<PROPNODENAME>\n");
+				BEGIN(PROPNODENAME);
+			}
+			return yytext[0];
+		}
+
+%%
+
+static void push_input_file(const char *filename)
+{
+	assert(filename);
+
+	srcfile_push(filename);
+
+	yyin = current_srcfile->f;
+
+	yypush_buffer_state(yy_create_buffer(yyin, YY_BUF_SIZE));
+}
+
+
+static bool pop_input_file(void)
+{
+	if (srcfile_pop() == 0)
+		return false;
+
+	yypop_buffer_state();
+	yyin = current_srcfile->f;
+
+	return true;
+}
+
+static void lexical_error(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	srcpos_verror(&yylloc, "Lexical error", fmt, ap);
+	va_end(ap);
+
+	treesource_error = true;
+}
diff --git a/dtc/dtc-parser.y b/dtc/dtc-parser.y
new file mode 100644
index 0000000..a0316a3
--- /dev/null
+++ b/dtc/dtc-parser.y
@@ -0,0 +1,576 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+%locations
+
+%{
+#include <stdio.h>
+#include <inttypes.h>
+
+#include "dtc.h"
+#include "srcpos.h"
+
+extern int yylex(void);
+extern void yyerror(char const *s);
+#define ERROR(loc, ...) \
+	do { \
+		srcpos_error((loc), "Error", __VA_ARGS__); \
+		treesource_error = true; \
+	} while (0)
+
+#define YYERROR_CALL(msg) yyerror(msg)
+
+extern struct dt_info *parser_output;
+extern bool treesource_error;
+%}
+
+%union {
+	char *propnodename;
+	char *labelref;
+	uint8_t byte;
+	struct data data;
+
+	struct {
+		struct data	data;
+		int		bits;
+	} array;
+
+	struct property *prop;
+	struct property *proplist;
+	struct node *node;
+	struct node *nodelist;
+	struct reserve_info *re;
+	uint64_t integer;
+	unsigned int flags;
+}
+
+%token DT_V1
+%token DT_PLUGIN
+%token DT_MEMRESERVE
+%token DT_LSHIFT DT_RSHIFT DT_LE DT_GE DT_EQ DT_NE DT_AND DT_OR
+%token DT_BITS
+%token DT_DEL_PROP
+%token DT_DEL_NODE
+%token DT_OMIT_NO_REF
+%token <propnodename> DT_PROPNODENAME
+%token <integer> DT_LITERAL
+%token <integer> DT_CHAR_LITERAL
+%token <byte> DT_BYTE
+%token <data> DT_STRING
+%token <labelref> DT_LABEL
+%token <labelref> DT_LABEL_REF
+%token <labelref> DT_PATH_REF
+%token DT_INCBIN
+
+%type <data> propdata
+%type <data> propdataprefix
+%type <flags> header
+%type <flags> headers
+%type <re> memreserve
+%type <re> memreserves
+%type <array> arrayprefix
+%type <data> bytestring
+%type <prop> propdef
+%type <proplist> proplist
+%type <labelref> dt_ref
+
+%type <node> devicetree
+%type <node> nodedef
+%type <node> subnode
+%type <nodelist> subnodes
+
+%type <integer> integer_prim
+%type <integer> integer_unary
+%type <integer> integer_mul
+%type <integer> integer_add
+%type <integer> integer_shift
+%type <integer> integer_rela
+%type <integer> integer_eq
+%type <integer> integer_bitand
+%type <integer> integer_bitxor
+%type <integer> integer_bitor
+%type <integer> integer_and
+%type <integer> integer_or
+%type <integer> integer_trinary
+%type <integer> integer_expr
+
+%%
+
+sourcefile:
+	  headers memreserves devicetree
+		{
+			parser_output = build_dt_info($1, $2, $3,
+			                              guess_boot_cpuid($3));
+		}
+	;
+
+header:
+	  DT_V1 ';'
+		{
+			$$ = DTSF_V1;
+		}
+	| DT_V1 ';' DT_PLUGIN ';'
+		{
+			$$ = DTSF_V1 | DTSF_PLUGIN;
+		}
+	;
+
+headers:
+	  header
+	| header headers
+		{
+			if ($2 != $1)
+				ERROR(&@2, "Header flags don't match earlier ones");
+			$$ = $1;
+		}
+	;
+
+memreserves:
+	  /* empty */
+		{
+			$$ = NULL;
+		}
+	| memreserve memreserves
+		{
+			$$ = chain_reserve_entry($1, $2);
+		}
+	;
+
+memreserve:
+	  DT_MEMRESERVE integer_prim integer_prim ';'
+		{
+			$$ = build_reserve_entry($2, $3);
+		}
+	| DT_LABEL memreserve
+		{
+			add_label(&$2->labels, $1);
+			$$ = $2;
+		}
+	;
+
+dt_ref: DT_LABEL_REF | DT_PATH_REF;
+
+devicetree:
+	  '/' nodedef
+		{
+			$$ = name_node($2, "");
+		}
+	| devicetree '/' nodedef
+		{
+			$$ = merge_nodes($1, $3);
+		}
+	| dt_ref nodedef
+		{
+			/*
+			 * We rely on the rule being always:
+			 *   versioninfo plugindecl memreserves devicetree
+			 * so $-1 is what we want (plugindecl)
+			 */
+			if (!($<flags>-1 & DTSF_PLUGIN))
+				ERROR(&@2, "Label or path %s not found", $1);
+			$$ = add_orphan_node(
+					name_node(build_node(NULL, NULL, NULL),
+						  ""),
+					$2, $1);
+		}
+	| devicetree DT_LABEL dt_ref nodedef
+		{
+			struct node *target = get_node_by_ref($1, $3);
+
+			if (target) {
+				add_label(&target->labels, $2);
+				merge_nodes(target, $4);
+			} else
+				ERROR(&@3, "Label or path %s not found", $3);
+			$$ = $1;
+		}
+	| devicetree DT_PATH_REF nodedef
+		{
+			/*
+			 * We rely on the rule being always:
+			 *   versioninfo plugindecl memreserves devicetree
+			 * so $-1 is what we want (plugindecl)
+			 */
+			if ($<flags>-1 & DTSF_PLUGIN) {
+				add_orphan_node($1, $3, $2);
+			} else {
+				struct node *target = get_node_by_ref($1, $2);
+
+				if (target)
+					merge_nodes(target, $3);
+				else
+					ERROR(&@2, "Label or path %s not found", $2);
+			}
+			$$ = $1;
+		}
+	| devicetree DT_LABEL_REF nodedef
+		{
+			struct node *target = get_node_by_ref($1, $2);
+
+			if (target) {
+				merge_nodes(target, $3);
+			} else {
+				/*
+				 * We rely on the rule being always:
+				 *   versioninfo plugindecl memreserves devicetree
+				 * so $-1 is what we want (plugindecl)
+				 */
+				if ($<flags>-1 & DTSF_PLUGIN)
+					add_orphan_node($1, $3, $2);
+				else
+					ERROR(&@2, "Label or path %s not found", $2);
+			}
+			$$ = $1;
+		}
+	| devicetree DT_DEL_NODE dt_ref ';'
+		{
+			struct node *target = get_node_by_ref($1, $3);
+
+			if (target)
+				delete_node(target);
+			else
+				ERROR(&@3, "Label or path %s not found", $3);
+
+
+			$$ = $1;
+		}
+	| devicetree DT_OMIT_NO_REF dt_ref ';'
+		{
+			struct node *target = get_node_by_ref($1, $3);
+
+			if (target)
+				omit_node_if_unused(target);
+			else
+				ERROR(&@3, "Label or path %s not found", $3);
+
+
+			$$ = $1;
+		}
+	;
+
+nodedef:
+	  '{' proplist subnodes '}' ';'
+		{
+			$$ = build_node($2, $3, &@$);
+		}
+	;
+
+proplist:
+	  /* empty */
+		{
+			$$ = NULL;
+		}
+	| proplist propdef
+		{
+			$$ = chain_property($2, $1);
+		}
+	;
+
+propdef:
+	  DT_PROPNODENAME '=' propdata ';'
+		{
+			$$ = build_property($1, $3, &@$);
+		}
+	| DT_PROPNODENAME ';'
+		{
+			$$ = build_property($1, empty_data, &@$);
+		}
+	| DT_DEL_PROP DT_PROPNODENAME ';'
+		{
+			$$ = build_property_delete($2);
+		}
+	| DT_LABEL propdef
+		{
+			add_label(&$2->labels, $1);
+			$$ = $2;
+		}
+	;
+
+propdata:
+	  propdataprefix DT_STRING
+		{
+			$$ = data_merge($1, $2);
+		}
+	| propdataprefix arrayprefix '>'
+		{
+			$$ = data_merge($1, $2.data);
+		}
+	| propdataprefix '[' bytestring ']'
+		{
+			$$ = data_merge($1, $3);
+		}
+	| propdataprefix dt_ref
+		{
+			$1 = data_add_marker($1, TYPE_STRING, $2);
+			$$ = data_add_marker($1, REF_PATH, $2);
+		}
+	| propdataprefix DT_INCBIN '(' DT_STRING ',' integer_prim ',' integer_prim ')'
+		{
+			FILE *f = srcfile_relative_open($4.val, NULL);
+			struct data d;
+
+			if ($6 != 0)
+				if (fseek(f, $6, SEEK_SET) != 0)
+					die("Couldn't seek to offset %llu in \"%s\": %s",
+					    (unsigned long long)$6, $4.val,
+					    strerror(errno));
+
+			d = data_copy_file(f, $8);
+
+			$$ = data_merge($1, d);
+			fclose(f);
+		}
+	| propdataprefix DT_INCBIN '(' DT_STRING ')'
+		{
+			FILE *f = srcfile_relative_open($4.val, NULL);
+			struct data d = empty_data;
+
+			d = data_copy_file(f, -1);
+
+			$$ = data_merge($1, d);
+			fclose(f);
+		}
+	| propdata DT_LABEL
+		{
+			$$ = data_add_marker($1, LABEL, $2);
+		}
+	;
+
+propdataprefix:
+	  /* empty */
+		{
+			$$ = empty_data;
+		}
+	| propdata ','
+		{
+			$$ = $1;
+		}
+	| propdataprefix DT_LABEL
+		{
+			$$ = data_add_marker($1, LABEL, $2);
+		}
+	;
+
+arrayprefix:
+	DT_BITS DT_LITERAL '<'
+		{
+			unsigned long long bits;
+			enum markertype type = TYPE_UINT32;
+
+			bits = $2;
+
+			switch (bits) {
+			case 8: type = TYPE_UINT8; break;
+			case 16: type = TYPE_UINT16; break;
+			case 32: type = TYPE_UINT32; break;
+			case 64: type = TYPE_UINT64; break;
+			default:
+				ERROR(&@2, "Array elements must be"
+				      " 8, 16, 32 or 64-bits");
+				bits = 32;
+			}
+
+			$$.data = data_add_marker(empty_data, type, NULL);
+			$$.bits = bits;
+		}
+	| '<'
+		{
+			$$.data = data_add_marker(empty_data, TYPE_UINT32, NULL);
+			$$.bits = 32;
+		}
+	| arrayprefix integer_prim
+		{
+			if ($1.bits < 64) {
+				uint64_t mask = (1ULL << $1.bits) - 1;
+				/*
+				 * Bits above mask must either be all zero
+				 * (positive within range of mask) or all one
+				 * (negative and sign-extended). The second
+				 * condition is true if when we set all bits
+				 * within the mask to one (i.e. | in the
+				 * mask), all bits are one.
+				 */
+				if (($2 > mask) && (($2 | mask) != -1ULL))
+					ERROR(&@2, "Value out of range for"
+					      " %d-bit array element", $1.bits);
+			}
+
+			$$.data = data_append_integer($1.data, $2, $1.bits);
+		}
+	| arrayprefix dt_ref
+		{
+			uint64_t val = ~0ULL >> (64 - $1.bits);
+
+			if ($1.bits == 32)
+				$1.data = data_add_marker($1.data,
+							  REF_PHANDLE,
+							  $2);
+			else
+				ERROR(&@2, "References are only allowed in "
+					    "arrays with 32-bit elements.");
+
+			$$.data = data_append_integer($1.data, val, $1.bits);
+		}
+	| arrayprefix DT_LABEL
+		{
+			$$.data = data_add_marker($1.data, LABEL, $2);
+		}
+	;
+
+integer_prim:
+	  DT_LITERAL
+	| DT_CHAR_LITERAL
+	| '(' integer_expr ')'
+		{
+			$$ = $2;
+		}
+	;
+
+integer_expr:
+	integer_trinary
+	;
+
+integer_trinary:
+	  integer_or
+	| integer_or '?' integer_expr ':' integer_trinary { $$ = $1 ? $3 : $5; }
+	;
+
+integer_or:
+	  integer_and
+	| integer_or DT_OR integer_and { $$ = $1 || $3; }
+	;
+
+integer_and:
+	  integer_bitor
+	| integer_and DT_AND integer_bitor { $$ = $1 && $3; }
+	;
+
+integer_bitor:
+	  integer_bitxor
+	| integer_bitor '|' integer_bitxor { $$ = $1 | $3; }
+	;
+
+integer_bitxor:
+	  integer_bitand
+	| integer_bitxor '^' integer_bitand { $$ = $1 ^ $3; }
+	;
+
+integer_bitand:
+	  integer_eq
+	| integer_bitand '&' integer_eq { $$ = $1 & $3; }
+	;
+
+integer_eq:
+	  integer_rela
+	| integer_eq DT_EQ integer_rela { $$ = $1 == $3; }
+	| integer_eq DT_NE integer_rela { $$ = $1 != $3; }
+	;
+
+integer_rela:
+	  integer_shift
+	| integer_rela '<' integer_shift { $$ = $1 < $3; }
+	| integer_rela '>' integer_shift { $$ = $1 > $3; }
+	| integer_rela DT_LE integer_shift { $$ = $1 <= $3; }
+	| integer_rela DT_GE integer_shift { $$ = $1 >= $3; }
+	;
+
+integer_shift:
+	  integer_shift DT_LSHIFT integer_add { $$ = ($3 < 64) ? ($1 << $3) : 0; }
+	| integer_shift DT_RSHIFT integer_add { $$ = ($3 < 64) ? ($1 >> $3) : 0; }
+	| integer_add
+	;
+
+integer_add:
+	  integer_add '+' integer_mul { $$ = $1 + $3; }
+	| integer_add '-' integer_mul { $$ = $1 - $3; }
+	| integer_mul
+	;
+
+integer_mul:
+	  integer_mul '*' integer_unary { $$ = $1 * $3; }
+	| integer_mul '/' integer_unary
+		{
+			if ($3 != 0) {
+				$$ = $1 / $3;
+			} else {
+				ERROR(&@$, "Division by zero");
+				$$ = 0;
+			}
+		}
+	| integer_mul '%' integer_unary
+		{
+			if ($3 != 0) {
+				$$ = $1 % $3;
+			} else {
+				ERROR(&@$, "Division by zero");
+				$$ = 0;
+			}
+		}
+	| integer_unary
+	;
+
+integer_unary:
+	  integer_prim
+	| '-' integer_unary { $$ = -$2; }
+	| '~' integer_unary { $$ = ~$2; }
+	| '!' integer_unary { $$ = !$2; }
+	;
+
+bytestring:
+	  /* empty */
+		{
+			$$ = data_add_marker(empty_data, TYPE_UINT8, NULL);
+		}
+	| bytestring DT_BYTE
+		{
+			$$ = data_append_byte($1, $2);
+		}
+	| bytestring DT_LABEL
+		{
+			$$ = data_add_marker($1, LABEL, $2);
+		}
+	;
+
+subnodes:
+	  /* empty */
+		{
+			$$ = NULL;
+		}
+	| subnode subnodes
+		{
+			$$ = chain_node($1, $2);
+		}
+	| subnode propdef
+		{
+			ERROR(&@2, "Properties must precede subnodes");
+			YYERROR;
+		}
+	;
+
+subnode:
+	  DT_PROPNODENAME nodedef
+		{
+			$$ = name_node($2, $1);
+		}
+	| DT_DEL_NODE DT_PROPNODENAME ';'
+		{
+			$$ = name_node(build_node_delete(&@$), $2);
+		}
+	| DT_OMIT_NO_REF subnode
+		{
+			$$ = omit_node_if_unused($2);
+		}
+	| DT_LABEL subnode
+		{
+			add_label(&$2->labels, $1);
+			$$ = $2;
+		}
+	;
+
+%%
+
+void yyerror(char const *s)
+{
+	ERROR(&yylloc, "%s", s);
+}
diff --git a/dtc/dtc.c b/dtc/dtc.c
new file mode 100644
index 0000000..3962d3f
--- /dev/null
+++ b/dtc/dtc.c
@@ -0,0 +1,371 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include <sys/stat.h>
+
+#include "dtc.h"
+#include "srcpos.h"
+
+/*
+ * Command line options
+ */
+int quiet;		/* Level of quietness */
+int reservenum;		/* Number of memory reservation slots */
+int minsize;		/* Minimum blob size */
+int padsize;		/* Additional padding to blob */
+int alignsize;		/* Additional padding to blob accroding to the alignsize */
+int phandle_format = PHANDLE_EPAPR;	/* Use linux,phandle or phandle properties */
+int generate_symbols;	/* enable symbols & fixup support */
+int generate_fixups;		/* suppress generation of fixups on symbol support */
+int auto_label_aliases;		/* auto generate labels -> aliases */
+int annotate;		/* Level of annotation: 1 for input source location
+			   >1 for full input source location. */
+
+static int is_power_of_2(int x)
+{
+	return (x > 0) && ((x & (x - 1)) == 0);
+}
+
+static void fill_fullpaths(struct node *tree, const char *prefix)
+{
+	struct node *child;
+	const char *unit;
+
+	tree->fullpath = join_path(prefix, tree->name);
+
+	unit = strchr(tree->name, '@');
+	if (unit)
+		tree->basenamelen = unit - tree->name;
+	else
+		tree->basenamelen = strlen(tree->name);
+
+	for_each_child(tree, child)
+		fill_fullpaths(child, tree->fullpath);
+}
+
+/* Usage related data. */
+static const char usage_synopsis[] = "dtc [options] <input file>";
+static const char usage_short_opts[] = "qI:O:o:V:d:R:S:p:a:fb:i:H:sW:E:@AThv";
+static struct option const usage_long_opts[] = {
+	{"quiet",            no_argument, NULL, 'q'},
+	{"in-format",         a_argument, NULL, 'I'},
+	{"out",               a_argument, NULL, 'o'},
+	{"out-format",        a_argument, NULL, 'O'},
+	{"out-version",       a_argument, NULL, 'V'},
+	{"out-dependency",    a_argument, NULL, 'd'},
+	{"reserve",           a_argument, NULL, 'R'},
+	{"space",             a_argument, NULL, 'S'},
+	{"pad",               a_argument, NULL, 'p'},
+	{"align",             a_argument, NULL, 'a'},
+	{"boot-cpu",          a_argument, NULL, 'b'},
+	{"force",            no_argument, NULL, 'f'},
+	{"include",           a_argument, NULL, 'i'},
+	{"sort",             no_argument, NULL, 's'},
+	{"phandle",           a_argument, NULL, 'H'},
+	{"warning",           a_argument, NULL, 'W'},
+	{"error",             a_argument, NULL, 'E'},
+	{"symbols",	     no_argument, NULL, '@'},
+	{"auto-alias",       no_argument, NULL, 'A'},
+	{"annotate",         no_argument, NULL, 'T'},
+	{"help",             no_argument, NULL, 'h'},
+	{"version",          no_argument, NULL, 'v'},
+	{NULL,               no_argument, NULL, 0x0},
+};
+static const char * const usage_opts_help[] = {
+	"\n\tQuiet: -q suppress warnings, -qq errors, -qqq all",
+	"\n\tInput formats are:\n"
+	 "\t\tdts - device tree source text\n"
+	 "\t\tdtb - device tree blob\n"
+	 "\t\tfs  - /proc/device-tree style directory",
+	"\n\tOutput file",
+	"\n\tOutput formats are:\n"
+	 "\t\tdts - device tree source text\n"
+	 "\t\tdtb - device tree blob\n"
+#ifndef NO_YAML
+	 "\t\tyaml - device tree encoded as YAML\n"
+#endif
+	 "\t\tasm - assembler source",
+	"\n\tBlob version to produce, defaults to "stringify(DEFAULT_FDT_VERSION)" (for dtb and asm output)",
+	"\n\tOutput dependency file",
+	"\n\tMake space for <number> reserve map entries (for dtb and asm output)",
+	"\n\tMake the blob at least <bytes> long (extra space)",
+	"\n\tAdd padding to the blob of <bytes> long (extra space)",
+	"\n\tMake the blob align to the <bytes> (extra space)",
+	"\n\tSet the physical boot cpu",
+	"\n\tTry to produce output even if the input tree has errors",
+	"\n\tAdd a path to search for include files",
+	"\n\tSort nodes and properties before outputting (useful for comparing trees)",
+	"\n\tValid phandle formats are:\n"
+	 "\t\tlegacy - \"linux,phandle\" properties only\n"
+	 "\t\tepapr  - \"phandle\" properties only\n"
+	 "\t\tboth   - Both \"linux,phandle\" and \"phandle\" properties",
+	"\n\tEnable/disable warnings (prefix with \"no-\")",
+	"\n\tEnable/disable errors (prefix with \"no-\")",
+	"\n\tEnable generation of symbols",
+	"\n\tEnable auto-alias of labels",
+	"\n\tAnnotate output .dts with input source file and line (-T -T for more details)",
+	"\n\tPrint this help and exit",
+	"\n\tPrint version and exit",
+	NULL,
+};
+
+static const char *guess_type_by_name(const char *fname, const char *fallback)
+{
+	const char *s;
+
+	s = strrchr(fname, '.');
+	if (s == NULL)
+		return fallback;
+	if (!strcasecmp(s, ".dts"))
+		return "dts";
+	if (!strcasecmp(s, ".yaml"))
+		return "yaml";
+	if (!strcasecmp(s, ".dtbo"))
+		return "dtb";
+	if (!strcasecmp(s, ".dtb"))
+		return "dtb";
+	return fallback;
+}
+
+static const char *guess_input_format(const char *fname, const char *fallback)
+{
+	struct stat statbuf;
+	fdt32_t magic;
+	FILE *f;
+
+	if (stat(fname, &statbuf) != 0)
+		return fallback;
+
+	if (S_ISDIR(statbuf.st_mode))
+		return "fs";
+
+	if (!S_ISREG(statbuf.st_mode))
+		return fallback;
+
+	f = fopen(fname, "r");
+	if (f == NULL)
+		return fallback;
+	if (fread(&magic, 4, 1, f) != 1) {
+		fclose(f);
+		return fallback;
+	}
+	fclose(f);
+
+	if (fdt32_to_cpu(magic) == FDT_MAGIC)
+		return "dtb";
+
+	return guess_type_by_name(fname, fallback);
+}
+
+int main(int argc, char *argv[])
+{
+	struct dt_info *dti;
+	const char *inform = NULL;
+	const char *outform = NULL;
+	const char *outname = "-";
+	const char *depname = NULL;
+	bool force = false, sort = false;
+	const char *arg;
+	int opt;
+	FILE *outf = NULL;
+	int outversion = DEFAULT_FDT_VERSION;
+	long long cmdline_boot_cpuid = -1;
+
+	quiet      = 0;
+	reservenum = 0;
+	minsize    = 0;
+	padsize    = 0;
+	alignsize  = 0;
+
+	while ((opt = util_getopt_long()) != EOF) {
+		switch (opt) {
+		case 'I':
+			inform = optarg;
+			break;
+		case 'O':
+			outform = optarg;
+			break;
+		case 'o':
+			outname = optarg;
+			break;
+		case 'V':
+			outversion = strtol(optarg, NULL, 0);
+			break;
+		case 'd':
+			depname = optarg;
+			break;
+		case 'R':
+			reservenum = strtol(optarg, NULL, 0);
+			break;
+		case 'S':
+			minsize = strtol(optarg, NULL, 0);
+			break;
+		case 'p':
+			padsize = strtol(optarg, NULL, 0);
+			break;
+		case 'a':
+			alignsize = strtol(optarg, NULL, 0);
+			if (!is_power_of_2(alignsize))
+				die("Invalid argument \"%d\" to -a option\n",
+				    alignsize);
+			break;
+		case 'f':
+			force = true;
+			break;
+		case 'q':
+			quiet++;
+			break;
+		case 'b':
+			cmdline_boot_cpuid = strtoll(optarg, NULL, 0);
+			break;
+		case 'i':
+			srcfile_add_search_path(optarg);
+			break;
+		case 'v':
+			util_version();
+		case 'H':
+			if (streq(optarg, "legacy"))
+				phandle_format = PHANDLE_LEGACY;
+			else if (streq(optarg, "epapr"))
+				phandle_format = PHANDLE_EPAPR;
+			else if (streq(optarg, "both"))
+				phandle_format = PHANDLE_BOTH;
+			else
+				die("Invalid argument \"%s\" to -H option\n",
+				    optarg);
+			break;
+
+		case 's':
+			sort = true;
+			break;
+
+		case 'W':
+			parse_checks_option(true, false, optarg);
+			break;
+
+		case 'E':
+			parse_checks_option(false, true, optarg);
+			break;
+
+		case '@':
+			generate_symbols = 1;
+			break;
+		case 'A':
+			auto_label_aliases = 1;
+			break;
+		case 'T':
+			annotate++;
+			break;
+
+		case 'h':
+			usage(NULL);
+		default:
+			usage("unknown option");
+		}
+	}
+
+	if (argc > (optind+1))
+		usage("missing files");
+	else if (argc < (optind+1))
+		arg = "-";
+	else
+		arg = argv[optind];
+
+	/* minsize and padsize are mutually exclusive */
+	if (minsize && padsize)
+		die("Can't set both -p and -S\n");
+
+	if (depname) {
+		depfile = fopen(depname, "w");
+		if (!depfile)
+			die("Couldn't open dependency file %s: %s\n", depname,
+			    strerror(errno));
+		fprintf(depfile, "%s:", outname);
+	}
+
+	if (inform == NULL)
+		inform = guess_input_format(arg, "dts");
+	if (outform == NULL) {
+		outform = guess_type_by_name(outname, NULL);
+		if (outform == NULL) {
+			if (streq(inform, "dts"))
+				outform = "dtb";
+			else
+				outform = "dts";
+		}
+	}
+	if (annotate && (!streq(inform, "dts") || !streq(outform, "dts")))
+		die("--annotate requires -I dts -O dts\n");
+	if (streq(inform, "dts"))
+		dti = dt_from_source(arg);
+	else if (streq(inform, "fs"))
+		dti = dt_from_fs(arg);
+	else if(streq(inform, "dtb"))
+		dti = dt_from_blob(arg);
+	else
+		die("Unknown input format \"%s\"\n", inform);
+
+	dti->outname = outname;
+
+	if (depfile) {
+		fputc('\n', depfile);
+		fclose(depfile);
+	}
+
+	if (cmdline_boot_cpuid != -1)
+		dti->boot_cpuid_phys = cmdline_boot_cpuid;
+
+	fill_fullpaths(dti->dt, "");
+
+	/* on a plugin, generate by default */
+	if (dti->dtsflags & DTSF_PLUGIN) {
+		generate_fixups = 1;
+	}
+
+	process_checks(force, dti);
+
+	if (auto_label_aliases)
+		generate_label_tree(dti, "aliases", false);
+
+	if (generate_symbols)
+		generate_label_tree(dti, "__symbols__", true);
+
+	if (generate_fixups) {
+		generate_fixups_tree(dti, "__fixups__");
+		generate_local_fixups_tree(dti, "__local_fixups__");
+	}
+
+	if (sort)
+		sort_tree(dti);
+
+	if (streq(outname, "-")) {
+		outf = stdout;
+	} else {
+		outf = fopen(outname, "wb");
+		if (! outf)
+			die("Couldn't open output file %s: %s\n",
+			    outname, strerror(errno));
+	}
+
+	if (streq(outform, "dts")) {
+		dt_to_source(outf, dti);
+#ifndef NO_YAML
+	} else if (streq(outform, "yaml")) {
+		if (!streq(inform, "dts"))
+			die("YAML output format requires dts input format\n");
+		dt_to_yaml(outf, dti);
+#endif
+	} else if (streq(outform, "dtb")) {
+		dt_to_blob(outf, dti, outversion);
+	} else if (streq(outform, "asm")) {
+		dt_to_asm(outf, dti, outversion);
+	} else if (streq(outform, "null")) {
+		/* do nothing */
+	} else {
+		die("Unknown output format \"%s\"\n", outform);
+	}
+
+	exit(0);
+}
diff --git a/dtc/dtc.h b/dtc/dtc.h
new file mode 100644
index 0000000..6296361
--- /dev/null
+++ b/dtc/dtc.h
@@ -0,0 +1,342 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef DTC_H
+#define DTC_H
+
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#include <libfdt_env.h>
+#include <fdt.h>
+
+#include "util.h"
+
+#ifdef DEBUG
+#define debug(...)	printf(__VA_ARGS__)
+#else
+#define debug(...)
+#endif
+
+#define DEFAULT_FDT_VERSION	17
+
+/*
+ * Command line options
+ */
+extern int quiet;		/* Level of quietness */
+extern int reservenum;		/* Number of memory reservation slots */
+extern int minsize;		/* Minimum blob size */
+extern int padsize;		/* Additional padding to blob */
+extern int alignsize;		/* Additional padding to blob accroding to the alignsize */
+extern int phandle_format;	/* Use linux,phandle or phandle properties */
+extern int generate_symbols;	/* generate symbols for nodes with labels */
+extern int generate_fixups;	/* generate fixups */
+extern int auto_label_aliases;	/* auto generate labels -> aliases */
+extern int annotate;		/* annotate .dts with input source location */
+
+#define PHANDLE_LEGACY	0x1
+#define PHANDLE_EPAPR	0x2
+#define PHANDLE_BOTH	0x3
+
+typedef uint32_t cell_t;
+
+static inline uint16_t dtb_ld16(const void *p)
+{
+	const uint8_t *bp = (const uint8_t *)p;
+
+	return ((uint16_t)bp[0] << 8)
+		| bp[1];
+}
+
+static inline uint32_t dtb_ld32(const void *p)
+{
+	const uint8_t *bp = (const uint8_t *)p;
+
+	return ((uint32_t)bp[0] << 24)
+		| ((uint32_t)bp[1] << 16)
+		| ((uint32_t)bp[2] << 8)
+		| bp[3];
+}
+
+static inline uint64_t dtb_ld64(const void *p)
+{
+	const uint8_t *bp = (const uint8_t *)p;
+
+	return ((uint64_t)bp[0] << 56)
+		| ((uint64_t)bp[1] << 48)
+		| ((uint64_t)bp[2] << 40)
+		| ((uint64_t)bp[3] << 32)
+		| ((uint64_t)bp[4] << 24)
+		| ((uint64_t)bp[5] << 16)
+		| ((uint64_t)bp[6] << 8)
+		| bp[7];
+}
+
+#define streq(a, b)	(strcmp((a), (b)) == 0)
+#define strstarts(s, prefix)	(strncmp((s), (prefix), strlen(prefix)) == 0)
+#define strprefixeq(a, n, b)	(strlen(b) == (n) && (memcmp(a, b, n) == 0))
+static inline bool strends(const char *str, const char *suffix)
+{
+	unsigned int len, suffix_len;
+
+	len = strlen(str);
+	suffix_len = strlen(suffix);
+	if (len < suffix_len)
+		return false;
+	return streq(str + len - suffix_len, suffix);
+}
+
+#define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
+
+/* Data blobs */
+enum markertype {
+	TYPE_NONE,
+	REF_PHANDLE,
+	REF_PATH,
+	LABEL,
+	TYPE_UINT8,
+	TYPE_UINT16,
+	TYPE_UINT32,
+	TYPE_UINT64,
+	TYPE_STRING,
+};
+extern const char *markername(enum markertype markertype);
+
+struct  marker {
+	enum markertype type;
+	unsigned int offset;
+	char *ref;
+	struct marker *next;
+};
+
+struct data {
+	unsigned int len;
+	char *val;
+	struct marker *markers;
+};
+
+
+#define empty_data ((struct data){ 0 /* all .members = 0 or NULL */ })
+
+#define for_each_marker(m) \
+	for (; (m); (m) = (m)->next)
+#define for_each_marker_of_type(m, t) \
+	for_each_marker(m) \
+		if ((m)->type == (t))
+
+size_t type_marker_length(struct marker *m);
+
+void data_free(struct data d);
+
+struct data data_grow_for(struct data d, unsigned int xlen);
+
+struct data data_copy_mem(const char *mem, int len);
+struct data data_copy_escape_string(const char *s, int len);
+struct data data_copy_file(FILE *f, size_t len);
+
+struct data data_append_data(struct data d, const void *p, int len);
+struct data data_insert_at_marker(struct data d, struct marker *m,
+				  const void *p, int len);
+struct data data_merge(struct data d1, struct data d2);
+struct data data_append_cell(struct data d, cell_t word);
+struct data data_append_integer(struct data d, uint64_t word, int bits);
+struct data data_append_re(struct data d, uint64_t address, uint64_t size);
+struct data data_append_addr(struct data d, uint64_t addr);
+struct data data_append_byte(struct data d, uint8_t byte);
+struct data data_append_zeroes(struct data d, int len);
+struct data data_append_align(struct data d, int align);
+
+struct data data_add_marker(struct data d, enum markertype type, char *ref);
+
+bool data_is_one_string(struct data d);
+
+/* DT constraints */
+
+#define MAX_PROPNAME_LEN	31
+#define MAX_NODENAME_LEN	31
+
+/* Live trees */
+struct label {
+	bool deleted;
+	char *label;
+	struct label *next;
+};
+
+struct bus_type {
+	const char *name;
+};
+
+struct property {
+	bool deleted;
+	char *name;
+	struct data val;
+
+	struct property *next;
+
+	struct label *labels;
+	struct srcpos *srcpos;
+};
+
+struct node {
+	bool deleted;
+	char *name;
+	struct property *proplist;
+	struct node *children;
+
+	struct node *parent;
+	struct node *next_sibling;
+
+	char *fullpath;
+	int basenamelen;
+
+	cell_t phandle;
+	int addr_cells, size_cells;
+
+	struct label *labels;
+	const struct bus_type *bus;
+	struct srcpos *srcpos;
+
+	bool omit_if_unused, is_referenced;
+};
+
+#define for_each_label_withdel(l0, l) \
+	for ((l) = (l0); (l); (l) = (l)->next)
+
+#define for_each_label(l0, l) \
+	for_each_label_withdel(l0, l) \
+		if (!(l)->deleted)
+
+#define for_each_property_withdel(n, p) \
+	for ((p) = (n)->proplist; (p); (p) = (p)->next)
+
+#define for_each_property(n, p) \
+	for_each_property_withdel(n, p) \
+		if (!(p)->deleted)
+
+#define for_each_child_withdel(n, c) \
+	for ((c) = (n)->children; (c); (c) = (c)->next_sibling)
+
+#define for_each_child(n, c) \
+	for_each_child_withdel(n, c) \
+		if (!(c)->deleted)
+
+void add_label(struct label **labels, char *label);
+void delete_labels(struct label **labels);
+
+struct property *build_property(char *name, struct data val,
+				struct srcpos *srcpos);
+struct property *build_property_delete(char *name);
+struct property *chain_property(struct property *first, struct property *list);
+struct property *reverse_properties(struct property *first);
+
+struct node *build_node(struct property *proplist, struct node *children,
+			struct srcpos *srcpos);
+struct node *build_node_delete(struct srcpos *srcpos);
+struct node *name_node(struct node *node, char *name);
+struct node *omit_node_if_unused(struct node *node);
+struct node *reference_node(struct node *node);
+struct node *chain_node(struct node *first, struct node *list);
+struct node *merge_nodes(struct node *old_node, struct node *new_node);
+struct node *add_orphan_node(struct node *old_node, struct node *new_node, char *ref);
+
+void add_property(struct node *node, struct property *prop);
+void delete_property_by_name(struct node *node, char *name);
+void delete_property(struct property *prop);
+void add_child(struct node *parent, struct node *child);
+void delete_node_by_name(struct node *parent, char *name);
+void delete_node(struct node *node);
+void append_to_property(struct node *node,
+			char *name, const void *data, int len,
+			enum markertype type);
+
+const char *get_unitname(struct node *node);
+struct property *get_property(struct node *node, const char *propname);
+cell_t propval_cell(struct property *prop);
+cell_t propval_cell_n(struct property *prop, unsigned int n);
+struct property *get_property_by_label(struct node *tree, const char *label,
+				       struct node **node);
+struct marker *get_marker_label(struct node *tree, const char *label,
+				struct node **node, struct property **prop);
+struct node *get_subnode(struct node *node, const char *nodename);
+struct node *get_node_by_path(struct node *tree, const char *path);
+struct node *get_node_by_label(struct node *tree, const char *label);
+struct node *get_node_by_phandle(struct node *tree, cell_t phandle);
+struct node *get_node_by_ref(struct node *tree, const char *ref);
+cell_t get_node_phandle(struct node *root, struct node *node);
+
+uint32_t guess_boot_cpuid(struct node *tree);
+
+/* Boot info (tree plus memreserve information */
+
+struct reserve_info {
+	uint64_t address, size;
+
+	struct reserve_info *next;
+
+	struct label *labels;
+};
+
+struct reserve_info *build_reserve_entry(uint64_t start, uint64_t len);
+struct reserve_info *chain_reserve_entry(struct reserve_info *first,
+					 struct reserve_info *list);
+struct reserve_info *add_reserve_entry(struct reserve_info *list,
+				       struct reserve_info *new);
+
+
+struct dt_info {
+	unsigned int dtsflags;
+	struct reserve_info *reservelist;
+	uint32_t boot_cpuid_phys;
+	struct node *dt;		/* the device tree */
+	const char *outname;		/* filename being written to, "-" for stdout */
+};
+
+/* DTS version flags definitions */
+#define DTSF_V1		0x0001	/* /dts-v1/ */
+#define DTSF_PLUGIN	0x0002	/* /plugin/ */
+
+struct dt_info *build_dt_info(unsigned int dtsflags,
+			      struct reserve_info *reservelist,
+			      struct node *tree, uint32_t boot_cpuid_phys);
+void sort_tree(struct dt_info *dti);
+void generate_label_tree(struct dt_info *dti, char *name, bool allocph);
+void generate_fixups_tree(struct dt_info *dti, char *name);
+void generate_local_fixups_tree(struct dt_info *dti, char *name);
+
+/* Checks */
+
+void parse_checks_option(bool warn, bool error, const char *arg);
+void process_checks(bool force, struct dt_info *dti);
+
+/* Flattened trees */
+
+void dt_to_blob(FILE *f, struct dt_info *dti, int version);
+void dt_to_asm(FILE *f, struct dt_info *dti, int version);
+
+struct dt_info *dt_from_blob(const char *fname);
+
+/* Tree source */
+
+void dt_to_source(FILE *f, struct dt_info *dti);
+struct dt_info *dt_from_source(const char *f);
+
+/* YAML source */
+
+void dt_to_yaml(FILE *f, struct dt_info *dti);
+
+/* FS trees */
+
+struct dt_info *dt_from_fs(const char *dirname);
+
+#endif /* DTC_H */
diff --git a/dtc/dtdiff b/dtc/dtdiff
new file mode 100644
index 0000000..cdbf079
--- /dev/null
+++ b/dtc/dtdiff
@@ -0,0 +1,39 @@
+#! /bin/bash
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+# This script uses the bash <(...) extension.
+# If you want to change this to work with a generic /bin/sh, make sure
+# you fix that.
+
+
+DTC=dtc
+
+source_and_sort () {
+    DT="$1"
+    if [ -d "$DT" ]; then
+	IFORMAT=fs
+    elif [ -f "$DT" ]; then
+	case "$DT" in
+	    *.dts)
+		IFORMAT=dts
+		;;
+	    *.dtb)
+		IFORMAT=dtb
+		;;
+	esac
+    fi
+
+    if [ -z "$IFORMAT" ]; then
+	echo "Unrecognized format for $DT" >&2
+	exit 2
+    fi
+
+    $DTC -I $IFORMAT -O dts -qq -f -s -o - "$DT"
+}
+
+if [ $# != 2 ]; then
+    echo "Usage: dtdiff <device tree> <device tree>" >&2
+    exit 1
+fi
+
+diff -u <(source_and_sort "$1") <(source_and_sort "$2")
diff --git a/dtc/fdtdump.c b/dtc/fdtdump.c
new file mode 100644
index 0000000..d9fb374
--- /dev/null
+++ b/dtc/fdtdump.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * fdtdump.c - Contributed by Pantelis Antoniou <pantelis.antoniou AT gmail.com>
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <inttypes.h>
+
+#include <libfdt.h>
+#include <libfdt_env.h>
+#include <fdt.h>
+
+#include "util.h"
+
+#define FDT_MAGIC_SIZE	4
+#define MAX_VERSION 17
+
+#define ALIGN(x, a)	(((x) + ((a) - 1)) & ~((a) - 1))
+#define PALIGN(p, a)	((void *)(ALIGN((unsigned long)(p), (a))))
+#define GET_CELL(p)	(p += 4, *((const fdt32_t *)(p-4)))
+
+static const char *tagname(uint32_t tag)
+{
+	static const char * const names[] = {
+#define TN(t) [t] = #t
+		TN(FDT_BEGIN_NODE),
+		TN(FDT_END_NODE),
+		TN(FDT_PROP),
+		TN(FDT_NOP),
+		TN(FDT_END),
+#undef TN
+	};
+	if (tag < ARRAY_SIZE(names))
+		if (names[tag])
+			return names[tag];
+	return "FDT_???";
+}
+
+#define dumpf(fmt, args...) \
+	do { if (debug) printf("// " fmt, ## args); } while (0)
+
+static void dump_blob(void *blob, bool debug)
+{
+	uintptr_t blob_off = (uintptr_t)blob;
+	struct fdt_header *bph = blob;
+	uint32_t off_mem_rsvmap = fdt32_to_cpu(bph->off_mem_rsvmap);
+	uint32_t off_dt = fdt32_to_cpu(bph->off_dt_struct);
+	uint32_t off_str = fdt32_to_cpu(bph->off_dt_strings);
+	struct fdt_reserve_entry *p_rsvmap =
+		(struct fdt_reserve_entry *)((char *)blob + off_mem_rsvmap);
+	const char *p_struct = (const char *)blob + off_dt;
+	const char *p_strings = (const char *)blob + off_str;
+	uint32_t version = fdt32_to_cpu(bph->version);
+	uint32_t totalsize = fdt32_to_cpu(bph->totalsize);
+	uint32_t tag;
+	const char *p, *s, *t;
+	int depth, sz, shift;
+	int i;
+	uint64_t addr, size;
+
+	depth = 0;
+	shift = 4;
+
+	printf("/dts-v1/;\n");
+	printf("// magic:\t\t0x%"PRIx32"\n", fdt32_to_cpu(bph->magic));
+	printf("// totalsize:\t\t0x%"PRIx32" (%"PRIu32")\n",
+	       totalsize, totalsize);
+	printf("// off_dt_struct:\t0x%"PRIx32"\n", off_dt);
+	printf("// off_dt_strings:\t0x%"PRIx32"\n", off_str);
+	printf("// off_mem_rsvmap:\t0x%"PRIx32"\n", off_mem_rsvmap);
+	printf("// version:\t\t%"PRIu32"\n", version);
+	printf("// last_comp_version:\t%"PRIu32"\n",
+	       fdt32_to_cpu(bph->last_comp_version));
+	if (version >= 2)
+		printf("// boot_cpuid_phys:\t0x%"PRIx32"\n",
+		       fdt32_to_cpu(bph->boot_cpuid_phys));
+
+	if (version >= 3)
+		printf("// size_dt_strings:\t0x%"PRIx32"\n",
+		       fdt32_to_cpu(bph->size_dt_strings));
+	if (version >= 17)
+		printf("// size_dt_struct:\t0x%"PRIx32"\n",
+		       fdt32_to_cpu(bph->size_dt_struct));
+	printf("\n");
+
+	for (i = 0; ; i++) {
+		addr = fdt64_to_cpu(p_rsvmap[i].address);
+		size = fdt64_to_cpu(p_rsvmap[i].size);
+		if (addr == 0 && size == 0)
+			break;
+
+		printf("/memreserve/ %#"PRIx64" %#"PRIx64";\n",
+		       addr, size);
+	}
+
+	p = p_struct;
+	while ((tag = fdt32_to_cpu(GET_CELL(p))) != FDT_END) {
+
+		dumpf("%04"PRIxPTR": tag: 0x%08"PRIx32" (%s)\n",
+		        (uintptr_t)p - blob_off - 4, tag, tagname(tag));
+
+		if (tag == FDT_BEGIN_NODE) {
+			s = p;
+			p = PALIGN(p + strlen(s) + 1, 4);
+
+			if (*s == '\0')
+				s = "/";
+
+			printf("%*s%s {\n", depth * shift, "", s);
+
+			depth++;
+			continue;
+		}
+
+		if (tag == FDT_END_NODE) {
+			depth--;
+
+			printf("%*s};\n", depth * shift, "");
+			continue;
+		}
+
+		if (tag == FDT_NOP) {
+			printf("%*s// [NOP]\n", depth * shift, "");
+			continue;
+		}
+
+		if (tag != FDT_PROP) {
+			fprintf(stderr, "%*s ** Unknown tag 0x%08"PRIx32"\n", depth * shift, "", tag);
+			break;
+		}
+		sz = fdt32_to_cpu(GET_CELL(p));
+		s = p_strings + fdt32_to_cpu(GET_CELL(p));
+		if (version < 16 && sz >= 8)
+			p = PALIGN(p, 8);
+		t = p;
+
+		p = PALIGN(p + sz, 4);
+
+		dumpf("%04"PRIxPTR": string: %s\n", (uintptr_t)s - blob_off, s);
+		dumpf("%04"PRIxPTR": value\n", (uintptr_t)t - blob_off);
+		printf("%*s%s", depth * shift, "", s);
+		utilfdt_print_data(t, sz);
+		printf(";\n");
+	}
+}
+
+/* Usage related data. */
+static const char usage_synopsis[] = "fdtdump [options] <file>";
+static const char usage_short_opts[] = "ds" USAGE_COMMON_SHORT_OPTS;
+static struct option const usage_long_opts[] = {
+	{"debug",            no_argument, NULL, 'd'},
+	{"scan",             no_argument, NULL, 's'},
+	USAGE_COMMON_LONG_OPTS
+};
+static const char * const usage_opts_help[] = {
+	"Dump debug information while decoding the file",
+	"Scan for an embedded fdt in file",
+	USAGE_COMMON_OPTS_HELP
+};
+
+static bool valid_header(char *p, off_t len)
+{
+	if (len < sizeof(struct fdt_header) ||
+	    fdt_magic(p) != FDT_MAGIC ||
+	    fdt_version(p) > MAX_VERSION ||
+	    fdt_last_comp_version(p) > MAX_VERSION ||
+	    fdt_totalsize(p) >= len ||
+	    fdt_off_dt_struct(p) >= len ||
+	    fdt_off_dt_strings(p) >= len)
+		return 0;
+	else
+		return 1;
+}
+
+int main(int argc, char *argv[])
+{
+	int opt;
+	const char *file;
+	char *buf;
+	bool debug = false;
+	bool scan = false;
+	size_t len;
+
+	fprintf(stderr, "\n"
+"**** fdtdump is a low-level debugging tool, not meant for general use.\n"
+"**** If you want to decompile a dtb, you probably want\n"
+"****     dtc -I dtb -O dts <filename>\n\n"
+		);
+	while ((opt = util_getopt_long()) != EOF) {
+		switch (opt) {
+		case_USAGE_COMMON_FLAGS
+
+		case 'd':
+			debug = true;
+			break;
+		case 's':
+			scan = true;
+			break;
+		}
+	}
+	if (optind != argc - 1)
+		usage("missing input filename");
+	file = argv[optind];
+
+	buf = utilfdt_read(file, &len);
+	if (!buf)
+		die("could not read: %s\n", file);
+
+	/* try and locate an embedded fdt in a bigger blob */
+	if (scan) {
+		unsigned char smagic[FDT_MAGIC_SIZE];
+		char *p = buf;
+		char *endp = buf + len;
+
+		fdt32_st(smagic, FDT_MAGIC);
+
+		/* poor man's memmem */
+		while ((endp - p) >= FDT_MAGIC_SIZE) {
+			p = memchr(p, smagic[0], endp - p - FDT_MAGIC_SIZE);
+			if (!p)
+				break;
+			if (fdt_magic(p) == FDT_MAGIC) {
+				/* try and validate the main struct */
+				off_t this_len = endp - p;
+				if (valid_header(p, this_len))
+					break;
+				if (debug)
+					printf("%s: skipping fdt magic at offset %#tx\n",
+						file, p - buf);
+			}
+			++p;
+		}
+		if (!p || endp - p < sizeof(struct fdt_header))
+			die("%s: could not locate fdt magic\n", file);
+		printf("%s: found fdt at offset %#tx\n", file, p - buf);
+		buf = p;
+	} else if (!valid_header(buf, len))
+		die("%s: header is not valid\n", file);
+
+	dump_blob(buf, debug);
+
+	return 0;
+}
diff --git a/dtc/fdtget.c b/dtc/fdtget.c
new file mode 100644
index 0000000..777582e
--- /dev/null
+++ b/dtc/fdtget.c
@@ -0,0 +1,369 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ *
+ * Portions from U-Boot cmd_fdt.c (C) Copyright 2007
+ * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ * Based on code written by:
+ *   Pantelis Antoniou <pantelis.antoniou@gmail.com> and
+ *   Matthew McClintock <msm@freescale.com>
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libfdt.h>
+
+#include "util.h"
+
+enum display_mode {
+	MODE_SHOW_VALUE,	/* show values for node properties */
+	MODE_LIST_PROPS,	/* list the properties for a node */
+	MODE_LIST_SUBNODES,	/* list the subnodes of a node */
+};
+
+/* Holds information which controls our output and options */
+struct display_info {
+	int type;		/* data type (s/i/u/x or 0 for default) */
+	int size;		/* data size (1/2/4) */
+	enum display_mode mode;	/* display mode that we are using */
+	const char *default_val; /* default value if node/property not found */
+};
+
+static void report_error(const char *where, int err)
+{
+	fprintf(stderr, "Error at '%s': %s\n", where, fdt_strerror(err));
+}
+
+/**
+ * Shows a list of cells in the requested format
+ *
+ * @param disp		Display information / options
+ * @param data		Data to display
+ * @param len		Maximum length of buffer
+ * @param size		Data size to use for display (e.g. 4 for 32-bit)
+ * @return 0 if ok, -1 on error
+ */
+static int show_cell_list(struct display_info *disp, const char *data, int len,
+			  int size)
+{
+	const uint8_t *p = (const uint8_t *)data;
+	char fmt[3];
+	int value;
+	int i;
+
+	fmt[0] = '%';
+	fmt[1] = disp->type ? disp->type : 'd';
+	fmt[2] = '\0';
+	for (i = 0; i < len; i += size, p += size) {
+		if (i)
+			printf(" ");
+		value = size == 4 ? fdt32_ld((const fdt32_t *)p) :
+			size == 2 ? (*p << 8) | p[1] : *p;
+		printf(fmt, value);
+	}
+
+	return 0;
+}
+
+/**
+ * Displays data of a given length according to selected options
+ *
+ * If a specific data type is provided in disp, then this is used. Otherwise
+ * we try to guess the data type / size from the contents.
+ *
+ * @param disp		Display information / options
+ * @param data		Data to display
+ * @param len		Maximum length of buffer
+ * @return 0 if ok, -1 if data does not match format
+ */
+static int show_data(struct display_info *disp, const char *data, int len)
+{
+	int size;
+	const char *s;
+	int is_string;
+
+	/* no data, don't print */
+	if (len == 0)
+		return 0;
+
+	is_string = (disp->type) == 's' ||
+		(!disp->type && util_is_printable_string(data, len));
+	if (is_string) {
+		if (data[len - 1] != '\0') {
+			fprintf(stderr, "Unterminated string\n");
+			return -1;
+		}
+		for (s = data; s - data < len; s += strlen(s) + 1) {
+			if (s != data)
+				printf(" ");
+			printf("%s", (const char *)s);
+		}
+		return 0;
+	}
+	size = disp->size;
+	if (size == -1) {
+		size = (len % 4) == 0 ? 4 : 1;
+	} else if (len % size) {
+		fprintf(stderr, "Property length must be a multiple of "
+				"selected data size\n");
+		return -1;
+	}
+
+	return show_cell_list(disp, data, len, size);
+}
+
+/**
+ * List all properties in a node, one per line.
+ *
+ * @param blob		FDT blob
+ * @param node		Node to display
+ * @return 0 if ok, or FDT_ERR... if not.
+ */
+static int list_properties(const void *blob, int node)
+{
+	const char *name;
+	int prop;
+
+	prop = fdt_first_property_offset(blob, node);
+	do {
+		/* Stop silently when there are no more properties */
+		if (prop < 0)
+			return prop == -FDT_ERR_NOTFOUND ? 0 : prop;
+		fdt_getprop_by_offset(blob, prop, &name, NULL);
+		if (name)
+			puts(name);
+		prop = fdt_next_property_offset(blob, prop);
+	} while (1);
+}
+
+#define MAX_LEVEL	32		/* how deeply nested we will go */
+
+/**
+ * List all subnodes in a node, one per line
+ *
+ * @param blob		FDT blob
+ * @param node		Node to display
+ * @return 0 if ok, or FDT_ERR... if not.
+ */
+static int list_subnodes(const void *blob, int node)
+{
+	int nextoffset;		/* next node offset from libfdt */
+	uint32_t tag;		/* current tag */
+	int level = 0;		/* keep track of nesting level */
+	const char *pathp;
+	int depth = 1;		/* the assumed depth of this node */
+
+	while (level >= 0) {
+		tag = fdt_next_tag(blob, node, &nextoffset);
+		switch (tag) {
+		case FDT_BEGIN_NODE:
+			pathp = fdt_get_name(blob, node, NULL);
+			if (level <= depth) {
+				if (pathp == NULL)
+					pathp = "/* NULL pointer error */";
+				if (*pathp == '\0')
+					pathp = "/";	/* root is nameless */
+				if (level == 1)
+					puts(pathp);
+			}
+			level++;
+			if (level >= MAX_LEVEL) {
+				printf("Nested too deep, aborting.\n");
+				return 1;
+			}
+			break;
+		case FDT_END_NODE:
+			level--;
+			if (level == 0)
+				level = -1;		/* exit the loop */
+			break;
+		case FDT_END:
+			return 1;
+		case FDT_PROP:
+			break;
+		default:
+			if (level <= depth)
+				printf("Unknown tag 0x%08X\n", tag);
+			return 1;
+		}
+		node = nextoffset;
+	}
+	return 0;
+}
+
+/**
+ * Show the data for a given node (and perhaps property) according to the
+ * display option provided.
+ *
+ * @param blob		FDT blob
+ * @param disp		Display information / options
+ * @param node		Node to display
+ * @param property	Name of property to display, or NULL if none
+ * @return 0 if ok, -ve on error
+ */
+static int show_data_for_item(const void *blob, struct display_info *disp,
+		int node, const char *property)
+{
+	const void *value = NULL;
+	int len, err = 0;
+
+	switch (disp->mode) {
+	case MODE_LIST_PROPS:
+		err = list_properties(blob, node);
+		break;
+
+	case MODE_LIST_SUBNODES:
+		err = list_subnodes(blob, node);
+		break;
+
+	default:
+		assert(property);
+		value = fdt_getprop(blob, node, property, &len);
+		if (value) {
+			if (show_data(disp, value, len))
+				err = -1;
+			else
+				printf("\n");
+		} else if (disp->default_val) {
+			puts(disp->default_val);
+		} else {
+			report_error(property, len);
+			err = -1;
+		}
+		break;
+	}
+
+	return err;
+}
+
+/**
+ * Run the main fdtget operation, given a filename and valid arguments
+ *
+ * @param disp		Display information / options
+ * @param filename	Filename of blob file
+ * @param arg		List of arguments to process
+ * @param arg_count	Number of arguments
+ * @return 0 if ok, -ve on error
+ */
+static int do_fdtget(struct display_info *disp, const char *filename,
+		     char **arg, int arg_count, int args_per_step)
+{
+	char *blob;
+	const char *prop;
+	int i, node;
+
+	blob = utilfdt_read(filename, NULL);
+	if (!blob)
+		return -1;
+
+	for (i = 0; i + args_per_step <= arg_count; i += args_per_step) {
+		node = fdt_path_offset(blob, arg[i]);
+		if (node < 0) {
+			if (disp->default_val) {
+				puts(disp->default_val);
+				continue;
+			} else {
+				report_error(arg[i], node);
+				free(blob);
+				return -1;
+			}
+		}
+		prop = args_per_step == 1 ? NULL : arg[i + 1];
+
+		if (show_data_for_item(blob, disp, node, prop)) {
+			free(blob);
+			return -1;
+		}
+	}
+
+	free(blob);
+
+	return 0;
+}
+
+/* Usage related data. */
+static const char usage_synopsis[] =
+	"read values from device tree\n"
+	"	fdtget <options> <dt file> [<node> <property>]...\n"
+	"	fdtget -p <options> <dt file> [<node> ]...\n"
+	"\n"
+	"Each value is printed on a new line.\n"
+	USAGE_TYPE_MSG;
+static const char usage_short_opts[] = "t:pld:" USAGE_COMMON_SHORT_OPTS;
+static struct option const usage_long_opts[] = {
+	{"type",              a_argument, NULL, 't'},
+	{"properties",       no_argument, NULL, 'p'},
+	{"list",             no_argument, NULL, 'l'},
+	{"default",           a_argument, NULL, 'd'},
+	USAGE_COMMON_LONG_OPTS,
+};
+static const char * const usage_opts_help[] = {
+	"Type of data",
+	"List properties for each node",
+	"List subnodes for each node",
+	"Default value to display when the property is missing",
+	USAGE_COMMON_OPTS_HELP
+};
+
+int main(int argc, char *argv[])
+{
+	int opt;
+	char *filename = NULL;
+	struct display_info disp;
+	int args_per_step = 2;
+
+	/* set defaults */
+	memset(&disp, '\0', sizeof(disp));
+	disp.size = -1;
+	disp.mode = MODE_SHOW_VALUE;
+	while ((opt = util_getopt_long()) != EOF) {
+		switch (opt) {
+		case_USAGE_COMMON_FLAGS
+
+		case 't':
+			if (utilfdt_decode_type(optarg, &disp.type,
+					&disp.size))
+				usage("invalid type string");
+			break;
+
+		case 'p':
+			disp.mode = MODE_LIST_PROPS;
+			args_per_step = 1;
+			break;
+
+		case 'l':
+			disp.mode = MODE_LIST_SUBNODES;
+			args_per_step = 1;
+			break;
+
+		case 'd':
+			disp.default_val = optarg;
+			break;
+		}
+	}
+
+	if (optind < argc)
+		filename = argv[optind++];
+	if (!filename)
+		usage("missing filename");
+
+	argv += optind;
+	argc -= optind;
+
+	/* Allow no arguments, and silently succeed */
+	if (!argc)
+		return 0;
+
+	/* Check for node, property arguments */
+	if (args_per_step == 2 && (argc % 2))
+		usage("must have an even number of arguments");
+
+	if (do_fdtget(&disp, filename, argv, argc, args_per_step))
+		return 1;
+	return 0;
+}
diff --git a/dtc/fdtoverlay.c b/dtc/fdtoverlay.c
new file mode 100644
index 0000000..5350af6
--- /dev/null
+++ b/dtc/fdtoverlay.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2017 Konsulko Group Inc. All rights reserved.
+ *
+ * Author:
+ *	 Pantelis Antoniou <pantelis.antoniou@konsulko.com>
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include <libfdt.h>
+
+#include "util.h"
+
+#define BUF_INCREMENT	65536
+
+/* Usage related data. */
+static const char usage_synopsis[] =
+	"apply a number of overlays to a base blob\n"
+	"	fdtoverlay <options> [<overlay.dtbo> [<overlay.dtbo>]]\n"
+	"\n"
+	USAGE_TYPE_MSG;
+static const char usage_short_opts[] = "i:o:v" USAGE_COMMON_SHORT_OPTS;
+static struct option const usage_long_opts[] = {
+	{"input",            required_argument, NULL, 'i'},
+	{"output",	     required_argument, NULL, 'o'},
+	{"verbose",	           no_argument, NULL, 'v'},
+	USAGE_COMMON_LONG_OPTS,
+};
+static const char * const usage_opts_help[] = {
+	"Input base DT blob",
+	"Output DT blob",
+	"Verbose messages",
+	USAGE_COMMON_OPTS_HELP
+};
+
+int verbose = 0;
+
+static void *apply_one(char *base, const char *overlay, size_t *buf_len,
+		       const char *name)
+{
+	char *tmp = NULL;
+	char *tmpo;
+	int ret;
+
+	/*
+	 * We take a copies first, because a a failed apply can trash
+	 * both the base blob and the overlay
+	 */
+	tmpo = xmalloc(fdt_totalsize(overlay));
+
+	do {
+		tmp = xrealloc(tmp, *buf_len);
+		ret = fdt_open_into(base, tmp, *buf_len);
+		if (ret) {
+			fprintf(stderr,
+				"\nFailed to make temporary copy: %s\n",
+				fdt_strerror(ret));
+			goto fail;
+		}
+
+		memcpy(tmpo, overlay, fdt_totalsize(overlay));
+
+		ret = fdt_overlay_apply(tmp, tmpo);
+		if (ret == -FDT_ERR_NOSPACE) {
+			*buf_len += BUF_INCREMENT;
+		}
+	} while (ret == -FDT_ERR_NOSPACE);
+
+	if (ret) {
+		fprintf(stderr, "\nFailed to apply '%s': %s\n",
+			name, fdt_strerror(ret));
+		goto fail;
+	}
+
+	free(base);
+	free(tmpo);
+	return tmp;
+
+fail:
+	free(tmpo);
+	if (tmp)
+		free(tmp);
+
+	return NULL;
+}
+static int do_fdtoverlay(const char *input_filename,
+			 const char *output_filename,
+			 int argc, char *argv[])
+{
+	char *blob = NULL;
+	char **ovblob = NULL;
+	size_t buf_len;
+	int i, ret = -1;
+
+	blob = utilfdt_read(input_filename, &buf_len);
+	if (!blob) {
+		fprintf(stderr, "\nFailed to read '%s'\n", input_filename);
+		goto out_err;
+	}
+	if (fdt_totalsize(blob) > buf_len) {
+		fprintf(stderr,
+ "\nBase blob is incomplete (%lu / %" PRIu32 " bytes read)\n",
+			(unsigned long)buf_len, fdt_totalsize(blob));
+		goto out_err;
+	}
+
+	/* allocate blob pointer array */
+	ovblob = xmalloc(sizeof(*ovblob) * argc);
+	memset(ovblob, 0, sizeof(*ovblob) * argc);
+
+	/* read and keep track of the overlay blobs */
+	for (i = 0; i < argc; i++) {
+		size_t ov_len;
+		ovblob[i] = utilfdt_read(argv[i], &ov_len);
+		if (!ovblob[i]) {
+			fprintf(stderr, "\nFailed to read '%s'\n", argv[i]);
+			goto out_err;
+		}
+		if (fdt_totalsize(ovblob[i]) > ov_len) {
+			fprintf(stderr,
+"\nOverlay '%s' is incomplete (%lu / %" PRIu32 " bytes read)\n",
+				argv[i], (unsigned long)ov_len,
+				fdt_totalsize(ovblob[i]));
+			goto out_err;
+		}
+	}
+
+	buf_len = fdt_totalsize(blob);
+
+	/* apply the overlays in sequence */
+	for (i = 0; i < argc; i++) {
+		blob = apply_one(blob, ovblob[i], &buf_len, argv[i]);
+		if (!blob)
+			goto out_err;
+	}
+
+	fdt_pack(blob);
+	ret = utilfdt_write(output_filename, blob);
+	if (ret)
+		fprintf(stderr, "\nFailed to write '%s'\n",
+			output_filename);
+
+out_err:
+	if (ovblob) {
+		for (i = 0; i < argc; i++) {
+			if (ovblob[i])
+				free(ovblob[i]);
+		}
+		free(ovblob);
+	}
+	free(blob);
+
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	int opt, i;
+	char *input_filename = NULL;
+	char *output_filename = NULL;
+
+	while ((opt = util_getopt_long()) != EOF) {
+		switch (opt) {
+		case_USAGE_COMMON_FLAGS
+
+		case 'i':
+			input_filename = optarg;
+			break;
+		case 'o':
+			output_filename = optarg;
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		}
+	}
+
+	if (!input_filename)
+		usage("missing input file");
+
+	if (!output_filename)
+		usage("missing output file");
+
+	argv += optind;
+	argc -= optind;
+
+	if (argc <= 0)
+		usage("missing overlay file(s)");
+
+	if (verbose) {
+		printf("input  = %s\n", input_filename);
+		printf("output = %s\n", output_filename);
+		for (i = 0; i < argc; i++)
+			printf("overlay[%d] = %s\n", i, argv[i]);
+	}
+
+	if (do_fdtoverlay(input_filename, output_filename, argc, argv))
+		return 1;
+
+	return 0;
+}
diff --git a/dtc/fdtput.c b/dtc/fdtput.c
new file mode 100644
index 0000000..428745a
--- /dev/null
+++ b/dtc/fdtput.c
@@ -0,0 +1,466 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libfdt.h>
+
+#include "util.h"
+
+/* These are the operations we support */
+enum oper_type {
+	OPER_WRITE_PROP,		/* Write a property in a node */
+	OPER_CREATE_NODE,		/* Create a new node */
+	OPER_REMOVE_NODE,		/* Delete a node */
+	OPER_DELETE_PROP,		/* Delete a property in a node */
+};
+
+struct display_info {
+	enum oper_type oper;	/* operation to perform */
+	int type;		/* data type (s/i/u/x or 0 for default) */
+	int size;		/* data size (1/2/4) */
+	int verbose;		/* verbose output */
+	int auto_path;		/* automatically create all path components */
+};
+
+
+/**
+ * Report an error with a particular node.
+ *
+ * @param name		Node name to report error on
+ * @param namelen	Length of node name, or -1 to use entire string
+ * @param err		Error number to report (-FDT_ERR_...)
+ */
+static void report_error(const char *name, int namelen, int err)
+{
+	if (namelen == -1)
+		namelen = strlen(name);
+	fprintf(stderr, "Error at '%1.*s': %s\n", namelen, name,
+		fdt_strerror(err));
+}
+
+/**
+ * Encode a series of arguments in a property value.
+ *
+ * @param disp		Display information / options
+ * @param arg		List of arguments from command line
+ * @param arg_count	Number of arguments (may be 0)
+ * @param valuep	Returns buffer containing value
+ * @param value_len	Returns length of value encoded
+ */
+static int encode_value(struct display_info *disp, char **arg, int arg_count,
+			char **valuep, int *value_len)
+{
+	char *value = NULL;	/* holding area for value */
+	int value_size = 0;	/* size of holding area */
+	char *ptr;		/* pointer to current value position */
+	int len;		/* length of this cell/string/byte */
+	int ival;
+	int upto;	/* the number of bytes we have written to buf */
+	char fmt[3];
+
+	upto = 0;
+
+	if (disp->verbose)
+		fprintf(stderr, "Decoding value:\n");
+
+	fmt[0] = '%';
+	fmt[1] = disp->type ? disp->type : 'd';
+	fmt[2] = '\0';
+	for (; arg_count > 0; arg++, arg_count--, upto += len) {
+		/* assume integer unless told otherwise */
+		if (disp->type == 's')
+			len = strlen(*arg) + 1;
+		else
+			len = disp->size == -1 ? 4 : disp->size;
+
+		/* enlarge our value buffer by a suitable margin if needed */
+		if (upto + len > value_size) {
+			value_size = (upto + len) + 500;
+			value = xrealloc(value, value_size);
+		}
+
+		ptr = value + upto;
+		if (disp->type == 's') {
+			memcpy(ptr, *arg, len);
+			if (disp->verbose)
+				fprintf(stderr, "\tstring: '%s'\n", ptr);
+		} else {
+			fdt32_t *iptr = (fdt32_t *)ptr;
+			sscanf(*arg, fmt, &ival);
+			if (len == 4)
+				*iptr = cpu_to_fdt32(ival);
+			else
+				*ptr = (uint8_t)ival;
+			if (disp->verbose) {
+				fprintf(stderr, "\t%s: %d\n",
+					disp->size == 1 ? "byte" :
+					disp->size == 2 ? "short" : "int",
+					ival);
+			}
+		}
+	}
+	*value_len = upto;
+	*valuep = value;
+	if (disp->verbose)
+		fprintf(stderr, "Value size %d\n", upto);
+	return 0;
+}
+
+#define ALIGN(x)		(((x) + (FDT_TAGSIZE) - 1) & ~((FDT_TAGSIZE) - 1))
+
+static char *realloc_fdt(char *fdt, int delta)
+{
+	int new_sz = fdt_totalsize(fdt) + delta;
+	fdt = xrealloc(fdt, new_sz);
+	fdt_open_into(fdt, fdt, new_sz);
+	return fdt;
+}
+
+static char *realloc_node(char *fdt, const char *name)
+{
+	int delta;
+	/* FDT_BEGIN_NODE, node name in off_struct and FDT_END_NODE */
+	delta = sizeof(struct fdt_node_header) + ALIGN(strlen(name) + 1)
+			+ FDT_TAGSIZE;
+	return realloc_fdt(fdt, delta);
+}
+
+static char *realloc_property(char *fdt, int nodeoffset,
+		const char *name, int newlen)
+{
+	int delta = 0;
+	int oldlen = 0;
+
+	if (!fdt_get_property(fdt, nodeoffset, name, &oldlen))
+		/* strings + property header */
+		delta = sizeof(struct fdt_property) + strlen(name) + 1;
+
+	if (newlen > oldlen)
+		/* actual value in off_struct */
+		delta += ALIGN(newlen) - ALIGN(oldlen);
+
+	return realloc_fdt(fdt, delta);
+}
+
+static int store_key_value(char **blob, const char *node_name,
+		const char *property, const char *buf, int len)
+{
+	int node;
+	int err;
+
+	node = fdt_path_offset(*blob, node_name);
+	if (node < 0) {
+		report_error(node_name, -1, node);
+		return -1;
+	}
+
+	err = fdt_setprop(*blob, node, property, buf, len);
+	if (err == -FDT_ERR_NOSPACE) {
+		*blob = realloc_property(*blob, node, property, len);
+		err = fdt_setprop(*blob, node, property, buf, len);
+	}
+	if (err) {
+		report_error(property, -1, err);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * Create paths as needed for all components of a path
+ *
+ * Any components of the path that do not exist are created. Errors are
+ * reported.
+ *
+ * @param blob		FDT blob to write into
+ * @param in_path	Path to process
+ * @return 0 if ok, -1 on error
+ */
+static int create_paths(char **blob, const char *in_path)
+{
+	const char *path = in_path;
+	const char *sep;
+	int node, offset = 0;
+
+	/* skip leading '/' */
+	while (*path == '/')
+		path++;
+
+	for (sep = path; *sep; path = sep + 1, offset = node) {
+		/* equivalent to strchrnul(), but it requires _GNU_SOURCE */
+		sep = strchr(path, '/');
+		if (!sep)
+			sep = path + strlen(path);
+
+		node = fdt_subnode_offset_namelen(*blob, offset, path,
+				sep - path);
+		if (node == -FDT_ERR_NOTFOUND) {
+			*blob = realloc_node(*blob, path);
+			node = fdt_add_subnode_namelen(*blob, offset, path,
+						       sep - path);
+		}
+		if (node < 0) {
+			report_error(path, sep - path, node);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Create a new node in the fdt.
+ *
+ * This will overwrite the node_name string. Any error is reported.
+ *
+ * TODO: Perhaps create fdt_path_offset_namelen() so we don't need to do this.
+ *
+ * @param blob		FDT blob to write into
+ * @param node_name	Name of node to create
+ * @return new node offset if found, or -1 on failure
+ */
+static int create_node(char **blob, const char *node_name)
+{
+	int node = 0;
+	char *p;
+
+	p = strrchr(node_name, '/');
+	if (!p) {
+		report_error(node_name, -1, -FDT_ERR_BADPATH);
+		return -1;
+	}
+	*p = '\0';
+
+	*blob = realloc_node(*blob, p + 1);
+
+	if (p > node_name) {
+		node = fdt_path_offset(*blob, node_name);
+		if (node < 0) {
+			report_error(node_name, -1, node);
+			return -1;
+		}
+	}
+
+	node = fdt_add_subnode(*blob, node, p + 1);
+	if (node < 0) {
+		report_error(p + 1, -1, node);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * Delete a property of a node in the fdt.
+ *
+ * @param blob		FDT blob to write into
+ * @param node_name	Path to node containing the property to delete
+ * @param prop_name	Name of property to delete
+ * @return 0 on success, or -1 on failure
+ */
+static int delete_prop(char *blob, const char *node_name, const char *prop_name)
+{
+	int node = 0;
+
+	node = fdt_path_offset(blob, node_name);
+	if (node < 0) {
+		report_error(node_name, -1, node);
+		return -1;
+	}
+
+	node = fdt_delprop(blob, node, prop_name);
+	if (node < 0) {
+		report_error(node_name, -1, node);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * Delete a node in the fdt.
+ *
+ * @param blob		FDT blob to write into
+ * @param node_name	Name of node to delete
+ * @return 0 on success, or -1 on failure
+ */
+static int delete_node(char *blob, const char *node_name)
+{
+	int node = 0;
+
+	node = fdt_path_offset(blob, node_name);
+	if (node < 0) {
+		report_error(node_name, -1, node);
+		return -1;
+	}
+
+	node = fdt_del_node(blob, node);
+	if (node < 0) {
+		report_error(node_name, -1, node);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int do_fdtput(struct display_info *disp, const char *filename,
+		    char **arg, int arg_count)
+{
+	char *value = NULL;
+	char *blob;
+	char *node;
+	int len, ret = 0;
+
+	blob = utilfdt_read(filename, NULL);
+	if (!blob)
+		return -1;
+
+	switch (disp->oper) {
+	case OPER_WRITE_PROP:
+		/*
+		 * Convert the arguments into a single binary value, then
+		 * store them into the property.
+		 */
+		assert(arg_count >= 2);
+		if (disp->auto_path && create_paths(&blob, *arg))
+			return -1;
+		if (encode_value(disp, arg + 2, arg_count - 2, &value, &len) ||
+			store_key_value(&blob, *arg, arg[1], value, len))
+			ret = -1;
+		break;
+	case OPER_CREATE_NODE:
+		for (; ret >= 0 && arg_count--; arg++) {
+			if (disp->auto_path)
+				ret = create_paths(&blob, *arg);
+			else
+				ret = create_node(&blob, *arg);
+		}
+		break;
+	case OPER_REMOVE_NODE:
+		for (; ret >= 0 && arg_count--; arg++)
+			ret = delete_node(blob, *arg);
+		break;
+	case OPER_DELETE_PROP:
+		node = *arg;
+		for (arg++; ret >= 0 && arg_count-- > 1; arg++)
+			ret = delete_prop(blob, node, *arg);
+		break;
+	}
+	if (ret >= 0) {
+		fdt_pack(blob);
+		ret = utilfdt_write(filename, blob);
+	}
+
+	free(blob);
+
+	if (value) {
+		free(value);
+	}
+
+	return ret;
+}
+
+/* Usage related data. */
+static const char usage_synopsis[] =
+	"write a property value to a device tree\n"
+	"	fdtput <options> <dt file> <node> <property> [<value>...]\n"
+	"	fdtput -c <options> <dt file> [<node>...]\n"
+	"	fdtput -r <options> <dt file> [<node>...]\n"
+	"	fdtput -d <options> <dt file> <node> [<property>...]\n"
+	"\n"
+	"The command line arguments are joined together into a single value.\n"
+	USAGE_TYPE_MSG;
+static const char usage_short_opts[] = "crdpt:v" USAGE_COMMON_SHORT_OPTS;
+static struct option const usage_long_opts[] = {
+	{"create",           no_argument, NULL, 'c'},
+	{"remove",	     no_argument, NULL, 'r'},
+	{"delete",	     no_argument, NULL, 'd'},
+	{"auto-path",        no_argument, NULL, 'p'},
+	{"type",              a_argument, NULL, 't'},
+	{"verbose",          no_argument, NULL, 'v'},
+	USAGE_COMMON_LONG_OPTS,
+};
+static const char * const usage_opts_help[] = {
+	"Create nodes if they don't already exist",
+	"Delete nodes (and any subnodes) if they already exist",
+	"Delete properties if they already exist",
+	"Automatically create nodes as needed for the node path",
+	"Type of data",
+	"Display each value decoded from command line",
+	USAGE_COMMON_OPTS_HELP
+};
+
+int main(int argc, char *argv[])
+{
+	int opt;
+	struct display_info disp;
+	char *filename = NULL;
+
+	memset(&disp, '\0', sizeof(disp));
+	disp.size = -1;
+	disp.oper = OPER_WRITE_PROP;
+	while ((opt = util_getopt_long()) != EOF) {
+		/*
+		 * TODO: add options to:
+		 * - rename node
+		 * - pack fdt before writing
+		 * - set amount of free space when writing
+		 */
+		switch (opt) {
+		case_USAGE_COMMON_FLAGS
+
+		case 'c':
+			disp.oper = OPER_CREATE_NODE;
+			break;
+		case 'r':
+			disp.oper = OPER_REMOVE_NODE;
+			break;
+		case 'd':
+			disp.oper = OPER_DELETE_PROP;
+			break;
+		case 'p':
+			disp.auto_path = 1;
+			break;
+		case 't':
+			if (utilfdt_decode_type(optarg, &disp.type,
+					&disp.size))
+				usage("Invalid type string");
+			break;
+
+		case 'v':
+			disp.verbose = 1;
+			break;
+		}
+	}
+
+	if (optind < argc)
+		filename = argv[optind++];
+	if (!filename)
+		usage("missing filename");
+
+	argv += optind;
+	argc -= optind;
+
+	if (disp.oper == OPER_WRITE_PROP) {
+		if (argc < 1)
+			usage("missing node");
+		if (argc < 2)
+			usage("missing property");
+	}
+
+	if (disp.oper == OPER_DELETE_PROP)
+		if (argc < 1)
+			usage("missing node");
+
+	if (do_fdtput(&disp, filename, argv, argc))
+		return 1;
+	return 0;
+}
diff --git a/dtc/flattree.c b/dtc/flattree.c
new file mode 100644
index 0000000..4659afb
--- /dev/null
+++ b/dtc/flattree.c
@@ -0,0 +1,925 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include "dtc.h"
+#include "srcpos.h"
+
+#define FTF_FULLPATH	0x1
+#define FTF_VARALIGN	0x2
+#define FTF_NAMEPROPS	0x4
+#define FTF_BOOTCPUID	0x8
+#define FTF_STRTABSIZE	0x10
+#define FTF_STRUCTSIZE	0x20
+#define FTF_NOPS	0x40
+
+static struct version_info {
+	int version;
+	int last_comp_version;
+	int hdr_size;
+	int flags;
+} version_table[] = {
+	{1, 1, FDT_V1_SIZE,
+	 FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS},
+	{2, 1, FDT_V2_SIZE,
+	 FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS|FTF_BOOTCPUID},
+	{3, 1, FDT_V3_SIZE,
+	 FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS|FTF_BOOTCPUID|FTF_STRTABSIZE},
+	{16, 16, FDT_V3_SIZE,
+	 FTF_BOOTCPUID|FTF_STRTABSIZE|FTF_NOPS},
+	{17, 16, FDT_V17_SIZE,
+	 FTF_BOOTCPUID|FTF_STRTABSIZE|FTF_STRUCTSIZE|FTF_NOPS},
+};
+
+struct emitter {
+	void (*cell)(void *, cell_t);
+	void (*string)(void *, const char *, int);
+	void (*align)(void *, int);
+	void (*data)(void *, struct data);
+	void (*beginnode)(void *, struct label *labels);
+	void (*endnode)(void *, struct label *labels);
+	void (*property)(void *, struct label *labels);
+};
+
+static void bin_emit_cell(void *e, cell_t val)
+{
+	struct data *dtbuf = e;
+
+	*dtbuf = data_append_cell(*dtbuf, val);
+}
+
+static void bin_emit_string(void *e, const char *str, int len)
+{
+	struct data *dtbuf = e;
+
+	if (len == 0)
+		len = strlen(str);
+
+	*dtbuf = data_append_data(*dtbuf, str, len);
+	*dtbuf = data_append_byte(*dtbuf, '\0');
+}
+
+static void bin_emit_align(void *e, int a)
+{
+	struct data *dtbuf = e;
+
+	*dtbuf = data_append_align(*dtbuf, a);
+}
+
+static void bin_emit_data(void *e, struct data d)
+{
+	struct data *dtbuf = e;
+
+	*dtbuf = data_append_data(*dtbuf, d.val, d.len);
+}
+
+static void bin_emit_beginnode(void *e, struct label *labels)
+{
+	bin_emit_cell(e, FDT_BEGIN_NODE);
+}
+
+static void bin_emit_endnode(void *e, struct label *labels)
+{
+	bin_emit_cell(e, FDT_END_NODE);
+}
+
+static void bin_emit_property(void *e, struct label *labels)
+{
+	bin_emit_cell(e, FDT_PROP);
+}
+
+static struct emitter bin_emitter = {
+	.cell = bin_emit_cell,
+	.string = bin_emit_string,
+	.align = bin_emit_align,
+	.data = bin_emit_data,
+	.beginnode = bin_emit_beginnode,
+	.endnode = bin_emit_endnode,
+	.property = bin_emit_property,
+};
+
+static void emit_label(FILE *f, const char *prefix, const char *label)
+{
+	fprintf(f, "\t.globl\t%s_%s\n", prefix, label);
+	fprintf(f, "%s_%s:\n", prefix, label);
+	fprintf(f, "_%s_%s:\n", prefix, label);
+}
+
+static void emit_offset_label(FILE *f, const char *label, int offset)
+{
+	fprintf(f, "\t.globl\t%s\n", label);
+	fprintf(f, "%s\t= . + %d\n", label, offset);
+}
+
+#define ASM_EMIT_BELONG(f, fmt, ...) \
+	{ \
+		fprintf((f), "\t.byte\t((" fmt ") >> 24) & 0xff\n", __VA_ARGS__); \
+		fprintf((f), "\t.byte\t((" fmt ") >> 16) & 0xff\n", __VA_ARGS__); \
+		fprintf((f), "\t.byte\t((" fmt ") >> 8) & 0xff\n", __VA_ARGS__); \
+		fprintf((f), "\t.byte\t(" fmt ") & 0xff\n", __VA_ARGS__); \
+	}
+
+static void asm_emit_cell(void *e, cell_t val)
+{
+	FILE *f = e;
+
+	fprintf(f, "\t.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x\n",
+		(val >> 24) & 0xff, (val >> 16) & 0xff,
+		(val >> 8) & 0xff, val & 0xff);
+}
+
+static void asm_emit_string(void *e, const char *str, int len)
+{
+	FILE *f = e;
+
+	if (len != 0)
+		fprintf(f, "\t.string\t\"%.*s\"\n", len, str);
+	else
+		fprintf(f, "\t.string\t\"%s\"\n", str);
+}
+
+static void asm_emit_align(void *e, int a)
+{
+	FILE *f = e;
+
+	fprintf(f, "\t.balign\t%d, 0\n", a);
+}
+
+static void asm_emit_data(void *e, struct data d)
+{
+	FILE *f = e;
+	unsigned int off = 0;
+	struct marker *m = d.markers;
+
+	for_each_marker_of_type(m, LABEL)
+		emit_offset_label(f, m->ref, m->offset);
+
+	while ((d.len - off) >= sizeof(uint32_t)) {
+		asm_emit_cell(e, dtb_ld32(d.val + off));
+		off += sizeof(uint32_t);
+	}
+
+	while ((d.len - off) >= 1) {
+		fprintf(f, "\t.byte\t0x%hhx\n", d.val[off]);
+		off += 1;
+	}
+
+	assert(off == d.len);
+}
+
+static void asm_emit_beginnode(void *e, struct label *labels)
+{
+	FILE *f = e;
+	struct label *l;
+
+	for_each_label(labels, l) {
+		fprintf(f, "\t.globl\t%s\n", l->label);
+		fprintf(f, "%s:\n", l->label);
+	}
+	fprintf(f, "\t/* FDT_BEGIN_NODE */\n");
+	asm_emit_cell(e, FDT_BEGIN_NODE);
+}
+
+static void asm_emit_endnode(void *e, struct label *labels)
+{
+	FILE *f = e;
+	struct label *l;
+
+	fprintf(f, "\t/* FDT_END_NODE */\n");
+	asm_emit_cell(e, FDT_END_NODE);
+	for_each_label(labels, l) {
+		fprintf(f, "\t.globl\t%s_end\n", l->label);
+		fprintf(f, "%s_end:\n", l->label);
+	}
+}
+
+static void asm_emit_property(void *e, struct label *labels)
+{
+	FILE *f = e;
+	struct label *l;
+
+	for_each_label(labels, l) {
+		fprintf(f, "\t.globl\t%s\n", l->label);
+		fprintf(f, "%s:\n", l->label);
+	}
+	fprintf(f, "\t/* FDT_PROP */\n");
+	asm_emit_cell(e, FDT_PROP);
+}
+
+static struct emitter asm_emitter = {
+	.cell = asm_emit_cell,
+	.string = asm_emit_string,
+	.align = asm_emit_align,
+	.data = asm_emit_data,
+	.beginnode = asm_emit_beginnode,
+	.endnode = asm_emit_endnode,
+	.property = asm_emit_property,
+};
+
+static int stringtable_insert(struct data *d, const char *str)
+{
+	unsigned int i;
+
+	/* FIXME: do this more efficiently? */
+
+	for (i = 0; i < d->len; i++) {
+		if (streq(str, d->val + i))
+			return i;
+	}
+
+	*d = data_append_data(*d, str, strlen(str)+1);
+	return i;
+}
+
+static void flatten_tree(struct node *tree, struct emitter *emit,
+			 void *etarget, struct data *strbuf,
+			 struct version_info *vi)
+{
+	struct property *prop;
+	struct node *child;
+	bool seen_name_prop = false;
+
+	if (tree->deleted)
+		return;
+
+	emit->beginnode(etarget, tree->labels);
+
+	if (vi->flags & FTF_FULLPATH)
+		emit->string(etarget, tree->fullpath, 0);
+	else
+		emit->string(etarget, tree->name, 0);
+
+	emit->align(etarget, sizeof(cell_t));
+
+	for_each_property(tree, prop) {
+		int nameoff;
+
+		if (streq(prop->name, "name"))
+			seen_name_prop = true;
+
+		nameoff = stringtable_insert(strbuf, prop->name);
+
+		emit->property(etarget, prop->labels);
+		emit->cell(etarget, prop->val.len);
+		emit->cell(etarget, nameoff);
+
+		if ((vi->flags & FTF_VARALIGN) && (prop->val.len >= 8))
+			emit->align(etarget, 8);
+
+		emit->data(etarget, prop->val);
+		emit->align(etarget, sizeof(cell_t));
+	}
+
+	if ((vi->flags & FTF_NAMEPROPS) && !seen_name_prop) {
+		emit->property(etarget, NULL);
+		emit->cell(etarget, tree->basenamelen+1);
+		emit->cell(etarget, stringtable_insert(strbuf, "name"));
+
+		if ((vi->flags & FTF_VARALIGN) && ((tree->basenamelen+1) >= 8))
+			emit->align(etarget, 8);
+
+		emit->string(etarget, tree->name, tree->basenamelen);
+		emit->align(etarget, sizeof(cell_t));
+	}
+
+	for_each_child(tree, child) {
+		flatten_tree(child, emit, etarget, strbuf, vi);
+	}
+
+	emit->endnode(etarget, tree->labels);
+}
+
+static struct data flatten_reserve_list(struct reserve_info *reservelist,
+				 struct version_info *vi)
+{
+	struct reserve_info *re;
+	struct data d = empty_data;
+	int    j;
+
+	for (re = reservelist; re; re = re->next) {
+		d = data_append_re(d, re->address, re->size);
+	}
+	/*
+	 * Add additional reserved slots if the user asked for them.
+	 */
+	for (j = 0; j < reservenum; j++) {
+		d = data_append_re(d, 0, 0);
+	}
+
+	return d;
+}
+
+static void make_fdt_header(struct fdt_header *fdt,
+			    struct version_info *vi,
+			    int reservesize, int dtsize, int strsize,
+			    int boot_cpuid_phys)
+{
+	int reserve_off;
+
+	reservesize += sizeof(struct fdt_reserve_entry);
+
+	memset(fdt, 0xff, sizeof(*fdt));
+
+	fdt->magic = cpu_to_fdt32(FDT_MAGIC);
+	fdt->version = cpu_to_fdt32(vi->version);
+	fdt->last_comp_version = cpu_to_fdt32(vi->last_comp_version);
+
+	/* Reserve map should be doubleword aligned */
+	reserve_off = ALIGN(vi->hdr_size, 8);
+
+	fdt->off_mem_rsvmap = cpu_to_fdt32(reserve_off);
+	fdt->off_dt_struct = cpu_to_fdt32(reserve_off + reservesize);
+	fdt->off_dt_strings = cpu_to_fdt32(reserve_off + reservesize
+					  + dtsize);
+	fdt->totalsize = cpu_to_fdt32(reserve_off + reservesize + dtsize + strsize);
+
+	if (vi->flags & FTF_BOOTCPUID)
+		fdt->boot_cpuid_phys = cpu_to_fdt32(boot_cpuid_phys);
+	if (vi->flags & FTF_STRTABSIZE)
+		fdt->size_dt_strings = cpu_to_fdt32(strsize);
+	if (vi->flags & FTF_STRUCTSIZE)
+		fdt->size_dt_struct = cpu_to_fdt32(dtsize);
+}
+
+void dt_to_blob(FILE *f, struct dt_info *dti, int version)
+{
+	struct version_info *vi = NULL;
+	unsigned int i;
+	struct data blob       = empty_data;
+	struct data reservebuf = empty_data;
+	struct data dtbuf      = empty_data;
+	struct data strbuf     = empty_data;
+	struct fdt_header fdt;
+	int padlen = 0;
+
+	for (i = 0; i < ARRAY_SIZE(version_table); i++) {
+		if (version_table[i].version == version)
+			vi = &version_table[i];
+	}
+	if (!vi)
+		die("Unknown device tree blob version %d\n", version);
+
+	flatten_tree(dti->dt, &bin_emitter, &dtbuf, &strbuf, vi);
+	bin_emit_cell(&dtbuf, FDT_END);
+
+	reservebuf = flatten_reserve_list(dti->reservelist, vi);
+
+	/* Make header */
+	make_fdt_header(&fdt, vi, reservebuf.len, dtbuf.len, strbuf.len,
+			dti->boot_cpuid_phys);
+
+	/*
+	 * If the user asked for more space than is used, adjust the totalsize.
+	 */
+	if (minsize > 0) {
+		padlen = minsize - fdt32_to_cpu(fdt.totalsize);
+		if (padlen < 0) {
+			padlen = 0;
+			if (quiet < 1)
+				fprintf(stderr,
+					"Warning: blob size %"PRIu32" >= minimum size %d\n",
+					fdt32_to_cpu(fdt.totalsize), minsize);
+		}
+	}
+
+	if (padsize > 0)
+		padlen = padsize;
+
+	if (alignsize > 0)
+		padlen = ALIGN(fdt32_to_cpu(fdt.totalsize) + padlen, alignsize)
+			- fdt32_to_cpu(fdt.totalsize);
+
+	if (padlen > 0) {
+		int tsize = fdt32_to_cpu(fdt.totalsize);
+		tsize += padlen;
+		fdt.totalsize = cpu_to_fdt32(tsize);
+	}
+
+	/*
+	 * Assemble the blob: start with the header, add with alignment
+	 * the reserve buffer, add the reserve map terminating zeroes,
+	 * the device tree itself, and finally the strings.
+	 */
+	blob = data_append_data(blob, &fdt, vi->hdr_size);
+	blob = data_append_align(blob, 8);
+	blob = data_merge(blob, reservebuf);
+	blob = data_append_zeroes(blob, sizeof(struct fdt_reserve_entry));
+	blob = data_merge(blob, dtbuf);
+	blob = data_merge(blob, strbuf);
+
+	/*
+	 * If the user asked for more space than is used, pad out the blob.
+	 */
+	if (padlen > 0)
+		blob = data_append_zeroes(blob, padlen);
+
+	if (fwrite(blob.val, blob.len, 1, f) != 1) {
+		if (ferror(f))
+			die("Error writing device tree blob: %s\n",
+			    strerror(errno));
+		else
+			die("Short write on device tree blob\n");
+	}
+
+	/*
+	 * data_merge() frees the right-hand element so only the blob
+	 * remains to be freed.
+	 */
+	data_free(blob);
+}
+
+static void dump_stringtable_asm(FILE *f, struct data strbuf)
+{
+	const char *p;
+	int len;
+
+	p = strbuf.val;
+
+	while (p < (strbuf.val + strbuf.len)) {
+		len = strlen(p);
+		fprintf(f, "\t.string \"%s\"\n", p);
+		p += len+1;
+	}
+}
+
+void dt_to_asm(FILE *f, struct dt_info *dti, int version)
+{
+	struct version_info *vi = NULL;
+	unsigned int i;
+	struct data strbuf = empty_data;
+	struct reserve_info *re;
+	const char *symprefix = "dt";
+
+	for (i = 0; i < ARRAY_SIZE(version_table); i++) {
+		if (version_table[i].version == version)
+			vi = &version_table[i];
+	}
+	if (!vi)
+		die("Unknown device tree blob version %d\n", version);
+
+	fprintf(f, "/* autogenerated by dtc, do not edit */\n\n");
+
+	emit_label(f, symprefix, "blob_start");
+	emit_label(f, symprefix, "header");
+	fprintf(f, "\t/* magic */\n");
+	asm_emit_cell(f, FDT_MAGIC);
+	fprintf(f, "\t/* totalsize */\n");
+	ASM_EMIT_BELONG(f, "_%s_blob_abs_end - _%s_blob_start",
+			symprefix, symprefix);
+	fprintf(f, "\t/* off_dt_struct */\n");
+	ASM_EMIT_BELONG(f, "_%s_struct_start - _%s_blob_start",
+		symprefix, symprefix);
+	fprintf(f, "\t/* off_dt_strings */\n");
+	ASM_EMIT_BELONG(f, "_%s_strings_start - _%s_blob_start",
+		symprefix, symprefix);
+	fprintf(f, "\t/* off_mem_rsvmap */\n");
+	ASM_EMIT_BELONG(f, "_%s_reserve_map - _%s_blob_start",
+		symprefix, symprefix);
+	fprintf(f, "\t/* version */\n");
+	asm_emit_cell(f, vi->version);
+	fprintf(f, "\t/* last_comp_version */\n");
+	asm_emit_cell(f, vi->last_comp_version);
+
+	if (vi->flags & FTF_BOOTCPUID) {
+		fprintf(f, "\t/* boot_cpuid_phys */\n");
+		asm_emit_cell(f, dti->boot_cpuid_phys);
+	}
+
+	if (vi->flags & FTF_STRTABSIZE) {
+		fprintf(f, "\t/* size_dt_strings */\n");
+		ASM_EMIT_BELONG(f, "_%s_strings_end - _%s_strings_start",
+				symprefix, symprefix);
+	}
+
+	if (vi->flags & FTF_STRUCTSIZE) {
+		fprintf(f, "\t/* size_dt_struct */\n");
+		ASM_EMIT_BELONG(f, "_%s_struct_end - _%s_struct_start",
+			symprefix, symprefix);
+	}
+
+	/*
+	 * Reserve map entries.
+	 * Align the reserve map to a doubleword boundary.
+	 * Each entry is an (address, size) pair of u64 values.
+	 * Always supply a zero-sized temination entry.
+	 */
+	asm_emit_align(f, 8);
+	emit_label(f, symprefix, "reserve_map");
+
+	fprintf(f, "/* Memory reserve map from source file */\n");
+
+	/*
+	 * Use .long on high and low halves of u64s to avoid .quad
+	 * as it appears .quad isn't available in some assemblers.
+	 */
+	for (re = dti->reservelist; re; re = re->next) {
+		struct label *l;
+
+		for_each_label(re->labels, l) {
+			fprintf(f, "\t.globl\t%s\n", l->label);
+			fprintf(f, "%s:\n", l->label);
+		}
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->address >> 32));
+		ASM_EMIT_BELONG(f, "0x%08x",
+				(unsigned int)(re->address & 0xffffffff));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->size >> 32));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->size & 0xffffffff));
+	}
+	for (i = 0; i < reservenum; i++) {
+		fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
+	}
+
+	fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
+
+	emit_label(f, symprefix, "struct_start");
+	flatten_tree(dti->dt, &asm_emitter, f, &strbuf, vi);
+
+	fprintf(f, "\t/* FDT_END */\n");
+	asm_emit_cell(f, FDT_END);
+	emit_label(f, symprefix, "struct_end");
+
+	emit_label(f, symprefix, "strings_start");
+	dump_stringtable_asm(f, strbuf);
+	emit_label(f, symprefix, "strings_end");
+
+	emit_label(f, symprefix, "blob_end");
+
+	/*
+	 * If the user asked for more space than is used, pad it out.
+	 */
+	if (minsize > 0) {
+		fprintf(f, "\t.space\t%d - (_%s_blob_end - _%s_blob_start), 0\n",
+			minsize, symprefix, symprefix);
+	}
+	if (padsize > 0) {
+		fprintf(f, "\t.space\t%d, 0\n", padsize);
+	}
+	if (alignsize > 0)
+		asm_emit_align(f, alignsize);
+	emit_label(f, symprefix, "blob_abs_end");
+
+	data_free(strbuf);
+}
+
+struct inbuf {
+	char *base, *limit, *ptr;
+};
+
+static void inbuf_init(struct inbuf *inb, void *base, void *limit)
+{
+	inb->base = base;
+	inb->limit = limit;
+	inb->ptr = inb->base;
+}
+
+static void flat_read_chunk(struct inbuf *inb, void *p, int len)
+{
+	if ((inb->ptr + len) > inb->limit)
+		die("Premature end of data parsing flat device tree\n");
+
+	memcpy(p, inb->ptr, len);
+
+	inb->ptr += len;
+}
+
+static uint32_t flat_read_word(struct inbuf *inb)
+{
+	fdt32_t val;
+
+	assert(((inb->ptr - inb->base) % sizeof(val)) == 0);
+
+	flat_read_chunk(inb, &val, sizeof(val));
+
+	return fdt32_to_cpu(val);
+}
+
+static void flat_realign(struct inbuf *inb, int align)
+{
+	int off = inb->ptr - inb->base;
+
+	inb->ptr = inb->base + ALIGN(off, align);
+	if (inb->ptr > inb->limit)
+		die("Premature end of data parsing flat device tree\n");
+}
+
+static char *flat_read_string(struct inbuf *inb)
+{
+	int len = 0;
+	const char *p = inb->ptr;
+	char *str;
+
+	do {
+		if (p >= inb->limit)
+			die("Premature end of data parsing flat device tree\n");
+		len++;
+	} while ((*p++) != '\0');
+
+	str = xstrdup(inb->ptr);
+
+	inb->ptr += len;
+
+	flat_realign(inb, sizeof(uint32_t));
+
+	return str;
+}
+
+static struct data flat_read_data(struct inbuf *inb, int len)
+{
+	struct data d = empty_data;
+
+	if (len == 0)
+		return empty_data;
+
+	d = data_grow_for(d, len);
+	d.len = len;
+
+	flat_read_chunk(inb, d.val, len);
+
+	flat_realign(inb, sizeof(uint32_t));
+
+	return d;
+}
+
+static char *flat_read_stringtable(struct inbuf *inb, int offset)
+{
+	const char *p;
+
+	p = inb->base + offset;
+	while (1) {
+		if (p >= inb->limit || p < inb->base)
+			die("String offset %d overruns string table\n",
+			    offset);
+
+		if (*p == '\0')
+			break;
+
+		p++;
+	}
+
+	return xstrdup(inb->base + offset);
+}
+
+static struct property *flat_read_property(struct inbuf *dtbuf,
+					   struct inbuf *strbuf, int flags)
+{
+	uint32_t proplen, stroff;
+	char *name;
+	struct data val;
+
+	proplen = flat_read_word(dtbuf);
+	stroff = flat_read_word(dtbuf);
+
+	name = flat_read_stringtable(strbuf, stroff);
+
+	if ((flags & FTF_VARALIGN) && (proplen >= 8))
+		flat_realign(dtbuf, 8);
+
+	val = flat_read_data(dtbuf, proplen);
+
+	return build_property(name, val, NULL);
+}
+
+
+static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
+{
+	struct reserve_info *reservelist = NULL;
+	struct reserve_info *new;
+	struct fdt_reserve_entry re;
+
+	/*
+	 * Each entry is a pair of u64 (addr, size) values for 4 cell_t's.
+	 * List terminates at an entry with size equal to zero.
+	 *
+	 * First pass, count entries.
+	 */
+	while (1) {
+		uint64_t address, size;
+
+		flat_read_chunk(inb, &re, sizeof(re));
+		address  = fdt64_to_cpu(re.address);
+		size = fdt64_to_cpu(re.size);
+		if (size == 0)
+			break;
+
+		new = build_reserve_entry(address, size);
+		reservelist = add_reserve_entry(reservelist, new);
+	}
+
+	return reservelist;
+}
+
+
+static char *nodename_from_path(const char *ppath, const char *cpath)
+{
+	int plen;
+
+	plen = strlen(ppath);
+
+	if (!strstarts(cpath, ppath))
+		die("Path \"%s\" is not valid as a child of \"%s\"\n",
+		    cpath, ppath);
+
+	/* root node is a special case */
+	if (!streq(ppath, "/"))
+		plen++;
+
+	return xstrdup(cpath + plen);
+}
+
+static struct node *unflatten_tree(struct inbuf *dtbuf,
+				   struct inbuf *strbuf,
+				   const char *parent_flatname, int flags)
+{
+	struct node *node;
+	char *flatname;
+	uint32_t val;
+
+	node = build_node(NULL, NULL, NULL);
+
+	flatname = flat_read_string(dtbuf);
+
+	if (flags & FTF_FULLPATH)
+		node->name = nodename_from_path(parent_flatname, flatname);
+	else
+		node->name = flatname;
+
+	do {
+		struct property *prop;
+		struct node *child;
+
+		val = flat_read_word(dtbuf);
+		switch (val) {
+		case FDT_PROP:
+			if (node->children)
+				fprintf(stderr, "Warning: Flat tree input has "
+					"subnodes preceding a property.\n");
+			prop = flat_read_property(dtbuf, strbuf, flags);
+			add_property(node, prop);
+			break;
+
+		case FDT_BEGIN_NODE:
+			child = unflatten_tree(dtbuf,strbuf, flatname, flags);
+			add_child(node, child);
+			break;
+
+		case FDT_END_NODE:
+			break;
+
+		case FDT_END:
+			die("Premature FDT_END in device tree blob\n");
+			break;
+
+		case FDT_NOP:
+			if (!(flags & FTF_NOPS))
+				fprintf(stderr, "Warning: NOP tag found in flat tree"
+					" version <16\n");
+
+			/* Ignore */
+			break;
+
+		default:
+			die("Invalid opcode word %08x in device tree blob\n",
+			    val);
+		}
+	} while (val != FDT_END_NODE);
+
+	if (node->name != flatname) {
+		free(flatname);
+	}
+
+	return node;
+}
+
+
+struct dt_info *dt_from_blob(const char *fname)
+{
+	FILE *f;
+	fdt32_t magic_buf, totalsize_buf;
+	uint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;
+	uint32_t off_dt, off_str, off_mem_rsvmap;
+	int rc;
+	char *blob;
+	struct fdt_header *fdt;
+	char *p;
+	struct inbuf dtbuf, strbuf;
+	struct inbuf memresvbuf;
+	int sizeleft;
+	struct reserve_info *reservelist;
+	struct node *tree;
+	uint32_t val;
+	int flags = 0;
+
+	f = srcfile_relative_open(fname, NULL);
+
+	rc = fread(&magic_buf, sizeof(magic_buf), 1, f);
+	if (ferror(f))
+		die("Error reading DT blob magic number: %s\n",
+		    strerror(errno));
+	if (rc < 1) {
+		if (feof(f))
+			die("EOF reading DT blob magic number\n");
+		else
+			die("Mysterious short read reading magic number\n");
+	}
+
+	magic = fdt32_to_cpu(magic_buf);
+	if (magic != FDT_MAGIC)
+		die("Blob has incorrect magic number\n");
+
+	rc = fread(&totalsize_buf, sizeof(totalsize_buf), 1, f);
+	if (ferror(f))
+		die("Error reading DT blob size: %s\n", strerror(errno));
+	if (rc < 1) {
+		if (feof(f))
+			die("EOF reading DT blob size\n");
+		else
+			die("Mysterious short read reading blob size\n");
+	}
+
+	totalsize = fdt32_to_cpu(totalsize_buf);
+	if (totalsize < FDT_V1_SIZE)
+		die("DT blob size (%d) is too small\n", totalsize);
+
+	blob = xmalloc(totalsize);
+
+	fdt = (struct fdt_header *)blob;
+	fdt->magic = cpu_to_fdt32(magic);
+	fdt->totalsize = cpu_to_fdt32(totalsize);
+
+	sizeleft = totalsize - sizeof(magic) - sizeof(totalsize);
+	p = blob + sizeof(magic)  + sizeof(totalsize);
+
+	while (sizeleft) {
+		if (feof(f))
+			die("EOF before reading %d bytes of DT blob\n",
+			    totalsize);
+
+		rc = fread(p, 1, sizeleft, f);
+		if (ferror(f))
+			die("Error reading DT blob: %s\n",
+			    strerror(errno));
+
+		sizeleft -= rc;
+		p += rc;
+	}
+
+	off_dt = fdt32_to_cpu(fdt->off_dt_struct);
+	off_str = fdt32_to_cpu(fdt->off_dt_strings);
+	off_mem_rsvmap = fdt32_to_cpu(fdt->off_mem_rsvmap);
+	version = fdt32_to_cpu(fdt->version);
+	boot_cpuid_phys = fdt32_to_cpu(fdt->boot_cpuid_phys);
+
+	if (off_mem_rsvmap >= totalsize)
+		die("Mem Reserve structure offset exceeds total size\n");
+
+	if (off_dt >= totalsize)
+		die("DT structure offset exceeds total size\n");
+
+	if (off_str > totalsize)
+		die("String table offset exceeds total size\n");
+
+	if (version >= 3) {
+		uint32_t size_str = fdt32_to_cpu(fdt->size_dt_strings);
+		if ((off_str+size_str < off_str) || (off_str+size_str > totalsize))
+			die("String table extends past total size\n");
+		inbuf_init(&strbuf, blob + off_str, blob + off_str + size_str);
+	} else {
+		inbuf_init(&strbuf, blob + off_str, blob + totalsize);
+	}
+
+	if (version >= 17) {
+		size_dt = fdt32_to_cpu(fdt->size_dt_struct);
+		if ((off_dt+size_dt < off_dt) || (off_dt+size_dt > totalsize))
+			die("Structure block extends past total size\n");
+	}
+
+	if (version < 16) {
+		flags |= FTF_FULLPATH | FTF_NAMEPROPS | FTF_VARALIGN;
+	} else {
+		flags |= FTF_NOPS;
+	}
+
+	inbuf_init(&memresvbuf,
+		   blob + off_mem_rsvmap, blob + totalsize);
+	inbuf_init(&dtbuf, blob + off_dt, blob + totalsize);
+
+	reservelist = flat_read_mem_reserve(&memresvbuf);
+
+	val = flat_read_word(&dtbuf);
+
+	if (val != FDT_BEGIN_NODE)
+		die("Device tree blob doesn't begin with FDT_BEGIN_NODE (begins with 0x%08x)\n", val);
+
+	tree = unflatten_tree(&dtbuf, &strbuf, "", flags);
+
+	val = flat_read_word(&dtbuf);
+	if (val != FDT_END)
+		die("Device tree blob doesn't end with FDT_END\n");
+
+	free(blob);
+
+	fclose(f);
+
+	return build_dt_info(DTSF_V1, reservelist, tree, boot_cpuid_phys);
+}
diff --git a/dtc/fstree.c b/dtc/fstree.c
new file mode 100644
index 0000000..5e59594
--- /dev/null
+++ b/dtc/fstree.c
@@ -0,0 +1,76 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include "dtc.h"
+
+#include <dirent.h>
+#include <sys/stat.h>
+
+static struct node *read_fstree(const char *dirname)
+{
+	DIR *d;
+	struct dirent *de;
+	struct stat st;
+	struct node *tree;
+
+	d = opendir(dirname);
+	if (!d)
+		die("Couldn't opendir() \"%s\": %s\n", dirname, strerror(errno));
+
+	tree = build_node(NULL, NULL, NULL);
+
+	while ((de = readdir(d)) != NULL) {
+		char *tmpname;
+
+		if (streq(de->d_name, ".")
+		    || streq(de->d_name, ".."))
+			continue;
+
+		tmpname = join_path(dirname, de->d_name);
+
+		if (stat(tmpname, &st) < 0)
+			die("stat(%s): %s\n", tmpname, strerror(errno));
+
+		if (S_ISREG(st.st_mode)) {
+			struct property *prop;
+			FILE *pfile;
+
+			pfile = fopen(tmpname, "rb");
+			if (! pfile) {
+				fprintf(stderr,
+					"WARNING: Cannot open %s: %s\n",
+					tmpname, strerror(errno));
+			} else {
+				prop = build_property(xstrdup(de->d_name),
+						      data_copy_file(pfile,
+								     st.st_size),
+						      NULL);
+				add_property(tree, prop);
+				fclose(pfile);
+			}
+		} else if (S_ISDIR(st.st_mode)) {
+			struct node *newchild;
+
+			newchild = read_fstree(tmpname);
+			newchild = name_node(newchild, xstrdup(de->d_name));
+			add_child(tree, newchild);
+		}
+
+		free(tmpname);
+	}
+
+	closedir(d);
+	return tree;
+}
+
+struct dt_info *dt_from_fs(const char *dirname)
+{
+	struct node *tree;
+
+	tree = read_fstree(dirname);
+	tree = name_node(tree, "");
+
+	return build_dt_info(DTSF_V1, NULL, tree, guess_boot_cpuid(tree));
+}
diff --git a/dtc/libfdt/Makefile.libfdt b/dtc/libfdt/Makefile.libfdt
new file mode 100644
index 0000000..b6d8fc0
--- /dev/null
+++ b/dtc/libfdt/Makefile.libfdt
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+# Makefile.libfdt
+#
+# This is not a complete Makefile of itself.  Instead, it is designed to
+# be easily embeddable into other systems of Makefiles.
+#
+LIBFDT_soname = libfdt.$(SHAREDLIB_EXT).1
+LIBFDT_INCLUDES = fdt.h libfdt.h libfdt_env.h
+LIBFDT_VERSION = version.lds
+LIBFDT_SRCS = fdt.c fdt_ro.c fdt_wip.c fdt_sw.c fdt_rw.c fdt_strerror.c fdt_empty_tree.c \
+	fdt_addresses.c fdt_overlay.c fdt_check.c
+LIBFDT_OBJS = $(LIBFDT_SRCS:%.c=%.o)
+LIBFDT_LIB = libfdt-$(DTC_VERSION).$(SHAREDLIB_EXT)
+
+libfdt_clean:
+	@$(VECHO) CLEAN "(libfdt)"
+	rm -f $(STD_CLEANFILES:%=$(LIBFDT_dir)/%)
+	rm -f $(LIBFDT_dir)/$(LIBFDT_soname)
diff --git a/dtc/libfdt/TODO b/dtc/libfdt/TODO
new file mode 100644
index 0000000..288437e
--- /dev/null
+++ b/dtc/libfdt/TODO
@@ -0,0 +1,3 @@
+- Tree traversal functions
+- Graft function
+- Complete libfdt.h documenting comments
diff --git a/dtc/libfdt/fdt.c b/dtc/libfdt/fdt.c
new file mode 100644
index 0000000..9fe7cf4
--- /dev/null
+++ b/dtc/libfdt/fdt.c
@@ -0,0 +1,335 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+/*
+ * Minimal sanity check for a read-only tree. fdt_ro_probe_() checks
+ * that the given buffer contains what appears to be a flattened
+ * device tree with sane information in its header.
+ */
+int32_t fdt_ro_probe_(const void *fdt)
+{
+	uint32_t totalsize = fdt_totalsize(fdt);
+
+	if (can_assume(VALID_DTB))
+		return totalsize;
+
+	/* The device tree must be at an 8-byte aligned address */
+	if ((uintptr_t)fdt & 7)
+		return -FDT_ERR_ALIGNMENT;
+
+	if (fdt_magic(fdt) == FDT_MAGIC) {
+		/* Complete tree */
+		if (!can_assume(LATEST)) {
+			if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
+				return -FDT_ERR_BADVERSION;
+			if (fdt_last_comp_version(fdt) >
+					FDT_LAST_SUPPORTED_VERSION)
+				return -FDT_ERR_BADVERSION;
+		}
+	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
+		/* Unfinished sequential-write blob */
+		if (!can_assume(VALID_INPUT) && fdt_size_dt_struct(fdt) == 0)
+			return -FDT_ERR_BADSTATE;
+	} else {
+		return -FDT_ERR_BADMAGIC;
+	}
+
+	if (totalsize < INT32_MAX)
+		return totalsize;
+	else
+		return -FDT_ERR_TRUNCATED;
+}
+
+static int check_off_(uint32_t hdrsize, uint32_t totalsize, uint32_t off)
+{
+	return (off >= hdrsize) && (off <= totalsize);
+}
+
+static int check_block_(uint32_t hdrsize, uint32_t totalsize,
+			uint32_t base, uint32_t size)
+{
+	if (!check_off_(hdrsize, totalsize, base))
+		return 0; /* block start out of bounds */
+	if ((base + size) < base)
+		return 0; /* overflow */
+	if (!check_off_(hdrsize, totalsize, base + size))
+		return 0; /* block end out of bounds */
+	return 1;
+}
+
+size_t fdt_header_size_(uint32_t version)
+{
+	if (version <= 1)
+		return FDT_V1_SIZE;
+	else if (version <= 2)
+		return FDT_V2_SIZE;
+	else if (version <= 3)
+		return FDT_V3_SIZE;
+	else if (version <= 16)
+		return FDT_V16_SIZE;
+	else
+		return FDT_V17_SIZE;
+}
+
+size_t fdt_header_size(const void *fdt)
+{
+	return can_assume(LATEST) ? FDT_V17_SIZE :
+		fdt_header_size_(fdt_version(fdt));
+}
+
+int fdt_check_header(const void *fdt)
+{
+	size_t hdrsize;
+
+	/* The device tree must be at an 8-byte aligned address */
+	if ((uintptr_t)fdt & 7)
+		return -FDT_ERR_ALIGNMENT;
+
+	if (fdt_magic(fdt) != FDT_MAGIC)
+		return -FDT_ERR_BADMAGIC;
+	if (!can_assume(LATEST)) {
+		if ((fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
+		    || (fdt_last_comp_version(fdt) >
+			FDT_LAST_SUPPORTED_VERSION))
+			return -FDT_ERR_BADVERSION;
+		if (fdt_version(fdt) < fdt_last_comp_version(fdt))
+			return -FDT_ERR_BADVERSION;
+	}
+	hdrsize = fdt_header_size(fdt);
+	if (!can_assume(VALID_DTB)) {
+
+		if ((fdt_totalsize(fdt) < hdrsize)
+		    || (fdt_totalsize(fdt) > INT_MAX))
+			return -FDT_ERR_TRUNCATED;
+
+		/* Bounds check memrsv block */
+		if (!check_off_(hdrsize, fdt_totalsize(fdt),
+				fdt_off_mem_rsvmap(fdt)))
+			return -FDT_ERR_TRUNCATED;
+	}
+
+	if (!can_assume(VALID_DTB)) {
+		/* Bounds check structure block */
+		if (!can_assume(LATEST) && fdt_version(fdt) < 17) {
+			if (!check_off_(hdrsize, fdt_totalsize(fdt),
+					fdt_off_dt_struct(fdt)))
+				return -FDT_ERR_TRUNCATED;
+		} else {
+			if (!check_block_(hdrsize, fdt_totalsize(fdt),
+					  fdt_off_dt_struct(fdt),
+					  fdt_size_dt_struct(fdt)))
+				return -FDT_ERR_TRUNCATED;
+		}
+
+		/* Bounds check strings block */
+		if (!check_block_(hdrsize, fdt_totalsize(fdt),
+				  fdt_off_dt_strings(fdt),
+				  fdt_size_dt_strings(fdt)))
+			return -FDT_ERR_TRUNCATED;
+	}
+
+	return 0;
+}
+
+const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int len)
+{
+	unsigned int uoffset = offset;
+	unsigned int absoffset = offset + fdt_off_dt_struct(fdt);
+
+	if (offset < 0)
+		return NULL;
+
+	if (!can_assume(VALID_INPUT))
+		if ((absoffset < uoffset)
+		    || ((absoffset + len) < absoffset)
+		    || (absoffset + len) > fdt_totalsize(fdt))
+			return NULL;
+
+	if (can_assume(LATEST) || fdt_version(fdt) >= 0x11)
+		if (((uoffset + len) < uoffset)
+		    || ((offset + len) > fdt_size_dt_struct(fdt)))
+			return NULL;
+
+	return fdt_offset_ptr_(fdt, offset);
+}
+
+uint32_t fdt_next_tag(const void *fdt, int startoffset, int *nextoffset)
+{
+	const fdt32_t *tagp, *lenp;
+	uint32_t tag;
+	int offset = startoffset;
+	const char *p;
+
+	*nextoffset = -FDT_ERR_TRUNCATED;
+	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
+	if (!can_assume(VALID_DTB) && !tagp)
+		return FDT_END; /* premature end */
+	tag = fdt32_to_cpu(*tagp);
+	offset += FDT_TAGSIZE;
+
+	*nextoffset = -FDT_ERR_BADSTRUCTURE;
+	switch (tag) {
+	case FDT_BEGIN_NODE:
+		/* skip name */
+		do {
+			p = fdt_offset_ptr(fdt, offset++, 1);
+		} while (p && (*p != '\0'));
+		if (!can_assume(VALID_DTB) && !p)
+			return FDT_END; /* premature end */
+		break;
+
+	case FDT_PROP:
+		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
+		if (!can_assume(VALID_DTB) && !lenp)
+			return FDT_END; /* premature end */
+		/* skip-name offset, length and value */
+		offset += sizeof(struct fdt_property) - FDT_TAGSIZE
+			+ fdt32_to_cpu(*lenp);
+		if (!can_assume(LATEST) &&
+		    fdt_version(fdt) < 0x10 && fdt32_to_cpu(*lenp) >= 8 &&
+		    ((offset - fdt32_to_cpu(*lenp)) % 8) != 0)
+			offset += 4;
+		break;
+
+	case FDT_END:
+	case FDT_END_NODE:
+	case FDT_NOP:
+		break;
+
+	default:
+		return FDT_END;
+	}
+
+	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
+		return FDT_END; /* premature end */
+
+	*nextoffset = FDT_TAGALIGN(offset);
+	return tag;
+}
+
+int fdt_check_node_offset_(const void *fdt, int offset)
+{
+	if (!can_assume(VALID_INPUT)
+	    && ((offset < 0) || (offset % FDT_TAGSIZE)))
+		return -FDT_ERR_BADOFFSET;
+
+	if (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE)
+		return -FDT_ERR_BADOFFSET;
+
+	return offset;
+}
+
+int fdt_check_prop_offset_(const void *fdt, int offset)
+{
+	if (!can_assume(VALID_INPUT)
+	    && ((offset < 0) || (offset % FDT_TAGSIZE)))
+		return -FDT_ERR_BADOFFSET;
+
+	if (fdt_next_tag(fdt, offset, &offset) != FDT_PROP)
+		return -FDT_ERR_BADOFFSET;
+
+	return offset;
+}
+
+int fdt_next_node(const void *fdt, int offset, int *depth)
+{
+	int nextoffset = 0;
+	uint32_t tag;
+
+	if (offset >= 0)
+		if ((nextoffset = fdt_check_node_offset_(fdt, offset)) < 0)
+			return nextoffset;
+
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_PROP:
+		case FDT_NOP:
+			break;
+
+		case FDT_BEGIN_NODE:
+			if (depth)
+				(*depth)++;
+			break;
+
+		case FDT_END_NODE:
+			if (depth && ((--(*depth)) < 0))
+				return nextoffset;
+			break;
+
+		case FDT_END:
+			if ((nextoffset >= 0)
+			    || ((nextoffset == -FDT_ERR_TRUNCATED) && !depth))
+				return -FDT_ERR_NOTFOUND;
+			else
+				return nextoffset;
+		}
+	} while (tag != FDT_BEGIN_NODE);
+
+	return offset;
+}
+
+int fdt_first_subnode(const void *fdt, int offset)
+{
+	int depth = 0;
+
+	offset = fdt_next_node(fdt, offset, &depth);
+	if (offset < 0 || depth != 1)
+		return -FDT_ERR_NOTFOUND;
+
+	return offset;
+}
+
+int fdt_next_subnode(const void *fdt, int offset)
+{
+	int depth = 1;
+
+	/*
+	 * With respect to the parent, the depth of the next subnode will be
+	 * the same as the last.
+	 */
+	do {
+		offset = fdt_next_node(fdt, offset, &depth);
+		if (offset < 0 || depth < 1)
+			return -FDT_ERR_NOTFOUND;
+	} while (depth > 1);
+
+	return offset;
+}
+
+const char *fdt_find_string_(const char *strtab, int tabsize, const char *s)
+{
+	int len = strlen(s) + 1;
+	const char *last = strtab + tabsize - len;
+	const char *p;
+
+	for (p = strtab; p <= last; p++)
+		if (memcmp(p, s, len) == 0)
+			return p;
+	return NULL;
+}
+
+int fdt_move(const void *fdt, void *buf, int bufsize)
+{
+	if (!can_assume(VALID_INPUT) && bufsize < 0)
+		return -FDT_ERR_NOSPACE;
+
+	FDT_RO_PROBE(fdt);
+
+	if (fdt_totalsize(fdt) > (unsigned int)bufsize)
+		return -FDT_ERR_NOSPACE;
+
+	memmove(buf, fdt, fdt_totalsize(fdt));
+	return 0;
+}
diff --git a/dtc/libfdt/fdt.h b/dtc/libfdt/fdt.h
new file mode 100644
index 0000000..f2e6880
--- /dev/null
+++ b/dtc/libfdt/fdt.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+#ifndef FDT_H
+#define FDT_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2012 Kim Phillips, Freescale Semiconductor.
+ */
+
+#ifndef __ASSEMBLY__
+
+struct fdt_header {
+	fdt32_t magic;			 /* magic word FDT_MAGIC */
+	fdt32_t totalsize;		 /* total size of DT block */
+	fdt32_t off_dt_struct;		 /* offset to structure */
+	fdt32_t off_dt_strings;		 /* offset to strings */
+	fdt32_t off_mem_rsvmap;		 /* offset to memory reserve map */
+	fdt32_t version;		 /* format version */
+	fdt32_t last_comp_version;	 /* last compatible version */
+
+	/* version 2 fields below */
+	fdt32_t boot_cpuid_phys;	 /* Which physical CPU id we're
+					    booting on */
+	/* version 3 fields below */
+	fdt32_t size_dt_strings;	 /* size of the strings block */
+
+	/* version 17 fields below */
+	fdt32_t size_dt_struct;		 /* size of the structure block */
+};
+
+struct fdt_reserve_entry {
+	fdt64_t address;
+	fdt64_t size;
+};
+
+struct fdt_node_header {
+	fdt32_t tag;
+	char name[0];
+};
+
+struct fdt_property {
+	fdt32_t tag;
+	fdt32_t len;
+	fdt32_t nameoff;
+	char data[0];
+};
+
+#endif /* !__ASSEMBLY */
+
+#define FDT_MAGIC	0xd00dfeed	/* 4: version, 4: total size */
+#define FDT_TAGSIZE	sizeof(fdt32_t)
+
+#define FDT_BEGIN_NODE	0x1		/* Start node: full name */
+#define FDT_END_NODE	0x2		/* End node */
+#define FDT_PROP	0x3		/* Property: name off,
+					   size, content */
+#define FDT_NOP		0x4		/* nop */
+#define FDT_END		0x9
+
+#define FDT_V1_SIZE	(7*sizeof(fdt32_t))
+#define FDT_V2_SIZE	(FDT_V1_SIZE + sizeof(fdt32_t))
+#define FDT_V3_SIZE	(FDT_V2_SIZE + sizeof(fdt32_t))
+#define FDT_V16_SIZE	FDT_V3_SIZE
+#define FDT_V17_SIZE	(FDT_V16_SIZE + sizeof(fdt32_t))
+
+#endif /* FDT_H */
diff --git a/dtc/libfdt/fdt_addresses.c b/dtc/libfdt/fdt_addresses.c
new file mode 100644
index 0000000..9a82cd0
--- /dev/null
+++ b/dtc/libfdt/fdt_addresses.c
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2014 David Gibson <david@gibson.dropbear.id.au>
+ * Copyright (C) 2018 embedded brains GmbH
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+static int fdt_cells(const void *fdt, int nodeoffset, const char *name)
+{
+	const fdt32_t *c;
+	uint32_t val;
+	int len;
+
+	c = fdt_getprop(fdt, nodeoffset, name, &len);
+	if (!c)
+		return len;
+
+	if (len != sizeof(*c))
+		return -FDT_ERR_BADNCELLS;
+
+	val = fdt32_to_cpu(*c);
+	if (val > FDT_MAX_NCELLS)
+		return -FDT_ERR_BADNCELLS;
+
+	return (int)val;
+}
+
+int fdt_address_cells(const void *fdt, int nodeoffset)
+{
+	int val;
+
+	val = fdt_cells(fdt, nodeoffset, "#address-cells");
+	if (val == 0)
+		return -FDT_ERR_BADNCELLS;
+	if (val == -FDT_ERR_NOTFOUND)
+		return 2;
+	return val;
+}
+
+int fdt_size_cells(const void *fdt, int nodeoffset)
+{
+	int val;
+
+	val = fdt_cells(fdt, nodeoffset, "#size-cells");
+	if (val == -FDT_ERR_NOTFOUND)
+		return 1;
+	return val;
+}
+
+/* This function assumes that [address|size]_cells is 1 or 2 */
+int fdt_appendprop_addrrange(void *fdt, int parent, int nodeoffset,
+			     const char *name, uint64_t addr, uint64_t size)
+{
+	int addr_cells, size_cells, ret;
+	uint8_t data[sizeof(fdt64_t) * 2], *prop;
+
+	ret = fdt_address_cells(fdt, parent);
+	if (ret < 0)
+		return ret;
+	addr_cells = ret;
+
+	ret = fdt_size_cells(fdt, parent);
+	if (ret < 0)
+		return ret;
+	size_cells = ret;
+
+	/* check validity of address */
+	prop = data;
+	if (addr_cells == 1) {
+		if ((addr > UINT32_MAX) || ((UINT32_MAX + 1 - addr) < size))
+			return -FDT_ERR_BADVALUE;
+
+		fdt32_st(prop, (uint32_t)addr);
+	} else if (addr_cells == 2) {
+		fdt64_st(prop, addr);
+	} else {
+		return -FDT_ERR_BADNCELLS;
+	}
+
+	/* check validity of size */
+	prop += addr_cells * sizeof(fdt32_t);
+	if (size_cells == 1) {
+		if (size > UINT32_MAX)
+			return -FDT_ERR_BADVALUE;
+
+		fdt32_st(prop, (uint32_t)size);
+	} else if (size_cells == 2) {
+		fdt64_st(prop, size);
+	} else {
+		return -FDT_ERR_BADNCELLS;
+	}
+
+	return fdt_appendprop(fdt, nodeoffset, name, data,
+			      (addr_cells + size_cells) * sizeof(fdt32_t));
+}
diff --git a/dtc/libfdt/fdt_check.c b/dtc/libfdt/fdt_check.c
new file mode 100644
index 0000000..fa410a8
--- /dev/null
+++ b/dtc/libfdt/fdt_check.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_check_full(const void *fdt, size_t bufsize)
+{
+	int err;
+	int num_memrsv;
+	int offset, nextoffset = 0;
+	uint32_t tag;
+	unsigned int depth = 0;
+	const void *prop;
+	const char *propname;
+	bool expect_end = false;
+
+	if (bufsize < FDT_V1_SIZE)
+		return -FDT_ERR_TRUNCATED;
+	if (bufsize < fdt_header_size(fdt))
+		return -FDT_ERR_TRUNCATED;
+	err = fdt_check_header(fdt);
+	if (err != 0)
+		return err;
+	if (bufsize < fdt_totalsize(fdt))
+		return -FDT_ERR_TRUNCATED;
+
+	num_memrsv = fdt_num_mem_rsv(fdt);
+	if (num_memrsv < 0)
+		return num_memrsv;
+
+	while (1) {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		if (nextoffset < 0)
+			return nextoffset;
+
+		/* If we see two root nodes, something is wrong */
+		if (expect_end && tag != FDT_END)
+			return -FDT_ERR_BADSTRUCTURE;
+
+		switch (tag) {
+		case FDT_NOP:
+			break;
+
+		case FDT_END:
+			if (depth != 0)
+				return -FDT_ERR_BADSTRUCTURE;
+			return 0;
+
+		case FDT_BEGIN_NODE:
+			depth++;
+			if (depth > INT_MAX)
+				return -FDT_ERR_BADSTRUCTURE;
+
+			/* The root node must have an empty name */
+			if (depth == 1) {
+				const char *name;
+				int len;
+
+				name = fdt_get_name(fdt, offset, &len);
+				if (*name || len)
+					return -FDT_ERR_BADSTRUCTURE;
+			}
+			break;
+
+		case FDT_END_NODE:
+			if (depth == 0)
+				return -FDT_ERR_BADSTRUCTURE;
+			depth--;
+			if (depth == 0)
+				expect_end = true;
+			break;
+
+		case FDT_PROP:
+			prop = fdt_getprop_by_offset(fdt, offset, &propname,
+						     &err);
+			if (!prop)
+				return err;
+			break;
+
+		default:
+			return -FDT_ERR_INTERNAL;
+		}
+	}
+}
diff --git a/dtc/libfdt/fdt_empty_tree.c b/dtc/libfdt/fdt_empty_tree.c
new file mode 100644
index 0000000..49d54d4
--- /dev/null
+++ b/dtc/libfdt/fdt_empty_tree.c
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2012 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_create_empty_tree(void *buf, int bufsize)
+{
+	int err;
+
+	err = fdt_create(buf, bufsize);
+	if (err)
+		return err;
+
+	err = fdt_finish_reservemap(buf);
+	if (err)
+		return err;
+
+	err = fdt_begin_node(buf, "");
+	if (err)
+		return err;
+
+	err =  fdt_end_node(buf);
+	if (err)
+		return err;
+
+	err = fdt_finish(buf);
+	if (err)
+		return err;
+
+	return fdt_open_into(buf, buf, bufsize);
+}
diff --git a/dtc/libfdt/fdt_overlay.c b/dtc/libfdt/fdt_overlay.c
new file mode 100644
index 0000000..d217e79
--- /dev/null
+++ b/dtc/libfdt/fdt_overlay.c
@@ -0,0 +1,882 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2016 Free Electrons
+ * Copyright (C) 2016 NextThing Co.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+/**
+ * overlay_get_target_phandle - retrieves the target phandle of a fragment
+ * @fdto: pointer to the device tree overlay blob
+ * @fragment: node offset of the fragment in the overlay
+ *
+ * overlay_get_target_phandle() retrieves the target phandle of an
+ * overlay fragment when that fragment uses a phandle (target
+ * property) instead of a path (target-path property).
+ *
+ * returns:
+ *      the phandle pointed by the target property
+ *      0, if the phandle was not found
+ *	-1, if the phandle was malformed
+ */
+static uint32_t overlay_get_target_phandle(const void *fdto, int fragment)
+{
+	const fdt32_t *val;
+	int len;
+
+	val = fdt_getprop(fdto, fragment, "target", &len);
+	if (!val)
+		return 0;
+
+	if ((len != sizeof(*val)) || (fdt32_to_cpu(*val) == (uint32_t)-1))
+		return (uint32_t)-1;
+
+	return fdt32_to_cpu(*val);
+}
+
+/**
+ * overlay_get_target - retrieves the offset of a fragment's target
+ * @fdt: Base device tree blob
+ * @fdto: Device tree overlay blob
+ * @fragment: node offset of the fragment in the overlay
+ * @pathp: pointer which receives the path of the target (or NULL)
+ *
+ * overlay_get_target() retrieves the target offset in the base
+ * device tree of a fragment, no matter how the actual targeting is
+ * done (through a phandle or a path)
+ *
+ * returns:
+ *      the targeted node offset in the base device tree
+ *      Negative error code on error
+ */
+static int overlay_get_target(const void *fdt, const void *fdto,
+			      int fragment, char const **pathp)
+{
+	uint32_t phandle;
+	const char *path = NULL;
+	int path_len = 0, ret;
+
+	/* Try first to do a phandle based lookup */
+	phandle = overlay_get_target_phandle(fdto, fragment);
+	if (phandle == (uint32_t)-1)
+		return -FDT_ERR_BADPHANDLE;
+
+	/* no phandle, try path */
+	if (!phandle) {
+		/* And then a path based lookup */
+		path = fdt_getprop(fdto, fragment, "target-path", &path_len);
+		if (path)
+			ret = fdt_path_offset(fdt, path);
+		else
+			ret = path_len;
+	} else
+		ret = fdt_node_offset_by_phandle(fdt, phandle);
+
+	/*
+	* If we haven't found either a target or a
+	* target-path property in a node that contains a
+	* __overlay__ subnode (we wouldn't be called
+	* otherwise), consider it a improperly written
+	* overlay
+	*/
+	if (ret < 0 && path_len == -FDT_ERR_NOTFOUND)
+		ret = -FDT_ERR_BADOVERLAY;
+
+	/* return on error */
+	if (ret < 0)
+		return ret;
+
+	/* return pointer to path (if available) */
+	if (pathp)
+		*pathp = path ? path : NULL;
+
+	return ret;
+}
+
+/**
+ * overlay_phandle_add_offset - Increases a phandle by an offset
+ * @fdt: Base device tree blob
+ * @node: Device tree overlay blob
+ * @name: Name of the property to modify (phandle or linux,phandle)
+ * @delta: offset to apply
+ *
+ * overlay_phandle_add_offset() increments a node phandle by a given
+ * offset.
+ *
+ * returns:
+ *      0 on success.
+ *      Negative error code on error
+ */
+static int overlay_phandle_add_offset(void *fdt, int node,
+				      const char *name, uint32_t delta)
+{
+	const fdt32_t *val;
+	uint32_t adj_val;
+	int len;
+
+	val = fdt_getprop(fdt, node, name, &len);
+	if (!val)
+		return len;
+
+	if (len != sizeof(*val))
+		return -FDT_ERR_BADPHANDLE;
+
+	adj_val = fdt32_to_cpu(*val);
+	if ((adj_val + delta) < adj_val)
+		return -FDT_ERR_NOPHANDLES;
+
+	adj_val += delta;
+	if (adj_val == (uint32_t)-1)
+		return -FDT_ERR_NOPHANDLES;
+
+	return fdt_setprop_inplace_u32(fdt, node, name, adj_val);
+}
+
+/**
+ * overlay_adjust_node_phandles - Offsets the phandles of a node
+ * @fdto: Device tree overlay blob
+ * @node: Offset of the node we want to adjust
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_adjust_node_phandles() adds a constant to all the phandles
+ * of a given node. This is mainly use as part of the overlay
+ * application process, when we want to update all the overlay
+ * phandles to not conflict with the overlays of the base device tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_adjust_node_phandles(void *fdto, int node,
+					uint32_t delta)
+{
+	int child;
+	int ret;
+
+	ret = overlay_phandle_add_offset(fdto, node, "phandle", delta);
+	if (ret && ret != -FDT_ERR_NOTFOUND)
+		return ret;
+
+	ret = overlay_phandle_add_offset(fdto, node, "linux,phandle", delta);
+	if (ret && ret != -FDT_ERR_NOTFOUND)
+		return ret;
+
+	fdt_for_each_subnode(child, fdto, node) {
+		ret = overlay_adjust_node_phandles(fdto, child, delta);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_adjust_local_phandles - Adjust the phandles of a whole overlay
+ * @fdto: Device tree overlay blob
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_adjust_local_phandles() adds a constant to all the
+ * phandles of an overlay. This is mainly use as part of the overlay
+ * application process, when we want to update all the overlay
+ * phandles to not conflict with the overlays of the base device tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_adjust_local_phandles(void *fdto, uint32_t delta)
+{
+	/*
+	 * Start adjusting the phandles from the overlay root
+	 */
+	return overlay_adjust_node_phandles(fdto, 0, delta);
+}
+
+/**
+ * overlay_update_local_node_references - Adjust the overlay references
+ * @fdto: Device tree overlay blob
+ * @tree_node: Node offset of the node to operate on
+ * @fixup_node: Node offset of the matching local fixups node
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_update_local_nodes_references() update the phandles
+ * pointing to a node within the device tree overlay by adding a
+ * constant delta.
+ *
+ * This is mainly used as part of a device tree application process,
+ * where you want the device tree overlays phandles to not conflict
+ * with the ones from the base device tree before merging them.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_update_local_node_references(void *fdto,
+						int tree_node,
+						int fixup_node,
+						uint32_t delta)
+{
+	int fixup_prop;
+	int fixup_child;
+	int ret;
+
+	fdt_for_each_property_offset(fixup_prop, fdto, fixup_node) {
+		const fdt32_t *fixup_val;
+		const char *tree_val;
+		const char *name;
+		int fixup_len;
+		int tree_len;
+		int i;
+
+		fixup_val = fdt_getprop_by_offset(fdto, fixup_prop,
+						  &name, &fixup_len);
+		if (!fixup_val)
+			return fixup_len;
+
+		if (fixup_len % sizeof(uint32_t))
+			return -FDT_ERR_BADOVERLAY;
+		fixup_len /= sizeof(uint32_t);
+
+		tree_val = fdt_getprop(fdto, tree_node, name, &tree_len);
+		if (!tree_val) {
+			if (tree_len == -FDT_ERR_NOTFOUND)
+				return -FDT_ERR_BADOVERLAY;
+
+			return tree_len;
+		}
+
+		for (i = 0; i < fixup_len; i++) {
+			fdt32_t adj_val;
+			uint32_t poffset;
+
+			poffset = fdt32_to_cpu(fixup_val[i]);
+
+			/*
+			 * phandles to fixup can be unaligned.
+			 *
+			 * Use a memcpy for the architectures that do
+			 * not support unaligned accesses.
+			 */
+			memcpy(&adj_val, tree_val + poffset, sizeof(adj_val));
+
+			adj_val = cpu_to_fdt32(fdt32_to_cpu(adj_val) + delta);
+
+			ret = fdt_setprop_inplace_namelen_partial(fdto,
+								  tree_node,
+								  name,
+								  strlen(name),
+								  poffset,
+								  &adj_val,
+								  sizeof(adj_val));
+			if (ret == -FDT_ERR_NOSPACE)
+				return -FDT_ERR_BADOVERLAY;
+
+			if (ret)
+				return ret;
+		}
+	}
+
+	fdt_for_each_subnode(fixup_child, fdto, fixup_node) {
+		const char *fixup_child_name = fdt_get_name(fdto, fixup_child,
+							    NULL);
+		int tree_child;
+
+		tree_child = fdt_subnode_offset(fdto, tree_node,
+						fixup_child_name);
+		if (tree_child == -FDT_ERR_NOTFOUND)
+			return -FDT_ERR_BADOVERLAY;
+		if (tree_child < 0)
+			return tree_child;
+
+		ret = overlay_update_local_node_references(fdto,
+							   tree_child,
+							   fixup_child,
+							   delta);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_update_local_references - Adjust the overlay references
+ * @fdto: Device tree overlay blob
+ * @delta: Offset to shift the phandles of
+ *
+ * overlay_update_local_references() update all the phandles pointing
+ * to a node within the device tree overlay by adding a constant
+ * delta to not conflict with the base overlay.
+ *
+ * This is mainly used as part of a device tree application process,
+ * where you want the device tree overlays phandles to not conflict
+ * with the ones from the base device tree before merging them.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_update_local_references(void *fdto, uint32_t delta)
+{
+	int fixups;
+
+	fixups = fdt_path_offset(fdto, "/__local_fixups__");
+	if (fixups < 0) {
+		/* There's no local phandles to adjust, bail out */
+		if (fixups == -FDT_ERR_NOTFOUND)
+			return 0;
+
+		return fixups;
+	}
+
+	/*
+	 * Update our local references from the root of the tree
+	 */
+	return overlay_update_local_node_references(fdto, 0, fixups,
+						    delta);
+}
+
+/**
+ * overlay_fixup_one_phandle - Set an overlay phandle to the base one
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ * @symbols_off: Node offset of the symbols node in the base device tree
+ * @path: Path to a node holding a phandle in the overlay
+ * @path_len: number of path characters to consider
+ * @name: Name of the property holding the phandle reference in the overlay
+ * @name_len: number of name characters to consider
+ * @poffset: Offset within the overlay property where the phandle is stored
+ * @label: Label of the node referenced by the phandle
+ *
+ * overlay_fixup_one_phandle() resolves an overlay phandle pointing to
+ * a node in the base device tree.
+ *
+ * This is part of the device tree overlay application process, when
+ * you want all the phandles in the overlay to point to the actual
+ * base dt nodes.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_fixup_one_phandle(void *fdt, void *fdto,
+				     int symbols_off,
+				     const char *path, uint32_t path_len,
+				     const char *name, uint32_t name_len,
+				     int poffset, const char *label)
+{
+	const char *symbol_path;
+	uint32_t phandle;
+	fdt32_t phandle_prop;
+	int symbol_off, fixup_off;
+	int prop_len;
+
+	if (symbols_off < 0)
+		return symbols_off;
+
+	symbol_path = fdt_getprop(fdt, symbols_off, label,
+				  &prop_len);
+	if (!symbol_path)
+		return prop_len;
+
+	symbol_off = fdt_path_offset(fdt, symbol_path);
+	if (symbol_off < 0)
+		return symbol_off;
+
+	phandle = fdt_get_phandle(fdt, symbol_off);
+	if (!phandle)
+		return -FDT_ERR_NOTFOUND;
+
+	fixup_off = fdt_path_offset_namelen(fdto, path, path_len);
+	if (fixup_off == -FDT_ERR_NOTFOUND)
+		return -FDT_ERR_BADOVERLAY;
+	if (fixup_off < 0)
+		return fixup_off;
+
+	phandle_prop = cpu_to_fdt32(phandle);
+	return fdt_setprop_inplace_namelen_partial(fdto, fixup_off,
+						   name, name_len, poffset,
+						   &phandle_prop,
+						   sizeof(phandle_prop));
+};
+
+/**
+ * overlay_fixup_phandle - Set an overlay phandle to the base one
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ * @symbols_off: Node offset of the symbols node in the base device tree
+ * @property: Property offset in the overlay holding the list of fixups
+ *
+ * overlay_fixup_phandle() resolves all the overlay phandles pointed
+ * to in a __fixups__ property, and updates them to match the phandles
+ * in use in the base device tree.
+ *
+ * This is part of the device tree overlay application process, when
+ * you want all the phandles in the overlay to point to the actual
+ * base dt nodes.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
+				 int property)
+{
+	const char *value;
+	const char *label;
+	int len;
+
+	value = fdt_getprop_by_offset(fdto, property,
+				      &label, &len);
+	if (!value) {
+		if (len == -FDT_ERR_NOTFOUND)
+			return -FDT_ERR_INTERNAL;
+
+		return len;
+	}
+
+	do {
+		const char *path, *name, *fixup_end;
+		const char *fixup_str = value;
+		uint32_t path_len, name_len;
+		uint32_t fixup_len;
+		char *sep, *endptr;
+		int poffset, ret;
+
+		fixup_end = memchr(value, '\0', len);
+		if (!fixup_end)
+			return -FDT_ERR_BADOVERLAY;
+		fixup_len = fixup_end - fixup_str;
+
+		len -= fixup_len + 1;
+		value += fixup_len + 1;
+
+		path = fixup_str;
+		sep = memchr(fixup_str, ':', fixup_len);
+		if (!sep || *sep != ':')
+			return -FDT_ERR_BADOVERLAY;
+
+		path_len = sep - path;
+		if (path_len == (fixup_len - 1))
+			return -FDT_ERR_BADOVERLAY;
+
+		fixup_len -= path_len + 1;
+		name = sep + 1;
+		sep = memchr(name, ':', fixup_len);
+		if (!sep || *sep != ':')
+			return -FDT_ERR_BADOVERLAY;
+
+		name_len = sep - name;
+		if (!name_len)
+			return -FDT_ERR_BADOVERLAY;
+
+		poffset = strtoul(sep + 1, &endptr, 10);
+		if ((*endptr != '\0') || (endptr <= (sep + 1)))
+			return -FDT_ERR_BADOVERLAY;
+
+		ret = overlay_fixup_one_phandle(fdt, fdto, symbols_off,
+						path, path_len, name, name_len,
+						poffset, label);
+		if (ret)
+			return ret;
+	} while (len > 0);
+
+	return 0;
+}
+
+/**
+ * overlay_fixup_phandles - Resolve the overlay phandles to the base
+ *                          device tree
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ *
+ * overlay_fixup_phandles() resolves all the overlay phandles pointing
+ * to nodes in the base device tree.
+ *
+ * This is one of the steps of the device tree overlay application
+ * process, when you want all the phandles in the overlay to point to
+ * the actual base dt nodes.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_fixup_phandles(void *fdt, void *fdto)
+{
+	int fixups_off, symbols_off;
+	int property;
+
+	/* We can have overlays without any fixups */
+	fixups_off = fdt_path_offset(fdto, "/__fixups__");
+	if (fixups_off == -FDT_ERR_NOTFOUND)
+		return 0; /* nothing to do */
+	if (fixups_off < 0)
+		return fixups_off;
+
+	/* And base DTs without symbols */
+	symbols_off = fdt_path_offset(fdt, "/__symbols__");
+	if ((symbols_off < 0 && (symbols_off != -FDT_ERR_NOTFOUND)))
+		return symbols_off;
+
+	fdt_for_each_property_offset(property, fdto, fixups_off) {
+		int ret;
+
+		ret = overlay_fixup_phandle(fdt, fdto, symbols_off, property);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_apply_node - Merges a node into the base device tree
+ * @fdt: Base Device Tree blob
+ * @target: Node offset in the base device tree to apply the fragment to
+ * @fdto: Device tree overlay blob
+ * @node: Node offset in the overlay holding the changes to merge
+ *
+ * overlay_apply_node() merges a node into a target base device tree
+ * node pointed.
+ *
+ * This is part of the final step in the device tree overlay
+ * application process, when all the phandles have been adjusted and
+ * resolved and you just have to merge overlay into the base device
+ * tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_apply_node(void *fdt, int target,
+			      void *fdto, int node)
+{
+	int property;
+	int subnode;
+
+	fdt_for_each_property_offset(property, fdto, node) {
+		const char *name;
+		const void *prop;
+		int prop_len;
+		int ret;
+
+		prop = fdt_getprop_by_offset(fdto, property, &name,
+					     &prop_len);
+		if (prop_len == -FDT_ERR_NOTFOUND)
+			return -FDT_ERR_INTERNAL;
+		if (prop_len < 0)
+			return prop_len;
+
+		ret = fdt_setprop(fdt, target, name, prop, prop_len);
+		if (ret)
+			return ret;
+	}
+
+	fdt_for_each_subnode(subnode, fdto, node) {
+		const char *name = fdt_get_name(fdto, subnode, NULL);
+		int nnode;
+		int ret;
+
+		nnode = fdt_add_subnode(fdt, target, name);
+		if (nnode == -FDT_ERR_EXISTS) {
+			nnode = fdt_subnode_offset(fdt, target, name);
+			if (nnode == -FDT_ERR_NOTFOUND)
+				return -FDT_ERR_INTERNAL;
+		}
+
+		if (nnode < 0)
+			return nnode;
+
+		ret = overlay_apply_node(fdt, nnode, fdto, subnode);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * overlay_merge - Merge an overlay into its base device tree
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ *
+ * overlay_merge() merges an overlay into its base device tree.
+ *
+ * This is the next to last step in the device tree overlay application
+ * process, when all the phandles have been adjusted and resolved and
+ * you just have to merge overlay into the base device tree.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_merge(void *fdt, void *fdto)
+{
+	int fragment;
+
+	fdt_for_each_subnode(fragment, fdto, 0) {
+		int overlay;
+		int target;
+		int ret;
+
+		/*
+		 * Each fragments will have an __overlay__ node. If
+		 * they don't, it's not supposed to be merged
+		 */
+		overlay = fdt_subnode_offset(fdto, fragment, "__overlay__");
+		if (overlay == -FDT_ERR_NOTFOUND)
+			continue;
+
+		if (overlay < 0)
+			return overlay;
+
+		target = overlay_get_target(fdt, fdto, fragment, NULL);
+		if (target < 0)
+			return target;
+
+		ret = overlay_apply_node(fdt, target, fdto, overlay);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int get_path_len(const void *fdt, int nodeoffset)
+{
+	int len = 0, namelen;
+	const char *name;
+
+	FDT_RO_PROBE(fdt);
+
+	for (;;) {
+		name = fdt_get_name(fdt, nodeoffset, &namelen);
+		if (!name)
+			return namelen;
+
+		/* root? we're done */
+		if (namelen == 0)
+			break;
+
+		nodeoffset = fdt_parent_offset(fdt, nodeoffset);
+		if (nodeoffset < 0)
+			return nodeoffset;
+		len += namelen + 1;
+	}
+
+	/* in case of root pretend it's "/" */
+	if (len == 0)
+		len++;
+	return len;
+}
+
+/**
+ * overlay_symbol_update - Update the symbols of base tree after a merge
+ * @fdt: Base Device Tree blob
+ * @fdto: Device tree overlay blob
+ *
+ * overlay_symbol_update() updates the symbols of the base tree with the
+ * symbols of the applied overlay
+ *
+ * This is the last step in the device tree overlay application
+ * process, allowing the reference of overlay symbols by subsequent
+ * overlay operations.
+ *
+ * returns:
+ *      0 on success
+ *      Negative error code on failure
+ */
+static int overlay_symbol_update(void *fdt, void *fdto)
+{
+	int root_sym, ov_sym, prop, path_len, fragment, target;
+	int len, frag_name_len, ret, rel_path_len;
+	const char *s, *e;
+	const char *path;
+	const char *name;
+	const char *frag_name;
+	const char *rel_path;
+	const char *target_path;
+	char *buf;
+	void *p;
+
+	ov_sym = fdt_subnode_offset(fdto, 0, "__symbols__");
+
+	/* if no overlay symbols exist no problem */
+	if (ov_sym < 0)
+		return 0;
+
+	root_sym = fdt_subnode_offset(fdt, 0, "__symbols__");
+
+	/* it no root symbols exist we should create them */
+	if (root_sym == -FDT_ERR_NOTFOUND)
+		root_sym = fdt_add_subnode(fdt, 0, "__symbols__");
+
+	/* any error is fatal now */
+	if (root_sym < 0)
+		return root_sym;
+
+	/* iterate over each overlay symbol */
+	fdt_for_each_property_offset(prop, fdto, ov_sym) {
+		path = fdt_getprop_by_offset(fdto, prop, &name, &path_len);
+		if (!path)
+			return path_len;
+
+		/* verify it's a string property (terminated by a single \0) */
+		if (path_len < 1 || memchr(path, '\0', path_len) != &path[path_len - 1])
+			return -FDT_ERR_BADVALUE;
+
+		/* keep end marker to avoid strlen() */
+		e = path + path_len;
+
+		if (*path != '/')
+			return -FDT_ERR_BADVALUE;
+
+		/* get fragment name first */
+		s = strchr(path + 1, '/');
+		if (!s) {
+			/* Symbol refers to something that won't end
+			 * up in the target tree */
+			continue;
+		}
+
+		frag_name = path + 1;
+		frag_name_len = s - path - 1;
+
+		/* verify format; safe since "s" lies in \0 terminated prop */
+		len = sizeof("/__overlay__/") - 1;
+		if ((e - s) > len && (memcmp(s, "/__overlay__/", len) == 0)) {
+			/* /<fragment-name>/__overlay__/<relative-subnode-path> */
+			rel_path = s + len;
+			rel_path_len = e - rel_path - 1;
+		} else if ((e - s) == len
+			   && (memcmp(s, "/__overlay__", len - 1) == 0)) {
+			/* /<fragment-name>/__overlay__ */
+			rel_path = "";
+			rel_path_len = 0;
+		} else {
+			/* Symbol refers to something that won't end
+			 * up in the target tree */
+			continue;
+		}
+
+		/* find the fragment index in which the symbol lies */
+		ret = fdt_subnode_offset_namelen(fdto, 0, frag_name,
+					       frag_name_len);
+		/* not found? */
+		if (ret < 0)
+			return -FDT_ERR_BADOVERLAY;
+		fragment = ret;
+
+		/* an __overlay__ subnode must exist */
+		ret = fdt_subnode_offset(fdto, fragment, "__overlay__");
+		if (ret < 0)
+			return -FDT_ERR_BADOVERLAY;
+
+		/* get the target of the fragment */
+		ret = overlay_get_target(fdt, fdto, fragment, &target_path);
+		if (ret < 0)
+			return ret;
+		target = ret;
+
+		/* if we have a target path use */
+		if (!target_path) {
+			ret = get_path_len(fdt, target);
+			if (ret < 0)
+				return ret;
+			len = ret;
+		} else {
+			len = strlen(target_path);
+		}
+
+		ret = fdt_setprop_placeholder(fdt, root_sym, name,
+				len + (len > 1) + rel_path_len + 1, &p);
+		if (ret < 0)
+			return ret;
+
+		if (!target_path) {
+			/* again in case setprop_placeholder changed it */
+			ret = overlay_get_target(fdt, fdto, fragment, &target_path);
+			if (ret < 0)
+				return ret;
+			target = ret;
+		}
+
+		buf = p;
+		if (len > 1) { /* target is not root */
+			if (!target_path) {
+				ret = fdt_get_path(fdt, target, buf, len + 1);
+				if (ret < 0)
+					return ret;
+			} else
+				memcpy(buf, target_path, len + 1);
+
+		} else
+			len--;
+
+		buf[len] = '/';
+		memcpy(buf + len + 1, rel_path, rel_path_len);
+		buf[len + 1 + rel_path_len] = '\0';
+	}
+
+	return 0;
+}
+
+int fdt_overlay_apply(void *fdt, void *fdto)
+{
+	uint32_t delta;
+	int ret;
+
+	FDT_RO_PROBE(fdt);
+	FDT_RO_PROBE(fdto);
+
+	ret = fdt_find_max_phandle(fdt, &delta);
+	if (ret)
+		goto err;
+
+	ret = overlay_adjust_local_phandles(fdto, delta);
+	if (ret)
+		goto err;
+
+	ret = overlay_update_local_references(fdto, delta);
+	if (ret)
+		goto err;
+
+	ret = overlay_fixup_phandles(fdt, fdto);
+	if (ret)
+		goto err;
+
+	ret = overlay_merge(fdt, fdto);
+	if (ret)
+		goto err;
+
+	ret = overlay_symbol_update(fdt, fdto);
+	if (ret)
+		goto err;
+
+	/*
+	 * The overlay has been damaged, erase its magic.
+	 */
+	fdt_set_magic(fdto, ~0);
+
+	return 0;
+
+err:
+	/*
+	 * The overlay might have been damaged, erase its magic.
+	 */
+	fdt_set_magic(fdto, ~0);
+
+	/*
+	 * The base device tree might have been damaged, erase its
+	 * magic.
+	 */
+	fdt_set_magic(fdt, ~0);
+
+	return ret;
+}
diff --git a/dtc/libfdt/fdt_ro.c b/dtc/libfdt/fdt_ro.c
new file mode 100644
index 0000000..17584da
--- /dev/null
+++ b/dtc/libfdt/fdt_ro.c
@@ -0,0 +1,859 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+static int fdt_nodename_eq_(const void *fdt, int offset,
+			    const char *s, int len)
+{
+	int olen;
+	const char *p = fdt_get_name(fdt, offset, &olen);
+
+	if (!p || olen < len)
+		/* short match */
+		return 0;
+
+	if (memcmp(p, s, len) != 0)
+		return 0;
+
+	if (p[len] == '\0')
+		return 1;
+	else if (!memchr(s, '@', len) && (p[len] == '@'))
+		return 1;
+	else
+		return 0;
+}
+
+const char *fdt_get_string(const void *fdt, int stroffset, int *lenp)
+{
+	int32_t totalsize;
+	uint32_t absoffset;
+	size_t len;
+	int err;
+	const char *s, *n;
+
+	if (can_assume(VALID_INPUT)) {
+		s = (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
+
+		if (lenp)
+			*lenp = strlen(s);
+		return s;
+	}
+	totalsize = fdt_ro_probe_(fdt);
+	err = totalsize;
+	if (totalsize < 0)
+		goto fail;
+
+	err = -FDT_ERR_BADOFFSET;
+	absoffset = stroffset + fdt_off_dt_strings(fdt);
+	if (absoffset >= (unsigned)totalsize)
+		goto fail;
+	len = totalsize - absoffset;
+
+	if (fdt_magic(fdt) == FDT_MAGIC) {
+		if (stroffset < 0)
+			goto fail;
+		if (can_assume(LATEST) || fdt_version(fdt) >= 17) {
+			if ((unsigned)stroffset >= fdt_size_dt_strings(fdt))
+				goto fail;
+			if ((fdt_size_dt_strings(fdt) - stroffset) < len)
+				len = fdt_size_dt_strings(fdt) - stroffset;
+		}
+	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
+		unsigned int sw_stroffset = -stroffset;
+
+		if ((stroffset >= 0) ||
+		    (sw_stroffset > fdt_size_dt_strings(fdt)))
+			goto fail;
+		if (sw_stroffset < len)
+			len = sw_stroffset;
+	} else {
+		err = -FDT_ERR_INTERNAL;
+		goto fail;
+	}
+
+	s = (const char *)fdt + absoffset;
+	n = memchr(s, '\0', len);
+	if (!n) {
+		/* missing terminating NULL */
+		err = -FDT_ERR_TRUNCATED;
+		goto fail;
+	}
+
+	if (lenp)
+		*lenp = n - s;
+	return s;
+
+fail:
+	if (lenp)
+		*lenp = err;
+	return NULL;
+}
+
+const char *fdt_string(const void *fdt, int stroffset)
+{
+	return fdt_get_string(fdt, stroffset, NULL);
+}
+
+static int fdt_string_eq_(const void *fdt, int stroffset,
+			  const char *s, int len)
+{
+	int slen;
+	const char *p = fdt_get_string(fdt, stroffset, &slen);
+
+	return p && (slen == len) && (memcmp(p, s, len) == 0);
+}
+
+int fdt_find_max_phandle(const void *fdt, uint32_t *phandle)
+{
+	uint32_t max = 0;
+	int offset = -1;
+
+	while (true) {
+		uint32_t value;
+
+		offset = fdt_next_node(fdt, offset, NULL);
+		if (offset < 0) {
+			if (offset == -FDT_ERR_NOTFOUND)
+				break;
+
+			return offset;
+		}
+
+		value = fdt_get_phandle(fdt, offset);
+
+		if (value > max)
+			max = value;
+	}
+
+	if (phandle)
+		*phandle = max;
+
+	return 0;
+}
+
+int fdt_generate_phandle(const void *fdt, uint32_t *phandle)
+{
+	uint32_t max;
+	int err;
+
+	err = fdt_find_max_phandle(fdt, &max);
+	if (err < 0)
+		return err;
+
+	if (max == FDT_MAX_PHANDLE)
+		return -FDT_ERR_NOPHANDLES;
+
+	if (phandle)
+		*phandle = max + 1;
+
+	return 0;
+}
+
+static const struct fdt_reserve_entry *fdt_mem_rsv(const void *fdt, int n)
+{
+	unsigned int offset = n * sizeof(struct fdt_reserve_entry);
+	unsigned int absoffset = fdt_off_mem_rsvmap(fdt) + offset;
+
+	if (!can_assume(VALID_INPUT)) {
+		if (absoffset < fdt_off_mem_rsvmap(fdt))
+			return NULL;
+		if (absoffset > fdt_totalsize(fdt) -
+		    sizeof(struct fdt_reserve_entry))
+			return NULL;
+	}
+	return fdt_mem_rsv_(fdt, n);
+}
+
+int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)
+{
+	const struct fdt_reserve_entry *re;
+
+	FDT_RO_PROBE(fdt);
+	re = fdt_mem_rsv(fdt, n);
+	if (!can_assume(VALID_INPUT) && !re)
+		return -FDT_ERR_BADOFFSET;
+
+	*address = fdt64_ld_(&re->address);
+	*size = fdt64_ld_(&re->size);
+	return 0;
+}
+
+int fdt_num_mem_rsv(const void *fdt)
+{
+	int i;
+	const struct fdt_reserve_entry *re;
+
+	for (i = 0; (re = fdt_mem_rsv(fdt, i)) != NULL; i++) {
+		if (fdt64_ld_(&re->size) == 0)
+			return i;
+	}
+	return -FDT_ERR_TRUNCATED;
+}
+
+static int nextprop_(const void *fdt, int offset)
+{
+	uint32_t tag;
+	int nextoffset;
+
+	do {
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_END:
+			if (nextoffset >= 0)
+				return -FDT_ERR_BADSTRUCTURE;
+			else
+				return nextoffset;
+
+		case FDT_PROP:
+			return offset;
+		}
+		offset = nextoffset;
+	} while (tag == FDT_NOP);
+
+	return -FDT_ERR_NOTFOUND;
+}
+
+int fdt_subnode_offset_namelen(const void *fdt, int offset,
+			       const char *name, int namelen)
+{
+	int depth;
+
+	FDT_RO_PROBE(fdt);
+
+	for (depth = 0;
+	     (offset >= 0) && (depth >= 0);
+	     offset = fdt_next_node(fdt, offset, &depth))
+		if ((depth == 1)
+		    && fdt_nodename_eq_(fdt, offset, name, namelen))
+			return offset;
+
+	if (depth < 0)
+		return -FDT_ERR_NOTFOUND;
+	return offset; /* error */
+}
+
+int fdt_subnode_offset(const void *fdt, int parentoffset,
+		       const char *name)
+{
+	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
+}
+
+int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen)
+{
+	const char *end = path + namelen;
+	const char *p = path;
+	int offset = 0;
+
+	FDT_RO_PROBE(fdt);
+
+	/* see if we have an alias */
+	if (*path != '/') {
+		const char *q = memchr(path, '/', end - p);
+
+		if (!q)
+			q = end;
+
+		p = fdt_get_alias_namelen(fdt, p, q - p);
+		if (!p)
+			return -FDT_ERR_BADPATH;
+		offset = fdt_path_offset(fdt, p);
+
+		p = q;
+	}
+
+	while (p < end) {
+		const char *q;
+
+		while (*p == '/') {
+			p++;
+			if (p == end)
+				return offset;
+		}
+		q = memchr(p, '/', end - p);
+		if (! q)
+			q = end;
+
+		offset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);
+		if (offset < 0)
+			return offset;
+
+		p = q;
+	}
+
+	return offset;
+}
+
+int fdt_path_offset(const void *fdt, const char *path)
+{
+	return fdt_path_offset_namelen(fdt, path, strlen(path));
+}
+
+const char *fdt_get_name(const void *fdt, int nodeoffset, int *len)
+{
+	const struct fdt_node_header *nh = fdt_offset_ptr_(fdt, nodeoffset);
+	const char *nameptr;
+	int err;
+
+	if (((err = fdt_ro_probe_(fdt)) < 0)
+	    || ((err = fdt_check_node_offset_(fdt, nodeoffset)) < 0))
+			goto fail;
+
+	nameptr = nh->name;
+
+	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {
+		/*
+		 * For old FDT versions, match the naming conventions of V16:
+		 * give only the leaf name (after all /). The actual tree
+		 * contents are loosely checked.
+		 */
+		const char *leaf;
+		leaf = strrchr(nameptr, '/');
+		if (leaf == NULL) {
+			err = -FDT_ERR_BADSTRUCTURE;
+			goto fail;
+		}
+		nameptr = leaf+1;
+	}
+
+	if (len)
+		*len = strlen(nameptr);
+
+	return nameptr;
+
+ fail:
+	if (len)
+		*len = err;
+	return NULL;
+}
+
+int fdt_first_property_offset(const void *fdt, int nodeoffset)
+{
+	int offset;
+
+	if ((offset = fdt_check_node_offset_(fdt, nodeoffset)) < 0)
+		return offset;
+
+	return nextprop_(fdt, offset);
+}
+
+int fdt_next_property_offset(const void *fdt, int offset)
+{
+	if ((offset = fdt_check_prop_offset_(fdt, offset)) < 0)
+		return offset;
+
+	return nextprop_(fdt, offset);
+}
+
+static const struct fdt_property *fdt_get_property_by_offset_(const void *fdt,
+						              int offset,
+						              int *lenp)
+{
+	int err;
+	const struct fdt_property *prop;
+
+	if (!can_assume(VALID_INPUT) &&
+	    (err = fdt_check_prop_offset_(fdt, offset)) < 0) {
+		if (lenp)
+			*lenp = err;
+		return NULL;
+	}
+
+	prop = fdt_offset_ptr_(fdt, offset);
+
+	if (lenp)
+		*lenp = fdt32_ld_(&prop->len);
+
+	return prop;
+}
+
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp)
+{
+	/* Prior to version 16, properties may need realignment
+	 * and this API does not work. fdt_getprop_*() will, however. */
+
+	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {
+		if (lenp)
+			*lenp = -FDT_ERR_BADVERSION;
+		return NULL;
+	}
+
+	return fdt_get_property_by_offset_(fdt, offset, lenp);
+}
+
+static const struct fdt_property *fdt_get_property_namelen_(const void *fdt,
+						            int offset,
+						            const char *name,
+						            int namelen,
+							    int *lenp,
+							    int *poffset)
+{
+	for (offset = fdt_first_property_offset(fdt, offset);
+	     (offset >= 0);
+	     (offset = fdt_next_property_offset(fdt, offset))) {
+		const struct fdt_property *prop;
+
+		prop = fdt_get_property_by_offset_(fdt, offset, lenp);
+		if (!can_assume(LIBFDT_FLAWLESS) && !prop) {
+			offset = -FDT_ERR_INTERNAL;
+			break;
+		}
+		if (fdt_string_eq_(fdt, fdt32_ld_(&prop->nameoff),
+				   name, namelen)) {
+			if (poffset)
+				*poffset = offset;
+			return prop;
+		}
+	}
+
+	if (lenp)
+		*lenp = offset;
+	return NULL;
+}
+
+
+const struct fdt_property *fdt_get_property_namelen(const void *fdt,
+						    int offset,
+						    const char *name,
+						    int namelen, int *lenp)
+{
+	/* Prior to version 16, properties may need realignment
+	 * and this API does not work. fdt_getprop_*() will, however. */
+	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {
+		if (lenp)
+			*lenp = -FDT_ERR_BADVERSION;
+		return NULL;
+	}
+
+	return fdt_get_property_namelen_(fdt, offset, name, namelen, lenp,
+					 NULL);
+}
+
+
+const struct fdt_property *fdt_get_property(const void *fdt,
+					    int nodeoffset,
+					    const char *name, int *lenp)
+{
+	return fdt_get_property_namelen(fdt, nodeoffset, name,
+					strlen(name), lenp);
+}
+
+const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
+				const char *name, int namelen, int *lenp)
+{
+	int poffset;
+	const struct fdt_property *prop;
+
+	prop = fdt_get_property_namelen_(fdt, nodeoffset, name, namelen, lenp,
+					 &poffset);
+	if (!prop)
+		return NULL;
+
+	/* Handle realignment */
+	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
+	    (poffset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
+		return prop->data + 4;
+	return prop->data;
+}
+
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp)
+{
+	const struct fdt_property *prop;
+
+	prop = fdt_get_property_by_offset_(fdt, offset, lenp);
+	if (!prop)
+		return NULL;
+	if (namep) {
+		const char *name;
+		int namelen;
+
+		if (!can_assume(VALID_INPUT)) {
+			name = fdt_get_string(fdt, fdt32_ld_(&prop->nameoff),
+					      &namelen);
+			if (!name) {
+				if (lenp)
+					*lenp = namelen;
+				return NULL;
+			}
+			*namep = name;
+		} else {
+			*namep = fdt_string(fdt, fdt32_ld_(&prop->nameoff));
+		}
+	}
+
+	/* Handle realignment */
+	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
+	    (offset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
+		return prop->data + 4;
+	return prop->data;
+}
+
+const void *fdt_getprop(const void *fdt, int nodeoffset,
+			const char *name, int *lenp)
+{
+	return fdt_getprop_namelen(fdt, nodeoffset, name, strlen(name), lenp);
+}
+
+uint32_t fdt_get_phandle(const void *fdt, int nodeoffset)
+{
+	const fdt32_t *php;
+	int len;
+
+	/* FIXME: This is a bit sub-optimal, since we potentially scan
+	 * over all the properties twice. */
+	php = fdt_getprop(fdt, nodeoffset, "phandle", &len);
+	if (!php || (len != sizeof(*php))) {
+		php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
+		if (!php || (len != sizeof(*php)))
+			return 0;
+	}
+
+	return fdt32_ld_(php);
+}
+
+const char *fdt_get_alias_namelen(const void *fdt,
+				  const char *name, int namelen)
+{
+	int aliasoffset;
+
+	aliasoffset = fdt_path_offset(fdt, "/aliases");
+	if (aliasoffset < 0)
+		return NULL;
+
+	return fdt_getprop_namelen(fdt, aliasoffset, name, namelen, NULL);
+}
+
+const char *fdt_get_alias(const void *fdt, const char *name)
+{
+	return fdt_get_alias_namelen(fdt, name, strlen(name));
+}
+
+int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)
+{
+	int pdepth = 0, p = 0;
+	int offset, depth, namelen;
+	const char *name;
+
+	FDT_RO_PROBE(fdt);
+
+	if (buflen < 2)
+		return -FDT_ERR_NOSPACE;
+
+	for (offset = 0, depth = 0;
+	     (offset >= 0) && (offset <= nodeoffset);
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		while (pdepth > depth) {
+			do {
+				p--;
+			} while (buf[p-1] != '/');
+			pdepth--;
+		}
+
+		if (pdepth >= depth) {
+			name = fdt_get_name(fdt, offset, &namelen);
+			if (!name)
+				return namelen;
+			if ((p + namelen + 1) <= buflen) {
+				memcpy(buf + p, name, namelen);
+				p += namelen;
+				buf[p++] = '/';
+				pdepth++;
+			}
+		}
+
+		if (offset == nodeoffset) {
+			if (pdepth < (depth + 1))
+				return -FDT_ERR_NOSPACE;
+
+			if (p > 1) /* special case so that root path is "/", not "" */
+				p--;
+			buf[p] = '\0';
+			return 0;
+		}
+	}
+
+	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+		return -FDT_ERR_BADOFFSET;
+	else if (offset == -FDT_ERR_BADOFFSET)
+		return -FDT_ERR_BADSTRUCTURE;
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+				 int supernodedepth, int *nodedepth)
+{
+	int offset, depth;
+	int supernodeoffset = -FDT_ERR_INTERNAL;
+
+	FDT_RO_PROBE(fdt);
+
+	if (supernodedepth < 0)
+		return -FDT_ERR_NOTFOUND;
+
+	for (offset = 0, depth = 0;
+	     (offset >= 0) && (offset <= nodeoffset);
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		if (depth == supernodedepth)
+			supernodeoffset = offset;
+
+		if (offset == nodeoffset) {
+			if (nodedepth)
+				*nodedepth = depth;
+
+			if (supernodedepth > depth)
+				return -FDT_ERR_NOTFOUND;
+			else
+				return supernodeoffset;
+		}
+	}
+
+	if (!can_assume(VALID_INPUT)) {
+		if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+			return -FDT_ERR_BADOFFSET;
+		else if (offset == -FDT_ERR_BADOFFSET)
+			return -FDT_ERR_BADSTRUCTURE;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_node_depth(const void *fdt, int nodeoffset)
+{
+	int nodedepth;
+	int err;
+
+	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);
+	if (err)
+		return (can_assume(LIBFDT_FLAWLESS) || err < 0) ? err :
+			-FDT_ERR_INTERNAL;
+	return nodedepth;
+}
+
+int fdt_parent_offset(const void *fdt, int nodeoffset)
+{
+	int nodedepth = fdt_node_depth(fdt, nodeoffset);
+
+	if (nodedepth < 0)
+		return nodedepth;
+	return fdt_supernode_atdepth_offset(fdt, nodeoffset,
+					    nodedepth - 1, NULL);
+}
+
+int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+				  const char *propname,
+				  const void *propval, int proplen)
+{
+	int offset;
+	const void *val;
+	int len;
+
+	FDT_RO_PROBE(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we scan each
+	 * property of a node in fdt_getprop(), then if that didn't
+	 * find what we want, we scan over them again making our way
+	 * to the next node.  Still it's the easiest to implement
+	 * approach; performance can come later. */
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		val = fdt_getprop(fdt, offset, propname, &len);
+		if (val && (len == proplen)
+		    && (memcmp(val, propval, len) == 0))
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
+{
+	int offset;
+
+	if ((phandle == 0) || (phandle == ~0U))
+		return -FDT_ERR_BADPHANDLE;
+
+	FDT_RO_PROBE(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we
+	 * potentially scan each property of a node in
+	 * fdt_get_phandle(), then if that didn't find what
+	 * we want, we scan over them again making our way to the next
+	 * node.  Still it's the easiest to implement approach;
+	 * performance can come later. */
+	for (offset = fdt_next_node(fdt, -1, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		if (fdt_get_phandle(fdt, offset) == phandle)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_stringlist_contains(const char *strlist, int listlen, const char *str)
+{
+	int len = strlen(str);
+	const char *p;
+
+	while (listlen >= len) {
+		if (memcmp(str, strlist, len+1) == 0)
+			return 1;
+		p = memchr(strlist, '\0', listlen);
+		if (!p)
+			return 0; /* malformed strlist.. */
+		listlen -= (p-strlist) + 1;
+		strlist = p + 1;
+	}
+	return 0;
+}
+
+int fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property)
+{
+	const char *list, *end;
+	int length, count = 0;
+
+	list = fdt_getprop(fdt, nodeoffset, property, &length);
+	if (!list)
+		return length;
+
+	end = list + length;
+
+	while (list < end) {
+		length = strnlen(list, end - list) + 1;
+
+		/* Abort if the last string isn't properly NUL-terminated. */
+		if (list + length > end)
+			return -FDT_ERR_BADVALUE;
+
+		list += length;
+		count++;
+	}
+
+	return count;
+}
+
+int fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,
+			  const char *string)
+{
+	int length, len, idx = 0;
+	const char *list, *end;
+
+	list = fdt_getprop(fdt, nodeoffset, property, &length);
+	if (!list)
+		return length;
+
+	len = strlen(string) + 1;
+	end = list + length;
+
+	while (list < end) {
+		length = strnlen(list, end - list) + 1;
+
+		/* Abort if the last string isn't properly NUL-terminated. */
+		if (list + length > end)
+			return -FDT_ERR_BADVALUE;
+
+		if (length == len && memcmp(list, string, length) == 0)
+			return idx;
+
+		list += length;
+		idx++;
+	}
+
+	return -FDT_ERR_NOTFOUND;
+}
+
+const char *fdt_stringlist_get(const void *fdt, int nodeoffset,
+			       const char *property, int idx,
+			       int *lenp)
+{
+	const char *list, *end;
+	int length;
+
+	list = fdt_getprop(fdt, nodeoffset, property, &length);
+	if (!list) {
+		if (lenp)
+			*lenp = length;
+
+		return NULL;
+	}
+
+	end = list + length;
+
+	while (list < end) {
+		length = strnlen(list, end - list) + 1;
+
+		/* Abort if the last string isn't properly NUL-terminated. */
+		if (list + length > end) {
+			if (lenp)
+				*lenp = -FDT_ERR_BADVALUE;
+
+			return NULL;
+		}
+
+		if (idx == 0) {
+			if (lenp)
+				*lenp = length - 1;
+
+			return list;
+		}
+
+		list += length;
+		idx--;
+	}
+
+	if (lenp)
+		*lenp = -FDT_ERR_NOTFOUND;
+
+	return NULL;
+}
+
+int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+			      const char *compatible)
+{
+	const void *prop;
+	int len;
+
+	prop = fdt_getprop(fdt, nodeoffset, "compatible", &len);
+	if (!prop)
+		return len;
+
+	return !fdt_stringlist_contains(prop, len, compatible);
+}
+
+int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+				  const char *compatible)
+{
+	int offset, err;
+
+	FDT_RO_PROBE(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we scan each
+	 * property of a node in fdt_node_check_compatible(), then if
+	 * that didn't find what we want, we scan over them again
+	 * making our way to the next node.  Still it's the easiest to
+	 * implement approach; performance can come later. */
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		err = fdt_node_check_compatible(fdt, offset, compatible);
+		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
+			return err;
+		else if (err == 0)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
diff --git a/dtc/libfdt/fdt_rw.c b/dtc/libfdt/fdt_rw.c
new file mode 100644
index 0000000..3621d36
--- /dev/null
+++ b/dtc/libfdt/fdt_rw.c
@@ -0,0 +1,500 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+static int fdt_blocks_misordered_(const void *fdt,
+				  int mem_rsv_size, int struct_size)
+{
+	return (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))
+		|| (fdt_off_dt_struct(fdt) <
+		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
+		|| (fdt_off_dt_strings(fdt) <
+		    (fdt_off_dt_struct(fdt) + struct_size))
+		|| (fdt_totalsize(fdt) <
+		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
+}
+
+static int fdt_rw_probe_(void *fdt)
+{
+	if (can_assume(VALID_DTB))
+		return 0;
+	FDT_RO_PROBE(fdt);
+
+	if (!can_assume(LATEST) && fdt_version(fdt) < 17)
+		return -FDT_ERR_BADVERSION;
+	if (fdt_blocks_misordered_(fdt, sizeof(struct fdt_reserve_entry),
+				   fdt_size_dt_struct(fdt)))
+		return -FDT_ERR_BADLAYOUT;
+	if (!can_assume(LATEST) && fdt_version(fdt) > 17)
+		fdt_set_version(fdt, 17);
+
+	return 0;
+}
+
+#define FDT_RW_PROBE(fdt) \
+	{ \
+		int err_; \
+		if ((err_ = fdt_rw_probe_(fdt)) != 0) \
+			return err_; \
+	}
+
+static inline unsigned int fdt_data_size_(void *fdt)
+{
+	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+}
+
+static int fdt_splice_(void *fdt, void *splicepoint, int oldlen, int newlen)
+{
+	char *p = splicepoint;
+	unsigned int dsize = fdt_data_size_(fdt);
+	size_t soff = p - (char *)fdt;
+
+	if ((oldlen < 0) || (soff + oldlen < soff) || (soff + oldlen > dsize))
+		return -FDT_ERR_BADOFFSET;
+	if ((p < (char *)fdt) || (dsize + newlen < (unsigned)oldlen))
+		return -FDT_ERR_BADOFFSET;
+	if (dsize - oldlen + newlen > fdt_totalsize(fdt))
+		return -FDT_ERR_NOSPACE;
+	memmove(p + newlen, p + oldlen, ((char *)fdt + dsize) - (p + oldlen));
+	return 0;
+}
+
+static int fdt_splice_mem_rsv_(void *fdt, struct fdt_reserve_entry *p,
+			       int oldn, int newn)
+{
+	int delta = (newn - oldn) * sizeof(*p);
+	int err;
+	err = fdt_splice_(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));
+	if (err)
+		return err;
+	fdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);
+	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+	return 0;
+}
+
+static int fdt_splice_struct_(void *fdt, void *p,
+			      int oldlen, int newlen)
+{
+	int delta = newlen - oldlen;
+	int err;
+
+	if ((err = fdt_splice_(fdt, p, oldlen, newlen)))
+		return err;
+
+	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
+	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+	return 0;
+}
+
+/* Must only be used to roll back in case of error */
+static void fdt_del_last_string_(void *fdt, const char *s)
+{
+	int newlen = strlen(s) + 1;
+
+	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) - newlen);
+}
+
+static int fdt_splice_string_(void *fdt, int newlen)
+{
+	void *p = (char *)fdt
+		+ fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+	int err;
+
+	if ((err = fdt_splice_(fdt, p, 0, newlen)))
+		return err;
+
+	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
+	return 0;
+}
+
+/**
+ * fdt_find_add_string_() - Find or allocate a string
+ *
+ * @fdt: pointer to the device tree to check/adjust
+ * @s: string to find/add
+ * @allocated: Set to 0 if the string was found, 1 if not found and so
+ *	allocated. Ignored if can_assume(NO_ROLLBACK)
+ * @return offset of string in the string table (whether found or added)
+ */
+static int fdt_find_add_string_(void *fdt, const char *s, int *allocated)
+{
+	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
+	const char *p;
+	char *new;
+	int len = strlen(s) + 1;
+	int err;
+
+	if (!can_assume(NO_ROLLBACK))
+		*allocated = 0;
+
+	p = fdt_find_string_(strtab, fdt_size_dt_strings(fdt), s);
+	if (p)
+		/* found it */
+		return (p - strtab);
+
+	new = strtab + fdt_size_dt_strings(fdt);
+	err = fdt_splice_string_(fdt, len);
+	if (err)
+		return err;
+
+	if (!can_assume(NO_ROLLBACK))
+		*allocated = 1;
+
+	memcpy(new, s, len);
+	return (new - strtab);
+}
+
+int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)
+{
+	struct fdt_reserve_entry *re;
+	int err;
+
+	FDT_RW_PROBE(fdt);
+
+	re = fdt_mem_rsv_w_(fdt, fdt_num_mem_rsv(fdt));
+	err = fdt_splice_mem_rsv_(fdt, re, 0, 1);
+	if (err)
+		return err;
+
+	re->address = cpu_to_fdt64(address);
+	re->size = cpu_to_fdt64(size);
+	return 0;
+}
+
+int fdt_del_mem_rsv(void *fdt, int n)
+{
+	struct fdt_reserve_entry *re = fdt_mem_rsv_w_(fdt, n);
+
+	FDT_RW_PROBE(fdt);
+
+	if (n >= fdt_num_mem_rsv(fdt))
+		return -FDT_ERR_NOTFOUND;
+
+	return fdt_splice_mem_rsv_(fdt, re, 1, 0);
+}
+
+static int fdt_resize_property_(void *fdt, int nodeoffset, const char *name,
+				int len, struct fdt_property **prop)
+{
+	int oldlen;
+	int err;
+
+	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
+	if (!*prop)
+		return oldlen;
+
+	if ((err = fdt_splice_struct_(fdt, (*prop)->data, FDT_TAGALIGN(oldlen),
+				      FDT_TAGALIGN(len))))
+		return err;
+
+	(*prop)->len = cpu_to_fdt32(len);
+	return 0;
+}
+
+static int fdt_add_property_(void *fdt, int nodeoffset, const char *name,
+			     int len, struct fdt_property **prop)
+{
+	int proplen;
+	int nextoffset;
+	int namestroff;
+	int err;
+	int allocated;
+
+	if ((nextoffset = fdt_check_node_offset_(fdt, nodeoffset)) < 0)
+		return nextoffset;
+
+	namestroff = fdt_find_add_string_(fdt, name, &allocated);
+	if (namestroff < 0)
+		return namestroff;
+
+	*prop = fdt_offset_ptr_w_(fdt, nextoffset);
+	proplen = sizeof(**prop) + FDT_TAGALIGN(len);
+
+	err = fdt_splice_struct_(fdt, *prop, 0, proplen);
+	if (err) {
+		/* Delete the string if we failed to add it */
+		if (!can_assume(NO_ROLLBACK) && allocated)
+			fdt_del_last_string_(fdt, name);
+		return err;
+	}
+
+	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
+	(*prop)->nameoff = cpu_to_fdt32(namestroff);
+	(*prop)->len = cpu_to_fdt32(len);
+	return 0;
+}
+
+int fdt_set_name(void *fdt, int nodeoffset, const char *name)
+{
+	char *namep;
+	int oldlen, newlen;
+	int err;
+
+	FDT_RW_PROBE(fdt);
+
+	namep = (char *)(uintptr_t)fdt_get_name(fdt, nodeoffset, &oldlen);
+	if (!namep)
+		return oldlen;
+
+	newlen = strlen(name);
+
+	err = fdt_splice_struct_(fdt, namep, FDT_TAGALIGN(oldlen+1),
+				 FDT_TAGALIGN(newlen+1));
+	if (err)
+		return err;
+
+	memcpy(namep, name, newlen+1);
+	return 0;
+}
+
+int fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,
+			    int len, void **prop_data)
+{
+	struct fdt_property *prop;
+	int err;
+
+	FDT_RW_PROBE(fdt);
+
+	err = fdt_resize_property_(fdt, nodeoffset, name, len, &prop);
+	if (err == -FDT_ERR_NOTFOUND)
+		err = fdt_add_property_(fdt, nodeoffset, name, len, &prop);
+	if (err)
+		return err;
+
+	*prop_data = prop->data;
+	return 0;
+}
+
+int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+		const void *val, int len)
+{
+	void *prop_data;
+	int err;
+
+	err = fdt_setprop_placeholder(fdt, nodeoffset, name, len, &prop_data);
+	if (err)
+		return err;
+
+	if (len)
+		memcpy(prop_data, val, len);
+	return 0;
+}
+
+int fdt_appendprop(void *fdt, int nodeoffset, const char *name,
+		   const void *val, int len)
+{
+	struct fdt_property *prop;
+	int err, oldlen, newlen;
+
+	FDT_RW_PROBE(fdt);
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
+	if (prop) {
+		newlen = len + oldlen;
+		err = fdt_splice_struct_(fdt, prop->data,
+					 FDT_TAGALIGN(oldlen),
+					 FDT_TAGALIGN(newlen));
+		if (err)
+			return err;
+		prop->len = cpu_to_fdt32(newlen);
+		memcpy(prop->data + oldlen, val, len);
+	} else {
+		err = fdt_add_property_(fdt, nodeoffset, name, len, &prop);
+		if (err)
+			return err;
+		memcpy(prop->data, val, len);
+	}
+	return 0;
+}
+
+int fdt_delprop(void *fdt, int nodeoffset, const char *name)
+{
+	struct fdt_property *prop;
+	int len, proplen;
+
+	FDT_RW_PROBE(fdt);
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+	if (!prop)
+		return len;
+
+	proplen = sizeof(*prop) + FDT_TAGALIGN(len);
+	return fdt_splice_struct_(fdt, prop, proplen, 0);
+}
+
+int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+			    const char *name, int namelen)
+{
+	struct fdt_node_header *nh;
+	int offset, nextoffset;
+	int nodelen;
+	int err;
+	uint32_t tag;
+	fdt32_t *endtag;
+
+	FDT_RW_PROBE(fdt);
+
+	offset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);
+	if (offset >= 0)
+		return -FDT_ERR_EXISTS;
+	else if (offset != -FDT_ERR_NOTFOUND)
+		return offset;
+
+	/* Try to place the new node after the parent's properties */
+	tag = fdt_next_tag(fdt, parentoffset, &nextoffset);
+	/* the fdt_subnode_offset_namelen() should ensure this never hits */
+	if (!can_assume(LIBFDT_FLAWLESS) && (tag != FDT_BEGIN_NODE))
+		return -FDT_ERR_INTERNAL;
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+	} while ((tag == FDT_PROP) || (tag == FDT_NOP));
+
+	nh = fdt_offset_ptr_w_(fdt, offset);
+	nodelen = sizeof(*nh) + FDT_TAGALIGN(namelen+1) + FDT_TAGSIZE;
+
+	err = fdt_splice_struct_(fdt, nh, 0, nodelen);
+	if (err)
+		return err;
+
+	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
+	memset(nh->name, 0, FDT_TAGALIGN(namelen+1));
+	memcpy(nh->name, name, namelen);
+	endtag = (fdt32_t *)((char *)nh + nodelen - FDT_TAGSIZE);
+	*endtag = cpu_to_fdt32(FDT_END_NODE);
+
+	return offset;
+}
+
+int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
+{
+	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
+}
+
+int fdt_del_node(void *fdt, int nodeoffset)
+{
+	int endoffset;
+
+	FDT_RW_PROBE(fdt);
+
+	endoffset = fdt_node_end_offset_(fdt, nodeoffset);
+	if (endoffset < 0)
+		return endoffset;
+
+	return fdt_splice_struct_(fdt, fdt_offset_ptr_w_(fdt, nodeoffset),
+				  endoffset - nodeoffset, 0);
+}
+
+static void fdt_packblocks_(const char *old, char *new,
+			    int mem_rsv_size,
+			    int struct_size,
+			    int strings_size)
+{
+	int mem_rsv_off, struct_off, strings_off;
+
+	mem_rsv_off = FDT_ALIGN(sizeof(struct fdt_header), 8);
+	struct_off = mem_rsv_off + mem_rsv_size;
+	strings_off = struct_off + struct_size;
+
+	memmove(new + mem_rsv_off, old + fdt_off_mem_rsvmap(old), mem_rsv_size);
+	fdt_set_off_mem_rsvmap(new, mem_rsv_off);
+
+	memmove(new + struct_off, old + fdt_off_dt_struct(old), struct_size);
+	fdt_set_off_dt_struct(new, struct_off);
+	fdt_set_size_dt_struct(new, struct_size);
+
+	memmove(new + strings_off, old + fdt_off_dt_strings(old), strings_size);
+	fdt_set_off_dt_strings(new, strings_off);
+	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
+}
+
+int fdt_open_into(const void *fdt, void *buf, int bufsize)
+{
+	int err;
+	int mem_rsv_size, struct_size;
+	int newsize;
+	const char *fdtstart = fdt;
+	const char *fdtend = fdtstart + fdt_totalsize(fdt);
+	char *tmp;
+
+	FDT_RO_PROBE(fdt);
+
+	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+		* sizeof(struct fdt_reserve_entry);
+
+	if (can_assume(LATEST) || fdt_version(fdt) >= 17) {
+		struct_size = fdt_size_dt_struct(fdt);
+	} else if (fdt_version(fdt) == 16) {
+		struct_size = 0;
+		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
+			;
+		if (struct_size < 0)
+			return struct_size;
+	} else {
+		return -FDT_ERR_BADVERSION;
+	}
+
+	if (can_assume(LIBFDT_ORDER) ||
+	    !fdt_blocks_misordered_(fdt, mem_rsv_size, struct_size)) {
+		/* no further work necessary */
+		err = fdt_move(fdt, buf, bufsize);
+		if (err)
+			return err;
+		fdt_set_version(buf, 17);
+		fdt_set_size_dt_struct(buf, struct_size);
+		fdt_set_totalsize(buf, bufsize);
+		return 0;
+	}
+
+	/* Need to reorder */
+	newsize = FDT_ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size
+		+ struct_size + fdt_size_dt_strings(fdt);
+
+	if (bufsize < newsize)
+		return -FDT_ERR_NOSPACE;
+
+	/* First attempt to build converted tree at beginning of buffer */
+	tmp = buf;
+	/* But if that overlaps with the old tree... */
+	if (((tmp + newsize) > fdtstart) && (tmp < fdtend)) {
+		/* Try right after the old tree instead */
+		tmp = (char *)(uintptr_t)fdtend;
+		if ((tmp + newsize) > ((char *)buf + bufsize))
+			return -FDT_ERR_NOSPACE;
+	}
+
+	fdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size,
+			fdt_size_dt_strings(fdt));
+	memmove(buf, tmp, newsize);
+
+	fdt_set_magic(buf, FDT_MAGIC);
+	fdt_set_totalsize(buf, bufsize);
+	fdt_set_version(buf, 17);
+	fdt_set_last_comp_version(buf, 16);
+	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
+
+	return 0;
+}
+
+int fdt_pack(void *fdt)
+{
+	int mem_rsv_size;
+
+	FDT_RW_PROBE(fdt);
+
+	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+		* sizeof(struct fdt_reserve_entry);
+	fdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt),
+			fdt_size_dt_strings(fdt));
+	fdt_set_totalsize(fdt, fdt_data_size_(fdt));
+
+	return 0;
+}
diff --git a/dtc/libfdt/fdt_strerror.c b/dtc/libfdt/fdt_strerror.c
new file mode 100644
index 0000000..b435693
--- /dev/null
+++ b/dtc/libfdt/fdt_strerror.c
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+struct fdt_errtabent {
+	const char *str;
+};
+
+#define FDT_ERRTABENT(val) \
+	[(val)] = { .str = #val, }
+
+static struct fdt_errtabent fdt_errtable[] = {
+	FDT_ERRTABENT(FDT_ERR_NOTFOUND),
+	FDT_ERRTABENT(FDT_ERR_EXISTS),
+	FDT_ERRTABENT(FDT_ERR_NOSPACE),
+
+	FDT_ERRTABENT(FDT_ERR_BADOFFSET),
+	FDT_ERRTABENT(FDT_ERR_BADPATH),
+	FDT_ERRTABENT(FDT_ERR_BADPHANDLE),
+	FDT_ERRTABENT(FDT_ERR_BADSTATE),
+
+	FDT_ERRTABENT(FDT_ERR_TRUNCATED),
+	FDT_ERRTABENT(FDT_ERR_BADMAGIC),
+	FDT_ERRTABENT(FDT_ERR_BADVERSION),
+	FDT_ERRTABENT(FDT_ERR_BADSTRUCTURE),
+	FDT_ERRTABENT(FDT_ERR_BADLAYOUT),
+	FDT_ERRTABENT(FDT_ERR_INTERNAL),
+	FDT_ERRTABENT(FDT_ERR_BADNCELLS),
+	FDT_ERRTABENT(FDT_ERR_BADVALUE),
+	FDT_ERRTABENT(FDT_ERR_BADOVERLAY),
+	FDT_ERRTABENT(FDT_ERR_NOPHANDLES),
+	FDT_ERRTABENT(FDT_ERR_BADFLAGS),
+};
+#define FDT_ERRTABSIZE	((int)(sizeof(fdt_errtable) / sizeof(fdt_errtable[0])))
+
+const char *fdt_strerror(int errval)
+{
+	if (errval > 0)
+		return "<valid offset/length>";
+	else if (errval == 0)
+		return "<no error>";
+	else if (-errval < FDT_ERRTABSIZE) {
+		const char *s = fdt_errtable[-errval].str;
+
+		if (s)
+			return s;
+	}
+
+	return "<unknown error>";
+}
diff --git a/dtc/libfdt/fdt_sw.c b/dtc/libfdt/fdt_sw.c
new file mode 100644
index 0000000..4c569ee
--- /dev/null
+++ b/dtc/libfdt/fdt_sw.c
@@ -0,0 +1,384 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+static int fdt_sw_probe_(void *fdt)
+{
+	if (!can_assume(VALID_INPUT)) {
+		if (fdt_magic(fdt) == FDT_MAGIC)
+			return -FDT_ERR_BADSTATE;
+		else if (fdt_magic(fdt) != FDT_SW_MAGIC)
+			return -FDT_ERR_BADMAGIC;
+	}
+
+	return 0;
+}
+
+#define FDT_SW_PROBE(fdt) \
+	{ \
+		int err; \
+		if ((err = fdt_sw_probe_(fdt)) != 0) \
+			return err; \
+	}
+
+/* 'memrsv' state:	Initial state after fdt_create()
+ *
+ * Allowed functions:
+ *	fdt_add_reservemap_entry()
+ *	fdt_finish_reservemap()		[moves to 'struct' state]
+ */
+static int fdt_sw_probe_memrsv_(void *fdt)
+{
+	int err = fdt_sw_probe_(fdt);
+	if (err)
+		return err;
+
+	if (!can_assume(VALID_INPUT) && fdt_off_dt_strings(fdt) != 0)
+		return -FDT_ERR_BADSTATE;
+	return 0;
+}
+
+#define FDT_SW_PROBE_MEMRSV(fdt) \
+	{ \
+		int err; \
+		if ((err = fdt_sw_probe_memrsv_(fdt)) != 0) \
+			return err; \
+	}
+
+/* 'struct' state:	Enter this state after fdt_finish_reservemap()
+ *
+ * Allowed functions:
+ *	fdt_begin_node()
+ *	fdt_end_node()
+ *	fdt_property*()
+ *	fdt_finish()			[moves to 'complete' state]
+ */
+static int fdt_sw_probe_struct_(void *fdt)
+{
+	int err = fdt_sw_probe_(fdt);
+	if (err)
+		return err;
+
+	if (!can_assume(VALID_INPUT) &&
+	    fdt_off_dt_strings(fdt) != fdt_totalsize(fdt))
+		return -FDT_ERR_BADSTATE;
+	return 0;
+}
+
+#define FDT_SW_PROBE_STRUCT(fdt) \
+	{ \
+		int err; \
+		if ((err = fdt_sw_probe_struct_(fdt)) != 0) \
+			return err; \
+	}
+
+static inline uint32_t sw_flags(void *fdt)
+{
+	/* assert: (fdt_magic(fdt) == FDT_SW_MAGIC) */
+	return fdt_last_comp_version(fdt);
+}
+
+/* 'complete' state:	Enter this state after fdt_finish()
+ *
+ * Allowed functions: none
+ */
+
+static void *fdt_grab_space_(void *fdt, size_t len)
+{
+	unsigned int offset = fdt_size_dt_struct(fdt);
+	unsigned int spaceleft;
+
+	spaceleft = fdt_totalsize(fdt) - fdt_off_dt_struct(fdt)
+		- fdt_size_dt_strings(fdt);
+
+	if ((offset + len < offset) || (offset + len > spaceleft))
+		return NULL;
+
+	fdt_set_size_dt_struct(fdt, offset + len);
+	return fdt_offset_ptr_w_(fdt, offset);
+}
+
+int fdt_create_with_flags(void *buf, int bufsize, uint32_t flags)
+{
+	const int hdrsize = FDT_ALIGN(sizeof(struct fdt_header),
+				      sizeof(struct fdt_reserve_entry));
+	void *fdt = buf;
+
+	if (bufsize < hdrsize)
+		return -FDT_ERR_NOSPACE;
+
+	if (flags & ~FDT_CREATE_FLAGS_ALL)
+		return -FDT_ERR_BADFLAGS;
+
+	memset(buf, 0, bufsize);
+
+	/*
+	 * magic and last_comp_version keep intermediate state during the fdt
+	 * creation process, which is replaced with the proper FDT format by
+	 * fdt_finish().
+	 *
+	 * flags should be accessed with sw_flags().
+	 */
+	fdt_set_magic(fdt, FDT_SW_MAGIC);
+	fdt_set_version(fdt, FDT_LAST_SUPPORTED_VERSION);
+	fdt_set_last_comp_version(fdt, flags);
+
+	fdt_set_totalsize(fdt,  bufsize);
+
+	fdt_set_off_mem_rsvmap(fdt, hdrsize);
+	fdt_set_off_dt_struct(fdt, fdt_off_mem_rsvmap(fdt));
+	fdt_set_off_dt_strings(fdt, 0);
+
+	return 0;
+}
+
+int fdt_create(void *buf, int bufsize)
+{
+	return fdt_create_with_flags(buf, bufsize, 0);
+}
+
+int fdt_resize(void *fdt, void *buf, int bufsize)
+{
+	size_t headsize, tailsize;
+	char *oldtail, *newtail;
+
+	FDT_SW_PROBE(fdt);
+
+	if (bufsize < 0)
+		return -FDT_ERR_NOSPACE;
+
+	headsize = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
+	tailsize = fdt_size_dt_strings(fdt);
+
+	if (!can_assume(VALID_DTB) &&
+	    headsize + tailsize > fdt_totalsize(fdt))
+		return -FDT_ERR_INTERNAL;
+
+	if ((headsize + tailsize) > (unsigned)bufsize)
+		return -FDT_ERR_NOSPACE;
+
+	oldtail = (char *)fdt + fdt_totalsize(fdt) - tailsize;
+	newtail = (char *)buf + bufsize - tailsize;
+
+	/* Two cases to avoid clobbering data if the old and new
+	 * buffers partially overlap */
+	if (buf <= fdt) {
+		memmove(buf, fdt, headsize);
+		memmove(newtail, oldtail, tailsize);
+	} else {
+		memmove(newtail, oldtail, tailsize);
+		memmove(buf, fdt, headsize);
+	}
+
+	fdt_set_totalsize(buf, bufsize);
+	if (fdt_off_dt_strings(buf))
+		fdt_set_off_dt_strings(buf, bufsize);
+
+	return 0;
+}
+
+int fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size)
+{
+	struct fdt_reserve_entry *re;
+	int offset;
+
+	FDT_SW_PROBE_MEMRSV(fdt);
+
+	offset = fdt_off_dt_struct(fdt);
+	if ((offset + sizeof(*re)) > fdt_totalsize(fdt))
+		return -FDT_ERR_NOSPACE;
+
+	re = (struct fdt_reserve_entry *)((char *)fdt + offset);
+	re->address = cpu_to_fdt64(addr);
+	re->size = cpu_to_fdt64(size);
+
+	fdt_set_off_dt_struct(fdt, offset + sizeof(*re));
+
+	return 0;
+}
+
+int fdt_finish_reservemap(void *fdt)
+{
+	int err = fdt_add_reservemap_entry(fdt, 0, 0);
+
+	if (err)
+		return err;
+
+	fdt_set_off_dt_strings(fdt, fdt_totalsize(fdt));
+	return 0;
+}
+
+int fdt_begin_node(void *fdt, const char *name)
+{
+	struct fdt_node_header *nh;
+	int namelen;
+
+	FDT_SW_PROBE_STRUCT(fdt);
+
+	namelen = strlen(name) + 1;
+	nh = fdt_grab_space_(fdt, sizeof(*nh) + FDT_TAGALIGN(namelen));
+	if (! nh)
+		return -FDT_ERR_NOSPACE;
+
+	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
+	memcpy(nh->name, name, namelen);
+	return 0;
+}
+
+int fdt_end_node(void *fdt)
+{
+	fdt32_t *en;
+
+	FDT_SW_PROBE_STRUCT(fdt);
+
+	en = fdt_grab_space_(fdt, FDT_TAGSIZE);
+	if (! en)
+		return -FDT_ERR_NOSPACE;
+
+	*en = cpu_to_fdt32(FDT_END_NODE);
+	return 0;
+}
+
+static int fdt_add_string_(void *fdt, const char *s)
+{
+	char *strtab = (char *)fdt + fdt_totalsize(fdt);
+	unsigned int strtabsize = fdt_size_dt_strings(fdt);
+	unsigned int len = strlen(s) + 1;
+	unsigned int struct_top, offset;
+
+	offset = strtabsize + len;
+	struct_top = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
+	if (fdt_totalsize(fdt) - offset < struct_top)
+		return 0; /* no more room :( */
+
+	memcpy(strtab - offset, s, len);
+	fdt_set_size_dt_strings(fdt, strtabsize + len);
+	return -offset;
+}
+
+/* Must only be used to roll back in case of error */
+static void fdt_del_last_string_(void *fdt, const char *s)
+{
+	int strtabsize = fdt_size_dt_strings(fdt);
+	int len = strlen(s) + 1;
+
+	fdt_set_size_dt_strings(fdt, strtabsize - len);
+}
+
+static int fdt_find_add_string_(void *fdt, const char *s, int *allocated)
+{
+	char *strtab = (char *)fdt + fdt_totalsize(fdt);
+	int strtabsize = fdt_size_dt_strings(fdt);
+	const char *p;
+
+	*allocated = 0;
+
+	p = fdt_find_string_(strtab - strtabsize, strtabsize, s);
+	if (p)
+		return p - strtab;
+
+	*allocated = 1;
+
+	return fdt_add_string_(fdt, s);
+}
+
+int fdt_property_placeholder(void *fdt, const char *name, int len, void **valp)
+{
+	struct fdt_property *prop;
+	int nameoff;
+	int allocated;
+
+	FDT_SW_PROBE_STRUCT(fdt);
+
+	/* String de-duplication can be slow, _NO_NAME_DEDUP skips it */
+	if (sw_flags(fdt) & FDT_CREATE_FLAG_NO_NAME_DEDUP) {
+		allocated = 1;
+		nameoff = fdt_add_string_(fdt, name);
+	} else {
+		nameoff = fdt_find_add_string_(fdt, name, &allocated);
+	}
+	if (nameoff == 0)
+		return -FDT_ERR_NOSPACE;
+
+	prop = fdt_grab_space_(fdt, sizeof(*prop) + FDT_TAGALIGN(len));
+	if (! prop) {
+		if (allocated)
+			fdt_del_last_string_(fdt, name);
+		return -FDT_ERR_NOSPACE;
+	}
+
+	prop->tag = cpu_to_fdt32(FDT_PROP);
+	prop->nameoff = cpu_to_fdt32(nameoff);
+	prop->len = cpu_to_fdt32(len);
+	*valp = prop->data;
+	return 0;
+}
+
+int fdt_property(void *fdt, const char *name, const void *val, int len)
+{
+	void *ptr;
+	int ret;
+
+	ret = fdt_property_placeholder(fdt, name, len, &ptr);
+	if (ret)
+		return ret;
+	memcpy(ptr, val, len);
+	return 0;
+}
+
+int fdt_finish(void *fdt)
+{
+	char *p = (char *)fdt;
+	fdt32_t *end;
+	int oldstroffset, newstroffset;
+	uint32_t tag;
+	int offset, nextoffset;
+
+	FDT_SW_PROBE_STRUCT(fdt);
+
+	/* Add terminator */
+	end = fdt_grab_space_(fdt, sizeof(*end));
+	if (! end)
+		return -FDT_ERR_NOSPACE;
+	*end = cpu_to_fdt32(FDT_END);
+
+	/* Relocate the string table */
+	oldstroffset = fdt_totalsize(fdt) - fdt_size_dt_strings(fdt);
+	newstroffset = fdt_off_dt_struct(fdt) + fdt_size_dt_struct(fdt);
+	memmove(p + newstroffset, p + oldstroffset, fdt_size_dt_strings(fdt));
+	fdt_set_off_dt_strings(fdt, newstroffset);
+
+	/* Walk the structure, correcting string offsets */
+	offset = 0;
+	while ((tag = fdt_next_tag(fdt, offset, &nextoffset)) != FDT_END) {
+		if (tag == FDT_PROP) {
+			struct fdt_property *prop =
+				fdt_offset_ptr_w_(fdt, offset);
+			int nameoff;
+
+			nameoff = fdt32_to_cpu(prop->nameoff);
+			nameoff += fdt_size_dt_strings(fdt);
+			prop->nameoff = cpu_to_fdt32(nameoff);
+		}
+		offset = nextoffset;
+	}
+	if (nextoffset < 0)
+		return nextoffset;
+
+	/* Finally, adjust the header */
+	fdt_set_totalsize(fdt, newstroffset + fdt_size_dt_strings(fdt));
+
+	/* And fix up fields that were keeping intermediate state. */
+	fdt_set_last_comp_version(fdt, FDT_LAST_COMPATIBLE_VERSION);
+	fdt_set_magic(fdt, FDT_MAGIC);
+
+	return 0;
+}
diff --git a/dtc/libfdt/fdt_wip.c b/dtc/libfdt/fdt_wip.c
new file mode 100644
index 0000000..c2d7566
--- /dev/null
+++ b/dtc/libfdt/fdt_wip.c
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include "libfdt_env.h"
+
+#include <fdt.h>
+#include <libfdt.h>
+
+#include "libfdt_internal.h"
+
+int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
+					const char *name, int namelen,
+					uint32_t idx, const void *val,
+					int len)
+{
+	void *propval;
+	int proplen;
+
+	propval = fdt_getprop_namelen_w(fdt, nodeoffset, name, namelen,
+					&proplen);
+	if (!propval)
+		return proplen;
+
+	if ((unsigned)proplen < (len + idx))
+		return -FDT_ERR_NOSPACE;
+
+	memcpy((char *)propval + idx, val, len);
+	return 0;
+}
+
+int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+			const void *val, int len)
+{
+	const void *propval;
+	int proplen;
+
+	propval = fdt_getprop(fdt, nodeoffset, name, &proplen);
+	if (!propval)
+		return proplen;
+
+	if (proplen != len)
+		return -FDT_ERR_NOSPACE;
+
+	return fdt_setprop_inplace_namelen_partial(fdt, nodeoffset, name,
+						   strlen(name), 0,
+						   val, len);
+}
+
+static void fdt_nop_region_(void *start, int len)
+{
+	fdt32_t *p;
+
+	for (p = start; (char *)p < ((char *)start + len); p++)
+		*p = cpu_to_fdt32(FDT_NOP);
+}
+
+int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
+{
+	struct fdt_property *prop;
+	int len;
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+	if (!prop)
+		return len;
+
+	fdt_nop_region_(prop, len + sizeof(*prop));
+
+	return 0;
+}
+
+int fdt_node_end_offset_(void *fdt, int offset)
+{
+	int depth = 0;
+
+	while ((offset >= 0) && (depth >= 0))
+		offset = fdt_next_node(fdt, offset, &depth);
+
+	return offset;
+}
+
+int fdt_nop_node(void *fdt, int nodeoffset)
+{
+	int endoffset;
+
+	endoffset = fdt_node_end_offset_(fdt, nodeoffset);
+	if (endoffset < 0)
+		return endoffset;
+
+	fdt_nop_region_(fdt_offset_ptr_w(fdt, nodeoffset, 0),
+			endoffset - nodeoffset);
+	return 0;
+}
diff --git a/dtc/libfdt/libfdt.h b/dtc/libfdt/libfdt.h
new file mode 100644
index 0000000..73467f7
--- /dev/null
+++ b/dtc/libfdt/libfdt.h
@@ -0,0 +1,2122 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+#ifndef LIBFDT_H
+#define LIBFDT_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <libfdt_env.h>
+#include <fdt.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FDT_FIRST_SUPPORTED_VERSION	0x02
+#define FDT_LAST_COMPATIBLE_VERSION 0x10
+#define FDT_LAST_SUPPORTED_VERSION	0x11
+
+/* Error codes: informative error codes */
+#define FDT_ERR_NOTFOUND	1
+	/* FDT_ERR_NOTFOUND: The requested node or property does not exist */
+#define FDT_ERR_EXISTS		2
+	/* FDT_ERR_EXISTS: Attempted to create a node or property which
+	 * already exists */
+#define FDT_ERR_NOSPACE		3
+	/* FDT_ERR_NOSPACE: Operation needed to expand the device
+	 * tree, but its buffer did not have sufficient space to
+	 * contain the expanded tree. Use fdt_open_into() to move the
+	 * device tree to a buffer with more space. */
+
+/* Error codes: codes for bad parameters */
+#define FDT_ERR_BADOFFSET	4
+	/* FDT_ERR_BADOFFSET: Function was passed a structure block
+	 * offset which is out-of-bounds, or which points to an
+	 * unsuitable part of the structure for the operation. */
+#define FDT_ERR_BADPATH		5
+	/* FDT_ERR_BADPATH: Function was passed a badly formatted path
+	 * (e.g. missing a leading / for a function which requires an
+	 * absolute path) */
+#define FDT_ERR_BADPHANDLE	6
+	/* FDT_ERR_BADPHANDLE: Function was passed an invalid phandle.
+	 * This can be caused either by an invalid phandle property
+	 * length, or the phandle value was either 0 or -1, which are
+	 * not permitted. */
+#define FDT_ERR_BADSTATE	7
+	/* FDT_ERR_BADSTATE: Function was passed an incomplete device
+	 * tree created by the sequential-write functions, which is
+	 * not sufficiently complete for the requested operation. */
+
+/* Error codes: codes for bad device tree blobs */
+#define FDT_ERR_TRUNCATED	8
+	/* FDT_ERR_TRUNCATED: FDT or a sub-block is improperly
+	 * terminated (overflows, goes outside allowed bounds, or
+	 * isn't properly terminated).  */
+#define FDT_ERR_BADMAGIC	9
+	/* FDT_ERR_BADMAGIC: Given "device tree" appears not to be a
+	 * device tree at all - it is missing the flattened device
+	 * tree magic number. */
+#define FDT_ERR_BADVERSION	10
+	/* FDT_ERR_BADVERSION: Given device tree has a version which
+	 * can't be handled by the requested operation.  For
+	 * read-write functions, this may mean that fdt_open_into() is
+	 * required to convert the tree to the expected version. */
+#define FDT_ERR_BADSTRUCTURE	11
+	/* FDT_ERR_BADSTRUCTURE: Given device tree has a corrupt
+	 * structure block or other serious error (e.g. misnested
+	 * nodes, or subnodes preceding properties). */
+#define FDT_ERR_BADLAYOUT	12
+	/* FDT_ERR_BADLAYOUT: For read-write functions, the given
+	 * device tree has it's sub-blocks in an order that the
+	 * function can't handle (memory reserve map, then structure,
+	 * then strings).  Use fdt_open_into() to reorganize the tree
+	 * into a form suitable for the read-write operations. */
+
+/* "Can't happen" error indicating a bug in libfdt */
+#define FDT_ERR_INTERNAL	13
+	/* FDT_ERR_INTERNAL: libfdt has failed an internal assertion.
+	 * Should never be returned, if it is, it indicates a bug in
+	 * libfdt itself. */
+
+/* Errors in device tree content */
+#define FDT_ERR_BADNCELLS	14
+	/* FDT_ERR_BADNCELLS: Device tree has a #address-cells, #size-cells
+	 * or similar property with a bad format or value */
+
+#define FDT_ERR_BADVALUE	15
+	/* FDT_ERR_BADVALUE: Device tree has a property with an unexpected
+	 * value. For example: a property expected to contain a string list
+	 * is not NUL-terminated within the length of its value. */
+
+#define FDT_ERR_BADOVERLAY	16
+	/* FDT_ERR_BADOVERLAY: The device tree overlay, while
+	 * correctly structured, cannot be applied due to some
+	 * unexpected or missing value, property or node. */
+
+#define FDT_ERR_NOPHANDLES	17
+	/* FDT_ERR_NOPHANDLES: The device tree doesn't have any
+	 * phandle available anymore without causing an overflow */
+
+#define FDT_ERR_BADFLAGS	18
+	/* FDT_ERR_BADFLAGS: The function was passed a flags field that
+	 * contains invalid flags or an invalid combination of flags. */
+
+#define FDT_ERR_ALIGNMENT	19
+	/* FDT_ERR_ALIGNMENT: The device tree base address is not 8-byte
+	 * aligned. */
+
+#define FDT_ERR_MAX		19
+
+/* constants */
+#define FDT_MAX_PHANDLE 0xfffffffe
+	/* Valid values for phandles range from 1 to 2^32-2. */
+
+/**********************************************************************/
+/* Low-level functions (you probably don't need these)                */
+/**********************************************************************/
+
+#ifndef SWIG /* This function is not useful in Python */
+const void *fdt_offset_ptr(const void *fdt, int offset, unsigned int checklen);
+#endif
+static inline void *fdt_offset_ptr_w(void *fdt, int offset, int checklen)
+{
+	return (void *)(uintptr_t)fdt_offset_ptr(fdt, offset, checklen);
+}
+
+uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset);
+
+/*
+ * External helpers to access words from a device tree blob. They're built
+ * to work even with unaligned pointers on platforms (such as ARMv5) that don't
+ * like unaligned loads and stores.
+ */
+static inline uint32_t fdt32_ld(const fdt32_t *p)
+{
+	const uint8_t *bp = (const uint8_t *)p;
+
+	return ((uint32_t)bp[0] << 24)
+		| ((uint32_t)bp[1] << 16)
+		| ((uint32_t)bp[2] << 8)
+		| bp[3];
+}
+
+static inline void fdt32_st(void *property, uint32_t value)
+{
+	uint8_t *bp = (uint8_t *)property;
+
+	bp[0] = value >> 24;
+	bp[1] = (value >> 16) & 0xff;
+	bp[2] = (value >> 8) & 0xff;
+	bp[3] = value & 0xff;
+}
+
+static inline uint64_t fdt64_ld(const fdt64_t *p)
+{
+	const uint8_t *bp = (const uint8_t *)p;
+
+	return ((uint64_t)bp[0] << 56)
+		| ((uint64_t)bp[1] << 48)
+		| ((uint64_t)bp[2] << 40)
+		| ((uint64_t)bp[3] << 32)
+		| ((uint64_t)bp[4] << 24)
+		| ((uint64_t)bp[5] << 16)
+		| ((uint64_t)bp[6] << 8)
+		| bp[7];
+}
+
+static inline void fdt64_st(void *property, uint64_t value)
+{
+	uint8_t *bp = (uint8_t *)property;
+
+	bp[0] = value >> 56;
+	bp[1] = (value >> 48) & 0xff;
+	bp[2] = (value >> 40) & 0xff;
+	bp[3] = (value >> 32) & 0xff;
+	bp[4] = (value >> 24) & 0xff;
+	bp[5] = (value >> 16) & 0xff;
+	bp[6] = (value >> 8) & 0xff;
+	bp[7] = value & 0xff;
+}
+
+/**********************************************************************/
+/* Traversal functions                                                */
+/**********************************************************************/
+
+int fdt_next_node(const void *fdt, int offset, int *depth);
+
+/**
+ * fdt_first_subnode() - get offset of first direct subnode
+ * @fdt:	FDT blob
+ * @offset:	Offset of node to check
+ *
+ * Return: offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
+ */
+int fdt_first_subnode(const void *fdt, int offset);
+
+/**
+ * fdt_next_subnode() - get offset of next direct subnode
+ * @fdt:	FDT blob
+ * @offset:	Offset of previous subnode
+ *
+ * After first calling fdt_first_subnode(), call this function repeatedly to
+ * get direct subnodes of a parent node.
+ *
+ * Return: offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
+ *         subnodes
+ */
+int fdt_next_subnode(const void *fdt, int offset);
+
+/**
+ * fdt_for_each_subnode - iterate over all subnodes of a parent
+ *
+ * @node:	child node (int, lvalue)
+ * @fdt:	FDT blob (const void *)
+ * @parent:	parent node (int)
+ *
+ * This is actually a wrapper around a for loop and would be used like so:
+ *
+ *	fdt_for_each_subnode(node, fdt, parent) {
+ *		Use node
+ *		...
+ *	}
+ *
+ *	if ((node < 0) && (node != -FDT_ERR_NOTFOUND)) {
+ *		Error handling
+ *	}
+ *
+ * Note that this is implemented as a macro and @node is used as
+ * iterator in the loop. The parent variable be constant or even a
+ * literal.
+ */
+#define fdt_for_each_subnode(node, fdt, parent)		\
+	for (node = fdt_first_subnode(fdt, parent);	\
+	     node >= 0;					\
+	     node = fdt_next_subnode(fdt, node))
+
+/**********************************************************************/
+/* General functions                                                  */
+/**********************************************************************/
+#define fdt_get_header(fdt, field) \
+	(fdt32_ld(&((const struct fdt_header *)(fdt))->field))
+#define fdt_magic(fdt)			(fdt_get_header(fdt, magic))
+#define fdt_totalsize(fdt)		(fdt_get_header(fdt, totalsize))
+#define fdt_off_dt_struct(fdt)		(fdt_get_header(fdt, off_dt_struct))
+#define fdt_off_dt_strings(fdt)		(fdt_get_header(fdt, off_dt_strings))
+#define fdt_off_mem_rsvmap(fdt)		(fdt_get_header(fdt, off_mem_rsvmap))
+#define fdt_version(fdt)		(fdt_get_header(fdt, version))
+#define fdt_last_comp_version(fdt)	(fdt_get_header(fdt, last_comp_version))
+#define fdt_boot_cpuid_phys(fdt)	(fdt_get_header(fdt, boot_cpuid_phys))
+#define fdt_size_dt_strings(fdt)	(fdt_get_header(fdt, size_dt_strings))
+#define fdt_size_dt_struct(fdt)		(fdt_get_header(fdt, size_dt_struct))
+
+#define fdt_set_hdr_(name) \
+	static inline void fdt_set_##name(void *fdt, uint32_t val) \
+	{ \
+		struct fdt_header *fdth = (struct fdt_header *)fdt; \
+		fdth->name = cpu_to_fdt32(val); \
+	}
+fdt_set_hdr_(magic);
+fdt_set_hdr_(totalsize);
+fdt_set_hdr_(off_dt_struct);
+fdt_set_hdr_(off_dt_strings);
+fdt_set_hdr_(off_mem_rsvmap);
+fdt_set_hdr_(version);
+fdt_set_hdr_(last_comp_version);
+fdt_set_hdr_(boot_cpuid_phys);
+fdt_set_hdr_(size_dt_strings);
+fdt_set_hdr_(size_dt_struct);
+#undef fdt_set_hdr_
+
+/**
+ * fdt_header_size - return the size of the tree's header
+ * @fdt: pointer to a flattened device tree
+ *
+ * Return: size of DTB header in bytes
+ */
+size_t fdt_header_size(const void *fdt);
+
+/**
+ * fdt_header_size_ - internal function to get header size from a version number
+ * @version: devicetree version number
+ *
+ * Return: size of DTB header in bytes
+ */
+size_t fdt_header_size_(uint32_t version);
+
+/**
+ * fdt_check_header - sanity check a device tree header
+ * @fdt: pointer to data which might be a flattened device tree
+ *
+ * fdt_check_header() checks that the given buffer contains what
+ * appears to be a flattened device tree, and that the header contains
+ * valid information (to the extent that can be determined from the
+ * header alone).
+ *
+ * returns:
+ *     0, if the buffer appears to contain a valid device tree
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE,
+ *     -FDT_ERR_TRUNCATED, standard meanings, as above
+ */
+int fdt_check_header(const void *fdt);
+
+/**
+ * fdt_move - move a device tree around in memory
+ * @fdt: pointer to the device tree to move
+ * @buf: pointer to memory where the device is to be moved
+ * @bufsize: size of the memory space at buf
+ *
+ * fdt_move() relocates, if possible, the device tree blob located at
+ * fdt to the buffer at buf of size bufsize.  The buffer may overlap
+ * with the existing device tree blob at fdt.  Therefore,
+ *     fdt_move(fdt, fdt, fdt_totalsize(fdt))
+ * should always succeed.
+ *
+ * returns:
+ *     0, on success
+ *     -FDT_ERR_NOSPACE, bufsize is insufficient to contain the device tree
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_move(const void *fdt, void *buf, int bufsize);
+
+/**********************************************************************/
+/* Read-only functions                                                */
+/**********************************************************************/
+
+int fdt_check_full(const void *fdt, size_t bufsize);
+
+/**
+ * fdt_get_string - retrieve a string from the strings block of a device tree
+ * @fdt: pointer to the device tree blob
+ * @stroffset: offset of the string within the strings block (native endian)
+ * @lenp: optional pointer to return the string's length
+ *
+ * fdt_get_string() retrieves a pointer to a single string from the
+ * strings block of the device tree blob at fdt, and optionally also
+ * returns the string's length in *lenp.
+ *
+ * returns:
+ *     a pointer to the string, on success
+ *     NULL, if stroffset is out of bounds, or doesn't point to a valid string
+ */
+const char *fdt_get_string(const void *fdt, int stroffset, int *lenp);
+
+/**
+ * fdt_string - retrieve a string from the strings block of a device tree
+ * @fdt: pointer to the device tree blob
+ * @stroffset: offset of the string within the strings block (native endian)
+ *
+ * fdt_string() retrieves a pointer to a single string from the
+ * strings block of the device tree blob at fdt.
+ *
+ * returns:
+ *     a pointer to the string, on success
+ *     NULL, if stroffset is out of bounds, or doesn't point to a valid string
+ */
+const char *fdt_string(const void *fdt, int stroffset);
+
+/**
+ * fdt_find_max_phandle - find and return the highest phandle in a tree
+ * @fdt: pointer to the device tree blob
+ * @phandle: return location for the highest phandle value found in the tree
+ *
+ * fdt_find_max_phandle() finds the highest phandle value in the given device
+ * tree. The value returned in @phandle is only valid if the function returns
+ * success.
+ *
+ * returns:
+ *     0 on success or a negative error code on failure
+ */
+int fdt_find_max_phandle(const void *fdt, uint32_t *phandle);
+
+/**
+ * fdt_get_max_phandle - retrieves the highest phandle in a tree
+ * @fdt: pointer to the device tree blob
+ *
+ * fdt_get_max_phandle retrieves the highest phandle in the given
+ * device tree. This will ignore badly formatted phandles, or phandles
+ * with a value of 0 or -1.
+ *
+ * This function is deprecated in favour of fdt_find_max_phandle().
+ *
+ * returns:
+ *      the highest phandle on success
+ *      0, if no phandle was found in the device tree
+ *      -1, if an error occurred
+ */
+static inline uint32_t fdt_get_max_phandle(const void *fdt)
+{
+	uint32_t phandle;
+	int err;
+
+	err = fdt_find_max_phandle(fdt, &phandle);
+	if (err < 0)
+		return (uint32_t)-1;
+
+	return phandle;
+}
+
+/**
+ * fdt_generate_phandle - return a new, unused phandle for a device tree blob
+ * @fdt: pointer to the device tree blob
+ * @phandle: return location for the new phandle
+ *
+ * Walks the device tree blob and looks for the highest phandle value. On
+ * success, the new, unused phandle value (one higher than the previously
+ * highest phandle value in the device tree blob) will be returned in the
+ * @phandle parameter.
+ *
+ * Return: 0 on success or a negative error-code on failure
+ */
+int fdt_generate_phandle(const void *fdt, uint32_t *phandle);
+
+/**
+ * fdt_num_mem_rsv - retrieve the number of memory reserve map entries
+ * @fdt: pointer to the device tree blob
+ *
+ * Returns the number of entries in the device tree blob's memory
+ * reservation map.  This does not include the terminating 0,0 entry
+ * or any other (0,0) entries reserved for expansion.
+ *
+ * returns:
+ *     the number of entries
+ */
+int fdt_num_mem_rsv(const void *fdt);
+
+/**
+ * fdt_get_mem_rsv - retrieve one memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @n: index of reserve map entry
+ * @address: pointer to 64-bit variable to hold the start address
+ * @size: pointer to 64-bit variable to hold the size of the entry
+ *
+ * On success, @address and @size will contain the address and size of
+ * the n-th reserve map entry from the device tree blob, in
+ * native-endian format.
+ *
+ * returns:
+ *     0, on success
+ *     -FDT_ERR_BADMAGIC,
+ *     -FDT_ERR_BADVERSION,
+ *     -FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size);
+
+/**
+ * fdt_subnode_offset_namelen - find a subnode based on substring
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_subnode_offset(), but only examine the first
+ * namelen characters of name for matching the subnode name.  This is
+ * useful for finding subnodes based on a portion of a larger string,
+ * such as a full path.
+ *
+ * Return: offset of the subnode or -FDT_ERR_NOTFOUND if name not found.
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_subnode_offset_namelen(const void *fdt, int parentoffset,
+			       const char *name, int namelen);
+#endif
+/**
+ * fdt_subnode_offset - find a subnode of a given node
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_subnode_offset() finds a subnode of the node at structure block
+ * offset parentoffset with the given name.  name may include a unit
+ * address, in which case fdt_subnode_offset() will find the subnode
+ * with that unit address, or the unit address may be omitted, in
+ * which case fdt_subnode_offset() will find an arbitrary subnode
+ * whose name excluding unit address matches the given name.
+ *
+ * returns:
+ *	structure block offset of the requested subnode (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
+ *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
+ *		tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_subnode_offset(const void *fdt, int parentoffset, const char *name);
+
+/**
+ * fdt_path_offset_namelen - find a tree node by its full path
+ * @fdt: pointer to the device tree blob
+ * @path: full path of the node to locate
+ * @namelen: number of characters of path to consider
+ *
+ * Identical to fdt_path_offset(), but only consider the first namelen
+ * characters of path as the path name.
+ *
+ * Return: offset of the node or negative libfdt error value otherwise
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
+#endif
+
+/**
+ * fdt_path_offset - find a tree node by its full path
+ * @fdt: pointer to the device tree blob
+ * @path: full path of the node to locate
+ *
+ * fdt_path_offset() finds a node of a given path in the device tree.
+ * Each path component may omit the unit address portion, but the
+ * results of this are undefined if any such path component is
+ * ambiguous (that is if there are multiple nodes at the relevant
+ * level matching the given component, differentiated only by unit
+ * address).
+ *
+ * returns:
+ *	structure block offset of the node with the requested path (>=0), on
+ *		success
+ *	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
+ *	-FDT_ERR_NOTFOUND, if the requested node does not exist
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_path_offset(const void *fdt, const char *path);
+
+/**
+ * fdt_get_name - retrieve the name of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of the starting node
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_name() retrieves the name (including unit address) of the
+ * device tree node at structure block offset nodeoffset.  If lenp is
+ * non-NULL, the length of this name is also returned, in the integer
+ * pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the node's name, on success
+ *		If lenp is non-NULL, *lenp contains the length of that name
+ *			(>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE, standard meanings
+ */
+const char *fdt_get_name(const void *fdt, int nodeoffset, int *lenp);
+
+/**
+ * fdt_first_property_offset - find the offset of a node's first property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ *
+ * fdt_first_property_offset() finds the first property of the node at
+ * the given structure block offset.
+ *
+ * returns:
+ *	structure block offset of the property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the requested node has no properties
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_BEGIN_NODE tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_first_property_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_next_property_offset - step through a node's properties
+ * @fdt: pointer to the device tree blob
+ * @offset: structure block offset of a property
+ *
+ * fdt_next_property_offset() finds the property immediately after the
+ * one at the given structure block offset.  This will be a property
+ * of the same node as the given property.
+ *
+ * returns:
+ *	structure block offset of the next property (>=0), on success
+ *	-FDT_ERR_NOTFOUND, if the given property is the last in its node
+ *	-FDT_ERR_BADOFFSET, if nodeoffset did not point to an FDT_PROP tag
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_next_property_offset(const void *fdt, int offset);
+
+/**
+ * fdt_for_each_property_offset - iterate over all properties of a node
+ *
+ * @property:	property offset (int, lvalue)
+ * @fdt:	FDT blob (const void *)
+ * @node:	node offset (int)
+ *
+ * This is actually a wrapper around a for loop and would be used like so:
+ *
+ *	fdt_for_each_property_offset(property, fdt, node) {
+ *		Use property
+ *		...
+ *	}
+ *
+ *	if ((property < 0) && (property != -FDT_ERR_NOTFOUND)) {
+ *		Error handling
+ *	}
+ *
+ * Note that this is implemented as a macro and property is used as
+ * iterator in the loop. The node variable can be constant or even a
+ * literal.
+ */
+#define fdt_for_each_property_offset(property, fdt, node)	\
+	for (property = fdt_first_property_offset(fdt, node);	\
+	     property >= 0;					\
+	     property = fdt_next_property_offset(fdt, property))
+
+/**
+ * fdt_get_property_by_offset - retrieve the property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @offset: offset of the property to retrieve
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property_by_offset() retrieves a pointer to the
+ * fdt_property structure within the device tree blob at the given
+ * offset.  If lenp is non-NULL, the length of the property value is
+ * also returned, in the integer pointed to by lenp.
+ *
+ * Note that this code only works on device tree versions >= 16. fdt_getprop()
+ * works on all versions.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property_by_offset(const void *fdt,
+						      int offset,
+						      int *lenp);
+
+/**
+ * fdt_get_property_namelen - find a property based on substring
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @namelen: number of characters of name to consider
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * Identical to fdt_get_property(), but only examine the first namelen
+ * characters of name for matching the property name.
+ *
+ * Return: pointer to the structure representing the property, or NULL
+ *         if not found
+ */
+#ifndef SWIG /* Not available in Python */
+const struct fdt_property *fdt_get_property_namelen(const void *fdt,
+						    int nodeoffset,
+						    const char *name,
+						    int namelen, int *lenp);
+#endif
+
+/**
+ * fdt_get_property - find a given property in a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_get_property() retrieves a pointer to the fdt_property
+ * structure within the device tree blob corresponding to the property
+ * named 'name' of the node at offset nodeoffset.  If lenp is
+ * non-NULL, the length of the property value is also returned, in the
+ * integer pointed to by lenp.
+ *
+ * returns:
+ *	pointer to the structure representing the property
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_NOTFOUND, node does not have named property
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const struct fdt_property *fdt_get_property(const void *fdt, int nodeoffset,
+					    const char *name, int *lenp);
+static inline struct fdt_property *fdt_get_property_w(void *fdt, int nodeoffset,
+						      const char *name,
+						      int *lenp)
+{
+	return (struct fdt_property *)(uintptr_t)
+		fdt_get_property(fdt, nodeoffset, name, lenp);
+}
+
+/**
+ * fdt_getprop_by_offset - retrieve the value of a property at a given offset
+ * @fdt: pointer to the device tree blob
+ * @offset: offset of the property to read
+ * @namep: pointer to a string variable (will be overwritten) or NULL
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop_by_offset() retrieves a pointer to the value of the
+ * property at structure block offset 'offset' (this will be a pointer
+ * to within the device blob itself, not a copy of the value).  If
+ * lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.  If namep is non-NULL,
+ * the property's namne will also be returned in the char * pointed to
+ * by namep (this will be a pointer to within the device tree's string
+ * block, not a new copy of the name).
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *		if namep is non-NULL *namep contiains a pointer to the property
+ *		name.
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_PROP tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+#ifndef SWIG /* This function is not useful in Python */
+const void *fdt_getprop_by_offset(const void *fdt, int offset,
+				  const char **namep, int *lenp);
+#endif
+
+/**
+ * fdt_getprop_namelen - get property value based on substring
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @namelen: number of characters of name to consider
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * Identical to fdt_getprop(), but only examine the first namelen
+ * characters of name for matching the property name.
+ *
+ * Return: pointer to the property's value or NULL on error
+ */
+#ifndef SWIG /* Not available in Python */
+const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
+				const char *name, int namelen, int *lenp);
+static inline void *fdt_getprop_namelen_w(void *fdt, int nodeoffset,
+					  const char *name, int namelen,
+					  int *lenp)
+{
+	return (void *)(uintptr_t)fdt_getprop_namelen(fdt, nodeoffset, name,
+						      namelen, lenp);
+}
+#endif
+
+/**
+ * fdt_getprop - retrieve the value of a given property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to find
+ * @name: name of the property to find
+ * @lenp: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_getprop() retrieves a pointer to the value of the property
+ * named @name of the node at offset @nodeoffset (this will be a
+ * pointer to within the device blob itself, not a copy of the value).
+ * If @lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by @lenp.
+ *
+ * returns:
+ *	pointer to the property's value
+ *		if lenp is non-NULL, *lenp contains the length of the property
+ *		value (>=0)
+ *	NULL, on error
+ *		if lenp is non-NULL, *lenp contains an error code (<0):
+ *		-FDT_ERR_NOTFOUND, node does not have named property
+ *		-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE
+ *			tag
+ *		-FDT_ERR_BADMAGIC,
+ *		-FDT_ERR_BADVERSION,
+ *		-FDT_ERR_BADSTATE,
+ *		-FDT_ERR_BADSTRUCTURE,
+ *		-FDT_ERR_TRUNCATED, standard meanings
+ */
+const void *fdt_getprop(const void *fdt, int nodeoffset,
+			const char *name, int *lenp);
+static inline void *fdt_getprop_w(void *fdt, int nodeoffset,
+				  const char *name, int *lenp)
+{
+	return (void *)(uintptr_t)fdt_getprop(fdt, nodeoffset, name, lenp);
+}
+
+/**
+ * fdt_get_phandle - retrieve the phandle of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of the node
+ *
+ * fdt_get_phandle() retrieves the phandle of the device tree node at
+ * structure block offset nodeoffset.
+ *
+ * returns:
+ *	the phandle of the node at nodeoffset, on success (!= 0, != -1)
+ *	0, if the node has no phandle, or another error occurs
+ */
+uint32_t fdt_get_phandle(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_get_alias_namelen - get alias based on substring
+ * @fdt: pointer to the device tree blob
+ * @name: name of the alias th look up
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_get_alias(), but only examine the first @namelen
+ * characters of @name for matching the alias name.
+ *
+ * Return: a pointer to the expansion of the alias named @name, if it exists,
+ *	   NULL otherwise
+ */
+#ifndef SWIG /* Not available in Python */
+const char *fdt_get_alias_namelen(const void *fdt,
+				  const char *name, int namelen);
+#endif
+
+/**
+ * fdt_get_alias - retrieve the path referenced by a given alias
+ * @fdt: pointer to the device tree blob
+ * @name: name of the alias th look up
+ *
+ * fdt_get_alias() retrieves the value of a given alias.  That is, the
+ * value of the property named @name in the node /aliases.
+ *
+ * returns:
+ *	a pointer to the expansion of the alias named 'name', if it exists
+ *	NULL, if the given alias or the /aliases node does not exist
+ */
+const char *fdt_get_alias(const void *fdt, const char *name);
+
+/**
+ * fdt_get_path - determine the full path of a node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose path to find
+ * @buf: character buffer to contain the returned path (will be overwritten)
+ * @buflen: size of the character buffer at buf
+ *
+ * fdt_get_path() computes the full path of the node at offset
+ * nodeoffset, and records that path in the buffer at buf.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	0, on success
+ *		buf contains the absolute path of the node at
+ *		nodeoffset, as a NUL-terminated string.
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_NOSPACE, the path of the given node is longer than (bufsize-1)
+ *		characters and will not fit in the given buffer.
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen);
+
+/**
+ * fdt_supernode_atdepth_offset - find a specific ancestor of a node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ * @supernodedepth: depth of the ancestor to find
+ * @nodedepth: pointer to an integer variable (will be overwritten) or NULL
+ *
+ * fdt_supernode_atdepth_offset() finds an ancestor of the given node
+ * at a specific depth from the root (where the root itself has depth
+ * 0, its immediate subnodes depth 1 and so forth).  So
+ *	fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, NULL);
+ * will always return 0, the offset of the root node.  If the node at
+ * nodeoffset has depth D, then:
+ *	fdt_supernode_atdepth_offset(fdt, nodeoffset, D, NULL);
+ * will return nodeoffset itself.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	structure block offset of the node at node offset's ancestor
+ *		of depth supernodedepth (>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_NOTFOUND, supernodedepth was greater than the depth of
+ *		nodeoffset
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+				 int supernodedepth, int *nodedepth);
+
+/**
+ * fdt_node_depth - find the depth of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ *
+ * fdt_node_depth() finds the depth of a given node.  The root node
+ * has depth 0, its immediate subnodes depth 1 and so forth.
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset.
+ *
+ * returns:
+ *	depth of the node at nodeoffset (>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_depth(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_parent_offset - find the parent of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose parent to find
+ *
+ * fdt_parent_offset() locates the parent node of a given node (that
+ * is, it finds the offset of the node which contains the node at
+ * nodeoffset as a subnode).
+ *
+ * NOTE: This function is expensive, as it must scan the device tree
+ * structure from the start to nodeoffset, *twice*.
+ *
+ * returns:
+ *	structure block offset of the parent of the node at nodeoffset
+ *		(>=0), on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_parent_offset(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_node_offset_by_prop_value - find nodes with a given property value
+ * @fdt: pointer to the device tree blob
+ * @startoffset: only find nodes after this offset
+ * @propname: property name to check
+ * @propval: property value to search for
+ * @proplen: length of the value in propval
+ *
+ * fdt_node_offset_by_prop_value() returns the offset of the first
+ * node after startoffset, which has a property named propname whose
+ * value is of length proplen and has value equal to propval; or if
+ * startoffset is -1, the very first such node in the tree.
+ *
+ * To iterate through all nodes matching the criterion, the following
+ * idiom can be used:
+ *	offset = fdt_node_offset_by_prop_value(fdt, -1, propname,
+ *					       propval, proplen);
+ *	while (offset != -FDT_ERR_NOTFOUND) {
+ *		// other code here
+ *		offset = fdt_node_offset_by_prop_value(fdt, offset, propname,
+ *						       propval, proplen);
+ *	}
+ *
+ * Note the -1 in the first call to the function, if 0 is used here
+ * instead, the function will never locate the root node, even if it
+ * matches the criterion.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0, >startoffset),
+ *		 on success
+ *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the
+ *		tree after startoffset
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+				  const char *propname,
+				  const void *propval, int proplen);
+
+/**
+ * fdt_node_offset_by_phandle - find the node with a given phandle
+ * @fdt: pointer to the device tree blob
+ * @phandle: phandle value
+ *
+ * fdt_node_offset_by_phandle() returns the offset of the node
+ * which has the given phandle value.  If there is more than one node
+ * in the tree with the given phandle (an invalid tree), results are
+ * undefined.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0), on success
+ *	-FDT_ERR_NOTFOUND, no node with that phandle exists
+ *	-FDT_ERR_BADPHANDLE, given phandle value was invalid (0 or -1)
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle);
+
+/**
+ * fdt_node_check_compatible - check a node's compatible property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @compatible: string to match against
+ *
+ * fdt_node_check_compatible() returns 0 if the given node contains a
+ * @compatible property with the given string as one of its elements,
+ * it returns non-zero otherwise, or on error.
+ *
+ * returns:
+ *	0, if the node has a 'compatible' property listing the given string
+ *	1, if the node has a 'compatible' property, but it does not list
+ *		the given string
+ *	-FDT_ERR_NOTFOUND, if the given node has no 'compatible' property
+ *	-FDT_ERR_BADOFFSET, if nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+			      const char *compatible);
+
+/**
+ * fdt_node_offset_by_compatible - find nodes with a given 'compatible' value
+ * @fdt: pointer to the device tree blob
+ * @startoffset: only find nodes after this offset
+ * @compatible: 'compatible' string to match against
+ *
+ * fdt_node_offset_by_compatible() returns the offset of the first
+ * node after startoffset, which has a 'compatible' property which
+ * lists the given compatible string; or if startoffset is -1, the
+ * very first such node in the tree.
+ *
+ * To iterate through all nodes matching the criterion, the following
+ * idiom can be used:
+ *	offset = fdt_node_offset_by_compatible(fdt, -1, compatible);
+ *	while (offset != -FDT_ERR_NOTFOUND) {
+ *		// other code here
+ *		offset = fdt_node_offset_by_compatible(fdt, offset, compatible);
+ *	}
+ *
+ * Note the -1 in the first call to the function, if 0 is used here
+ * instead, the function will never locate the root node, even if it
+ * matches the criterion.
+ *
+ * returns:
+ *	structure block offset of the located node (>= 0, >startoffset),
+ *		 on success
+ *	-FDT_ERR_NOTFOUND, no node matching the criterion exists in the
+ *		tree after startoffset
+ *	-FDT_ERR_BADOFFSET, nodeoffset does not refer to a BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE, standard meanings
+ */
+int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+				  const char *compatible);
+
+/**
+ * fdt_stringlist_contains - check a string list property for a string
+ * @strlist: Property containing a list of strings to check
+ * @listlen: Length of property
+ * @str: String to search for
+ *
+ * This is a utility function provided for convenience. The list contains
+ * one or more strings, each terminated by \0, as is found in a device tree
+ * "compatible" property.
+ *
+ * Return: 1 if the string is found in the list, 0 not found, or invalid list
+ */
+int fdt_stringlist_contains(const char *strlist, int listlen, const char *str);
+
+/**
+ * fdt_stringlist_count - count the number of strings in a string list
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ *
+ * Return:
+ *   the number of strings in the given property
+ *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *   -FDT_ERR_NOTFOUND if the property does not exist
+ */
+int fdt_stringlist_count(const void *fdt, int nodeoffset, const char *property);
+
+/**
+ * fdt_stringlist_search - find a string in a string list and return its index
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @string: string to look up in the string list
+ *
+ * Note that it is possible for this function to succeed on property values
+ * that are not NUL-terminated. That's because the function will stop after
+ * finding the first occurrence of @string. This can for example happen with
+ * small-valued cell properties, such as #address-cells, when searching for
+ * the empty string.
+ *
+ * return:
+ *   the index of the string in the list of strings
+ *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *   -FDT_ERR_NOTFOUND if the property does not exist or does not contain
+ *                     the given string
+ */
+int fdt_stringlist_search(const void *fdt, int nodeoffset, const char *property,
+			  const char *string);
+
+/**
+ * fdt_stringlist_get() - obtain the string at a given index in a string list
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of a tree node
+ * @property: name of the property containing the string list
+ * @index: index of the string to return
+ * @lenp: return location for the string length or an error code on failure
+ *
+ * Note that this will successfully extract strings from properties with
+ * non-NUL-terminated values. For example on small-valued cell properties
+ * this function will return the empty string.
+ *
+ * If non-NULL, the length of the string (on success) or a negative error-code
+ * (on failure) will be stored in the integer pointer to by lenp.
+ *
+ * Return:
+ *   A pointer to the string at the given index in the string list or NULL on
+ *   failure. On success the length of the string will be stored in the memory
+ *   location pointed to by the lenp parameter, if non-NULL. On failure one of
+ *   the following negative error codes will be returned in the lenp parameter
+ *   (if non-NULL):
+ *     -FDT_ERR_BADVALUE if the property value is not NUL-terminated
+ *     -FDT_ERR_NOTFOUND if the property does not exist
+ */
+const char *fdt_stringlist_get(const void *fdt, int nodeoffset,
+			       const char *property, int index,
+			       int *lenp);
+
+/**********************************************************************/
+/* Read-only functions (addressing related)                           */
+/**********************************************************************/
+
+/**
+ * FDT_MAX_NCELLS - maximum value for #address-cells and #size-cells
+ *
+ * This is the maximum value for #address-cells, #size-cells and
+ * similar properties that will be processed by libfdt.  IEE1275
+ * requires that OF implementations handle values up to 4.
+ * Implementations may support larger values, but in practice higher
+ * values aren't used.
+ */
+#define FDT_MAX_NCELLS		4
+
+/**
+ * fdt_address_cells - retrieve address size for a bus represented in the tree
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to find the address size for
+ *
+ * When the node has a valid #address-cells property, returns its value.
+ *
+ * returns:
+ *	0 <= n < FDT_MAX_NCELLS, on success
+ *      2, if the node has no #address-cells property
+ *      -FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#address-cells property
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_address_cells(const void *fdt, int nodeoffset);
+
+/**
+ * fdt_size_cells - retrieve address range size for a bus represented in the
+ *                  tree
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to find the address range size for
+ *
+ * When the node has a valid #size-cells property, returns its value.
+ *
+ * returns:
+ *	0 <= n < FDT_MAX_NCELLS, on success
+ *      1, if the node has no #size-cells property
+ *      -FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#size-cells property
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_size_cells(const void *fdt, int nodeoffset);
+
+
+/**********************************************************************/
+/* Write-in-place functions                                           */
+/**********************************************************************/
+
+/**
+ * fdt_setprop_inplace_namelen_partial - change a property's value,
+ *                                       but not its size
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @namelen: number of characters of name to consider
+ * @idx: index of the property to change in the array
+ * @val: pointer to data to replace the property value with
+ * @len: length of the property value
+ *
+ * Identical to fdt_setprop_inplace(), but modifies the given property
+ * starting from the given index, and using only the first characters
+ * of the name. It is useful when you want to manipulate only one value of
+ * an array and you have a string that doesn't end with \0.
+ *
+ * Return: 0 on success, negative libfdt error value otherwise
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
+					const char *name, int namelen,
+					uint32_t idx, const void *val,
+					int len);
+#endif
+
+/**
+ * fdt_setprop_inplace - change a property's value, but not its size
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: pointer to data to replace the property value with
+ * @len: length of the property value
+ *
+ * fdt_setprop_inplace() replaces the value of a given property with
+ * the data in val, of length len.  This function cannot change the
+ * size of a property, and so will only work if len is equal to the
+ * current length of the property.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if len is not equal to the property's current length
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+			const void *val, int len);
+#endif
+
+/**
+ * fdt_setprop_inplace_u32 - change the value of a 32-bit integer property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to replace the property with
+ *
+ * fdt_setprop_inplace_u32() replaces the value of a given property
+ * with the 32-bit integer value in val, converting val to big-endian
+ * if necessary.  This function cannot change the size of a property,
+ * and so will only work if the property already exists and has length
+ * 4.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if the property's length is not equal to 4
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_inplace_u32(void *fdt, int nodeoffset,
+					  const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_setprop_inplace(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_inplace_u64 - change the value of a 64-bit integer property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value to replace the property with
+ *
+ * fdt_setprop_inplace_u64() replaces the value of a given property
+ * with the 64-bit integer value in val, converting val to big-endian
+ * if necessary.  This function cannot change the size of a property,
+ * and so will only work if the property already exists and has length
+ * 8.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the given property value, and will not alter or move any other part
+ * of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, if the property's length is not equal to 8
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_inplace_u64(void *fdt, int nodeoffset,
+					  const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_setprop_inplace(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_inplace_cell - change the value of a single-cell property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node containing the property
+ * @name: name of the property to change the value of
+ * @val: new value of the 32-bit cell
+ *
+ * This is an alternative name for fdt_setprop_inplace_u32()
+ * Return: 0 on success, negative libfdt error number otherwise.
+ */
+static inline int fdt_setprop_inplace_cell(void *fdt, int nodeoffset,
+					   const char *name, uint32_t val)
+{
+	return fdt_setprop_inplace_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_nop_property - replace a property with nop tags
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to nop
+ * @name: name of the property to nop
+ *
+ * fdt_nop_property() will replace a given property's representation
+ * in the blob with FDT_NOP tags, effectively removing it from the
+ * tree.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the property, and will not alter or move any other part of the
+ * tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_nop_property(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_nop_node - replace a node (subtree) with nop tags
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to nop
+ *
+ * fdt_nop_node() will replace a given node's representation in the
+ * blob, including all its subnodes, if any, with FDT_NOP tags,
+ * effectively removing it from the tree.
+ *
+ * This function will alter only the bytes in the blob which contain
+ * the node and its properties and subnodes, and will not alter or
+ * move any other part of the tree.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_nop_node(void *fdt, int nodeoffset);
+
+/**********************************************************************/
+/* Sequential write functions                                         */
+/**********************************************************************/
+
+/* fdt_create_with_flags flags */
+#define FDT_CREATE_FLAG_NO_NAME_DEDUP 0x1
+	/* FDT_CREATE_FLAG_NO_NAME_DEDUP: Do not try to de-duplicate property
+	 * names in the fdt. This can result in faster creation times, but
+	 * a larger fdt. */
+
+#define FDT_CREATE_FLAGS_ALL	(FDT_CREATE_FLAG_NO_NAME_DEDUP)
+
+/**
+ * fdt_create_with_flags - begin creation of a new fdt
+ * @buf: pointer to memory allocated where fdt will be created
+ * @bufsize: size of the memory space at fdt
+ * @flags: a valid combination of FDT_CREATE_FLAG_ flags, or 0.
+ *
+ * fdt_create_with_flags() begins the process of creating a new fdt with
+ * the sequential write interface.
+ *
+ * fdt creation process must end with fdt_finished() to produce a valid fdt.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, bufsize is insufficient for a minimal fdt
+ *	-FDT_ERR_BADFLAGS, flags is not valid
+ */
+int fdt_create_with_flags(void *buf, int bufsize, uint32_t flags);
+
+/**
+ * fdt_create - begin creation of a new fdt
+ * @buf: pointer to memory allocated where fdt will be created
+ * @bufsize: size of the memory space at fdt
+ *
+ * fdt_create() is equivalent to fdt_create_with_flags() with flags=0.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, bufsize is insufficient for a minimal fdt
+ */
+int fdt_create(void *buf, int bufsize);
+
+int fdt_resize(void *fdt, void *buf, int bufsize);
+int fdt_add_reservemap_entry(void *fdt, uint64_t addr, uint64_t size);
+int fdt_finish_reservemap(void *fdt);
+int fdt_begin_node(void *fdt, const char *name);
+int fdt_property(void *fdt, const char *name, const void *val, int len);
+static inline int fdt_property_u32(void *fdt, const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_property(fdt, name, &tmp, sizeof(tmp));
+}
+static inline int fdt_property_u64(void *fdt, const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_property(fdt, name, &tmp, sizeof(tmp));
+}
+
+#ifndef SWIG /* Not available in Python */
+static inline int fdt_property_cell(void *fdt, const char *name, uint32_t val)
+{
+	return fdt_property_u32(fdt, name, val);
+}
+#endif
+
+/**
+ * fdt_property_placeholder - add a new property and return a ptr to its value
+ *
+ * @fdt: pointer to the device tree blob
+ * @name: name of property to add
+ * @len: length of property value in bytes
+ * @valp: returns a pointer to where where the value should be placed
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_NOSPACE, standard meanings
+ */
+int fdt_property_placeholder(void *fdt, const char *name, int len, void **valp);
+
+#define fdt_property_string(fdt, name, str) \
+	fdt_property(fdt, name, str, strlen(str)+1)
+int fdt_end_node(void *fdt);
+int fdt_finish(void *fdt);
+
+/**********************************************************************/
+/* Read-write functions                                               */
+/**********************************************************************/
+
+int fdt_create_empty_tree(void *buf, int bufsize);
+int fdt_open_into(const void *fdt, void *buf, int bufsize);
+int fdt_pack(void *fdt);
+
+/**
+ * fdt_add_mem_rsv - add one memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @address: 64-bit start address of the reserve map entry
+ * @size: 64-bit size of the reserved region
+ *
+ * Adds a reserve map entry to the given blob reserving a region at
+ * address address of length size.
+ *
+ * This function will insert data into the reserve map and will
+ * therefore change the indexes of some entries in the table.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new reservation entry
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size);
+
+/**
+ * fdt_del_mem_rsv - remove a memory reserve map entry
+ * @fdt: pointer to the device tree blob
+ * @n: entry to remove
+ *
+ * fdt_del_mem_rsv() removes the n-th memory reserve map entry from
+ * the blob.
+ *
+ * This function will delete data from the reservation table and will
+ * therefore change the indexes of some entries in the table.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, there is no entry of the given index (i.e. there
+ *		are less than n+1 reserve map entries)
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_del_mem_rsv(void *fdt, int n);
+
+/**
+ * fdt_set_name - change the name of a given node
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: structure block offset of a node
+ * @name: name to give the node
+ *
+ * fdt_set_name() replaces the name (including unit address, if any)
+ * of the given node with the given string.  NOTE: this function can't
+ * efficiently check if the new name is unique amongst the given
+ * node's siblings; results are undefined if this function is invoked
+ * with a name equal to one of the given node's siblings.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob
+ *		to contain the new name
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE, standard meanings
+ */
+int fdt_set_name(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_setprop - create or change a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: pointer to data to set the property value to
+ * @len: length of the property value
+ *
+ * fdt_setprop() sets the value of the named property in the given
+ * node to the given value and length, creating the property if it
+ * does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+		const void *val, int len);
+
+/**
+ * fdt_setprop_placeholder - allocate space for a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @len: length of the property value
+ * @prop_data: return pointer to property data
+ *
+ * fdt_setprop_placeholer() allocates the named property in the given node.
+ * If the property exists it is resized. In either case a pointer to the
+ * property data is returned.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_setprop_placeholder(void *fdt, int nodeoffset, const char *name,
+			    int len, void **prop_data);
+
+/**
+ * fdt_setprop_u32 - set a property to a 32-bit integer
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value for the property (native endian)
+ *
+ * fdt_setprop_u32() sets the value of the named property in the given
+ * node to the given 32-bit integer value (converting to big-endian if
+ * necessary), or creates a new property with that value if it does
+ * not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_u32(void *fdt, int nodeoffset, const char *name,
+				  uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_setprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_u64 - set a property to a 64-bit integer
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value for the property (native endian)
+ *
+ * fdt_setprop_u64() sets the value of the named property in the given
+ * node to the given 64-bit integer value (converting to big-endian if
+ * necessary), or creates a new property with that value if it does
+ * not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_setprop_u64(void *fdt, int nodeoffset, const char *name,
+				  uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_setprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_setprop_cell - set a property to a single cell value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value for the property (native endian)
+ *
+ * This is an alternative name for fdt_setprop_u32()
+ *
+ * Return: 0 on success, negative libfdt error value otherwise.
+ */
+static inline int fdt_setprop_cell(void *fdt, int nodeoffset, const char *name,
+				   uint32_t val)
+{
+	return fdt_setprop_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_setprop_string - set a property to a string value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @str: string value for the property
+ *
+ * fdt_setprop_string() sets the value of the named property in the
+ * given node to the given string value (using the length of the
+ * string to determine the new length of the property), or creates a
+ * new property with that value if it does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_setprop_string(fdt, nodeoffset, name, str) \
+	fdt_setprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)
+
+
+/**
+ * fdt_setprop_empty - set a property to an empty value
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ *
+ * fdt_setprop_empty() sets the value of the named property in the
+ * given node to an empty (zero length) value, or creates a new empty
+ * property if it does not already exist.
+ *
+ * This function may insert or delete data from the blob, and will
+ * therefore change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_setprop_empty(fdt, nodeoffset, name) \
+	fdt_setprop((fdt), (nodeoffset), (name), NULL, 0)
+
+/**
+ * fdt_appendprop - append to or create a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to append to
+ * @val: pointer to data to append to the property value
+ * @len: length of the data to append to the property value
+ *
+ * fdt_appendprop() appends the value to the named property in the
+ * given node, creating the property if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_appendprop(void *fdt, int nodeoffset, const char *name,
+		   const void *val, int len);
+
+/**
+ * fdt_appendprop_u32 - append a 32-bit integer value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to append to the property (native endian)
+ *
+ * fdt_appendprop_u32() appends the given 32-bit integer value
+ * (converting to big-endian if necessary) to the value of the named
+ * property in the given node, or creates a new property with that
+ * value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_appendprop_u32(void *fdt, int nodeoffset,
+				     const char *name, uint32_t val)
+{
+	fdt32_t tmp = cpu_to_fdt32(val);
+	return fdt_appendprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_appendprop_u64 - append a 64-bit integer value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 64-bit integer value to append to the property (native endian)
+ *
+ * fdt_appendprop_u64() appends the given 64-bit integer value
+ * (converting to big-endian if necessary) to the value of the named
+ * property in the given node, or creates a new property with that
+ * value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+static inline int fdt_appendprop_u64(void *fdt, int nodeoffset,
+				     const char *name, uint64_t val)
+{
+	fdt64_t tmp = cpu_to_fdt64(val);
+	return fdt_appendprop(fdt, nodeoffset, name, &tmp, sizeof(tmp));
+}
+
+/**
+ * fdt_appendprop_cell - append a single cell value to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @val: 32-bit integer value to append to the property (native endian)
+ *
+ * This is an alternative name for fdt_appendprop_u32()
+ *
+ * Return: 0 on success, negative libfdt error value otherwise.
+ */
+static inline int fdt_appendprop_cell(void *fdt, int nodeoffset,
+				      const char *name, uint32_t val)
+{
+	return fdt_appendprop_u32(fdt, nodeoffset, name, val);
+}
+
+/**
+ * fdt_appendprop_string - append a string to a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to change
+ * @name: name of the property to change
+ * @str: string value to append to the property
+ *
+ * fdt_appendprop_string() appends the given string to the value of
+ * the named property in the given node, or creates a new property
+ * with that value if it does not already exist.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain the new property value
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+#define fdt_appendprop_string(fdt, nodeoffset, name, str) \
+	fdt_appendprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)
+
+/**
+ * fdt_appendprop_addrrange - append a address range property
+ * @fdt: pointer to the device tree blob
+ * @parent: offset of the parent node
+ * @nodeoffset: offset of the node to add a property at
+ * @name: name of property
+ * @addr: start address of a given range
+ * @size: size of a given range
+ *
+ * fdt_appendprop_addrrange() appends an address range value (start
+ * address and size) to the value of the named property in the given
+ * node, or creates a new property with that value if it does not
+ * already exist.
+ * If "name" is not specified, a default "reg" is used.
+ * Cell sizes are determined by parent's #address-cells and #size-cells.
+ *
+ * This function may insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADNCELLS, if the node has a badly formatted or invalid
+ *		#address-cells property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADVALUE, addr or size doesn't fit to respective cells size
+ *	-FDT_ERR_NOSPACE, there is insufficient free space in the blob to
+ *		contain a new property
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_appendprop_addrrange(void *fdt, int parent, int nodeoffset,
+			     const char *name, uint64_t addr, uint64_t size);
+
+/**
+ * fdt_delprop - delete a property
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node whose property to nop
+ * @name: name of the property to nop
+ *
+ * fdt_del_property() will delete the given property.
+ *
+ * This function will delete data from the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOTFOUND, node does not have the named property
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_delprop(void *fdt, int nodeoffset, const char *name);
+
+/**
+ * fdt_add_subnode_namelen - creates a new node based on substring
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to create
+ * @namelen: number of characters of name to consider
+ *
+ * Identical to fdt_add_subnode(), but use only the first @namelen
+ * characters of @name as the name of the new node.  This is useful for
+ * creating subnodes based on a portion of a larger string, such as a
+ * full path.
+ *
+ * Return: structure block offset of the created subnode (>=0),
+ *	   negative libfdt error value otherwise
+ */
+#ifndef SWIG /* Not available in Python */
+int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+			    const char *name, int namelen);
+#endif
+
+/**
+ * fdt_add_subnode - creates a new node
+ * @fdt: pointer to the device tree blob
+ * @parentoffset: structure block offset of a node
+ * @name: name of the subnode to locate
+ *
+ * fdt_add_subnode() creates a new node as a subnode of the node at
+ * structure block offset parentoffset, with the given name (which
+ * should include the unit address, if any).
+ *
+ * This function will insert data into the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	structure block offset of the created nodeequested subnode (>=0), on
+ *		success
+ *	-FDT_ERR_NOTFOUND, if the requested subnode does not exist
+ *	-FDT_ERR_BADOFFSET, if parentoffset did not point to an FDT_BEGIN_NODE
+ *		tag
+ *	-FDT_ERR_EXISTS, if the node at parentoffset already has a subnode of
+ *		the given name
+ *	-FDT_ERR_NOSPACE, if there is insufficient free space in the
+ *		blob to contain the new node
+ *	-FDT_ERR_NOSPACE
+ *	-FDT_ERR_BADLAYOUT
+ *      -FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings.
+ */
+int fdt_add_subnode(void *fdt, int parentoffset, const char *name);
+
+/**
+ * fdt_del_node - delete a node (subtree)
+ * @fdt: pointer to the device tree blob
+ * @nodeoffset: offset of the node to nop
+ *
+ * fdt_del_node() will remove the given node, including all its
+ * subnodes if any, from the blob.
+ *
+ * This function will delete data from the blob, and will therefore
+ * change the offsets of some existing nodes.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_BADOFFSET, nodeoffset did not point to FDT_BEGIN_NODE tag
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_del_node(void *fdt, int nodeoffset);
+
+/**
+ * fdt_overlay_apply - Applies a DT overlay on a base DT
+ * @fdt: pointer to the base device tree blob
+ * @fdto: pointer to the device tree overlay blob
+ *
+ * fdt_overlay_apply() will apply the given device tree overlay on the
+ * given base device tree.
+ *
+ * Expect the base device tree to be modified, even if the function
+ * returns an error.
+ *
+ * returns:
+ *	0, on success
+ *	-FDT_ERR_NOSPACE, there's not enough space in the base device tree
+ *	-FDT_ERR_NOTFOUND, the overlay points to some inexistant nodes or
+ *		properties in the base DT
+ *	-FDT_ERR_BADPHANDLE,
+ *	-FDT_ERR_BADOVERLAY,
+ *	-FDT_ERR_NOPHANDLES,
+ *	-FDT_ERR_INTERNAL,
+ *	-FDT_ERR_BADLAYOUT,
+ *	-FDT_ERR_BADMAGIC,
+ *	-FDT_ERR_BADOFFSET,
+ *	-FDT_ERR_BADPATH,
+ *	-FDT_ERR_BADVERSION,
+ *	-FDT_ERR_BADSTRUCTURE,
+ *	-FDT_ERR_BADSTATE,
+ *	-FDT_ERR_TRUNCATED, standard meanings
+ */
+int fdt_overlay_apply(void *fdt, void *fdto);
+
+/**********************************************************************/
+/* Debugging / informational functions                                */
+/**********************************************************************/
+
+const char *fdt_strerror(int errval);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBFDT_H */
diff --git a/dtc/libfdt/libfdt_env.h b/dtc/libfdt/libfdt_env.h
new file mode 100644
index 0000000..73b6d40
--- /dev/null
+++ b/dtc/libfdt/libfdt_env.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+#ifndef LIBFDT_ENV_H
+#define LIBFDT_ENV_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2012 Kim Phillips, Freescale Semiconductor.
+ */
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+
+#ifdef __CHECKER__
+#define FDT_FORCE __attribute__((force))
+#define FDT_BITWISE __attribute__((bitwise))
+#else
+#define FDT_FORCE
+#define FDT_BITWISE
+#endif
+
+typedef uint16_t FDT_BITWISE fdt16_t;
+typedef uint32_t FDT_BITWISE fdt32_t;
+typedef uint64_t FDT_BITWISE fdt64_t;
+
+#define EXTRACT_BYTE(x, n)	((unsigned long long)((uint8_t *)&x)[n])
+#define CPU_TO_FDT16(x) ((EXTRACT_BYTE(x, 0) << 8) | EXTRACT_BYTE(x, 1))
+#define CPU_TO_FDT32(x) ((EXTRACT_BYTE(x, 0) << 24) | (EXTRACT_BYTE(x, 1) << 16) | \
+			 (EXTRACT_BYTE(x, 2) << 8) | EXTRACT_BYTE(x, 3))
+#define CPU_TO_FDT64(x) ((EXTRACT_BYTE(x, 0) << 56) | (EXTRACT_BYTE(x, 1) << 48) | \
+			 (EXTRACT_BYTE(x, 2) << 40) | (EXTRACT_BYTE(x, 3) << 32) | \
+			 (EXTRACT_BYTE(x, 4) << 24) | (EXTRACT_BYTE(x, 5) << 16) | \
+			 (EXTRACT_BYTE(x, 6) << 8) | EXTRACT_BYTE(x, 7))
+
+static inline uint16_t fdt16_to_cpu(fdt16_t x)
+{
+	return (FDT_FORCE uint16_t)CPU_TO_FDT16(x);
+}
+static inline fdt16_t cpu_to_fdt16(uint16_t x)
+{
+	return (FDT_FORCE fdt16_t)CPU_TO_FDT16(x);
+}
+
+static inline uint32_t fdt32_to_cpu(fdt32_t x)
+{
+	return (FDT_FORCE uint32_t)CPU_TO_FDT32(x);
+}
+static inline fdt32_t cpu_to_fdt32(uint32_t x)
+{
+	return (FDT_FORCE fdt32_t)CPU_TO_FDT32(x);
+}
+
+static inline uint64_t fdt64_to_cpu(fdt64_t x)
+{
+	return (FDT_FORCE uint64_t)CPU_TO_FDT64(x);
+}
+static inline fdt64_t cpu_to_fdt64(uint64_t x)
+{
+	return (FDT_FORCE fdt64_t)CPU_TO_FDT64(x);
+}
+#undef CPU_TO_FDT64
+#undef CPU_TO_FDT32
+#undef CPU_TO_FDT16
+#undef EXTRACT_BYTE
+
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+
+/* strnlen() is not available on Mac OS < 10.7 */
+# if !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED < \
+                                         MAC_OS_X_VERSION_10_7)
+
+#define strnlen fdt_strnlen
+
+/*
+ * fdt_strnlen: returns the length of a string or max_count - which ever is
+ * smallest.
+ * Input 1 string: the string whose size is to be determined
+ * Input 2 max_count: the maximum value returned by this function
+ * Output: length of the string or max_count (the smallest of the two)
+ */
+static inline size_t fdt_strnlen(const char *string, size_t max_count)
+{
+    const char *p = memchr(string, 0, max_count);
+    return p ? p - string : max_count;
+}
+
+#endif /* !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED <
+          MAC_OS_X_VERSION_10_7) */
+
+#endif /* __APPLE__ */
+
+#endif /* LIBFDT_ENV_H */
diff --git a/dtc/libfdt/libfdt_internal.h b/dtc/libfdt/libfdt_internal.h
new file mode 100644
index 0000000..16bda19
--- /dev/null
+++ b/dtc/libfdt/libfdt_internal.h
@@ -0,0 +1,192 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+#ifndef LIBFDT_INTERNAL_H
+#define LIBFDT_INTERNAL_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <fdt.h>
+
+#define FDT_ALIGN(x, a)		(((x) + (a) - 1) & ~((a) - 1))
+#define FDT_TAGALIGN(x)		(FDT_ALIGN((x), FDT_TAGSIZE))
+
+int32_t fdt_ro_probe_(const void *fdt);
+#define FDT_RO_PROBE(fdt)					\
+	{							\
+		int32_t totalsize_;				\
+		if ((totalsize_ = fdt_ro_probe_(fdt)) < 0)	\
+			return totalsize_;			\
+	}
+
+int fdt_check_node_offset_(const void *fdt, int offset);
+int fdt_check_prop_offset_(const void *fdt, int offset);
+const char *fdt_find_string_(const char *strtab, int tabsize, const char *s);
+int fdt_node_end_offset_(void *fdt, int nodeoffset);
+
+static inline const void *fdt_offset_ptr_(const void *fdt, int offset)
+{
+	return (const char *)fdt + fdt_off_dt_struct(fdt) + offset;
+}
+
+static inline void *fdt_offset_ptr_w_(void *fdt, int offset)
+{
+	return (void *)(uintptr_t)fdt_offset_ptr_(fdt, offset);
+}
+
+static inline const struct fdt_reserve_entry *fdt_mem_rsv_(const void *fdt, int n)
+{
+	const struct fdt_reserve_entry *rsv_table =
+		(const struct fdt_reserve_entry *)
+		((const char *)fdt + fdt_off_mem_rsvmap(fdt));
+
+	return rsv_table + n;
+}
+static inline struct fdt_reserve_entry *fdt_mem_rsv_w_(void *fdt, int n)
+{
+	return (void *)(uintptr_t)fdt_mem_rsv_(fdt, n);
+}
+
+/*
+ * Internal helpers to access tructural elements of the device tree
+ * blob (rather than for exaple reading integers from within property
+ * values).  We assume that we are either given a naturally aligned
+ * address for the platform or if we are not, we are on a platform
+ * where unaligned memory reads will be handled in a graceful manner.
+ * If not the external helpers fdtXX_ld() from libfdt.h can be used
+ * instead.
+ */
+static inline uint32_t fdt32_ld_(const fdt32_t *p)
+{
+	return fdt32_to_cpu(*p);
+}
+
+static inline uint64_t fdt64_ld_(const fdt64_t *p)
+{
+	return fdt64_to_cpu(*p);
+}
+
+#define FDT_SW_MAGIC		(~FDT_MAGIC)
+
+/**********************************************************************/
+/* Checking controls                                                  */
+/**********************************************************************/
+
+#ifndef FDT_ASSUME_MASK
+#define FDT_ASSUME_MASK 0
+#endif
+
+/*
+ * Defines assumptions which can be enabled. Each of these can be enabled
+ * individually. For maximum safety, don't enable any assumptions!
+ *
+ * For minimal code size and no safety, use ASSUME_PERFECT at your own risk.
+ * You should have another method of validating the device tree, such as a
+ * signature or hash check before using libfdt.
+ *
+ * For situations where security is not a concern it may be safe to enable
+ * ASSUME_SANE.
+ */
+enum {
+	/*
+	 * This does essentially no checks. Only the latest device-tree
+	 * version is correctly handled. Inconsistencies or errors in the device
+	 * tree may cause undefined behaviour or crashes. Invalid parameters
+	 * passed to libfdt may do the same.
+	 *
+	 * If an error occurs when modifying the tree it may leave the tree in
+	 * an intermediate (but valid) state. As an example, adding a property
+	 * where there is insufficient space may result in the property name
+	 * being added to the string table even though the property itself is
+	 * not added to the struct section.
+	 *
+	 * Only use this if you have a fully validated device tree with
+	 * the latest supported version and wish to minimise code size.
+	 */
+	ASSUME_PERFECT		= 0xff,
+
+	/*
+	 * This assumes that the device tree is sane. i.e. header metadata
+	 * and basic hierarchy are correct.
+	 *
+	 * With this assumption enabled, normal device trees produced by libfdt
+	 * and the compiler should be handled safely. Malicious device trees and
+	 * complete garbage may cause libfdt to behave badly or crash. Truncated
+	 * device trees (e.g. those only partially loaded) can also cause
+	 * problems.
+	 *
+	 * Note: Only checks that relate exclusively to the device tree itself
+	 * (not the parameters passed to libfdt) are disabled by this
+	 * assumption. This includes checking headers, tags and the like.
+	 */
+	ASSUME_VALID_DTB	= 1 << 0,
+
+	/*
+	 * This builds on ASSUME_VALID_DTB and further assumes that libfdt
+	 * functions are called with valid parameters, i.e. not trigger
+	 * FDT_ERR_BADOFFSET or offsets that are out of bounds. It disables any
+	 * extensive checking of parameters and the device tree, making various
+	 * assumptions about correctness.
+	 *
+	 * It doesn't make sense to enable this assumption unless
+	 * ASSUME_VALID_DTB is also enabled.
+	 */
+	ASSUME_VALID_INPUT	= 1 << 1,
+
+	/*
+	 * This disables checks for device-tree version and removes all code
+	 * which handles older versions.
+	 *
+	 * Only enable this if you know you have a device tree with the latest
+	 * version.
+	 */
+	ASSUME_LATEST		= 1 << 2,
+
+	/*
+	 * This assumes that it is OK for a failed addition to the device tree,
+	 * due to lack of space or some other problem, to skip any rollback
+	 * steps (such as dropping the property name from the string table).
+	 * This is safe to enable in most circumstances, even though it may
+	 * leave the tree in a sub-optimal state.
+	 */
+	ASSUME_NO_ROLLBACK	= 1 << 3,
+
+	/*
+	 * This assumes that the device tree components appear in a 'convenient'
+	 * order, i.e. the memory reservation block first, then the structure
+	 * block and finally the string block.
+	 *
+	 * This order is not specified by the device-tree specification,
+	 * but is expected by libfdt. The device-tree compiler always created
+	 * device trees with this order.
+	 *
+	 * This assumption disables a check in fdt_open_into() and removes the
+	 * ability to fix the problem there. This is safe if you know that the
+	 * device tree is correctly ordered. See fdt_blocks_misordered_().
+	 */
+	ASSUME_LIBFDT_ORDER	= 1 << 4,
+
+	/*
+	 * This assumes that libfdt itself does not have any internal bugs. It
+	 * drops certain checks that should never be needed unless libfdt has an
+	 * undiscovered bug.
+	 *
+	 * This can generally be considered safe to enable.
+	 */
+	ASSUME_LIBFDT_FLAWLESS	= 1 << 5,
+};
+
+/**
+ * can_assume_() - check if a particular assumption is enabled
+ *
+ * @mask: Mask to check (ASSUME_...)
+ * @return true if that assumption is enabled, else false
+ */
+static inline bool can_assume_(int mask)
+{
+	return FDT_ASSUME_MASK & mask;
+}
+
+/** helper macros for checking assumptions */
+#define can_assume(_assume)	can_assume_(ASSUME_ ## _assume)
+
+#endif /* LIBFDT_INTERNAL_H */
diff --git a/dtc/libfdt/meson.build b/dtc/libfdt/meson.build
new file mode 100644
index 0000000..0307ffb
--- /dev/null
+++ b/dtc/libfdt/meson.build
@@ -0,0 +1,50 @@
+version_script = '-Wl,--version-script=@0@'.format(meson.current_source_dir() / 'version.lds')
+if not cc.has_link_argument(version_script)
+  version_script = []
+endif
+
+sources = files(
+  'fdt.c',
+  'fdt_addresses.c',
+  'fdt_check.c',
+  'fdt_empty_tree.c',
+  'fdt_overlay.c',
+  'fdt_ro.c',
+  'fdt_rw.c',
+  'fdt_strerror.c',
+  'fdt_sw.c',
+  'fdt_wip.c',
+)
+
+libfdt = library(
+  'fdt', sources,
+  version: '1.6.0',
+  link_args: ['-Wl,--no-undefined', version_script],
+  link_depends: 'version.lds',
+  install: true,
+)
+
+libfdt_inc = include_directories('.')
+
+libfdt_dep = declare_dependency(
+  include_directories: libfdt_inc,
+  link_with: libfdt,
+)
+
+install_headers(
+  files(
+    'fdt.h',
+    'libfdt.h',
+    'libfdt_env.h',
+  )
+)
+
+pkgconfig = import('pkgconfig')
+
+pkgconfig.generate(
+  libraries: libfdt,
+  version: meson.project_version(),
+  filebase: 'libfdt',
+  name: 'libfdt',
+  description: 'Flat Device Tree manipulation',
+)
diff --git a/dtc/libfdt/version.lds b/dtc/libfdt/version.lds
new file mode 100644
index 0000000..7ab85f1
--- /dev/null
+++ b/dtc/libfdt/version.lds
@@ -0,0 +1,82 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+LIBFDT_1.2 {
+	global:
+		fdt_next_node;
+		fdt_check_header;
+		fdt_move;
+		fdt_string;
+		fdt_num_mem_rsv;
+		fdt_get_mem_rsv;
+		fdt_subnode_offset_namelen;
+		fdt_subnode_offset;
+		fdt_path_offset_namelen;
+		fdt_path_offset;
+		fdt_get_name;
+		fdt_get_property_namelen;
+		fdt_get_property;
+		fdt_getprop_namelen;
+		fdt_getprop;
+		fdt_get_phandle;
+		fdt_get_alias_namelen;
+		fdt_get_alias;
+		fdt_get_path;
+                fdt_header_size;
+		fdt_supernode_atdepth_offset;
+		fdt_node_depth;
+		fdt_parent_offset;
+		fdt_node_offset_by_prop_value;
+		fdt_node_offset_by_phandle;
+		fdt_node_check_compatible;
+		fdt_node_offset_by_compatible;
+		fdt_setprop_inplace;
+		fdt_nop_property;
+		fdt_nop_node;
+		fdt_create;
+		fdt_add_reservemap_entry;
+		fdt_finish_reservemap;
+		fdt_begin_node;
+		fdt_property;
+		fdt_end_node;
+		fdt_finish;
+		fdt_open_into;
+		fdt_pack;
+		fdt_add_mem_rsv;
+		fdt_del_mem_rsv;
+		fdt_set_name;
+		fdt_setprop;
+		fdt_delprop;
+		fdt_add_subnode_namelen;
+		fdt_add_subnode;
+		fdt_del_node;
+		fdt_strerror;
+		fdt_offset_ptr;
+		fdt_next_tag;
+		fdt_appendprop;
+		fdt_create_empty_tree;
+		fdt_first_property_offset;
+		fdt_get_property_by_offset;
+		fdt_getprop_by_offset;
+		fdt_next_property_offset;
+		fdt_first_subnode;
+		fdt_next_subnode;
+		fdt_address_cells;
+		fdt_size_cells;
+		fdt_stringlist_contains;
+		fdt_stringlist_count;
+		fdt_stringlist_search;
+		fdt_stringlist_get;
+		fdt_resize;
+		fdt_overlay_apply;
+		fdt_get_string;
+		fdt_find_max_phandle;
+		fdt_generate_phandle;
+		fdt_check_full;
+		fdt_setprop_placeholder;
+		fdt_property_placeholder;
+		fdt_header_size_;
+		fdt_appendprop_addrrange;
+		fdt_setprop_inplace_namelen_partial;
+		fdt_create_with_flags;
+	local:
+		*;
+};
diff --git a/dtc/livetree.c b/dtc/livetree.c
new file mode 100644
index 0000000..7eacd02
--- /dev/null
+++ b/dtc/livetree.c
@@ -0,0 +1,1032 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include "dtc.h"
+#include "srcpos.h"
+
+/*
+ * Tree building functions
+ */
+
+void add_label(struct label **labels, char *label)
+{
+	struct label *new;
+
+	/* Make sure the label isn't already there */
+	for_each_label_withdel(*labels, new)
+		if (streq(new->label, label)) {
+			new->deleted = 0;
+			return;
+		}
+
+	new = xmalloc(sizeof(*new));
+	memset(new, 0, sizeof(*new));
+	new->label = label;
+	new->next = *labels;
+	*labels = new;
+}
+
+void delete_labels(struct label **labels)
+{
+	struct label *label;
+
+	for_each_label(*labels, label)
+		label->deleted = 1;
+}
+
+struct property *build_property(char *name, struct data val,
+				struct srcpos *srcpos)
+{
+	struct property *new = xmalloc(sizeof(*new));
+
+	memset(new, 0, sizeof(*new));
+
+	new->name = name;
+	new->val = val;
+	new->srcpos = srcpos_copy(srcpos);
+
+	return new;
+}
+
+struct property *build_property_delete(char *name)
+{
+	struct property *new = xmalloc(sizeof(*new));
+
+	memset(new, 0, sizeof(*new));
+
+	new->name = name;
+	new->deleted = 1;
+
+	return new;
+}
+
+struct property *chain_property(struct property *first, struct property *list)
+{
+	assert(first->next == NULL);
+
+	first->next = list;
+	return first;
+}
+
+struct property *reverse_properties(struct property *first)
+{
+	struct property *p = first;
+	struct property *head = NULL;
+	struct property *next;
+
+	while (p) {
+		next = p->next;
+		p->next = head;
+		head = p;
+		p = next;
+	}
+	return head;
+}
+
+struct node *build_node(struct property *proplist, struct node *children,
+			struct srcpos *srcpos)
+{
+	struct node *new = xmalloc(sizeof(*new));
+	struct node *child;
+
+	memset(new, 0, sizeof(*new));
+
+	new->proplist = reverse_properties(proplist);
+	new->children = children;
+	new->srcpos = srcpos_copy(srcpos);
+
+	for_each_child(new, child) {
+		child->parent = new;
+	}
+
+	return new;
+}
+
+struct node *build_node_delete(struct srcpos *srcpos)
+{
+	struct node *new = xmalloc(sizeof(*new));
+
+	memset(new, 0, sizeof(*new));
+
+	new->deleted = 1;
+	new->srcpos = srcpos_copy(srcpos);
+
+	return new;
+}
+
+struct node *name_node(struct node *node, char *name)
+{
+	assert(node->name == NULL);
+
+	node->name = name;
+
+	return node;
+}
+
+struct node *omit_node_if_unused(struct node *node)
+{
+	node->omit_if_unused = 1;
+
+	return node;
+}
+
+struct node *reference_node(struct node *node)
+{
+	node->is_referenced = 1;
+
+	return node;
+}
+
+struct node *merge_nodes(struct node *old_node, struct node *new_node)
+{
+	struct property *new_prop, *old_prop;
+	struct node *new_child, *old_child;
+	struct label *l;
+
+	old_node->deleted = 0;
+
+	/* Add new node labels to old node */
+	for_each_label_withdel(new_node->labels, l)
+		add_label(&old_node->labels, l->label);
+
+	/* Move properties from the new node to the old node.  If there
+	 * is a collision, replace the old value with the new */
+	while (new_node->proplist) {
+		/* Pop the property off the list */
+		new_prop = new_node->proplist;
+		new_node->proplist = new_prop->next;
+		new_prop->next = NULL;
+
+		if (new_prop->deleted) {
+			delete_property_by_name(old_node, new_prop->name);
+			free(new_prop);
+			continue;
+		}
+
+		/* Look for a collision, set new value if there is */
+		for_each_property_withdel(old_node, old_prop) {
+			if (streq(old_prop->name, new_prop->name)) {
+				/* Add new labels to old property */
+				for_each_label_withdel(new_prop->labels, l)
+					add_label(&old_prop->labels, l->label);
+
+				old_prop->val = new_prop->val;
+				old_prop->deleted = 0;
+				free(old_prop->srcpos);
+				old_prop->srcpos = new_prop->srcpos;
+				free(new_prop);
+				new_prop = NULL;
+				break;
+			}
+		}
+
+		/* if no collision occurred, add property to the old node. */
+		if (new_prop)
+			add_property(old_node, new_prop);
+	}
+
+	/* Move the override child nodes into the primary node.  If
+	 * there is a collision, then merge the nodes. */
+	while (new_node->children) {
+		/* Pop the child node off the list */
+		new_child = new_node->children;
+		new_node->children = new_child->next_sibling;
+		new_child->parent = NULL;
+		new_child->next_sibling = NULL;
+
+		if (new_child->deleted) {
+			delete_node_by_name(old_node, new_child->name);
+			free(new_child);
+			continue;
+		}
+
+		/* Search for a collision.  Merge if there is */
+		for_each_child_withdel(old_node, old_child) {
+			if (streq(old_child->name, new_child->name)) {
+				merge_nodes(old_child, new_child);
+				new_child = NULL;
+				break;
+			}
+		}
+
+		/* if no collision occurred, add child to the old node. */
+		if (new_child)
+			add_child(old_node, new_child);
+	}
+
+	old_node->srcpos = srcpos_extend(old_node->srcpos, new_node->srcpos);
+
+	/* The new node contents are now merged into the old node.  Free
+	 * the new node. */
+	free(new_node);
+
+	return old_node;
+}
+
+struct node * add_orphan_node(struct node *dt, struct node *new_node, char *ref)
+{
+	static unsigned int next_orphan_fragment = 0;
+	struct node *node;
+	struct property *p;
+	struct data d = empty_data;
+	char *name;
+
+	if (ref[0] == '/') {
+		d = data_add_marker(d, TYPE_STRING, ref);
+		d = data_append_data(d, ref, strlen(ref) + 1);
+
+		p = build_property("target-path", d, NULL);
+	} else {
+		d = data_add_marker(d, REF_PHANDLE, ref);
+		d = data_append_integer(d, 0xffffffff, 32);
+
+		p = build_property("target", d, NULL);
+	}
+
+	xasprintf(&name, "fragment@%u",
+			next_orphan_fragment++);
+	name_node(new_node, "__overlay__");
+	node = build_node(p, new_node, NULL);
+	name_node(node, name);
+
+	add_child(dt, node);
+	return dt;
+}
+
+struct node *chain_node(struct node *first, struct node *list)
+{
+	assert(first->next_sibling == NULL);
+
+	first->next_sibling = list;
+	return first;
+}
+
+void add_property(struct node *node, struct property *prop)
+{
+	struct property **p;
+
+	prop->next = NULL;
+
+	p = &node->proplist;
+	while (*p)
+		p = &((*p)->next);
+
+	*p = prop;
+}
+
+void delete_property_by_name(struct node *node, char *name)
+{
+	struct property *prop = node->proplist;
+
+	while (prop) {
+		if (streq(prop->name, name)) {
+			delete_property(prop);
+			return;
+		}
+		prop = prop->next;
+	}
+}
+
+void delete_property(struct property *prop)
+{
+	prop->deleted = 1;
+	delete_labels(&prop->labels);
+}
+
+void add_child(struct node *parent, struct node *child)
+{
+	struct node **p;
+
+	child->next_sibling = NULL;
+	child->parent = parent;
+
+	p = &parent->children;
+	while (*p)
+		p = &((*p)->next_sibling);
+
+	*p = child;
+}
+
+void delete_node_by_name(struct node *parent, char *name)
+{
+	struct node *node = parent->children;
+
+	while (node) {
+		if (streq(node->name, name)) {
+			delete_node(node);
+			return;
+		}
+		node = node->next_sibling;
+	}
+}
+
+void delete_node(struct node *node)
+{
+	struct property *prop;
+	struct node *child;
+
+	node->deleted = 1;
+	for_each_child(node, child)
+		delete_node(child);
+	for_each_property(node, prop)
+		delete_property(prop);
+	delete_labels(&node->labels);
+}
+
+void append_to_property(struct node *node,
+			char *name, const void *data, int len,
+			enum markertype type)
+{
+	struct data d;
+	struct property *p;
+
+	p = get_property(node, name);
+	if (p) {
+		d = data_add_marker(p->val, type, name);
+		d = data_append_data(d, data, len);
+		p->val = d;
+	} else {
+		d = data_add_marker(empty_data, type, name);
+		d = data_append_data(d, data, len);
+		p = build_property(name, d, NULL);
+		add_property(node, p);
+	}
+}
+
+struct reserve_info *build_reserve_entry(uint64_t address, uint64_t size)
+{
+	struct reserve_info *new = xmalloc(sizeof(*new));
+
+	memset(new, 0, sizeof(*new));
+
+	new->address = address;
+	new->size = size;
+
+	return new;
+}
+
+struct reserve_info *chain_reserve_entry(struct reserve_info *first,
+					struct reserve_info *list)
+{
+	assert(first->next == NULL);
+
+	first->next = list;
+	return first;
+}
+
+struct reserve_info *add_reserve_entry(struct reserve_info *list,
+				      struct reserve_info *new)
+{
+	struct reserve_info *last;
+
+	new->next = NULL;
+
+	if (! list)
+		return new;
+
+	for (last = list; last->next; last = last->next)
+		;
+
+	last->next = new;
+
+	return list;
+}
+
+struct dt_info *build_dt_info(unsigned int dtsflags,
+			      struct reserve_info *reservelist,
+			      struct node *tree, uint32_t boot_cpuid_phys)
+{
+	struct dt_info *dti;
+
+	dti = xmalloc(sizeof(*dti));
+	dti->dtsflags = dtsflags;
+	dti->reservelist = reservelist;
+	dti->dt = tree;
+	dti->boot_cpuid_phys = boot_cpuid_phys;
+
+	return dti;
+}
+
+/*
+ * Tree accessor functions
+ */
+
+const char *get_unitname(struct node *node)
+{
+	if (node->name[node->basenamelen] == '\0')
+		return "";
+	else
+		return node->name + node->basenamelen + 1;
+}
+
+struct property *get_property(struct node *node, const char *propname)
+{
+	struct property *prop;
+
+	for_each_property(node, prop)
+		if (streq(prop->name, propname))
+			return prop;
+
+	return NULL;
+}
+
+cell_t propval_cell(struct property *prop)
+{
+	assert(prop->val.len == sizeof(cell_t));
+	return fdt32_to_cpu(*((fdt32_t *)prop->val.val));
+}
+
+cell_t propval_cell_n(struct property *prop, unsigned int n)
+{
+	assert(prop->val.len / sizeof(cell_t) >= n);
+	return fdt32_to_cpu(*((fdt32_t *)prop->val.val + n));
+}
+
+struct property *get_property_by_label(struct node *tree, const char *label,
+				       struct node **node)
+{
+	struct property *prop;
+	struct node *c;
+
+	*node = tree;
+
+	for_each_property(tree, prop) {
+		struct label *l;
+
+		for_each_label(prop->labels, l)
+			if (streq(l->label, label))
+				return prop;
+	}
+
+	for_each_child(tree, c) {
+		prop = get_property_by_label(c, label, node);
+		if (prop)
+			return prop;
+	}
+
+	*node = NULL;
+	return NULL;
+}
+
+struct marker *get_marker_label(struct node *tree, const char *label,
+				struct node **node, struct property **prop)
+{
+	struct marker *m;
+	struct property *p;
+	struct node *c;
+
+	*node = tree;
+
+	for_each_property(tree, p) {
+		*prop = p;
+		m = p->val.markers;
+		for_each_marker_of_type(m, LABEL)
+			if (streq(m->ref, label))
+				return m;
+	}
+
+	for_each_child(tree, c) {
+		m = get_marker_label(c, label, node, prop);
+		if (m)
+			return m;
+	}
+
+	*prop = NULL;
+	*node = NULL;
+	return NULL;
+}
+
+struct node *get_subnode(struct node *node, const char *nodename)
+{
+	struct node *child;
+
+	for_each_child(node, child)
+		if (streq(child->name, nodename))
+			return child;
+
+	return NULL;
+}
+
+struct node *get_node_by_path(struct node *tree, const char *path)
+{
+	const char *p;
+	struct node *child;
+
+	if (!path || ! (*path)) {
+		if (tree->deleted)
+			return NULL;
+		return tree;
+	}
+
+	while (path[0] == '/')
+		path++;
+
+	p = strchr(path, '/');
+
+	for_each_child(tree, child) {
+		if (p && strprefixeq(path, p - path, child->name))
+			return get_node_by_path(child, p+1);
+		else if (!p && streq(path, child->name))
+			return child;
+	}
+
+	return NULL;
+}
+
+struct node *get_node_by_label(struct node *tree, const char *label)
+{
+	struct node *child, *node;
+	struct label *l;
+
+	assert(label && (strlen(label) > 0));
+
+	for_each_label(tree->labels, l)
+		if (streq(l->label, label))
+			return tree;
+
+	for_each_child(tree, child) {
+		node = get_node_by_label(child, label);
+		if (node)
+			return node;
+	}
+
+	return NULL;
+}
+
+struct node *get_node_by_phandle(struct node *tree, cell_t phandle)
+{
+	struct node *child, *node;
+
+	if ((phandle == 0) || (phandle == -1)) {
+		assert(generate_fixups);
+		return NULL;
+	}
+
+	if (tree->phandle == phandle) {
+		if (tree->deleted)
+			return NULL;
+		return tree;
+	}
+
+	for_each_child(tree, child) {
+		node = get_node_by_phandle(child, phandle);
+		if (node)
+			return node;
+	}
+
+	return NULL;
+}
+
+struct node *get_node_by_ref(struct node *tree, const char *ref)
+{
+	if (streq(ref, "/"))
+		return tree;
+	else if (ref[0] == '/')
+		return get_node_by_path(tree, ref);
+	else
+		return get_node_by_label(tree, ref);
+}
+
+cell_t get_node_phandle(struct node *root, struct node *node)
+{
+	static cell_t phandle = 1; /* FIXME: ick, static local */
+	struct data d = empty_data;
+
+	if ((node->phandle != 0) && (node->phandle != -1))
+		return node->phandle;
+
+	while (get_node_by_phandle(root, phandle))
+		phandle++;
+
+	node->phandle = phandle;
+
+	d = data_add_marker(d, TYPE_UINT32, NULL);
+	d = data_append_cell(d, phandle);
+
+	if (!get_property(node, "linux,phandle")
+	    && (phandle_format & PHANDLE_LEGACY))
+		add_property(node, build_property("linux,phandle", d, NULL));
+
+	if (!get_property(node, "phandle")
+	    && (phandle_format & PHANDLE_EPAPR))
+		add_property(node, build_property("phandle", d, NULL));
+
+	/* If the node *does* have a phandle property, we must
+	 * be dealing with a self-referencing phandle, which will be
+	 * fixed up momentarily in the caller */
+
+	return node->phandle;
+}
+
+uint32_t guess_boot_cpuid(struct node *tree)
+{
+	struct node *cpus, *bootcpu;
+	struct property *reg;
+
+	cpus = get_node_by_path(tree, "/cpus");
+	if (!cpus)
+		return 0;
+
+
+	bootcpu = cpus->children;
+	if (!bootcpu)
+		return 0;
+
+	reg = get_property(bootcpu, "reg");
+	if (!reg || (reg->val.len != sizeof(uint32_t)))
+		return 0;
+
+	/* FIXME: Sanity check node? */
+
+	return propval_cell(reg);
+}
+
+static int cmp_reserve_info(const void *ax, const void *bx)
+{
+	const struct reserve_info *a, *b;
+
+	a = *((const struct reserve_info * const *)ax);
+	b = *((const struct reserve_info * const *)bx);
+
+	if (a->address < b->address)
+		return -1;
+	else if (a->address > b->address)
+		return 1;
+	else if (a->size < b->size)
+		return -1;
+	else if (a->size > b->size)
+		return 1;
+	else
+		return 0;
+}
+
+static void sort_reserve_entries(struct dt_info *dti)
+{
+	struct reserve_info *ri, **tbl;
+	int n = 0, i = 0;
+
+	for (ri = dti->reservelist;
+	     ri;
+	     ri = ri->next)
+		n++;
+
+	if (n == 0)
+		return;
+
+	tbl = xmalloc(n * sizeof(*tbl));
+
+	for (ri = dti->reservelist;
+	     ri;
+	     ri = ri->next)
+		tbl[i++] = ri;
+
+	qsort(tbl, n, sizeof(*tbl), cmp_reserve_info);
+
+	dti->reservelist = tbl[0];
+	for (i = 0; i < (n-1); i++)
+		tbl[i]->next = tbl[i+1];
+	tbl[n-1]->next = NULL;
+
+	free(tbl);
+}
+
+static int cmp_prop(const void *ax, const void *bx)
+{
+	const struct property *a, *b;
+
+	a = *((const struct property * const *)ax);
+	b = *((const struct property * const *)bx);
+
+	return strcmp(a->name, b->name);
+}
+
+static void sort_properties(struct node *node)
+{
+	int n = 0, i = 0;
+	struct property *prop, **tbl;
+
+	for_each_property_withdel(node, prop)
+		n++;
+
+	if (n == 0)
+		return;
+
+	tbl = xmalloc(n * sizeof(*tbl));
+
+	for_each_property_withdel(node, prop)
+		tbl[i++] = prop;
+
+	qsort(tbl, n, sizeof(*tbl), cmp_prop);
+
+	node->proplist = tbl[0];
+	for (i = 0; i < (n-1); i++)
+		tbl[i]->next = tbl[i+1];
+	tbl[n-1]->next = NULL;
+
+	free(tbl);
+}
+
+static int cmp_subnode(const void *ax, const void *bx)
+{
+	const struct node *a, *b;
+
+	a = *((const struct node * const *)ax);
+	b = *((const struct node * const *)bx);
+
+	return strcmp(a->name, b->name);
+}
+
+static void sort_subnodes(struct node *node)
+{
+	int n = 0, i = 0;
+	struct node *subnode, **tbl;
+
+	for_each_child_withdel(node, subnode)
+		n++;
+
+	if (n == 0)
+		return;
+
+	tbl = xmalloc(n * sizeof(*tbl));
+
+	for_each_child_withdel(node, subnode)
+		tbl[i++] = subnode;
+
+	qsort(tbl, n, sizeof(*tbl), cmp_subnode);
+
+	node->children = tbl[0];
+	for (i = 0; i < (n-1); i++)
+		tbl[i]->next_sibling = tbl[i+1];
+	tbl[n-1]->next_sibling = NULL;
+
+	free(tbl);
+}
+
+static void sort_node(struct node *node)
+{
+	struct node *c;
+
+	sort_properties(node);
+	sort_subnodes(node);
+	for_each_child_withdel(node, c)
+		sort_node(c);
+}
+
+void sort_tree(struct dt_info *dti)
+{
+	sort_reserve_entries(dti);
+	sort_node(dti->dt);
+}
+
+/* utility helper to avoid code duplication */
+static struct node *build_and_name_child_node(struct node *parent, char *name)
+{
+	struct node *node;
+
+	node = build_node(NULL, NULL, NULL);
+	name_node(node, xstrdup(name));
+	add_child(parent, node);
+
+	return node;
+}
+
+static struct node *build_root_node(struct node *dt, char *name)
+{
+	struct node *an;
+
+	an = get_subnode(dt, name);
+	if (!an)
+		an = build_and_name_child_node(dt, name);
+
+	if (!an)
+		die("Could not build root node /%s\n", name);
+
+	return an;
+}
+
+static bool any_label_tree(struct dt_info *dti, struct node *node)
+{
+	struct node *c;
+
+	if (node->labels)
+		return true;
+
+	for_each_child(node, c)
+		if (any_label_tree(dti, c))
+			return true;
+
+	return false;
+}
+
+static void generate_label_tree_internal(struct dt_info *dti,
+					 struct node *an, struct node *node,
+					 bool allocph)
+{
+	struct node *dt = dti->dt;
+	struct node *c;
+	struct property *p;
+	struct label *l;
+
+	/* if there are labels */
+	if (node->labels) {
+
+		/* now add the label in the node */
+		for_each_label(node->labels, l) {
+
+			/* check whether the label already exists */
+			p = get_property(an, l->label);
+			if (p) {
+				fprintf(stderr, "WARNING: label %s already"
+					" exists in /%s", l->label,
+					an->name);
+				continue;
+			}
+
+			/* insert it */
+			p = build_property(l->label,
+				data_copy_escape_string(node->fullpath,
+						strlen(node->fullpath)),
+				NULL);
+			add_property(an, p);
+		}
+
+		/* force allocation of a phandle for this node */
+		if (allocph)
+			(void)get_node_phandle(dt, node);
+	}
+
+	for_each_child(node, c)
+		generate_label_tree_internal(dti, an, c, allocph);
+}
+
+static bool any_fixup_tree(struct dt_info *dti, struct node *node)
+{
+	struct node *c;
+	struct property *prop;
+	struct marker *m;
+
+	for_each_property(node, prop) {
+		m = prop->val.markers;
+		for_each_marker_of_type(m, REF_PHANDLE) {
+			if (!get_node_by_ref(dti->dt, m->ref))
+				return true;
+		}
+	}
+
+	for_each_child(node, c) {
+		if (any_fixup_tree(dti, c))
+			return true;
+	}
+
+	return false;
+}
+
+static void add_fixup_entry(struct dt_info *dti, struct node *fn,
+			    struct node *node, struct property *prop,
+			    struct marker *m)
+{
+	char *entry;
+
+	/* m->ref can only be a REF_PHANDLE, but check anyway */
+	assert(m->type == REF_PHANDLE);
+
+	/* there shouldn't be any ':' in the arguments */
+	if (strchr(node->fullpath, ':') || strchr(prop->name, ':'))
+		die("arguments should not contain ':'\n");
+
+	xasprintf(&entry, "%s:%s:%u",
+			node->fullpath, prop->name, m->offset);
+	append_to_property(fn, m->ref, entry, strlen(entry) + 1, TYPE_STRING);
+
+	free(entry);
+}
+
+static void generate_fixups_tree_internal(struct dt_info *dti,
+					  struct node *fn,
+					  struct node *node)
+{
+	struct node *dt = dti->dt;
+	struct node *c;
+	struct property *prop;
+	struct marker *m;
+	struct node *refnode;
+
+	for_each_property(node, prop) {
+		m = prop->val.markers;
+		for_each_marker_of_type(m, REF_PHANDLE) {
+			refnode = get_node_by_ref(dt, m->ref);
+			if (!refnode)
+				add_fixup_entry(dti, fn, node, prop, m);
+		}
+	}
+
+	for_each_child(node, c)
+		generate_fixups_tree_internal(dti, fn, c);
+}
+
+static bool any_local_fixup_tree(struct dt_info *dti, struct node *node)
+{
+	struct node *c;
+	struct property *prop;
+	struct marker *m;
+
+	for_each_property(node, prop) {
+		m = prop->val.markers;
+		for_each_marker_of_type(m, REF_PHANDLE) {
+			if (get_node_by_ref(dti->dt, m->ref))
+				return true;
+		}
+	}
+
+	for_each_child(node, c) {
+		if (any_local_fixup_tree(dti, c))
+			return true;
+	}
+
+	return false;
+}
+
+static void add_local_fixup_entry(struct dt_info *dti,
+		struct node *lfn, struct node *node,
+		struct property *prop, struct marker *m,
+		struct node *refnode)
+{
+	struct node *wn, *nwn;	/* local fixup node, walk node, new */
+	fdt32_t value_32;
+	char **compp;
+	int i, depth;
+
+	/* walk back retrieving depth */
+	depth = 0;
+	for (wn = node; wn; wn = wn->parent)
+		depth++;
+
+	/* allocate name array */
+	compp = xmalloc(sizeof(*compp) * depth);
+
+	/* store names in the array */
+	for (wn = node, i = depth - 1; wn; wn = wn->parent, i--)
+		compp[i] = wn->name;
+
+	/* walk the path components creating nodes if they don't exist */
+	for (wn = lfn, i = 1; i < depth; i++, wn = nwn) {
+		/* if no node exists, create it */
+		nwn = get_subnode(wn, compp[i]);
+		if (!nwn)
+			nwn = build_and_name_child_node(wn, compp[i]);
+	}
+
+	free(compp);
+
+	value_32 = cpu_to_fdt32(m->offset);
+	append_to_property(wn, prop->name, &value_32, sizeof(value_32), TYPE_UINT32);
+}
+
+static void generate_local_fixups_tree_internal(struct dt_info *dti,
+						struct node *lfn,
+						struct node *node)
+{
+	struct node *dt = dti->dt;
+	struct node *c;
+	struct property *prop;
+	struct marker *m;
+	struct node *refnode;
+
+	for_each_property(node, prop) {
+		m = prop->val.markers;
+		for_each_marker_of_type(m, REF_PHANDLE) {
+			refnode = get_node_by_ref(dt, m->ref);
+			if (refnode)
+				add_local_fixup_entry(dti, lfn, node, prop, m, refnode);
+		}
+	}
+
+	for_each_child(node, c)
+		generate_local_fixups_tree_internal(dti, lfn, c);
+}
+
+void generate_label_tree(struct dt_info *dti, char *name, bool allocph)
+{
+	if (!any_label_tree(dti, dti->dt))
+		return;
+	generate_label_tree_internal(dti, build_root_node(dti->dt, name),
+				     dti->dt, allocph);
+}
+
+void generate_fixups_tree(struct dt_info *dti, char *name)
+{
+	if (!any_fixup_tree(dti, dti->dt))
+		return;
+	generate_fixups_tree_internal(dti, build_root_node(dti->dt, name),
+				      dti->dt);
+}
+
+void generate_local_fixups_tree(struct dt_info *dti, char *name)
+{
+	if (!any_local_fixup_tree(dti, dti->dt))
+		return;
+	generate_local_fixups_tree_internal(dti, build_root_node(dti->dt, name),
+					    dti->dt);
+}
diff --git a/dtc/meson.build b/dtc/meson.build
new file mode 100644
index 0000000..b23ea1b
--- /dev/null
+++ b/dtc/meson.build
@@ -0,0 +1,129 @@
+project('dtc', 'c',
+  version: '1.6.0',
+  license: ['GPL2+', 'BSD-2'],
+  default_options: 'werror=true',
+)
+
+cc = meson.get_compiler('c')
+
+add_project_arguments(
+  cc.get_supported_arguments([
+    '-Wpointer-arith',
+    '-Wcast-qual',
+    '-Wnested-externs',
+    '-Wstrict-prototypes',
+    '-Wmissing-prototypes',
+    '-Wredundant-decls',
+    '-Wshadow'
+  ]),
+  language: 'c'
+)
+
+if host_machine.system() == 'windows'
+  add_project_arguments(
+    '-D__USE_MINGW_ANSI_STDIO=1',
+    language: 'c'
+  )
+endif
+
+add_project_arguments(
+  '-DFDT_ASSUME_MASK=' + get_option('assume-mask').to_string(),
+  language: 'c'
+)
+
+yamltree = 'yamltree.c'
+yaml = dependency('yaml-0.1', required: get_option('yaml'))
+if not yaml.found()
+  add_project_arguments('-DNO_YAML', language: 'c')
+  yamltree = []
+endif
+
+valgrind = dependency('valgrind', required: get_option('valgrind'))
+if not valgrind.found()
+  add_project_arguments('-DNO_VALGRIND', language: 'c')
+endif
+
+py = import('python')
+py = py.find_installation(required: get_option('python'))
+swig = find_program('swig', required: get_option('python'))
+
+version_gen_h = vcs_tag(
+  input: 'version_gen.h.in',
+  output: 'version_gen.h',
+)
+
+subdir('libfdt')
+
+if get_option('tools')
+  flex = find_program('flex', required: true)
+  bison = find_program('bison', required: true)
+
+  util_dep = declare_dependency(
+    sources: ['util.c', version_gen_h],
+    include_directories: '.',
+    dependencies: libfdt_dep
+  )
+
+  lgen = generator(
+    flex,
+    output: '@PLAINNAME@.lex.c',
+    arguments: ['-o', '@OUTPUT@', '@INPUT@'],
+  )
+
+  pgen = generator(
+    bison,
+    output: ['@BASENAME@.tab.c', '@BASENAME@.tab.h'],
+    arguments: ['@INPUT@', '--defines=@OUTPUT1@', '--output=@OUTPUT0@'],
+  )
+
+  if cc.check_header('fnmatch.h')
+    executable(
+      'convert-dtsv0',
+      [
+        lgen.process('convert-dtsv0-lexer.l'),
+        'srcpos.c',
+      ],
+      dependencies: util_dep,
+      install: true,
+    )
+  endif
+
+  executable(
+    'dtc',
+    [
+      lgen.process('dtc-lexer.l'),
+      pgen.process('dtc-parser.y'),
+      'checks.c',
+      'data.c',
+      'dtc.c',
+      'flattree.c',
+      'fstree.c',
+      'livetree.c',
+      'srcpos.c',
+      'treesource.c',
+      yamltree,
+    ],
+    dependencies: [util_dep, yaml],
+    install: true,
+  )
+
+  foreach e: ['fdtdump', 'fdtget', 'fdtput', 'fdtoverlay']
+    executable(e, files(e + '.c'), dependencies: util_dep, install: true)
+  endforeach
+
+  install_data(
+    'dtdiff',
+    install_dir: get_option('prefix') / get_option('bindir'),
+    install_mode: 'rwxr-xr-x',
+  )
+endif
+
+if not meson.is_cross_build()
+  if py.found() and swig.found()
+    subdir('pylibfdt')
+  endif
+
+  if get_option('tools')
+    subdir('tests')
+  endif
+endif
diff --git a/dtc/meson_options.txt b/dtc/meson_options.txt
new file mode 100644
index 0000000..ea59c28
--- /dev/null
+++ b/dtc/meson_options.txt
@@ -0,0 +1,10 @@
+option('tools', type: 'boolean', value: true,
+       description: 'Build tools')
+option('assume-mask', type: 'integer', value: 0,
+       description: 'Control the assumptions made (e.g. risking security issues) in the code.')
+option('yaml', type: 'feature', value: 'auto',
+       description: 'YAML support')
+option('valgrind', type: 'feature', value: 'auto',
+       description: 'Valgrind support')
+option('python', type: 'feature', value: 'auto',
+       description: 'Build pylibfdt Python library')
diff --git a/dtc/pylibfdt/Makefile.pylibfdt b/dtc/pylibfdt/Makefile.pylibfdt
new file mode 100644
index 0000000..1b5f236
--- /dev/null
+++ b/dtc/pylibfdt/Makefile.pylibfdt
@@ -0,0 +1,30 @@
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+# Makefile.pylibfdt
+#
+
+PYLIBFDT_srcs = $(PYLIBFDT_dir)/libfdt.i
+PYMODULE = $(PYLIBFDT_dir)/_libfdt.so
+PYLIBFDT_CLEANFILES_L = libfdt_wrap.c libfdt.py *.pyc *.so
+PYLIBFDT_CLEANFILES = $(PYLIBFDT_CLEANFILES_L:%=$(PYLIBFDT_dir)/%)
+PYLIBFDT_CLEANDIRS_L = build __pycache__
+PYLIBFDT_CLEANDIRS = $(PYLIBFDT_CLEANDIRS_L:%=$(PYLIBFDT_dir)/%)
+
+SETUP = $(PYLIBFDT_dir)/setup.py
+SETUPFLAGS = --top-builddir .
+
+ifndef V
+SETUPFLAGS += --quiet
+endif
+
+$(PYMODULE): $(PYLIBFDT_srcs) $(LIBFDT_archive) $(SETUP) $(VERSION_FILE)
+	@$(VECHO) PYMOD $@
+	$(PYTHON) $(SETUP) $(SETUPFLAGS) build_ext --build-lib=$(PYLIBFDT_dir)
+
+install_pylibfdt: $(PYMODULE)
+	@$(VECHO) INSTALL-PYLIB
+	$(PYTHON) $(SETUP) $(SETUPFLAGS) install --prefix=$(PREFIX)
+
+pylibfdt_clean:
+	@$(VECHO) CLEAN "(pylibfdt)"
+	rm -f $(PYLIBFDT_CLEANFILES)
+	rm -rf $(PYLIBFDT_CLEANDIRS)
diff --git a/dtc/pylibfdt/libfdt.i b/dtc/pylibfdt/libfdt.i
new file mode 100644
index 0000000..51ee801
--- /dev/null
+++ b/dtc/pylibfdt/libfdt.i
@@ -0,0 +1,1118 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+/*
+ * pylibfdt - Flat Device Tree manipulation in Python
+ * Copyright (C) 2017 Google, Inc.
+ * Written by Simon Glass <sjg@chromium.org>
+ */
+
+%module libfdt
+
+%include <stdint.i>
+
+%{
+#define SWIG_FILE_WITH_INIT
+#include "libfdt.h"
+
+/*
+ * We rename this function here to avoid problems with swig, since we also have
+ * a struct called fdt_property. That struct causes swig to create a class in
+ * libfdt.py called fdt_property(), which confuses things.
+ */
+static int fdt_property_stub(void *fdt, const char *name, const void *val,
+                             int len)
+{
+    return fdt_property(fdt, name, val, len);
+}
+
+%}
+
+%pythoncode %{
+
+import struct
+
+# Error codes, corresponding to FDT_ERR_... in libfdt.h
+(NOTFOUND,
+        EXISTS,
+        NOSPACE,
+        BADOFFSET,
+        BADPATH,
+        BADPHANDLE,
+        BADSTATE,
+        TRUNCATED,
+        BADMAGIC,
+        BADVERSION,
+        BADSTRUCTURE,
+        BADLAYOUT,
+        INTERNAL,
+        BADNCELLS,
+        BADVALUE,
+        BADOVERLAY,
+        NOPHANDLES) = QUIET_ALL = range(1, 18)
+# QUIET_ALL can be passed as the 'quiet' parameter to avoid exceptions
+# altogether. All # functions passed this value will return an error instead
+# of raising an exception.
+
+# Pass this as the 'quiet' parameter to return -ENOTFOUND on NOTFOUND errors,
+# instead of raising an exception.
+QUIET_NOTFOUND = (NOTFOUND,)
+QUIET_NOSPACE = (NOSPACE,)
+
+
+class FdtException(Exception):
+    """An exception caused by an error such as one of the codes above"""
+    def __init__(self, err):
+        self.err = err
+
+    def __str__(self):
+        return 'pylibfdt error %d: %s' % (self.err, fdt_strerror(self.err))
+
+def strerror(fdt_err):
+    """Get the string for an error number
+
+    Args:
+        fdt_err: Error number (-ve)
+
+    Returns:
+        String containing the associated error
+    """
+    return fdt_strerror(fdt_err)
+
+def check_err(val, quiet=()):
+    """Raise an error if the return value is -ve
+
+    This is used to check for errors returned by libfdt C functions.
+
+    Args:
+        val: Return value from a libfdt function
+        quiet: Errors to ignore (empty to raise on all errors)
+
+    Returns:
+        val if val >= 0
+
+    Raises
+        FdtException if val < 0
+    """
+    if isinstance(val, int) and val < 0:
+        if -val not in quiet:
+            raise FdtException(val)
+    return val
+
+def check_err_null(val, quiet=()):
+    """Raise an error if the return value is NULL
+
+    This is used to check for a NULL return value from certain libfdt C
+    functions
+
+    Args:
+        val: Return value from a libfdt function
+        quiet: Errors to ignore (empty to raise on all errors)
+
+    Returns:
+        val if val is a list, None if not
+
+    Raises
+        FdtException if val indicates an error was reported and the error
+        is not in @quiet.
+    """
+    # Normally a list is returned which contains the data and its length.
+    # If we get just an integer error code, it means the function failed.
+    if not isinstance(val, list):
+        if -val not in quiet:
+            raise FdtException(val)
+    return val
+
+class FdtRo(object):
+    """Class for a read-only device-tree
+
+    This is a base class used by FdtRw (read-write access) and FdtSw
+    (sequential-write access). It implements read-only access to the
+    device tree.
+
+    Here are the three classes and when you should use them:
+
+        FdtRo - read-only access to an existing FDT
+        FdtRw - read-write access to an existing FDT (most common case)
+        FdtSw - for creating a new FDT, as well as allowing read-only access
+    """
+    def __init__(self, data):
+        self._fdt = bytearray(data)
+        check_err(fdt_check_header(self._fdt));
+
+    def as_bytearray(self):
+        """Get the device tree contents as a bytearray
+
+        This can be passed directly to libfdt functions that access a
+        const void * for the device tree.
+
+        Returns:
+            bytearray containing the device tree
+        """
+        return bytearray(self._fdt)
+
+    def next_node(self, nodeoffset, depth, quiet=()):
+        """Find the next subnode
+
+        Args:
+            nodeoffset: Node offset of previous node
+            depth: The depth of the node at nodeoffset. This is used to
+                calculate the depth of the returned node
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Typle:
+                Offset of the next node, if any, else a -ve error
+                Depth of the returned node, if any, else undefined
+
+        Raises:
+            FdtException if no more nodes found or other error occurs
+        """
+        return check_err(fdt_next_node(self._fdt, nodeoffset, depth), quiet)
+
+    def first_subnode(self, nodeoffset, quiet=()):
+        """Find the first subnode of a parent node
+
+        Args:
+            nodeoffset: Node offset of parent node
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            The offset of the first subnode, if any
+
+        Raises:
+            FdtException if no subnodes found or other error occurs
+        """
+        return check_err(fdt_first_subnode(self._fdt, nodeoffset), quiet)
+
+    def next_subnode(self, nodeoffset, quiet=()):
+        """Find the next subnode
+
+        Args:
+            nodeoffset: Node offset of previous subnode
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            The offset of the next subnode, if any
+
+        Raises:
+            FdtException if no more subnodes found or other error occurs
+        """
+        return check_err(fdt_next_subnode(self._fdt, nodeoffset), quiet)
+
+    def magic(self):
+        """Return the magic word from the header
+
+        Returns:
+            Magic word
+        """
+        return fdt_magic(self._fdt)
+
+    def totalsize(self):
+        """Return the total size of the device tree
+
+        Returns:
+            Total tree size in bytes
+        """
+        return fdt_totalsize(self._fdt)
+
+    def off_dt_struct(self):
+        """Return the start of the device-tree struct area
+
+        Returns:
+            Start offset of struct area
+        """
+        return fdt_off_dt_struct(self._fdt)
+
+    def off_dt_strings(self):
+        """Return the start of the device-tree string area
+
+        Returns:
+            Start offset of string area
+        """
+        return fdt_off_dt_strings(self._fdt)
+
+    def off_mem_rsvmap(self):
+        """Return the start of the memory reserve map
+
+        Returns:
+            Start offset of memory reserve map
+        """
+        return fdt_off_mem_rsvmap(self._fdt)
+
+    def version(self):
+        """Return the version of the device tree
+
+        Returns:
+            Version number of the device tree
+        """
+        return fdt_version(self._fdt)
+
+    def last_comp_version(self):
+        """Return the last compatible version of the device tree
+
+        Returns:
+            Last compatible version number of the device tree
+        """
+        return fdt_last_comp_version(self._fdt)
+
+    def boot_cpuid_phys(self):
+        """Return the physical boot CPU ID
+
+        Returns:
+            Physical boot CPU ID
+        """
+        return fdt_boot_cpuid_phys(self._fdt)
+
+    def size_dt_strings(self):
+        """Return the start of the device-tree string area
+
+        Returns:
+            Start offset of string area
+        """
+        return fdt_size_dt_strings(self._fdt)
+
+    def size_dt_struct(self):
+        """Return the start of the device-tree struct area
+
+        Returns:
+            Start offset of struct area
+        """
+        return fdt_size_dt_struct(self._fdt)
+
+    def num_mem_rsv(self, quiet=()):
+        """Return the number of memory reserve-map records
+
+        Returns:
+            Number of memory reserve-map records
+        """
+        return check_err(fdt_num_mem_rsv(self._fdt), quiet)
+
+    def get_mem_rsv(self, index, quiet=()):
+        """Return the indexed memory reserve-map record
+
+        Args:
+            index: Record to return (0=first)
+
+        Returns:
+            Number of memory reserve-map records
+        """
+        return check_err(fdt_get_mem_rsv(self._fdt, index), quiet)
+
+    def subnode_offset(self, parentoffset, name, quiet=()):
+        """Get the offset of a named subnode
+
+        Args:
+            parentoffset: Offset of the parent node to check
+            name: Name of the required subnode, e.g. 'subnode@1'
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            The node offset of the found node, if any
+
+        Raises
+            FdtException if there is no node with that name, or other error
+        """
+        return check_err(fdt_subnode_offset(self._fdt, parentoffset, name),
+                         quiet)
+
+    def path_offset(self, path, quiet=()):
+        """Get the offset for a given path
+
+        Args:
+            path: Path to the required node, e.g. '/node@3/subnode@1'
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Node offset
+
+        Raises
+            FdtException if the path is not valid or not found
+        """
+        return check_err(fdt_path_offset(self._fdt, path), quiet)
+
+    def get_name(self, nodeoffset):
+        """Get the name of a node
+
+        Args:
+            nodeoffset: Offset of node to check
+
+        Returns:
+            Node name
+
+        Raises:
+            FdtException on error (e.g. nodeoffset is invalid)
+        """
+        return check_err_null(fdt_get_name(self._fdt, nodeoffset))[0]
+
+    def first_property_offset(self, nodeoffset, quiet=()):
+        """Get the offset of the first property in a node offset
+
+        Args:
+            nodeoffset: Offset to the node to check
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Offset of the first property
+
+        Raises
+            FdtException if the associated node has no properties, or some
+                other error occurred
+        """
+        return check_err(fdt_first_property_offset(self._fdt, nodeoffset),
+                         quiet)
+
+    def next_property_offset(self, prop_offset, quiet=()):
+        """Get the next property in a node
+
+        Args:
+            prop_offset: Offset of the previous property
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Offset of the next property
+
+        Raises:
+            FdtException if the associated node has no more properties, or
+                some other error occurred
+        """
+        return check_err(fdt_next_property_offset(self._fdt, prop_offset),
+                         quiet)
+
+    def get_property_by_offset(self, prop_offset, quiet=()):
+        """Obtains a property that can be examined
+
+        Args:
+            prop_offset: Offset of property (e.g. from first_property_offset())
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Property object, or None if not found
+
+        Raises:
+            FdtException on error (e.g. invalid prop_offset or device
+            tree format)
+        """
+        pdata = check_err_null(
+                fdt_get_property_by_offset(self._fdt, prop_offset), quiet)
+        if isinstance(pdata, (int)):
+            return pdata
+        return Property(pdata[0], pdata[1])
+
+    def getprop(self, nodeoffset, prop_name, quiet=()):
+        """Get a property from a node
+
+        Args:
+            nodeoffset: Node offset containing property to get
+            prop_name: Name of property to get
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Value of property as a Property object (which can be used as a
+               bytearray/string), or -ve error number. On failure, returns an
+               integer error
+
+        Raises:
+            FdtError if any error occurs (e.g. the property is not found)
+        """
+        pdata = check_err_null(fdt_getprop(self._fdt, nodeoffset, prop_name),
+                               quiet)
+        if isinstance(pdata, (int)):
+            return pdata
+        return Property(prop_name, bytearray(pdata[0]))
+
+    def get_phandle(self, nodeoffset):
+        """Get the phandle of a node
+
+        Args:
+            nodeoffset: Node offset to check
+
+        Returns:
+            phandle of node, or 0 if the node has no phandle or another error
+            occurs
+        """
+        return fdt_get_phandle(self._fdt, nodeoffset)
+
+    def get_alias(self, name):
+        """Get the full path referenced by a given alias
+
+        Args:
+            name: name of the alias to lookup
+
+        Returns:
+            Full path to the node for the alias named 'name', if it exists
+            None, if the given alias or the /aliases node does not exist
+        """
+        return fdt_get_alias(self._fdt, name)
+
+    def parent_offset(self, nodeoffset, quiet=()):
+        """Get the offset of a node's parent
+
+        Args:
+            nodeoffset: Node offset to check
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            The offset of the parent node, if any
+
+        Raises:
+            FdtException if no parent found or other error occurs
+        """
+        return check_err(fdt_parent_offset(self._fdt, nodeoffset), quiet)
+
+    def node_offset_by_phandle(self, phandle, quiet=()):
+        """Get the offset of a node with the given phandle
+
+        Args:
+            phandle: Phandle to search for
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            The offset of node with that phandle, if any
+
+        Raises:
+            FdtException if no node found or other error occurs
+        """
+        return check_err(fdt_node_offset_by_phandle(self._fdt, phandle), quiet)
+
+
+class Fdt(FdtRo):
+    """Device tree class, supporting all operations
+
+    The Fdt object is created is created from a device tree binary file,
+    e.g. with something like:
+
+       fdt = Fdt(open("filename.dtb").read())
+
+    Operations can then be performed using the methods in this class. Each
+    method xxx(args...) corresponds to a libfdt function fdt_xxx(fdt, args...).
+
+    All methods raise an FdtException if an error occurs. To avoid this
+    behaviour a 'quiet' parameter is provided for some functions. This
+    defaults to empty, but you can pass a list of errors that you expect.
+    If one of these errors occurs, the function will return an error number
+    (e.g. -NOTFOUND).
+    """
+    def __init__(self, data):
+        FdtRo.__init__(self, data)
+
+    @staticmethod
+    def create_empty_tree(size, quiet=()):
+        """Create an empty device tree ready for use
+
+        Args:
+            size: Size of device tree in bytes
+
+        Returns:
+            Fdt object containing the device tree
+        """
+        data = bytearray(size)
+        err = check_err(fdt_create_empty_tree(data, size), quiet)
+        if err:
+            return err
+        return Fdt(data)
+
+    def resize(self, size, quiet=()):
+        """Move the device tree into a larger or smaller space
+
+        This creates a new device tree of size @size and moves the existing
+        device tree contents over to that. It can be used to create more space
+        in a device tree. Note that the Fdt object remains the same, but it
+        now has a new bytearray holding the contents.
+
+        Args:
+            size: Required new size of device tree in bytes
+        """
+        fdt = bytearray(size)
+        err = check_err(fdt_open_into(self._fdt, fdt, size), quiet)
+        if err:
+            return err
+        self._fdt = fdt
+
+    def pack(self, quiet=()):
+        """Pack the device tree to remove unused space
+
+        This adjusts the tree in place.
+
+        Args:
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtException if any error occurs
+        """
+        err = check_err(fdt_pack(self._fdt), quiet)
+        if err:
+            return err
+        del self._fdt[self.totalsize():]
+        return err
+
+    def set_name(self, nodeoffset, name, quiet=()):
+        """Set the name of a node
+
+        Args:
+            nodeoffset: Node offset of node to update
+            name: New node name (string without \0)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtException if no parent found or other error occurs
+        """
+        if chr(0) in name:
+            raise ValueError('Property contains embedded nul characters')
+        return check_err(fdt_set_name(self._fdt, nodeoffset, name), quiet)
+
+    def setprop(self, nodeoffset, prop_name, val, quiet=()):
+        """Set the value of a property
+
+        Args:
+            nodeoffset: Node offset containing the property to create/update
+            prop_name: Name of property
+            val: Value to write (string or bytearray)
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtException if no parent found or other error occurs
+        """
+        return check_err(fdt_setprop(self._fdt, nodeoffset, prop_name, val,
+                                     len(val)), quiet)
+
+    def setprop_u32(self, nodeoffset, prop_name, val, quiet=()):
+        """Set the value of a property
+
+        Args:
+            nodeoffset: Node offset containing the property to create/update
+            prop_name: Name of property
+            val: Value to write (integer)
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtException if no parent found or other error occurs
+        """
+        return check_err(fdt_setprop_u32(self._fdt, nodeoffset, prop_name, val),
+                         quiet)
+
+    def setprop_u64(self, nodeoffset, prop_name, val, quiet=()):
+        """Set the value of a property
+
+        Args:
+            nodeoffset: Node offset containing the property to create/update
+            prop_name: Name of property
+            val: Value to write (integer)
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtException if no parent found or other error occurs
+        """
+        return check_err(fdt_setprop_u64(self._fdt, nodeoffset, prop_name, val),
+                         quiet)
+
+    def setprop_str(self, nodeoffset, prop_name, val, quiet=()):
+        """Set the string value of a property
+
+        The property is set to the string, with a nul terminator added
+
+        Args:
+            nodeoffset: Node offset containing the property to create/update
+            prop_name: Name of property
+            val: Value to write (string without nul terminator). Unicode is
+                supposed by encoding to UTF-8
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtException if no parent found or other error occurs
+        """
+        val = val.encode('utf-8') + b'\0'
+        return check_err(fdt_setprop(self._fdt, nodeoffset, prop_name,
+                                     val, len(val)), quiet)
+
+    def delprop(self, nodeoffset, prop_name, quiet=()):
+        """Delete a property from a node
+
+        Args:
+            nodeoffset: Node offset containing property to delete
+            prop_name: Name of property to delete
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtError if the property does not exist, or another error occurs
+        """
+        return check_err(fdt_delprop(self._fdt, nodeoffset, prop_name), quiet)
+
+    def add_subnode(self, parentoffset, name, quiet=()):
+        """Add a new subnode to a node
+
+        Args:
+            parentoffset: Parent offset to add the subnode to
+            name: Name of node to add
+
+        Returns:
+            offset of the node created, or negative error code on failure
+
+        Raises:
+            FdtError if there is not enough space, or another error occurs
+        """
+        return check_err(fdt_add_subnode(self._fdt, parentoffset, name), quiet)
+
+    def del_node(self, nodeoffset, quiet=()):
+        """Delete a node
+
+        Args:
+            nodeoffset: Offset of node to delete
+
+        Returns:
+            Error code, or 0 if OK
+
+        Raises:
+            FdtError if an error occurs
+        """
+        return check_err(fdt_del_node(self._fdt, nodeoffset), quiet)
+
+
+class Property(bytearray):
+    """Holds a device tree property name and value.
+
+    This holds a copy of a property taken from the device tree. It does not
+    reference the device tree, so if anything changes in the device tree,
+    a Property object will remain valid.
+
+    Properties:
+        name: Property name
+        value: Property value as a bytearray
+    """
+    def __init__(self, name, value):
+        bytearray.__init__(self, value)
+        self.name = name
+
+    def as_cell(self, fmt):
+        return struct.unpack('>' + fmt, self)[0]
+
+    def as_uint32(self):
+        return self.as_cell('L')
+
+    def as_int32(self):
+        return self.as_cell('l')
+
+    def as_uint64(self):
+        return self.as_cell('Q')
+
+    def as_int64(self):
+        return self.as_cell('q')
+
+    def as_str(self):
+        """Unicode is supported by decoding from UTF-8"""
+        if self[-1] != 0:
+            raise ValueError('Property lacks nul termination')
+        if 0 in self[:-1]:
+            raise ValueError('Property contains embedded nul characters')
+        return self[:-1].decode('utf-8')
+
+
+class FdtSw(FdtRo):
+    """Software interface to create a device tree from scratch
+
+    The methods in this class work by adding to an existing 'partial' device
+    tree buffer of a fixed size created by instantiating this class. When the
+    tree is complete, call as_fdt() to obtain a device tree ready to be used.
+
+    Similarly with nodes, a new node is started with begin_node() and finished
+    with end_node().
+
+    The context manager functions can be used to make this a bit easier:
+
+    # First create the device tree with a node and property:
+    sw = FdtSw()
+    sw.finish_reservemap()
+    with sw.add_node(''):
+        with sw.add_node('node'):
+            sw.property_u32('reg', 2)
+    fdt = sw.as_fdt()
+
+    # Now we can use it as a real device tree
+    fdt.setprop_u32(0, 'reg', 3)
+
+    The size hint provides a starting size for the space to be used by the
+    device tree. This will be increased automatically as needed as new items
+    are added to the tree.
+    """
+    INC_SIZE = 1024  # Expand size by this much when out of space
+
+    def __init__(self, size_hint=None):
+        """Create a new FdtSw object
+
+        Args:
+            size_hint: A hint as to the initial size to use
+
+        Raises:
+            ValueError if size_hint is negative
+
+        Returns:
+            FdtSw object on success, else integer error code (if not raising)
+        """
+        if not size_hint:
+            size_hint = self.INC_SIZE
+        fdtsw = bytearray(size_hint)
+        err = check_err(fdt_create(fdtsw, size_hint))
+        if err:
+            return err
+        self._fdt = fdtsw
+
+    def as_fdt(self):
+        """Convert a FdtSw into an Fdt so it can be accessed as normal
+
+        Creates a new Fdt object from the work-in-progress device tree. This
+        does not call fdt_finish() on the current object, so it is possible to
+        add more nodes/properties and call as_fdt() again to get an updated
+        tree.
+
+        Returns:
+            Fdt object allowing access to the newly created device tree
+        """
+        fdtsw = bytearray(self._fdt)
+        check_err(fdt_finish(fdtsw))
+        return Fdt(fdtsw)
+
+    def check_space(self, val):
+        """Check if we need to add more space to the FDT
+
+        This should be called with the error code from an operation. If this is
+        -NOSPACE then the FDT will be expanded to have more space, and True will
+        be returned, indicating that the operation needs to be tried again.
+
+        Args:
+            val: Return value from the operation that was attempted
+
+        Returns:
+            True if the operation must be retried, else False
+        """
+        if check_err(val, QUIET_NOSPACE) < 0:
+            self.resize(len(self._fdt) + self.INC_SIZE)
+            return True
+        return False
+
+    def resize(self, size):
+        """Resize the buffer to accommodate a larger tree
+
+        Args:
+            size: New size of tree
+
+        Raises:
+            FdtException on any error
+        """
+        fdt = bytearray(size)
+        err = check_err(fdt_resize(self._fdt, fdt, size))
+        self._fdt = fdt
+
+    def add_reservemap_entry(self, addr, size):
+        """Add a new memory reserve map entry
+
+        Once finished adding, you must call finish_reservemap().
+
+        Args:
+            addr: 64-bit start address
+            size: 64-bit size
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_add_reservemap_entry(self._fdt, addr,
+                                                        size)):
+            pass
+
+    def finish_reservemap(self):
+        """Indicate that there are no more reserve map entries to add
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_finish_reservemap(self._fdt)):
+            pass
+
+    def begin_node(self, name):
+        """Begin a new node
+
+        Use this before adding properties to the node. Then call end_node() to
+        finish it. You can also use the context manager as shown in the FdtSw
+        class comment.
+
+        Args:
+            name: Name of node to begin
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_begin_node(self._fdt, name)):
+            pass
+
+    def property_string(self, name, string):
+        """Add a property with a string value
+
+        The string will be nul-terminated when written to the device tree
+
+        Args:
+            name: Name of property to add
+            string: String value of property
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_property_string(self._fdt, name, string)):
+            pass
+
+    def property_u32(self, name, val):
+        """Add a property with a 32-bit value
+
+        Write a single-cell value to the device tree
+
+        Args:
+            name: Name of property to add
+            val: Value of property
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_property_u32(self._fdt, name, val)):
+            pass
+
+    def property_u64(self, name, val):
+        """Add a property with a 64-bit value
+
+        Write a double-cell value to the device tree in big-endian format
+
+        Args:
+            name: Name of property to add
+            val: Value of property
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_property_u64(self._fdt, name, val)):
+            pass
+
+    def property_cell(self, name, val):
+        """Add a property with a single-cell value
+
+        Write a single-cell value to the device tree
+
+        Args:
+            name: Name of property to add
+            val: Value of property
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_property_cell(self._fdt, name, val)):
+            pass
+
+    def property(self, name, val):
+        """Add a property
+
+        Write a new property with the given value to the device tree. The value
+        is taken as is and is not nul-terminated
+
+        Args:
+            name: Name of property to add
+            val: Value of property (bytes)
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_property_stub(self._fdt, name, val,
+                                                 len(val))):
+            pass
+
+    def end_node(self):
+        """End a node
+
+        Use this after adding properties to a node to close it off. You can also
+        use the context manager as shown in the FdtSw class comment.
+
+        Args:
+            quiet: Errors to ignore (empty to raise on all errors)
+
+        Raises:
+            FdtException on any error
+        """
+        while self.check_space(fdt_end_node(self._fdt)):
+            pass
+
+    def add_node(self, name):
+        """Create a new context for adding a node
+
+        When used in a 'with' clause this starts a new node and finishes it
+        afterward.
+
+        Args:
+            name: Name of node to add
+        """
+        return NodeAdder(self, name)
+
+
+class NodeAdder():
+    """Class to provide a node context
+
+    This allows you to add nodes in a more natural way:
+
+        with fdtsw.add_node('name'):
+            fdtsw.property_string('test', 'value')
+
+    The node is automatically completed with a call to end_node() when the
+    context exits.
+    """
+    def __init__(self, fdtsw, name):
+        self._fdt = fdtsw
+        self._name = name
+
+    def __enter__(self):
+        self._fdt.begin_node(self._name)
+
+    def __exit__(self, type, value, traceback):
+        self._fdt.end_node()
+%}
+
+%rename(fdt_property) fdt_property_func;
+
+/*
+ * fdt32_t is a big-endian 32-bit value defined to uint32_t in libfdt_env.h
+ * so use the same type here.
+ */
+typedef uint32_t fdt32_t;
+
+%include "fdt.h"
+
+%include "typemaps.i"
+
+/* Most functions don't change the device tree, so use a const void * */
+%typemap(in) (const void *)(const void *fdt) {
+	if (!PyByteArray_Check($input)) {
+		SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname"
+			"', argument " "$argnum"" of type '" "$type""'");
+	}
+	$1 = (void *)PyByteArray_AsString($input);
+        fdt = $1;
+        (void)fdt; /* avoid unused variable warning */
+}
+
+/* Some functions do change the device tree, so use void * */
+%typemap(in) (void *)(const void *fdt) {
+	if (!PyByteArray_Check($input)) {
+		SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname"
+			"', argument " "$argnum"" of type '" "$type""'");
+	}
+	$1 = PyByteArray_AsString($input);
+        fdt = $1;
+        (void)fdt; /* avoid unused variable warning */
+}
+
+/* typemap used for fdt_get_property_by_offset() */
+%typemap(out) (struct fdt_property *) {
+	PyObject *buff;
+
+	if ($1) {
+		resultobj = PyString_FromString(
+			fdt_string(fdt1, fdt32_to_cpu($1->nameoff)));
+		buff = PyByteArray_FromStringAndSize(
+			(const char *)($1 + 1), fdt32_to_cpu($1->len));
+		resultobj = SWIG_Python_AppendOutput(resultobj, buff);
+	}
+}
+
+%apply int *OUTPUT { int *lenp };
+
+/* typemap used for fdt_getprop() */
+%typemap(out) (const void *) {
+	if (!$1)
+		$result = Py_None;
+	else
+        %#if PY_VERSION_HEX >= 0x03000000
+            $result = Py_BuildValue("y#", $1, *arg4);
+        %#else
+            $result = Py_BuildValue("s#", $1, *arg4);
+        %#endif
+}
+
+/* typemap used for fdt_setprop() */
+%typemap(in) (const void *val) {
+    %#if PY_VERSION_HEX >= 0x03000000
+        if (!PyBytes_Check($input)) {
+            SWIG_exception_fail(SWIG_TypeError, "bytes expected in method '" "$symname"
+                "', argument " "$argnum"" of type '" "$type""'");
+        }
+        $1 = PyBytes_AsString($input);
+    %#else
+        $1 = PyString_AsString($input);   /* char *str */
+    %#endif
+}
+
+/* typemaps used for fdt_next_node() */
+%typemap(in, numinputs=1) int *depth (int depth) {
+   depth = (int) PyInt_AsLong($input);
+   $1 = &depth;
+}
+
+%typemap(argout) int *depth {
+        PyObject *val = Py_BuildValue("i", *arg$argnum);
+        resultobj = SWIG_Python_AppendOutput(resultobj, val);
+}
+
+%apply int *depth { int *depth };
+
+/* typemaps for fdt_get_mem_rsv */
+%typemap(in, numinputs=0) uint64_t * (uint64_t temp) {
+   $1 = &temp;
+}
+
+%typemap(argout) uint64_t * {
+        PyObject *val = PyLong_FromUnsignedLongLong(*arg$argnum);
+        if (!result) {
+           if (PyTuple_GET_SIZE(resultobj) == 0)
+              resultobj = val;
+           else
+              resultobj = SWIG_Python_AppendOutput(resultobj, val);
+        }
+}
+
+/* We have both struct fdt_property and a function fdt_property() */
+%warnfilter(302) fdt_property;
+
+/* These are macros in the header so have to be redefined here */
+uint32_t fdt_magic(const void *fdt);
+uint32_t fdt_totalsize(const void *fdt);
+uint32_t fdt_off_dt_struct(const void *fdt);
+uint32_t fdt_off_dt_strings(const void *fdt);
+uint32_t fdt_off_mem_rsvmap(const void *fdt);
+uint32_t fdt_version(const void *fdt);
+uint32_t fdt_last_comp_version(const void *fdt);
+uint32_t fdt_boot_cpuid_phys(const void *fdt);
+uint32_t fdt_size_dt_strings(const void *fdt);
+uint32_t fdt_size_dt_struct(const void *fdt);
+
+int fdt_property_string(void *fdt, const char *name, const char *val);
+int fdt_property_cell(void *fdt, const char *name, uint32_t val);
+
+/*
+ * This function has a stub since the name fdt_property is used for both a
+  * function and a struct, which confuses SWIG.
+ */
+int fdt_property_stub(void *fdt, const char *name, const void *val, int len);
+
+%include <libfdt.h>
diff --git a/dtc/pylibfdt/meson.build b/dtc/pylibfdt/meson.build
new file mode 100644
index 0000000..088f249
--- /dev/null
+++ b/dtc/pylibfdt/meson.build
@@ -0,0 +1,13 @@
+setup_py = find_program('setup.py')
+setup_py = [setup_py.path(), '--quiet', '--top-builddir', meson.current_build_dir() / '..']
+
+custom_target(
+  'pylibfdt',
+  input: 'libfdt.i',
+  output: '_libfdt.so',
+  depends: version_gen_h,
+  command: [setup_py, 'build_ext', '--build-lib=' + meson.current_build_dir()],
+  build_by_default: true,
+)
+
+meson.add_install_script(setup_py, 'install', '--prefix=' + get_option('prefix'), '--root=$DESTDIR')
diff --git a/dtc/pylibfdt/setup.py b/dtc/pylibfdt/setup.py
new file mode 100755
index 0000000..ef40f15
--- /dev/null
+++ b/dtc/pylibfdt/setup.py
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+
+# While Python 3 is the default, it's also possible to invoke
+# this setup.py script with Python 2.
+
+"""
+setup.py file for SWIG libfdt
+Copyright (C) 2017 Google, Inc.
+Written by Simon Glass <sjg@chromium.org>
+"""
+
+from distutils.core import setup, Extension
+import os
+import re
+import sys
+
+
+VERSION_PATTERN = '^#define DTC_VERSION "DTC ([^"]*)"$'
+
+
+def get_top_builddir():
+    if '--top-builddir' in sys.argv:
+        index = sys.argv.index('--top-builddir')
+        sys.argv.pop(index)
+        return sys.argv.pop(index)
+    else:
+        return os.getcwd()
+
+
+srcdir = os.path.dirname(os.path.abspath(sys.argv[0]))
+top_builddir = get_top_builddir()
+
+
+def get_version():
+    version_file = os.path.join(top_builddir, 'version_gen.h')
+    f = open(version_file, 'rt')
+    m = re.match(VERSION_PATTERN, f.readline())
+    return m.group(1)
+
+
+libfdt_module = Extension(
+    '_libfdt',
+    sources=[os.path.join(srcdir, 'libfdt.i')],
+    include_dirs=[os.path.join(srcdir, '../libfdt')],
+    libraries=['fdt'],
+    library_dirs=[os.path.join(top_builddir, 'libfdt')],
+    swig_opts=['-I' + os.path.join(srcdir, '../libfdt')],
+)
+
+setup(
+    name='libfdt',
+    version=get_version(),
+    author='Simon Glass <sjg@chromium.org>',
+    description='Python binding for libfdt',
+    ext_modules=[libfdt_module],
+    package_dir={'': srcdir},
+    py_modules=['libfdt'],
+)
diff --git a/dtc/scripts/kup-dtc b/dtc/scripts/kup-dtc
new file mode 100755
index 0000000..3c3376c
--- /dev/null
+++ b/dtc/scripts/kup-dtc
@@ -0,0 +1,32 @@
+#! /bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+REMOTE_GIT=/pub/scm/utils/dtc/dtc.git
+REMOTE_PATH=/pub/software/utils/dtc
+
+set -e
+
+kup_one () {
+    VERSION="$1"
+
+    TAG="v$VERSION"
+
+    PREFIX="dtc-$VERSION/"
+    TAR="dtc-$VERSION.tar"
+    SIG="$TAR.sign"
+
+    git archive --format=tar --prefix="$PREFIX" -o "$TAR" "$TAG"
+    gpg --detach-sign --armor -o "$SIG" "$TAR"
+
+    ls -l "$TAR"*
+
+    # Verify the signature as a sanity check
+    gpg --verify "$SIG" "$TAR"
+
+    kup put --tar --prefix="$PREFIX" "$REMOTE_GIT" "$TAG" "$SIG" "$REMOTE_PATH/$TAR.gz" 
+}
+
+for version; do
+    kup_one $version
+done
+
diff --git a/dtc/scripts/setlocalversion b/dtc/scripts/setlocalversion
new file mode 100755
index 0000000..ea333e7
--- /dev/null
+++ b/dtc/scripts/setlocalversion
@@ -0,0 +1,23 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-or-later
+# Print additional version information for non-release trees.
+
+usage() {
+	echo "Usage: $0 [srctree]" >&2
+	exit 1
+}
+
+cd "${1:-.}" || usage
+
+# Check for git and a git repo.
+if head=`git rev-parse --verify HEAD 2>/dev/null`; then
+	# Do we have an untagged version?
+	if git name-rev --tags HEAD | grep -E '^HEAD[[:space:]]+(.*~[0-9]*|undefined)$' > /dev/null; then
+		printf '%s%s' -g `echo "$head" | cut -c1-8`
+	fi
+
+	# Are there uncommitted changes?
+	if git diff-index HEAD | read dummy; then
+		printf '%s' -dirty
+	fi
+fi
diff --git a/dtc/srcpos.c b/dtc/srcpos.c
new file mode 100644
index 0000000..4fdb22a
--- /dev/null
+++ b/dtc/srcpos.c
@@ -0,0 +1,406 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright 2007 Jon Loeliger, Freescale Semiconductor, Inc.
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+
+#include "dtc.h"
+#include "srcpos.h"
+
+/* A node in our list of directories to search for source/include files */
+struct search_path {
+	struct search_path *next;	/* next node in list, NULL for end */
+	const char *dirname;		/* name of directory to search */
+};
+
+/* This is the list of directories that we search for source files */
+static struct search_path *search_path_head, **search_path_tail;
+
+/* Detect infinite include recursion. */
+#define MAX_SRCFILE_DEPTH     (200)
+static int srcfile_depth; /* = 0 */
+
+static char *get_dirname(const char *path)
+{
+	const char *slash = strrchr(path, '/');
+
+	if (slash) {
+		int len = slash - path;
+		char *dir = xmalloc(len + 1);
+
+		memcpy(dir, path, len);
+		dir[len] = '\0';
+		return dir;
+	}
+	return NULL;
+}
+
+FILE *depfile; /* = NULL */
+struct srcfile_state *current_srcfile; /* = NULL */
+static char *initial_path; /* = NULL */
+static int initial_pathlen; /* = 0 */
+static bool initial_cpp = true;
+
+static void set_initial_path(char *fname)
+{
+	int i, len = strlen(fname);
+
+	xasprintf(&initial_path, "%s", fname);
+	initial_pathlen = 0;
+	for (i = 0; i != len; i++)
+		if (initial_path[i] == '/')
+			initial_pathlen++;
+}
+
+static char *shorten_to_initial_path(char *fname)
+{
+	char *p1, *p2, *prevslash1 = NULL;
+	int slashes = 0;
+
+	for (p1 = fname, p2 = initial_path; *p1 && *p2; p1++, p2++) {
+		if (*p1 != *p2)
+			break;
+		if (*p1 == '/') {
+			prevslash1 = p1;
+			slashes++;
+		}
+	}
+	p1 = prevslash1 + 1;
+	if (prevslash1) {
+		int diff = initial_pathlen - slashes, i, j;
+		int restlen = strlen(fname) - (p1 - fname);
+		char *res;
+
+		res = xmalloc((3 * diff) + restlen + 1);
+		for (i = 0, j = 0; i != diff; i++) {
+			res[j++] = '.';
+			res[j++] = '.';
+			res[j++] = '/';
+		}
+		strcpy(res + j, p1);
+		return res;
+	}
+	return NULL;
+}
+
+/**
+ * Try to open a file in a given directory.
+ *
+ * If the filename is an absolute path, then dirname is ignored. If it is a
+ * relative path, then we look in that directory for the file.
+ *
+ * @param dirname	Directory to look in, or NULL for none
+ * @param fname		Filename to look for
+ * @param fp		Set to NULL if file did not open
+ * @return allocated filename on success (caller must free), NULL on failure
+ */
+static char *try_open(const char *dirname, const char *fname, FILE **fp)
+{
+	char *fullname;
+
+	if (!dirname || fname[0] == '/')
+		fullname = xstrdup(fname);
+	else
+		fullname = join_path(dirname, fname);
+
+	*fp = fopen(fullname, "rb");
+	if (!*fp) {
+		free(fullname);
+		fullname = NULL;
+	}
+
+	return fullname;
+}
+
+/**
+ * Open a file for read access
+ *
+ * If it is a relative filename, we search the full search path for it.
+ *
+ * @param fname	Filename to open
+ * @param fp	Returns pointer to opened FILE, or NULL on failure
+ * @return pointer to allocated filename, which caller must free
+ */
+static char *fopen_any_on_path(const char *fname, FILE **fp)
+{
+	const char *cur_dir = NULL;
+	struct search_path *node;
+	char *fullname;
+
+	/* Try current directory first */
+	assert(fp);
+	if (current_srcfile)
+		cur_dir = current_srcfile->dir;
+	fullname = try_open(cur_dir, fname, fp);
+
+	/* Failing that, try each search path in turn */
+	for (node = search_path_head; !*fp && node; node = node->next)
+		fullname = try_open(node->dirname, fname, fp);
+
+	return fullname;
+}
+
+FILE *srcfile_relative_open(const char *fname, char **fullnamep)
+{
+	FILE *f;
+	char *fullname;
+
+	if (streq(fname, "-")) {
+		f = stdin;
+		fullname = xstrdup("<stdin>");
+	} else {
+		fullname = fopen_any_on_path(fname, &f);
+		if (!f)
+			die("Couldn't open \"%s\": %s\n", fname,
+			    strerror(errno));
+	}
+
+	if (depfile)
+		fprintf(depfile, " %s", fullname);
+
+	if (fullnamep)
+		*fullnamep = fullname;
+	else
+		free(fullname);
+
+	return f;
+}
+
+void srcfile_push(const char *fname)
+{
+	struct srcfile_state *srcfile;
+
+	if (srcfile_depth++ >= MAX_SRCFILE_DEPTH)
+		die("Includes nested too deeply");
+
+	srcfile = xmalloc(sizeof(*srcfile));
+
+	srcfile->f = srcfile_relative_open(fname, &srcfile->name);
+	srcfile->dir = get_dirname(srcfile->name);
+	srcfile->prev = current_srcfile;
+
+	srcfile->lineno = 1;
+	srcfile->colno = 1;
+
+	current_srcfile = srcfile;
+
+	if (srcfile_depth == 1)
+		set_initial_path(srcfile->name);
+}
+
+bool srcfile_pop(void)
+{
+	struct srcfile_state *srcfile = current_srcfile;
+
+	assert(srcfile);
+
+	current_srcfile = srcfile->prev;
+
+	if (fclose(srcfile->f))
+		die("Error closing \"%s\": %s\n", srcfile->name,
+		    strerror(errno));
+
+	/* FIXME: We allow the srcfile_state structure to leak,
+	 * because it could still be referenced from a location
+	 * variable being carried through the parser somewhere.  To
+	 * fix this we could either allocate all the files from a
+	 * table, or use a pool allocator. */
+
+	return current_srcfile ? true : false;
+}
+
+void srcfile_add_search_path(const char *dirname)
+{
+	struct search_path *node;
+
+	/* Create the node */
+	node = xmalloc(sizeof(*node));
+	node->next = NULL;
+	node->dirname = xstrdup(dirname);
+
+	/* Add to the end of our list */
+	if (search_path_tail)
+		*search_path_tail = node;
+	else
+		search_path_head = node;
+	search_path_tail = &node->next;
+}
+
+void srcpos_update(struct srcpos *pos, const char *text, int len)
+{
+	int i;
+
+	pos->file = current_srcfile;
+
+	pos->first_line = current_srcfile->lineno;
+	pos->first_column = current_srcfile->colno;
+
+	for (i = 0; i < len; i++)
+		if (text[i] == '\n') {
+			current_srcfile->lineno++;
+			current_srcfile->colno = 1;
+		} else {
+			current_srcfile->colno++;
+		}
+
+	pos->last_line = current_srcfile->lineno;
+	pos->last_column = current_srcfile->colno;
+}
+
+struct srcpos *
+srcpos_copy(struct srcpos *pos)
+{
+	struct srcpos *pos_new;
+	struct srcfile_state *srcfile_state;
+
+	if (!pos)
+		return NULL;
+
+	pos_new = xmalloc(sizeof(struct srcpos));
+	assert(pos->next == NULL);
+	memcpy(pos_new, pos, sizeof(struct srcpos));
+
+	/* allocate without free */
+	srcfile_state = xmalloc(sizeof(struct srcfile_state));
+	memcpy(srcfile_state, pos->file, sizeof(struct srcfile_state));
+	pos_new->file = srcfile_state;
+
+	return pos_new;
+}
+
+struct srcpos *srcpos_extend(struct srcpos *pos, struct srcpos *newtail)
+{
+	struct srcpos *p;
+
+	if (!pos)
+		return newtail;
+
+	for (p = pos; p->next != NULL; p = p->next);
+	p->next = newtail;
+	return pos;
+}
+
+char *
+srcpos_string(struct srcpos *pos)
+{
+	const char *fname = "<no-file>";
+	char *pos_str;
+
+	if (pos->file && pos->file->name)
+		fname = pos->file->name;
+
+
+	if (pos->first_line != pos->last_line)
+		xasprintf(&pos_str, "%s:%d.%d-%d.%d", fname,
+			  pos->first_line, pos->first_column,
+			  pos->last_line, pos->last_column);
+	else if (pos->first_column != pos->last_column)
+		xasprintf(&pos_str, "%s:%d.%d-%d", fname,
+			  pos->first_line, pos->first_column,
+			  pos->last_column);
+	else
+		xasprintf(&pos_str, "%s:%d.%d", fname,
+			  pos->first_line, pos->first_column);
+
+	return pos_str;
+}
+
+static char *
+srcpos_string_comment(struct srcpos *pos, bool first_line, int level)
+{
+	char *pos_str, *fname, *first, *rest;
+	bool fresh_fname = false;
+
+	if (!pos) {
+		if (level > 1) {
+			xasprintf(&pos_str, "<no-file>:<no-line>");
+			return pos_str;
+		} else {
+			return NULL;
+		}
+	}
+
+	if (!pos->file)
+		fname = "<no-file>";
+	else if (!pos->file->name)
+		fname = "<no-filename>";
+	else if (level > 1)
+		fname = pos->file->name;
+	else {
+		fname = shorten_to_initial_path(pos->file->name);
+		if (fname)
+			fresh_fname = true;
+		else
+			fname = pos->file->name;
+	}
+
+	if (level > 1)
+		xasprintf(&first, "%s:%d:%d-%d:%d", fname,
+			  pos->first_line, pos->first_column,
+			  pos->last_line, pos->last_column);
+	else
+		xasprintf(&first, "%s:%d", fname,
+			  first_line ? pos->first_line : pos->last_line);
+
+	if (fresh_fname)
+		free(fname);
+
+	if (pos->next != NULL) {
+		rest = srcpos_string_comment(pos->next, first_line, level);
+		xasprintf(&pos_str, "%s, %s", first, rest);
+		free(first);
+		free(rest);
+	} else {
+		pos_str = first;
+	}
+
+	return pos_str;
+}
+
+char *srcpos_string_first(struct srcpos *pos, int level)
+{
+	return srcpos_string_comment(pos, true, level);
+}
+
+char *srcpos_string_last(struct srcpos *pos, int level)
+{
+	return srcpos_string_comment(pos, false, level);
+}
+
+void srcpos_verror(struct srcpos *pos, const char *prefix,
+		   const char *fmt, va_list va)
+{
+	char *srcstr;
+
+	srcstr = srcpos_string(pos);
+
+	fprintf(stderr, "%s: %s ", prefix, srcstr);
+	vfprintf(stderr, fmt, va);
+	fprintf(stderr, "\n");
+
+	free(srcstr);
+}
+
+void srcpos_error(struct srcpos *pos, const char *prefix,
+		  const char *fmt, ...)
+{
+	va_list va;
+
+	va_start(va, fmt);
+	srcpos_verror(pos, prefix, fmt, va);
+	va_end(va);
+}
+
+void srcpos_set_line(char *f, int l)
+{
+	current_srcfile->name = f;
+	current_srcfile->lineno = l;
+
+	if (initial_cpp) {
+		initial_cpp = false;
+		set_initial_path(f);
+	}
+}
diff --git a/dtc/srcpos.h b/dtc/srcpos.h
new file mode 100644
index 0000000..4318d7a
--- /dev/null
+++ b/dtc/srcpos.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2007 Jon Loeliger, Freescale Semiconductor, Inc.
+ */
+
+#ifndef SRCPOS_H
+#define SRCPOS_H
+
+#include <stdio.h>
+#include <stdbool.h>
+#include "util.h"
+
+struct srcfile_state {
+	FILE *f;
+	char *name;
+	char *dir;
+	int lineno, colno;
+	struct srcfile_state *prev;
+};
+
+extern FILE *depfile; /* = NULL */
+extern struct srcfile_state *current_srcfile; /* = NULL */
+
+/**
+ * Open a source file.
+ *
+ * If the source file is a relative pathname, then it is searched for in the
+ * current directory (the directory of the last source file read) and after
+ * that in the search path.
+ *
+ * We work through the search path in order from the first path specified to
+ * the last.
+ *
+ * If the file is not found, then this function does not return, but calls
+ * die().
+ *
+ * @param fname		Filename to search
+ * @param fullnamep	If non-NULL, it is set to the allocated filename of the
+ *			file that was opened. The caller is then responsible
+ *			for freeing the pointer.
+ * @return pointer to opened FILE
+ */
+FILE *srcfile_relative_open(const char *fname, char **fullnamep);
+
+void srcfile_push(const char *fname);
+bool srcfile_pop(void);
+
+/**
+ * Add a new directory to the search path for input files
+ *
+ * The new path is added at the end of the list.
+ *
+ * @param dirname	Directory to add
+ */
+void srcfile_add_search_path(const char *dirname);
+
+struct srcpos {
+    int first_line;
+    int first_column;
+    int last_line;
+    int last_column;
+    struct srcfile_state *file;
+    struct srcpos *next;
+};
+
+#define YYLTYPE struct srcpos
+
+#define YYLLOC_DEFAULT(Current, Rhs, N)						\
+	do {									\
+		if (N) {							\
+			(Current).first_line = YYRHSLOC(Rhs, 1).first_line;	\
+			(Current).first_column = YYRHSLOC(Rhs, 1).first_column;	\
+			(Current).last_line = YYRHSLOC(Rhs, N).last_line;	\
+			(Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+			(Current).file = YYRHSLOC(Rhs, N).file;			\
+		} else {							\
+			(Current).first_line = (Current).last_line =		\
+				YYRHSLOC(Rhs, 0).last_line;			\
+			(Current).first_column = (Current).last_column =	\
+				YYRHSLOC(Rhs, 0).last_column;			\
+			(Current).file = YYRHSLOC (Rhs, 0).file;		\
+		}								\
+		(Current).next = NULL;						\
+	} while (0)
+
+
+extern void srcpos_update(struct srcpos *pos, const char *text, int len);
+extern struct srcpos *srcpos_copy(struct srcpos *pos);
+extern struct srcpos *srcpos_extend(struct srcpos *new_srcpos,
+				    struct srcpos *old_srcpos);
+extern char *srcpos_string(struct srcpos *pos);
+extern char *srcpos_string_first(struct srcpos *pos, int level);
+extern char *srcpos_string_last(struct srcpos *pos, int level);
+
+
+extern void PRINTF(3, 0) srcpos_verror(struct srcpos *pos, const char *prefix,
+					const char *fmt, va_list va);
+extern void PRINTF(3, 4) srcpos_error(struct srcpos *pos, const char *prefix,
+				      const char *fmt, ...);
+
+extern void srcpos_set_line(char *f, int l);
+
+#endif /* SRCPOS_H */
diff --git a/dtc/tests/Makefile.tests b/dtc/tests/Makefile.tests
new file mode 100644
index 0000000..2b47627
--- /dev/null
+++ b/dtc/tests/Makefile.tests
@@ -0,0 +1,102 @@
+LIB_TESTS_L = get_mem_rsv \
+	root_node find_property subnode_offset path_offset \
+	get_name getprop get_prop_offset get_phandle \
+	get_path supernode_atdepth_offset parent_offset \
+	node_offset_by_prop_value node_offset_by_phandle \
+	node_check_compatible node_offset_by_compatible \
+	get_alias \
+	char_literal \
+	sized_cells \
+	notfound \
+	addr_size_cells \
+	addr_size_cells2 \
+	appendprop_addrrange \
+	stringlist \
+	setprop_inplace nop_property nop_node \
+	sw_tree1 sw_states \
+	move_and_save mangle-layout nopulate \
+	open_pack rw_tree1 rw_oom set_name setprop del_property del_node \
+	appendprop1 appendprop2 propname_escapes \
+	string_escapes references path-references phandle_format \
+	boot-cpuid incbin \
+	extra-terminating-null \
+	dtbs_equal_ordered \
+	dtb_reverse dtbs_equal_unordered \
+	add_subnode_with_nops path_offset_aliases \
+	utilfdt_test \
+	integer-expressions \
+	property_iterate \
+	subnode_iterate \
+	overlay overlay_bad_fixup \
+	check_path check_header check_full \
+	fs_tree1
+LIB_TESTS = $(LIB_TESTS_L:%=$(TESTS_PREFIX)%)
+
+LIBTREE_TESTS_L = truncated_property truncated_string truncated_memrsv \
+	two_roots named_root
+
+LIBTREE_TESTS = $(LIBTREE_TESTS_L:%=$(TESTS_PREFIX)%)
+
+DL_LIB_TESTS_L = asm_tree_dump value-labels
+DL_LIB_TESTS = $(DL_LIB_TESTS_L:%=$(TESTS_PREFIX)%)
+
+TESTS = $(LIB_TESTS) $(LIBTREE_TESTS) $(DL_LIB_TESTS)
+
+TESTS_TREES_L = test_tree1.dtb
+TESTS_TREES = $(TESTS_TREES_L:%=$(TESTS_PREFIX)%)
+
+TESTS_TARGETS = $(TESTS) $(TESTS_TREES)
+
+TESTS_DEPFILES = $(TESTS:%=%.d) \
+	$(addprefix $(TESTS_PREFIX),testutils.d trees.d dumptrees.d)
+
+TESTS_CLEANFILES_L = $(STD_CLEANFILES) \
+	*.dtb *.test.dts *.test.dt.yaml *.dtsv1 tmp.* *.bak \
+	dumptrees
+TESTS_CLEANFILES = $(TESTS) $(TESTS_CLEANFILES_L:%=$(TESTS_PREFIX)%)
+TESTS_CLEANDIRS_L = fs
+TESTS_CLEANDIRS = $(TESTS_CLEANDIRS_L:%=$(TESTS_PREFIX)%)
+
+.PHONY: tests
+tests:	$(TESTS) $(TESTS_TREES)
+
+$(LIB_TESTS): %: $(TESTS_PREFIX)testutils.o util.o $(LIBFDT_lib)
+
+# Not necessary on all platforms; allow -ldl to be excluded instead of forcing
+# other platforms to patch it out.
+LIBDL = -ldl
+$(DL_LIB_TESTS): %: %.o $(TESTS_PREFIX)testutils.o util.o $(LIBFDT_lib)
+	@$(VECHO) LD [libdl] $@
+	$(LINK.c) -o $@ $^ $(LIBDL)
+
+$(LIBTREE_TESTS): %: $(TESTS_PREFIX)testutils.o $(TESTS_PREFIX)trees.o \
+		util.o $(LIBFDT_lib)
+
+$(TESTS_PREFIX)dumptrees: $(TESTS_PREFIX)trees.o
+
+$(TESTS_TREES): $(TESTS_PREFIX)dumptrees
+	@$(VECHO) DUMPTREES
+	cd $(TESTS_PREFIX); ./dumptrees . >/dev/null
+
+tests_clean:
+	@$(VECHO) CLEAN "(tests)"
+	rm -f $(TESTS_CLEANFILES)
+	rm -rf $(TESTS_CLEANDIRS)
+
+check:	tests ${TESTS_BIN} $(TESTS_PYLIBFDT)
+	cd $(TESTS_PREFIX); ./run_tests.sh
+
+ifeq ($(NO_VALGRIND),1)
+checkm:
+	@echo "make checkm requires valgrind, but NO_VALGRIND=1"
+else
+checkm: tests ${TESTS_BIN} $(TESTS_PYLIBFDT)
+	cd $(TESTS_PREFIX); ./run_tests.sh -m
+endif
+
+checkv:	tests ${TESTS_BIN} $(TESTS_PYLIBFDT)
+	cd $(TESTS_PREFIX); ./run_tests.sh -v
+
+ifneq ($(DEPTARGETS),)
+-include $(TESTS_DEPFILES)
+endif
diff --git a/dtc/tests/add_subnode_with_nops.c b/dtc/tests/add_subnode_with_nops.c
new file mode 100644
index 0000000..29bd34b
--- /dev/null
+++ b/dtc/tests/add_subnode_with_nops.c
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_node()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE	65536
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+#define OFF_CHECK(off, code) \
+	{ \
+		(off) = (code); \
+		if (off < 0) \
+			FAIL(#code ": %s", fdt_strerror(off)); \
+	}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int err;
+	int offset;
+
+	test_init(argc, argv);
+
+	fdt = xmalloc(SPACE);
+
+	CHECK(fdt_create(fdt, SPACE));
+
+	CHECK(fdt_finish_reservemap(fdt));
+	CHECK(fdt_begin_node(fdt, ""));
+	CHECK(fdt_property_cell(fdt, "prop1", TEST_VALUE_1));
+	CHECK(fdt_property_cell(fdt, "prop2", TEST_VALUE_2));
+	CHECK(fdt_end_node(fdt));
+	CHECK(fdt_finish(fdt));
+
+	verbose_printf("Built empty tree, totalsize = %d\n",
+		       fdt_totalsize(fdt));
+
+	CHECK(fdt_open_into(fdt, fdt, SPACE));
+
+	check_getprop_cell(fdt, 0, "prop1", TEST_VALUE_1);
+	check_getprop_cell(fdt, 0, "prop2", TEST_VALUE_2);
+
+	CHECK(fdt_nop_property(fdt, 0, "prop1"));
+
+	check_getprop_cell(fdt, 0, "prop2", TEST_VALUE_2);
+
+	OFF_CHECK(offset, fdt_add_subnode(fdt, 0, "subnode"));
+
+	check_getprop_cell(fdt, 0, "prop2", TEST_VALUE_2);
+
+	PASS();
+}
diff --git a/dtc/tests/addr_size_cells.c b/dtc/tests/addr_size_cells.c
new file mode 100644
index 0000000..783574d
--- /dev/null
+++ b/dtc/tests/addr_size_cells.c
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for #address-cells and #size-cells handling
+ * Copyright (C) 2014 David Gibson, <david@gibson.dropbear.id.au>
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_node(const void *fdt, const char *path, int ac, int sc)
+{
+	int offset;
+	int xac, xsc;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find path %s", path);
+
+	xac = fdt_address_cells(fdt, offset);
+	xsc = fdt_size_cells(fdt, offset);
+
+	if (xac != ac)
+		FAIL("Address cells for %s is %d instead of %d\n",
+		     path, xac, ac);
+	if (xsc != sc)
+		FAIL("Size cells for %s is %d instead of %d\n",
+		     path, xsc, sc);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>\n", argv[0]);
+
+	test_init(argc, argv);
+	fdt = load_blob(argv[1]);
+
+	check_node(fdt, "/", 2, 2);
+	check_node(fdt, "/identity-bus@0", 2, 1);
+	check_node(fdt, "/simple-bus@1000000", 2, 1);
+	check_node(fdt, "/discrete-bus@2000000", 1, 0);
+	check_node(fdt, "/c0", -FDT_ERR_BADNCELLS, -FDT_ERR_BADNCELLS);
+	check_node(fdt, "/c1", -FDT_ERR_BADNCELLS, -FDT_ERR_BADNCELLS);
+	check_node(fdt, "/c2", -FDT_ERR_BADNCELLS, -FDT_ERR_BADNCELLS);
+	check_node(fdt, "/c3", -FDT_ERR_BADNCELLS, 0);
+	PASS();
+}
diff --git a/dtc/tests/addr_size_cells2.c b/dtc/tests/addr_size_cells2.c
new file mode 100644
index 0000000..d97541b
--- /dev/null
+++ b/dtc/tests/addr_size_cells2.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for #address-cells and #size-cells handling
+ * Copyright (C) 2014 David Gibson, <david@gibson.dropbear.id.au>
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_node(const void *fdt, const char *path, int ac, int sc)
+{
+	int offset;
+	int xac, xsc;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find path %s", path);
+
+	xac = fdt_address_cells(fdt, offset);
+	xsc = fdt_size_cells(fdt, offset);
+
+	if (xac != ac)
+		FAIL("Address cells for %s is %d instead of %d\n",
+		     path, xac, ac);
+	if (xsc != sc)
+		FAIL("Size cells for %s is %d instead of %d\n",
+		     path, xsc, sc);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>\n", argv[0]);
+
+	test_init(argc, argv);
+	fdt = load_blob(argv[1]);
+
+	check_node(fdt, "/", 2, 1);
+	PASS();
+}
diff --git a/dtc/tests/addresses.dts b/dtc/tests/addresses.dts
new file mode 100644
index 0000000..1b307ab
--- /dev/null
+++ b/dtc/tests/addresses.dts
@@ -0,0 +1,40 @@
+/dts-v1/;
+
+/ {
+	compatible = "test_addresses";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	identity-bus@0 {
+	};
+
+	simple-bus@1000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+	};
+
+	discrete-bus@2000000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	c0@0 {
+		#address-cells = <1 1>;
+		#size-cells = <1 1>;
+	};
+
+	c1@0 {
+		#address-cells = <0x80000000>;
+		#size-cells = <0x80000000>;
+	};
+
+	c2@0 {
+		#address-cells = <5>;
+		#size-cells = <5>;
+	};
+
+	c3@0 {
+		#address-cells = <0>;
+		#size-cells = <0>;
+	};
+};
diff --git a/dtc/tests/aliases.dts b/dtc/tests/aliases.dts
new file mode 100644
index 0000000..853479a
--- /dev/null
+++ b/dtc/tests/aliases.dts
@@ -0,0 +1,25 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	aliases {
+		s1 = &sub1;
+		ss1 = &subsub1;
+		sss1 = &subsubsub1;
+	};
+
+	sub1: subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+
+		subsub1: subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+
+			subsubsub1: subsubsubnode {
+				compatible = "subsubsubnode1", "subsubsubnode";
+			};
+		};
+	};
+};
diff --git a/dtc/tests/appendprop.dts b/dtc/tests/appendprop.dts
new file mode 100644
index 0000000..f4bc730
--- /dev/null
+++ b/dtc/tests/appendprop.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/ {
+	prop-str = "hello world", "nastystring: \a\b\t\n\v\f\r\\\"";
+	prop-int64 = /bits/ 64 <0xdeadbeef01abcdef 0xdeadbeef01abcdef>;
+	prop-int = <0xdeadbeef 123456789>;
+	prop-bytes = [00010203040001020304];
+};
diff --git a/dtc/tests/appendprop1.c b/dtc/tests/appendprop1.c
new file mode 100644
index 0000000..a7b502a
--- /dev/null
+++ b/dtc/tests/appendprop1.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_appendprop()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE		65536
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int err;
+	uint8_t bytes[] = {0x00, 0x01, 0x02, 0x03, 0x04};
+
+	test_init(argc, argv);
+
+	/* Create an empty tree first */
+	fdt = xmalloc(SPACE);
+	CHECK(fdt_create(fdt, SPACE));
+	CHECK(fdt_finish_reservemap(fdt));
+	CHECK(fdt_begin_node(fdt, ""));
+	CHECK(fdt_end_node(fdt));
+	CHECK(fdt_finish(fdt));
+
+	/* Now use appendprop to add properties */
+	CHECK(fdt_open_into(fdt, fdt, SPACE));
+
+	CHECK(fdt_appendprop(fdt, 0, "prop-bytes", bytes, sizeof(bytes)));
+	CHECK(fdt_appendprop_cell(fdt, 0, "prop-int", TEST_VALUE_1));
+	CHECK(fdt_appendprop_u64(fdt, 0, "prop-int64", TEST_VALUE64_1));
+	CHECK(fdt_appendprop_string(fdt, 0, "prop-str", TEST_STRING_1));
+
+	CHECK(fdt_pack(fdt));
+
+	save_blob("appendprop1.test.dtb", fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/appendprop2.c b/dtc/tests/appendprop2.c
new file mode 100644
index 0000000..a0c1f6f
--- /dev/null
+++ b/dtc/tests/appendprop2.c
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_appendprop()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE		65536
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+int main(int argc, char *argv[])
+{
+	void *fdt, *buf;
+	int err;
+	uint8_t bytes[] = {0x00, 0x01, 0x02, 0x03, 0x04};
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	buf = xmalloc(SPACE);
+	CHECK(fdt_open_into(fdt, buf, SPACE));
+	fdt = buf;
+
+	CHECK(fdt_appendprop(fdt, 0, "prop-bytes", bytes, sizeof(bytes)));
+	CHECK(fdt_appendprop_cell(fdt, 0, "prop-int", TEST_VALUE_2));
+	CHECK(fdt_appendprop_u64(fdt, 0, "prop-int64", TEST_VALUE64_1));
+	CHECK(fdt_appendprop_string(fdt, 0, "prop-str", TEST_STRING_2));
+
+	CHECK(fdt_pack(fdt));
+
+	save_blob("appendprop2.test.dtb", fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/appendprop_addrrange.c b/dtc/tests/appendprop_addrrange.c
new file mode 100644
index 0000000..538afcf
--- /dev/null
+++ b/dtc/tests/appendprop_addrrange.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_appendprop_addrrange()
+ * Copyright (C) 2018 AKASHI Takahiro, Linaro Limited
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt, *buf;
+	int offset, xac, xsc, num, i, err;
+	uint64_t addr, size;
+
+	if (argc != 5)
+		CONFIG("Usage: %s <dtb file> <address-cells> <size-cells> <num>\n",
+		       argv[0]);
+
+	test_init(argc, argv);
+	fdt = load_blob(argv[1]);
+	xac = strtol(argv[2], NULL, 10);
+	xsc = strtol(argv[3], NULL, 10);
+	num = strtol(argv[4], NULL, 10);
+
+	buf = xmalloc(0x1000);
+	if (!buf)
+		FAIL("Couldn't allocate temporary buffer");
+	err = fdt_open_into(fdt, buf, 0x1000);
+	if (err)
+		FAIL("fdt_open_into(): %s", fdt_strerror(err));
+
+	fdt = buf;
+
+	/* Set up */
+	err = fdt_setprop_cell(fdt, 0, "#address-cells", xac);
+	if (err)
+		FAIL("fdt_setprop_cell(\"#address-cells\"): %s",
+		     fdt_strerror(err));
+	err = fdt_setprop_cell(fdt, 0, "#size-cells", xsc);
+	if (err)
+		FAIL("fdt_setprop_cell(\"#size-cells\"): %s",
+		     fdt_strerror(err));
+
+	offset = fdt_path_offset(fdt, "/node@1");
+	if (offset < 0)
+		FAIL("Couldn't find path %s", "/node@1");
+
+	addr = TEST_MEMREGION_ADDR;
+	if (xac > 1)
+		addr += TEST_MEMREGION_ADDR_HI;
+	size = TEST_MEMREGION_SIZE;
+	if (xsc > 1)
+		size += TEST_MEMREGION_SIZE_HI;
+
+	/*
+	 * Do test
+	 */
+	/* 1. repeat append's */
+	for (i = 0; i < num; i++) {
+		err = fdt_appendprop_addrrange(fdt, 0, offset,
+					       "prop-memregion", addr, size);
+		if (err)
+			FAIL("Failed to append[%d] \"prop-memregion\": %s",
+			     i, fdt_strerror(err));
+
+		check_getprop_addrrange(fdt, 0, offset, "prop-memregion",
+					i + 1);
+
+		addr += size;
+		size += TEST_MEMREGION_SIZE_INC;
+	}
+
+	/* 2. default property name */
+	addr = TEST_MEMREGION_ADDR;
+	if (xac > 1)
+		addr += TEST_MEMREGION_ADDR_HI;
+	size = TEST_MEMREGION_SIZE;
+	if (xsc > 1)
+		size += TEST_MEMREGION_SIZE_HI;
+
+	err = fdt_appendprop_addrrange(fdt, 0, offset, "reg", addr, size);
+	if (err)
+		FAIL("Failed to set \"reg\": %s", fdt_strerror(err));
+	check_getprop_addrrange(fdt, 0, offset, "reg", 1);
+
+	PASS();
+}
diff --git a/dtc/tests/asm_tree_dump.c b/dtc/tests/asm_tree_dump.c
new file mode 100644
index 0000000..8236172
--- /dev/null
+++ b/dtc/tests/asm_tree_dump.c
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests if an asm tree built into a shared object matches a given dtb
+ * Copyright (C) 2008 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+
+#include <dlfcn.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *sohandle;
+	void *fdt;
+	int err;
+
+	test_init(argc, argv);
+	if (argc != 3)
+		CONFIG("Usage: %s <so file> <dtb file>", argv[0]);
+
+	sohandle = dlopen(argv[1], RTLD_NOW);
+	if (!sohandle)
+		FAIL("Couldn't dlopen() %s", argv[1]);
+
+	fdt = dlsym(sohandle, "dt_blob_start");
+	if (!fdt)
+		FAIL("Couldn't locate \"dt_blob_start\" symbol in %s",
+		     argv[1]);
+
+	err = fdt_check_header(fdt);
+	if (err != 0)
+		FAIL("%s contains invalid tree: %s", argv[1],
+		     fdt_strerror(err));
+
+	save_blob(argv[2], fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/bad-chosen.dts b/dtc/tests/bad-chosen.dts
new file mode 100644
index 0000000..d6f53c6
--- /dev/null
+++ b/dtc/tests/bad-chosen.dts
@@ -0,0 +1,10 @@
+/dts-v1/;
+
+/ {
+	node2 {
+		chosen {
+			bootargs = <0xdeadbeef>;
+			stdout-path = <1>;
+		};
+	};
+};
diff --git a/dtc/tests/bad-dma-ranges.dts b/dtc/tests/bad-dma-ranges.dts
new file mode 100644
index 0000000..fbe7ab8
--- /dev/null
+++ b/dtc/tests/bad-dma-ranges.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	node {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		dma-ranges = <0 0 0 0 0>;
+	};
+};
diff --git a/dtc/tests/bad-empty-ranges.dts b/dtc/tests/bad-empty-ranges.dts
new file mode 100644
index 0000000..2be7bc8
--- /dev/null
+++ b/dtc/tests/bad-empty-ranges.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	node {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+	};
+};
diff --git a/dtc/tests/bad-gpio.dts b/dtc/tests/bad-gpio.dts
new file mode 100644
index 0000000..6b77be4
--- /dev/null
+++ b/dtc/tests/bad-gpio.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+
+/ {
+	gpio: gpio-controller {
+		#gpio-cells = <3>;
+	};
+
+	node {
+		nr-gpios = <1>;
+		foo-gpios = <&gpio>;
+		bar-gpio = <&gpio 1 2 3>;
+	};
+};
diff --git a/dtc/tests/bad-graph.dts b/dtc/tests/bad-graph.dts
new file mode 100644
index 0000000..522da0e
--- /dev/null
+++ b/dtc/tests/bad-graph.dts
@@ -0,0 +1,24 @@
+/dts-v1/;
+
+/ {
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		bad_endpoint: port-a@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			endpoint@d0 {
+				reg = <0>;
+				remote-endpoint = <0xdeadbeef>;
+			};
+
+		};
+
+		port@1 {
+			reg = <0>;
+		};
+	};
+};
diff --git a/dtc/tests/bad-interrupt-cells.dts b/dtc/tests/bad-interrupt-cells.dts
new file mode 100644
index 0000000..39fc78f
--- /dev/null
+++ b/dtc/tests/bad-interrupt-cells.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	interrupt-parent = <&intc>;
+	intc: interrupt-controller {
+		#interrupt-cells = <3>;
+	};
+
+	node {
+		interrupts = <1>;
+	};
+};
diff --git a/dtc/tests/bad-interrupt-controller.dts b/dtc/tests/bad-interrupt-controller.dts
new file mode 100644
index 0000000..62fa118
--- /dev/null
+++ b/dtc/tests/bad-interrupt-controller.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	intc: interrupt-controller {
+		interrupt-controller;
+	};
+};
diff --git a/dtc/tests/bad-name-property.dts b/dtc/tests/bad-name-property.dts
new file mode 100644
index 0000000..4fde4be
--- /dev/null
+++ b/dtc/tests/bad-name-property.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	node@0 {
+		name = "badthing";
+	};
+};
diff --git a/dtc/tests/bad-ncells.dts b/dtc/tests/bad-ncells.dts
new file mode 100644
index 0000000..636198c
--- /dev/null
+++ b/dtc/tests/bad-ncells.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	#address-cells = "badthing";
+	#size-cells = "badthing";
+	#interrupt-cells = "badthing";
+};
diff --git a/dtc/tests/bad-octal-literal.dts b/dtc/tests/bad-octal-literal.dts
new file mode 100644
index 0000000..26558a2
--- /dev/null
+++ b/dtc/tests/bad-octal-literal.dts
@@ -0,0 +1,5 @@
+/dts-v1/;
+
+/ {
+	x = <09>;
+};
diff --git a/dtc/tests/bad-phandle-cells.dts b/dtc/tests/bad-phandle-cells.dts
new file mode 100644
index 0000000..7f7c6a2
--- /dev/null
+++ b/dtc/tests/bad-phandle-cells.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+
+/ {
+	intc: interrupt-controller {
+		#interrupt-cells = <3>;
+	};
+
+	node {
+		interrupts-extended = <&intc>;
+	};
+};
diff --git a/dtc/tests/bad-reg-ranges.dts b/dtc/tests/bad-reg-ranges.dts
new file mode 100644
index 0000000..77419f5
--- /dev/null
+++ b/dtc/tests/bad-reg-ranges.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	node {
+		reg = <0 0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0 0>;
+	};
+};
diff --git a/dtc/tests/bad-size-cells.dts b/dtc/tests/bad-size-cells.dts
new file mode 100644
index 0000000..515c0cc
--- /dev/null
+++ b/dtc/tests/bad-size-cells.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	mangled {
+		#address-cells = <0x0>;
+		#size-cells = <0x0>;
+
+		valid {
+            reg = <0x0 0x4000000>;
+        };
+    };
+};
diff --git a/dtc/tests/bad-string-props.dts b/dtc/tests/bad-string-props.dts
new file mode 100644
index 0000000..6694704
--- /dev/null
+++ b/dtc/tests/bad-string-props.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+
+/ {
+	device_type = <0xdeadbeef>;
+	model = <0xdeadbeef>;
+	status = <0xdeadbeef>;
+	label = <0xdeadbeef>;
+
+	foobar-names = "foo", <1>;
+
+	node {
+		compatible = "good", <0xdeadbeef>;
+	};
+};
diff --git a/dtc/tests/base01.asm b/dtc/tests/base01.asm
new file mode 100644
index 0000000..266e446
--- /dev/null
+++ b/dtc/tests/base01.asm
@@ -0,0 +1,175 @@
+/* autogenerated by dtc, do not edit */
+
+#define OF_DT_HEADER 0xd00dfeed
+#define OF_DT_BEGIN_NODE 0x1
+#define OF_DT_END_NODE 0x2
+#define OF_DT_PROP 0x3
+#define OF_DT_END 0x9
+
+	.globl	dt_blob_start
+dt_blob_start:
+_dt_blob_start:
+	.globl	dt_header
+dt_header:
+_dt_header:
+	.long	OF_DT_HEADER /* magic */
+	.long	_dt_blob_end - _dt_blob_start /* totalsize */
+	.long	_dt_struct_start - _dt_blob_start /* off_dt_struct */
+	.long	_dt_strings_start - _dt_blob_start /* off_dt_strings */
+	.long	_dt_reserve_map - _dt_blob_start /* off_dt_strings */
+	.long	16 /* version */
+	.long	16 /* last_comp_version */
+	.long	0	/*boot_cpuid_phys*/
+	.long	_dt_strings_end - _dt_strings_start	/* size_dt_strings */
+	.balign	8
+	.globl	dt_reserve_map
+dt_reserve_map:
+_dt_reserve_map:
+/* Memory reserve map from source file */
+	.long	0, 0
+	.long	0, 0
+	.globl	dt_struct_start
+dt_struct_start:
+_dt_struct_start:
+	.long	OF_DT_BEGIN_NODE
+	.string	""
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0xa
+	.long	0x0
+	.long	0x536f6d65
+	.long	0x4d6f6465
+	.short	0x6c00
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x8
+	.long	0x6
+	.long	0x4e6f7468
+	.long	0x696e6700
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x11
+	.long	0x2
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x20
+	.long	0x2
+	.balign	4
+	.long	OF_DT_BEGIN_NODE
+	.string	"memory@0"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x7
+	.long	0x2c
+	.long	0x6d656d6f
+	.short	0x7279
+	.byte	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x10
+	.long	0x38
+	.long	0x0
+	.long	0x0
+	.long	0x0
+	.long	0x20000000
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_BEGIN_NODE
+	.string	"cpus"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x11
+	.long	0x1
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x20
+	.long	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x3c
+	.long	0xa
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x40
+	.long	0x17
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x44
+	.long	0x5
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x49
+	.long	0xf
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x4d
+	.long	0xd00d
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x10
+	.long	0x53
+	.long	0x4d2
+	.long	0x162e
+	.long	0x2334
+	.long	0xd80
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x59
+	.long	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x61
+	.long	0xffffffff
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x69
+	.long	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x71
+	.long	0xffffffff
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_END_NODE
+	.long	OF_DT_END
+	.globl	dt_struct_end
+dt_struct_end:
+_dt_struct_end:
+	.globl	dt_strings_start
+dt_strings_start:
+_dt_strings_start:
+	.string "model"
+	.string "compatible"
+	.string "#address-cells"
+	.string "#size-cells"
+	.string "device_type"
+	.string "reg"
+	.string "d10"
+	.string "d23"
+	.string "b101"
+	.string "o17"
+	.string "hd00d"
+	.string "stuff"
+	.string "bad-d-1"
+	.string "bad-d-2"
+	.string "bad-o-1"
+	.string "bad-o-2"
+	.globl	dt_strings_end
+dt_strings_end:
+_dt_strings_end:
+	.globl	dt_blob_end
+dt_blob_end:
+_dt_blob_end:
diff --git a/dtc/tests/base01.cmd b/dtc/tests/base01.cmd
new file mode 100644
index 0000000..e1fce6c
--- /dev/null
+++ b/dtc/tests/base01.cmd
@@ -0,0 +1 @@
+dtc -f -b 0 -V 16 -I dts -O asm
diff --git a/dtc/tests/base01.dts b/dtc/tests/base01.dts
new file mode 100644
index 0000000..97a5dd5
--- /dev/null
+++ b/dtc/tests/base01.dts
@@ -0,0 +1,33 @@
+/dts-v1/;
+
+/ {
+	model = "SomeModel";
+	compatible = "Nothing";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+        memory@0 {
+                device_type = "memory";
+		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
+        };
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		d10 = < 10>;		// hex: 0xa
+		d23 = < 23>;		// hex: 0x17
+		b101 = < 0x5>;	// hex: 0x5
+		o17 = < 017>;		// hex: 0xf
+		hd00d = < 0xd00d>;	// hex: 0xd00d
+
+		//   hex:  0x4d2    0x163e      0x2334    0xd80
+		stuff = < 1234     5678     9012     3456>;
+
+
+		bad-d-1 = < 0>;		// Hrm. 0
+		bad-d-2 = < 123456789012345>;
+		bad-o-1 = < 00>;
+		bad-o-2 = < 0123456123456>;
+	};
+
+};
diff --git a/dtc/tests/base01.stderr b/dtc/tests/base01.stderr
new file mode 100644
index 0000000..0510b0f
--- /dev/null
+++ b/dtc/tests/base01.stderr
@@ -0,0 +1,6 @@
+DTC: dts->asm  on file "tests/base01.dts"
+Line 26: Invalid cell value '123456789012345'; -1 assumed
+Line 27: Invalid cell value '891'; 0 assumed
+Line 28: Invalid cell value '123456123456'; -1 assumed
+ERROR: Missing /chosen node
+Input tree has errors
diff --git a/dtc/tests/boot-cpuid.c b/dtc/tests/boot-cpuid.c
new file mode 100644
index 0000000..5ed4f9a
--- /dev/null
+++ b/dtc/tests/boot-cpuid.c
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright (C) 2008 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	uint32_t cpuid;
+
+	test_init(argc, argv);
+
+	if (argc != 3)
+		CONFIG("Usage: %s <dtb file> <cpuid>", argv[0]);
+
+	fdt = load_blob(argv[1]);
+	cpuid = strtoul(argv[2], NULL, 0);
+
+	if (fdt_boot_cpuid_phys(fdt) != cpuid)
+		FAIL("Incorrect boot_cpuid_phys (0x%x instead of 0x%x)",
+		     fdt_boot_cpuid_phys(fdt), cpuid);
+
+	PASS();
+}
diff --git a/dtc/tests/boot-cpuid.dts b/dtc/tests/boot-cpuid.dts
new file mode 100644
index 0000000..7021a24
--- /dev/null
+++ b/dtc/tests/boot-cpuid.dts
@@ -0,0 +1,16 @@
+/dts-v1/;
+
+/ {
+	cpus {
+		cpu@10 {
+			device_type = "cpu";
+			compatible = "fake-cpu";
+			reg = <0x10>;
+		};
+		cpu@11 {
+			device_type = "cpu";
+			compatible = "fake-cpu";
+			reg = <0x11>;
+		};
+	};
+};
diff --git a/dtc/tests/char_literal.c b/dtc/tests/char_literal.c
new file mode 100644
index 0000000..3a69e28
--- /dev/null
+++ b/dtc/tests/char_literal.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for character literals in dtc
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright (C) 2011 The Chromium Authors. All rights reserved.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	fdt32_t expected_cells[5];
+
+	expected_cells[0] = cpu_to_fdt32((unsigned char)TEST_CHAR1);
+	expected_cells[1] = cpu_to_fdt32((unsigned char)TEST_CHAR2);
+	expected_cells[2] = cpu_to_fdt32((unsigned char)TEST_CHAR3);
+	expected_cells[3] = cpu_to_fdt32((unsigned char)TEST_CHAR4);
+	expected_cells[4] = cpu_to_fdt32((unsigned char)TEST_CHAR5);
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_getprop(fdt, 0, "char-literal-cells",
+		      sizeof(expected_cells), expected_cells);
+
+	PASS();
+}
diff --git a/dtc/tests/char_literal.dts b/dtc/tests/char_literal.dts
new file mode 100644
index 0000000..22e17ed
--- /dev/null
+++ b/dtc/tests/char_literal.dts
@@ -0,0 +1,5 @@
+/dts-v1/;
+
+/ {
+	char-literal-cells = <'\r' 'b' '\0' '\'' '\xff'>;
+};
diff --git a/dtc/tests/check_full.c b/dtc/tests/check_full.c
new file mode 100644
index 0000000..b6d5fc3
--- /dev/null
+++ b/dtc/tests/check_full.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests if two given dtbs are structurally equal (including order)
+ * Copyright (C) 2007 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int expect_bad; /* = 0 */
+
+int main(int argc, char *argv[])
+{
+	const char *filename;
+	char *fdt;
+	size_t len;
+	int err;
+
+	test_init(argc, argv);
+	if ((argc != 2)
+	    && ((argc != 3) || !streq(argv[1], "-n")))
+		CONFIG("Usage: %s [-n] <dtb file>", argv[0]);
+	if (argc == 3)
+		expect_bad = 1;
+
+	filename = argv[argc-1];
+	err = utilfdt_read_err(filename, &fdt, &len);
+	if (err)
+		CONFIG("Couldn't open blob from \"%s\": %s",
+		       filename, strerror(err));
+
+	vg_prepare_blob(fdt, len);
+
+	err = fdt_check_full(fdt, len);
+
+	if (expect_bad && (err == 0))
+		FAIL("fdt_check_full() succeeded unexpectedly");
+	else if (!expect_bad && (err != 0))
+		FAIL("fdt_check_full() failed: %s", fdt_strerror(err));
+
+	PASS();
+}
diff --git a/dtc/tests/check_header.c b/dtc/tests/check_header.c
new file mode 100644
index 0000000..ca26ec1
--- /dev/null
+++ b/dtc/tests/check_header.c
@@ -0,0 +1,115 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_check_header
+ * Copyright (C) 2018 David Gibson
+ */
+
+#include <stdio.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+
+static void *dtdup(void *dt)
+{
+	size_t bufsize = fdt_totalsize(dt);
+	void *buf = xmalloc(bufsize);
+	fdt_move(dt, buf, bufsize);
+	return buf;
+}
+
+#define CHECK_MANGLE(exerr, code)					\
+	do {								\
+		void *fdt = dtdup(template);				\
+		{ code }						\
+		err = fdt_check_header(fdt);				\
+		verbose_printf("\"%s\" => %s\n", #code, fdt_strerror(err)); \
+		if (err != (exerr))					\
+			FAIL("fdt_check_header() didn't catch mangle %s", \
+			     #code);					\
+		free(fdt);						\
+	} while (0)
+
+int main(int argc, char *argv[])
+{
+	void *template;
+	int err;
+
+	test_init(argc, argv);
+	template = load_blob(argv[1]);
+
+	/* Check that the base dt is valid before mangling it */
+	err = fdt_check_header(template);
+	if (err != 0)
+		FAIL("Base tree fails: %s", fdt_strerror(err));
+
+	/* Check a no-op mangle doesn't break things */
+	CHECK_MANGLE(0, ; );
+
+	/* Mess up the magic number */
+	CHECK_MANGLE(-FDT_ERR_BADMAGIC,
+		fdt_set_magic(fdt, fdt_magic(fdt) ^ 0x1);
+	);
+	CHECK_MANGLE(-FDT_ERR_BADMAGIC,
+		fdt_set_magic(fdt, fdt_magic(fdt) ^ 0x80000000);
+	);
+
+	/* Mess up the version */
+	CHECK_MANGLE(-FDT_ERR_BADVERSION,
+		fdt_set_version(fdt, FDT_FIRST_SUPPORTED_VERSION - 1);
+		fdt_set_last_comp_version(fdt, FDT_FIRST_SUPPORTED_VERSION - 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_BADVERSION,
+		fdt_set_version(fdt, FDT_LAST_SUPPORTED_VERSION + 1);
+		fdt_set_last_comp_version(fdt, FDT_LAST_SUPPORTED_VERSION + 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_BADVERSION,
+		fdt_set_version(fdt, FDT_FIRST_SUPPORTED_VERSION);
+		fdt_set_last_comp_version(fdt, FDT_LAST_SUPPORTED_VERSION);
+	);
+
+	/* Out of bounds sizes */
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, FDT_V1_SIZE - 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		     fdt_set_totalsize(fdt, (uint32_t)INT_MAX + 1);
+	);
+
+	/* Truncate within various blocks */
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, fdt_off_dt_struct(fdt) - 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, fdt_off_dt_strings(fdt) - 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, fdt_off_mem_rsvmap(fdt) - 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, fdt_off_dt_struct(fdt) + 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, fdt_off_dt_strings(fdt) + 1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_totalsize(fdt, fdt_off_mem_rsvmap(fdt) + 1);
+	);
+
+	/* Negative block sizes */
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_size_dt_struct(fdt, (uint32_t)-1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_size_dt_strings(fdt, (uint32_t)-1);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		     fdt_set_size_dt_struct(fdt, (uint32_t)INT_MIN);
+	);
+	CHECK_MANGLE(-FDT_ERR_TRUNCATED,
+		fdt_set_size_dt_strings(fdt, (uint32_t)INT_MIN);
+	);
+
+	PASS();
+}
diff --git a/dtc/tests/check_path.c b/dtc/tests/check_path.c
new file mode 100644
index 0000000..cc9757a
--- /dev/null
+++ b/dtc/tests/check_path.c
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for node existence
+ * Copyright (C) 2016 Konsulko Inc.
+ */
+
+#include <stdio.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+
+#define CHECK(code) \
+	{ \
+		int err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+/* 4k ought to be enough for anybody */
+#define FDT_COPY_SIZE	(4 * 1024)
+
+static void *open_dt(char *path)
+{
+	void *dt, *copy;
+
+	dt = load_blob(path);
+	copy = xmalloc(FDT_COPY_SIZE);
+
+	/*
+	 * Resize our DTs to 4k so that we have room to operate on
+	 */
+	CHECK(fdt_open_into(dt, copy, FDT_COPY_SIZE));
+
+	return copy;
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt_base;
+	int fail_config, exists, check_exists;
+
+	test_init(argc, argv);
+	fail_config = 0;
+
+	if (argc != 4)
+		fail_config = 1;
+
+	if (!fail_config) {
+		if (!strcmp(argv[2], "exists"))
+			check_exists = 1;
+		else if (!strcmp(argv[2], "not-exists"))
+			check_exists = 0;
+		else
+			fail_config = 1;
+	}
+
+	if (fail_config)
+		CONFIG("Usage: %s <base dtb> <[exists|not-exists]> <node-path>", argv[0]);
+
+	fdt_base = open_dt(argv[1]);
+
+	exists = fdt_path_offset(fdt_base, argv[3]) >= 0;
+
+	if (exists == check_exists)
+		PASS();
+	else
+		FAIL();
+}
diff --git a/dtc/tests/comments-cmp.dts b/dtc/tests/comments-cmp.dts
new file mode 100644
index 0000000..4ee9f52
--- /dev/null
+++ b/dtc/tests/comments-cmp.dts
@@ -0,0 +1,16 @@
+/dts-v1/;
+
+/ {
+	prop1;
+	prop2;
+	prop3;
+	prop4;
+	prop5;
+	prop6;
+	prop7;
+	prop8;
+	prop9;
+	prop10;
+	child {
+	};
+};
diff --git a/dtc/tests/comments.dts b/dtc/tests/comments.dts
new file mode 100644
index 0000000..0b04b6b
--- /dev/null
+++ b/dtc/tests/comments.dts
@@ -0,0 +1,39 @@
+/* regexps for lexing comments are.. tricky.  Check if we've actually
+ * got it right */
+/dts-v1/;
+
+/ {
+	// line comment
+	prop1;
+	/* comment */
+	prop2;
+	/* multiline
+
+	notaprop1;
+
+	   comment */
+	prop3;
+	/**/
+	prop4;
+	/***/
+	prop5;
+	/****/
+	prop6;
+	/* another
+	 * multiline
+	 * comment */
+	prop7;
+	/* yet
+	 * another
+	 * multline
+	 * comment
+	 */
+	prop8;
+	/** try this */
+	prop9;
+	/* and this **/
+	prop10;
+	child /* finally */ {
+	};
+};
+/* final comment */
diff --git a/dtc/tests/data.S b/dtc/tests/data.S
new file mode 100644
index 0000000..86ad539
--- /dev/null
+++ b/dtc/tests/data.S
@@ -0,0 +1,3 @@
+/* Used in combination with dtc -Oasm output to embed
+ * a device tree in the data section of a .o */
+	.data
diff --git a/dtc/tests/default-addr-size.dts b/dtc/tests/default-addr-size.dts
new file mode 100644
index 0000000..e964a55
--- /dev/null
+++ b/dtc/tests/default-addr-size.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	node {
+		reg = <0 0 0>;
+	};
+};
diff --git a/dtc/tests/del_node.c b/dtc/tests/del_node.c
new file mode 100644
index 0000000..10846df
--- /dev/null
+++ b/dtc/tests/del_node.c
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_node()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode1_offset, subnode2_offset, subsubnode2_offset;
+	int err;
+	int oldsize, delsize, newsize;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	fdt = open_blob_rw(fdt);
+
+	oldsize = fdt_totalsize(fdt);
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	if (subnode1_offset < 0)
+		FAIL("Couldn't find \"/subnode@1\": %s",
+		     fdt_strerror(subnode1_offset));
+	check_getprop_cell(fdt, subnode1_offset, "prop-int", TEST_VALUE_1);
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	if (subnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode@2\": %s",
+		     fdt_strerror(subnode2_offset));
+	check_getprop_cell(fdt, subnode2_offset, "prop-int", TEST_VALUE_2);
+
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode");
+	if (subsubnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode@2/subsubnode\": %s",
+		     fdt_strerror(subsubnode2_offset));
+	check_getprop_cell(fdt, subsubnode2_offset, "prop-int", TEST_VALUE_2);
+
+	err = fdt_del_node(fdt, subnode1_offset);
+	if (err)
+		FAIL("fdt_del_node(subnode1): %s", fdt_strerror(err));
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	if (subnode1_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subnode1) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subnode1_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	if (subnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode2\": %s",
+		     fdt_strerror(subnode2_offset));
+	check_getprop_cell(fdt, subnode2_offset, "prop-int", TEST_VALUE_2);
+
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode");
+	if (subsubnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode@2/subsubnode\": %s",
+		     fdt_strerror(subsubnode2_offset));
+	check_getprop_cell(fdt, subsubnode2_offset, "prop-int", TEST_VALUE_2);
+
+	err = fdt_del_node(fdt, subnode2_offset);
+	if (err)
+		FAIL("fdt_del_node(subnode2): %s", fdt_strerror(err));
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	if (subnode1_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subnode1) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subnode1_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	if (subnode2_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subnode2) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subnode2_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode");
+	if (subsubnode2_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subsubnode2) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subsubnode2_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	delsize = fdt_totalsize(fdt);
+
+	err = fdt_pack(fdt);
+	if (err)
+		FAIL("fdt_pack(): %s", fdt_strerror(err));
+
+	newsize = fdt_totalsize(fdt);
+
+	verbose_printf("oldsize = %d, delsize = %d, newsize = %d\n",
+		       oldsize, delsize, newsize);
+
+	if (newsize >= oldsize)
+		FAIL("Tree failed to shrink after deletions");
+
+	PASS();
+}
diff --git a/dtc/tests/del_property.c b/dtc/tests/del_property.c
new file mode 100644
index 0000000..37e8303
--- /dev/null
+++ b/dtc/tests/del_property.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_delprop()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	const uint32_t *intp;
+	const char *strp;
+	int err, lenerr;
+	int oldsize, delsize, newsize;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	fdt = open_blob_rw(fdt);
+
+	oldsize = fdt_totalsize(fdt);
+
+	intp = check_getprop_cell(fdt, 0, "prop-int", TEST_VALUE_1);
+	verbose_printf("int value was 0x%08x\n", *intp);
+
+	err = fdt_delprop(fdt, 0, "prop-int");
+	if (err)
+		FAIL("Failed to delete \"prop-int\": %s", fdt_strerror(err));
+
+	intp = fdt_getprop(fdt, 0, "prop-int", &lenerr);
+	if (intp)
+		FAIL("prop-int still present after deletion");
+	if (lenerr != -FDT_ERR_NOTFOUND)
+		FAIL("Unexpected error on second getprop: %s",
+		     fdt_strerror(lenerr));
+
+	strp = check_getprop(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1,
+			     TEST_STRING_1);
+	verbose_printf("string value was \"%s\"\n", strp);
+	err = fdt_delprop(fdt, 0, "prop-str");
+	if (err)
+		FAIL("Failed to delete \"prop-str\": %s", fdt_strerror(err));
+
+	strp = fdt_getprop(fdt, 0, "prop-str", &lenerr);
+	if (strp)
+		FAIL("prop-str still present after deletion");
+	if (lenerr != -FDT_ERR_NOTFOUND)
+		FAIL("Unexpected error on second getprop: %s",
+		     fdt_strerror(lenerr));
+
+	delsize = fdt_totalsize(fdt);
+
+	err = fdt_pack(fdt);
+	if (err)
+		FAIL("fdt_pack(): %s\n", fdt_strerror(err));
+
+	newsize = fdt_totalsize(fdt);
+
+	verbose_printf("oldsize = %d, delsize = %d, newsize = %d\n",
+		       oldsize, delsize, newsize);
+
+	if (newsize >= oldsize)
+		FAIL("Tree failed to shrink after deletions");
+
+	PASS();
+}
diff --git a/dtc/tests/delete_reinstate_multilabel.dts b/dtc/tests/delete_reinstate_multilabel.dts
new file mode 100644
index 0000000..281a6b2
--- /dev/null
+++ b/dtc/tests/delete_reinstate_multilabel.dts
@@ -0,0 +1,37 @@
+/dts-v1/;
+
+/* Create some nodes and properties with multiple labels */
+
+/ {
+	label1: label2: prop = "value";
+
+	label3: label4: node {
+		label5: label6: prop = "value";
+	};
+};
+
+/* Delete them, and everything that's part of them, i.e. the labels */
+
+/ {
+	/delete-property/ prop;
+	/delete-node/ node;
+};
+
+/*
+ * Re-instate them. None of the old labels should come back
+ *
+ * Note: Do not add any new/extra labels here. As of the time of writing,
+ * when dtc adds labels to an object, they are added to the head of the list
+ * of labels, and this test is specifically about ensuring the correct
+ * handling of lists of labels where the first label in the list is marked as
+ * deleted. Failure to observe this note may result in the test passing when
+ * it should not.
+ */
+
+/ {
+	prop = "value";
+
+	node {
+		prop = "value";
+	};
+};
diff --git a/dtc/tests/delete_reinstate_multilabel_ref.dts b/dtc/tests/delete_reinstate_multilabel_ref.dts
new file mode 100644
index 0000000..28fa117
--- /dev/null
+++ b/dtc/tests/delete_reinstate_multilabel_ref.dts
@@ -0,0 +1,9 @@
+/dts-v1/;
+
+/ {
+	prop = "value";
+
+	node {
+		prop = "value";
+	};
+};
diff --git a/dtc/tests/dependencies.cmp b/dtc/tests/dependencies.cmp
new file mode 100644
index 0000000..bcd9432
--- /dev/null
+++ b/dtc/tests/dependencies.cmp
@@ -0,0 +1 @@
+dependencies.test.dtb: dependencies.dts deps_inc1.dtsi deps_inc2.dtsi
diff --git a/dtc/tests/dependencies.dts b/dtc/tests/dependencies.dts
new file mode 100644
index 0000000..2cfe31b
--- /dev/null
+++ b/dtc/tests/dependencies.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/include/ "deps_inc1.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/deps_inc1.dtsi b/dtc/tests/deps_inc1.dtsi
new file mode 100644
index 0000000..5c607dc
--- /dev/null
+++ b/dtc/tests/deps_inc1.dtsi
@@ -0,0 +1 @@
+/include/ "deps_inc2.dtsi"
diff --git a/dtc/tests/deps_inc2.dtsi b/dtc/tests/deps_inc2.dtsi
new file mode 100644
index 0000000..710cecc
--- /dev/null
+++ b/dtc/tests/deps_inc2.dtsi
@@ -0,0 +1 @@
+/* Empty */
diff --git a/dtc/tests/division-by-zero.dts b/dtc/tests/division-by-zero.dts
new file mode 100644
index 0000000..2984b29
--- /dev/null
+++ b/dtc/tests/division-by-zero.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	prop-div = < (1/0) >;
+	prop-mod = < (1%0) >;
+};
diff --git a/dtc/tests/dtb_reverse.c b/dtc/tests/dtb_reverse.c
new file mode 100644
index 0000000..95b6c1c
--- /dev/null
+++ b/dtc/tests/dtb_reverse.c
@@ -0,0 +1,150 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests if two given dtbs are structurally equal (including order)
+ * Copyright (C) 2010 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <limits.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+static void reverse_reservemap(void *in, void *out, int n)
+{
+	int err;
+	uint64_t addr, size;
+
+	verbose_printf("reverse_reservemap(): %d/%d\n",
+		       n, fdt_num_mem_rsv(in));
+
+	if (n < (fdt_num_mem_rsv(in)-1))
+		reverse_reservemap(in, out, n+1);
+
+	CHECK(fdt_get_mem_rsv(in, n, &addr, &size));
+	CHECK(fdt_add_reservemap_entry(out, addr, size));
+	verbose_printf("Added entry 0x%llx 0x%llx\n",
+		       (unsigned long long)addr, (unsigned long long)size);
+}
+
+static void reverse_properties(void *in, void *out, int offset)
+{
+	int err;
+	int len;
+	const char *name;
+	const void *data;
+
+	data = fdt_getprop_by_offset(in, offset, &name, &len);
+	if (!data)
+		FAIL("fdt_getprop_by_offset(): %s\n", fdt_strerror(len));
+
+	verbose_printf("reverse_properties(): offset=%d  name=%s\n",
+		       offset, name);
+
+	offset = fdt_next_property_offset(in, offset);
+	if (offset >= 0)
+		reverse_properties(in, out, offset);
+	else if (offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_next_property_offset(): %s\n", fdt_strerror(offset));
+
+	CHECK(fdt_property(out, name, data, len));
+	verbose_printf("  -> output property %s\n", name);
+}
+
+static void reverse_node(void *in, void *out, int nodeoffset);
+
+static void reverse_children(void *in, void *out, int offset)
+{
+	int err;
+	int nextoffset = offset;
+	int depth = 1;
+
+	do {
+		char path[PATH_MAX];
+
+		CHECK(fdt_get_path(in, nextoffset, path, sizeof(path)));
+		verbose_printf("reverse_children() offset=%d nextoffset=%d [%s]"
+			       " depth=%d\n", offset, nextoffset, path, depth);
+
+		nextoffset = fdt_next_node(in, nextoffset, &depth);
+	} while ((depth >= 0) && (depth != 1));
+
+	if (depth == 1)
+		reverse_children(in, out, nextoffset);
+
+	reverse_node(in, out, offset);
+}
+
+static void reverse_node(void *in, void *out, int nodeoffset)
+{
+	const char *name = fdt_get_name(in, nodeoffset, NULL);
+	char path[PATH_MAX];
+	int err;
+	int offset;
+	int depth = 0;
+
+	CHECK(fdt_get_path(in, nodeoffset, path, sizeof(path)));
+	verbose_printf("reverse_node(): nodeoffset=%d [%s]\n",
+		       nodeoffset, path);
+
+	CHECK(fdt_begin_node(out, name));
+
+	offset = fdt_first_property_offset(in, nodeoffset);
+	if (offset >= 0)
+		reverse_properties(in, out, offset);
+	else if (offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_first_property(): %s\n", fdt_strerror(offset));
+
+	offset = fdt_next_node(in, nodeoffset, &depth);
+
+	if (depth == 1)
+		reverse_children(in, out, offset);
+
+	CHECK(fdt_end_node(out));
+}
+
+int main(int argc, char *argv[])
+{
+	void *in, *out;
+	char outname[PATH_MAX];
+	int bufsize;
+	int err;
+
+	test_init(argc, argv);
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>", argv[0]);
+
+	in = load_blob(argv[1]);
+	sprintf(outname, "%s.reversed.test.dtb", argv[1]);
+
+	bufsize = fdt_totalsize(in);
+	out = xmalloc(bufsize);
+
+	CHECK(fdt_create(out, bufsize));
+
+	fdt_set_boot_cpuid_phys(out, fdt_boot_cpuid_phys(in));
+
+	reverse_reservemap(in, out, 0);
+	CHECK(fdt_finish_reservemap(out));
+
+	reverse_node(in, out, 0);
+
+	CHECK(fdt_finish(out));
+
+	save_blob(outname, out);
+
+	PASS();
+}
diff --git a/dtc/tests/dtbs_equal_ordered.c b/dtc/tests/dtbs_equal_ordered.c
new file mode 100644
index 0000000..90c7344
--- /dev/null
+++ b/dtc/tests/dtbs_equal_ordered.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests if two given dtbs are structurally equal (including order)
+ * Copyright (C) 2007 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int notequal; /* = 0 */
+
+#define MISMATCH(fmt, ...)			\
+	do { \
+		if (notequal) \
+			PASS(); \
+		else \
+			FAIL(fmt, ##__VA_ARGS__);	\
+	} while (0)
+
+#define MATCH()			\
+	do { \
+		if (!notequal) \
+			PASS(); \
+		else \
+			FAIL("Trees match which shouldn't");	\
+	} while (0)
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+static void compare_mem_rsv(const void *fdt1, const void *fdt2)
+{
+	int i;
+	uint64_t addr1, size1, addr2, size2;
+	int err;
+
+	if (fdt_num_mem_rsv(fdt1) != fdt_num_mem_rsv(fdt2))
+		MISMATCH("Trees have different number of reserve entries");
+	for (i = 0; i < fdt_num_mem_rsv(fdt1); i++) {
+		CHECK(fdt_get_mem_rsv(fdt1, i, &addr1, &size1));
+		CHECK(fdt_get_mem_rsv(fdt2, i, &addr2, &size2));
+
+		if ((addr1 != addr2) || (size1 != size2))
+			MISMATCH("Mismatch in reserve entry %d: "
+				 "(0x%llx, 0x%llx) != (0x%llx, 0x%llx)", i,
+				 (unsigned long long)addr1,
+				 (unsigned long long)size1,
+				 (unsigned long long)addr2,
+				 (unsigned long long)size2);
+	}
+}
+
+static void compare_structure(const void *fdt1, const void *fdt2)
+{
+	int nextoffset1 = 0, nextoffset2 = 0;
+	int offset1, offset2;
+	uint32_t tag1, tag2;
+	const char *name1, *name2;
+	int err;
+	const struct fdt_property *prop1, *prop2;
+	int len1, len2;
+
+	while (1) {
+		do {
+			offset1 = nextoffset1;
+			tag1 = fdt_next_tag(fdt1, offset1, &nextoffset1);
+		} while (tag1 == FDT_NOP);
+		do {
+			offset2 = nextoffset2;
+			tag2 = fdt_next_tag(fdt2, offset2, &nextoffset2);
+		} while (tag2 == FDT_NOP);
+
+		if (tag1 != tag2)
+			MISMATCH("Tag mismatch (%d != %d) at (%d, %d)",
+			     tag1, tag2, offset1, offset2);
+
+		switch (tag1) {
+		case FDT_BEGIN_NODE:
+			name1 = fdt_get_name(fdt1, offset1, &err);
+			if (!name1)
+				FAIL("fdt_get_name(fdt1, %d, ..): %s",
+				     offset1, fdt_strerror(err));
+			name2 = fdt_get_name(fdt2, offset2, NULL);
+			if (!name2)
+				FAIL("fdt_get_name(fdt2, %d, ..): %s",
+				     offset2, fdt_strerror(err));
+
+			if (!streq(name1, name2))
+			    MISMATCH("Name mismatch (\"%s\" != \"%s\") at (%d, %d)",
+				     name1, name2, offset1, offset2);
+			break;
+
+		case FDT_PROP:
+			prop1 = fdt_offset_ptr(fdt1, offset1, sizeof(*prop1));
+			if (!prop1)
+				FAIL("Could get fdt1 property at %d", offset1);
+			prop2 = fdt_offset_ptr(fdt2, offset2, sizeof(*prop2));
+			if (!prop2)
+				FAIL("Could get fdt2 property at %d", offset2);
+
+			name1 = fdt_string(fdt1, fdt32_to_cpu(prop1->nameoff));
+			name2 = fdt_string(fdt2, fdt32_to_cpu(prop2->nameoff));
+			if (!streq(name1, name2))
+				MISMATCH("Property name mismatch \"%s\" != \"%s\" "
+					 "at (%d, %d)", name1, name2, offset1, offset2);
+			len1 = fdt32_to_cpu(prop1->len);
+			len2 = fdt32_to_cpu(prop2->len);
+			if (len1 != len2)
+				MISMATCH("Property length mismatch %u != %u "
+					 "at (%d, %d)", len1, len2, offset1, offset2);
+
+			if (memcmp(prop1->data, prop2->data, len1) != 0)
+				MISMATCH("Property value mismatch at (%d, %d)",
+					 offset1, offset2);
+			break;
+
+		case FDT_END:
+			return;
+		}
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt1, *fdt2;
+	uint32_t cpuid1, cpuid2;
+
+	test_init(argc, argv);
+	if ((argc != 3)
+	    && ((argc != 4) || !streq(argv[1], "-n")))
+		CONFIG("Usage: %s [-n] <dtb file> <dtb file>", argv[0]);
+	if (argc == 4)
+		notequal = 1;
+
+	fdt1 = load_blob(argv[argc-2]);
+	fdt2 = load_blob(argv[argc-1]);
+
+	compare_mem_rsv(fdt1, fdt2);
+	compare_structure(fdt1, fdt2);
+
+	cpuid1 = fdt_boot_cpuid_phys(fdt1);
+	cpuid2 = fdt_boot_cpuid_phys(fdt2);
+	if (cpuid1 != cpuid2)
+		MISMATCH("boot_cpuid_phys mismatch 0x%x != 0x%x",
+			 cpuid1, cpuid2);
+
+	MATCH();
+}
diff --git a/dtc/tests/dtbs_equal_unordered.c b/dtc/tests/dtbs_equal_unordered.c
new file mode 100644
index 0000000..e5ff9e8
--- /dev/null
+++ b/dtc/tests/dtbs_equal_unordered.c
@@ -0,0 +1,230 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests if two given dtbs are structurally equal (including order)
+ * Copyright (C) 2007 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <limits.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int notequal; /* = 0 */
+static int ignore_memrsv; /* = 0 */
+
+#define MISMATCH(fmt, ...)			\
+	do { \
+		if (notequal) \
+			PASS(); \
+		else \
+			FAIL(fmt, ##__VA_ARGS__);	\
+	} while (0)
+
+#define MATCH()			\
+	do { \
+		if (!notequal) \
+			PASS(); \
+		else \
+			FAIL("Trees match which shouldn't");	\
+	} while (0)
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+static int mem_rsv_cmp(const void *p1, const void *p2)
+{
+	const struct fdt_reserve_entry *re1 = p1;
+	const struct fdt_reserve_entry *re2 = p2;
+
+	if (fdt64_to_cpu(re1->address) < fdt64_to_cpu(re2->address))
+		return -1;
+	else if (fdt64_to_cpu(re1->address) > fdt64_to_cpu(re2->address))
+		return 1;
+
+	if (fdt64_to_cpu(re1->size) < fdt64_to_cpu(re2->size))
+		return -1;
+	else if (fdt64_to_cpu(re1->size) > fdt64_to_cpu(re2->size))
+		return 1;
+
+	return 0;
+}
+
+static void compare_mem_rsv(void *fdt1, void *fdt2)
+{
+	int i;
+	uint64_t addr1, size1, addr2, size2;
+	int err;
+
+	if (fdt_num_mem_rsv(fdt1) != fdt_num_mem_rsv(fdt2))
+		MISMATCH("Trees have different number of reserve entries");
+
+	qsort((char *)fdt1 + fdt_off_mem_rsvmap(fdt1), fdt_num_mem_rsv(fdt1),
+	      sizeof(struct fdt_reserve_entry), mem_rsv_cmp);
+	qsort((char *)fdt2 + fdt_off_mem_rsvmap(fdt2), fdt_num_mem_rsv(fdt2),
+	      sizeof(struct fdt_reserve_entry), mem_rsv_cmp);
+
+	for (i = 0; i < fdt_num_mem_rsv(fdt1); i++) {
+		CHECK(fdt_get_mem_rsv(fdt1, i, &addr1, &size1));
+		CHECK(fdt_get_mem_rsv(fdt2, i, &addr2, &size2));
+
+		if ((addr1 != addr2) || (size1 != size2))
+			MISMATCH("Mismatch in reserve entry %d: "
+			     "(0x%llx, 0x%llx) != (0x%llx, 0x%llx)", i,
+			     (unsigned long long)addr1,
+			     (unsigned long long)size1,
+			     (unsigned long long)addr2,
+			     (unsigned long long)size2);
+	}
+}
+
+static void compare_properties(const void *fdt1, int offset1,
+			       const void *fdt2, int offset2)
+{
+	int offset = offset1;
+
+	/* Check the properties */
+	for (offset = fdt_first_property_offset(fdt1, offset1);
+	     offset >= 0;
+	     offset = fdt_next_property_offset(fdt1, offset)) {
+		const char *name;
+		int len1, len2;
+		const void *data1, *data2;
+		int i;
+
+		data1 = fdt_getprop_by_offset(fdt1, offset, &name, &len1);
+		if (!data1)
+			FAIL("fdt_getprop_by_offset(): %s\n",
+			     fdt_strerror(len1));
+
+		verbose_printf("Property '%s'\n", name);
+
+		data2 = fdt_getprop(fdt2, offset2, name, &len2);
+		if (!data2) {
+			if (len2 == -FDT_ERR_NOTFOUND)
+				MISMATCH("Property '%s' missing\n", name);
+			else
+				FAIL("fdt_get_property(): %s\n",
+				     fdt_strerror(len2));
+		}
+
+		verbose_printf("len1=%d data1=", len1);
+		for (i = 0; i < len1; i++)
+			verbose_printf(" %02x", ((const char *)data1)[i]);
+		verbose_printf("\nlen2=%d data2=", len2);
+		for (i = 0; i < len1; i++)
+			verbose_printf(" %02x", ((const char *)data2)[i]);
+		verbose_printf("\n");
+
+		if (len1 != len2)
+			MISMATCH("Property '%s' mismatched length %d vs. %d\n",
+			     name, len1, len2);
+		else if (memcmp(data1, data2, len1) != 0)
+			MISMATCH("Property '%s' mismatched value\n", name);
+	}
+}
+
+static void compare_node(const void *fdt1, int offset1,
+			 const void *fdt2, int offset2);
+
+static void compare_subnodes(const void *fdt1, int offset1,
+			     const void *fdt2, int offset2,
+			     int recurse)
+{
+	int coffset1, coffset2, depth;
+
+	for (depth = 0, coffset1 = offset1;
+	     (coffset1 >= 0) && (depth >= 0);
+	      coffset1 = fdt_next_node(fdt1, coffset1, &depth))
+		if (depth == 1) {
+			const char *name = fdt_get_name(fdt1, coffset1, NULL);
+
+			verbose_printf("Subnode %s\n", name);
+			coffset2 = fdt_subnode_offset(fdt2, offset2, name);
+			if (coffset2 == -FDT_ERR_NOTFOUND)
+				MISMATCH("Subnode %s missing\n", name);
+			else if (coffset2 < 0)
+				FAIL("fdt_subnode_offset(): %s\n",
+				     fdt_strerror(coffset2));
+
+			if (recurse)
+				compare_node(fdt1, coffset1, fdt2, coffset2);
+		}
+}
+
+static void compare_node(const void *fdt1, int offset1,
+			 const void *fdt2, int offset2)
+{
+	int err;
+	char path1[PATH_MAX], path2[PATH_MAX];
+
+	CHECK(fdt_get_path(fdt1, offset1, path1, sizeof(path1)));
+	CHECK(fdt_get_path(fdt2, offset2, path2, sizeof(path2)));
+
+	if (!streq(path1, path2))
+		TEST_BUG("Path mismatch %s vs. %s\n", path1, path2);
+
+	verbose_printf("Checking %s\n", path1);
+
+	compare_properties(fdt1, offset1, fdt2, offset2);
+	compare_properties(fdt2, offset2, fdt1, offset1);
+
+	compare_subnodes(fdt1, offset1, fdt2, offset2, 1);
+	compare_subnodes(fdt2, offset2, fdt1, offset1, 0);
+}
+
+static void badargs(char **argv)
+{
+	CONFIG("Usage: %s [-n] [-m] <dtb file> <dtb file>", argv[0]);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt1, *fdt2;
+	uint32_t cpuid1, cpuid2;
+	char **args;
+	int argsleft;
+
+	test_init(argc, argv);
+
+	args = &argv[1];
+	argsleft = argc - 1;
+
+	while (argsleft > 2) {
+		if (streq(args[0], "-n"))
+			notequal = 1;
+		else if (streq(args[0], "-m"))
+			ignore_memrsv = 1;
+		else
+			badargs(argv);
+		args++;
+		argsleft--;
+	}
+	if (argsleft != 2)
+		badargs(argv);
+
+	fdt1 = load_blob(args[0]);
+	fdt2 = load_blob(args[1]);
+
+	if (!ignore_memrsv)
+		compare_mem_rsv(fdt1, fdt2);
+	compare_node(fdt1, 0, fdt2, 0);
+
+	cpuid1 = fdt_boot_cpuid_phys(fdt1);
+	cpuid2 = fdt_boot_cpuid_phys(fdt2);
+	if (cpuid1 != cpuid2)
+		MISMATCH("boot_cpuid_phys mismatch 0x%x != 0x%x",
+		     cpuid1, cpuid2);
+
+	MATCH();
+}
diff --git a/dtc/tests/dtc-checkfails.sh b/dtc/tests/dtc-checkfails.sh
new file mode 100755
index 0000000..4fd9691
--- /dev/null
+++ b/dtc/tests/dtc-checkfails.sh
@@ -0,0 +1,45 @@
+#! /bin/sh
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+for x; do
+    shift
+    if [ "$x" = "-n" ]; then
+	for x; do
+	    shift
+	    if [ "$x" = "--" ]; then
+		break;
+	    fi
+	    NOCHECKS="$NOCHECKS $x"
+	done
+	break;
+    fi
+    if [ "$x" = "--" ]; then
+	break;
+    fi
+    YESCHECKS="$YESCHECKS $x"
+done
+
+LOG=tmp.log.$$
+rm -f $LOG
+trap "rm -f $LOG" 0
+
+verbose_run_log "$LOG" $VALGRIND "$DTC" -o /dev/null "$@"
+ret="$?"
+
+FAIL_IF_SIGNAL $ret
+
+for c in $YESCHECKS; do
+    if ! grep -E "(ERROR|Warning) \($c\):" $LOG > /dev/null; then
+	FAIL "Failed to trigger check \"$c\""
+    fi
+done
+
+for c in $NOCHECKS; do
+    if grep -E "(ERROR|Warning) \($c\):" $LOG > /dev/null; then
+	FAIL "Incorrectly triggered check \"$c\""
+    fi
+done
+
+PASS
diff --git a/dtc/tests/dtc-fails.sh b/dtc/tests/dtc-fails.sh
new file mode 100755
index 0000000..855b623
--- /dev/null
+++ b/dtc/tests/dtc-fails.sh
@@ -0,0 +1,31 @@
+#! /bin/sh
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+if [ "$1" = "-n" ]; then
+    NEG="$1"
+    shift
+fi
+
+OUTPUT="$1"
+shift
+
+verbose_run $VALGRIND "$DTC" -o "$OUTPUT" "$@"
+ret="$?"
+
+FAIL_IF_SIGNAL $ret
+
+if [ -n "$NEG" ]; then
+    if [ ! -e "$OUTPUT" ]; then
+	FAIL "Produced no output"
+    fi
+else
+    if [ -e "$OUTPUT" ]; then
+	FAIL "Incorrectly produced output"
+    fi
+fi
+
+rm -f "$OUTPUT"
+
+PASS
diff --git a/dtc/tests/dtc-fatal.sh b/dtc/tests/dtc-fatal.sh
new file mode 100755
index 0000000..08a4d29
--- /dev/null
+++ b/dtc/tests/dtc-fatal.sh
@@ -0,0 +1,15 @@
+#! /bin/sh
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+verbose_run $VALGRIND "$DTC" -o/dev/null "$@"
+ret="$?"
+
+if [ "$ret" -gt 127 ]; then
+    FAIL "dtc killed by signal (ret=$ret)"
+elif [ "$ret" != "1" ]; then
+    FAIL "dtc returned incorrect status $ret instead of 1"
+fi
+
+PASS
diff --git a/dtc/tests/dumptrees.c b/dtc/tests/dumptrees.c
new file mode 100644
index 0000000..f1e0ea9
--- /dev/null
+++ b/dtc/tests/dumptrees.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * dumptrees - utility for libfdt testing
+ *
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2006.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "testdata.h"
+
+static struct {
+	void *blob;
+	const char *filename;
+} trees[] = {
+#define TREE(name)	{ &name, #name ".dtb" }
+	TREE(test_tree1),
+	TREE(bad_node_char), TREE(bad_node_format), TREE(bad_prop_char),
+	TREE(ovf_size_strings),
+	TREE(truncated_property), TREE(truncated_string),
+	TREE(truncated_memrsv),
+	TREE(two_roots),
+	TREE(named_root)
+};
+
+#define NUM_TREES	(sizeof(trees) / sizeof(trees[0]))
+
+int main(int argc, char *argv[])
+{
+	int i;
+
+	if (argc != 2) {
+	    fprintf(stderr, "Missing output directory argument\n");
+	    return 1;
+	}
+
+	if (chdir(argv[1]) != 0) {
+	    perror("chdir()");
+	    return 1;
+	}
+
+	for (i = 0; i < NUM_TREES; i++) {
+		void *blob = trees[i].blob;
+		const char *filename = trees[i].filename;
+		int size;
+		int fd;
+		int ret;
+
+		size = fdt_totalsize(blob);
+
+		printf("Tree \"%s\", %d bytes\n", filename, size);
+
+		fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+		if (fd < 0)
+			perror("open()");
+
+		ret = write(fd, blob, size);
+		if (ret != size)
+			perror("write()");
+
+		close(fd);
+	}
+	exit(0);
+}
diff --git a/dtc/tests/dup-nodename.dts b/dtc/tests/dup-nodename.dts
new file mode 100644
index 0000000..2a3aa75
--- /dev/null
+++ b/dtc/tests/dup-nodename.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/ {
+	node {
+	};
+	node {
+	};
+};
diff --git a/dtc/tests/dup-phandle.dts b/dtc/tests/dup-phandle.dts
new file mode 100644
index 0000000..c266c61
--- /dev/null
+++ b/dtc/tests/dup-phandle.dts
@@ -0,0 +1,10 @@
+/dts-v1/;
+
+/ {
+	node1 {
+		linux,phandle = <1>;
+	};
+	node2 {
+		linux,phandle = <1>;
+	};
+};
diff --git a/dtc/tests/dup-propname.dts b/dtc/tests/dup-propname.dts
new file mode 100644
index 0000000..8145f6e
--- /dev/null
+++ b/dtc/tests/dup-propname.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	prop;
+	prop;
+};
diff --git a/dtc/tests/embedded_nul.dts b/dtc/tests/embedded_nul.dts
new file mode 100644
index 0000000000000000000000000000000000000000..7b4993cc5452ba57f78cedf01715deaba55d8613
GIT binary patch
literal 152
zcmdN-DJj-1Gt{@{;?h^B=He_$Elw>eOHI+uOUz9zR<Ko2O2hyRNnpT`j0}{lku(=2
W=B0ym+b9@R7?6Y&?5w$Jt+@ajWGrd`

literal 0
HcmV?d00001

diff --git a/dtc/tests/embedded_nul_equiv.dts b/dtc/tests/embedded_nul_equiv.dts
new file mode 100644
index 0000000..e978204
--- /dev/null
+++ b/dtc/tests/embedded_nul_equiv.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	reserved-names = "aaaaaaaaaaaaaaaaaa\0bbbbbb\0ccccccccccccc";
+	reserved-ranges = < 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0  >;
+};
diff --git a/dtc/tests/empty.dts b/dtc/tests/empty.dts
new file mode 100644
index 0000000..e160dad
--- /dev/null
+++ b/dtc/tests/empty.dts
@@ -0,0 +1,4 @@
+/dts-v1/;
+
+/ {
+};
diff --git a/dtc/tests/escapes.dts b/dtc/tests/escapes.dts
new file mode 100644
index 0000000..e05ab46
--- /dev/null
+++ b/dtc/tests/escapes.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	compatible = "test_string_escapes";
+	escape-str = "nastystring: \a\b\t\n\v\f\r\\\"";
+	escape-str-2 = "\xde\xad\xbe\xef";
+};
diff --git a/dtc/tests/extra-terminating-null.c b/dtc/tests/extra-terminating-null.c
new file mode 100644
index 0000000..0fa2ca8
--- /dev/null
+++ b/dtc/tests/extra-terminating-null.c
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for properties with more than one terminating null
+ * Copyright (C) 2009 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_extranull(void *fdt, const char *prop, const char *str, int numnulls)
+{
+	int len = strlen(str);
+	char checkbuf[len+numnulls];
+
+	memset(checkbuf, 0, sizeof(checkbuf));
+	memcpy(checkbuf, TEST_STRING_1, len);
+
+	check_getprop(fdt, 0, prop, len+numnulls, checkbuf);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+
+	fdt = load_blob_arg(argc, argv);
+
+	check_extranull(fdt, "extranull0", TEST_STRING_1, 1);
+	check_extranull(fdt, "extranull1,1", TEST_STRING_1, 2);
+	check_extranull(fdt, "extranull1,2", TEST_STRING_1, 2);
+	check_extranull(fdt, "extranull2,1", TEST_STRING_1, 3);
+	check_extranull(fdt, "extranull2,2", TEST_STRING_1, 3);
+	check_extranull(fdt, "extranull2,3", TEST_STRING_1, 3);
+	check_extranull(fdt, "extranull2,4", TEST_STRING_1, 3);
+
+	PASS();
+}
diff --git a/dtc/tests/extra-terminating-null.dts b/dtc/tests/extra-terminating-null.dts
new file mode 100644
index 0000000..b6cc19c
--- /dev/null
+++ b/dtc/tests/extra-terminating-null.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+
+/ {
+	extranull0 = "hello world";
+	extranull1,1 = "hello world\0";
+	extranull1,2 = "hello world", "";
+	extranull2,1 = "hello world\0\0";
+	extranull2,2 = "hello world", "", "";
+	extranull2,3 = "hello world\0", "";
+	extranull2,4 = "hello world", "\0";
+};
diff --git a/dtc/tests/fdtdump-runtest.sh b/dtc/tests/fdtdump-runtest.sh
new file mode 100755
index 0000000..71ac861
--- /dev/null
+++ b/dtc/tests/fdtdump-runtest.sh
@@ -0,0 +1,31 @@
+#! /bin/sh
+
+# Arguments:
+#   $1 - source file to compile and compare with fdtdump output of the
+#	  compiled file.
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+dts="$1"
+dtb="${dts}.dtb"
+out="${dts}.out"
+LOG=tmp.log.$$
+
+files="$dtb $out $LOG"
+
+rm -f $files
+trap "rm -f $files" 0
+
+verbose_run_log_check "$LOG" $VALGRIND $DTC -O dtb $dts -o $dtb
+$FDTDUMP ${dtb} | grep -v "//" >${out}
+
+if diff -w $dts $out >/dev/null; then
+    PASS
+else
+    if [ -z "$QUIET_TEST" ]; then
+	echo "DIFF :-:"
+	diff -u -w $dts $out
+    fi
+    FAIL "Results differ from expected"
+fi
diff --git a/dtc/tests/fdtdump.dts b/dtc/tests/fdtdump.dts
new file mode 100644
index 0000000..b83b7df
--- /dev/null
+++ b/dtc/tests/fdtdump.dts
@@ -0,0 +1,38 @@
+/dts-v1/;
+
+/memreserve/ 0 0xe;
+/ {
+	model = "MyBoardName";
+	compatible = "MyBoardName", "MyBoardFamilyName";
+	#address-cells = <0x00000002>;
+	#size-cells = <0x00000002>;
+	cpus {
+		linux,phandle = <0x00000001>;
+		#address-cells = <0x00000001>;
+		#size-cells = <0x00000000>;
+		PowerPC,970@0 {
+			device_type = "cpu";
+			reg = <0x00000000>;
+			linux,boot-cpu;
+			};
+		PowerPC,970@1 {
+			device_type = "cpu";
+			reg = <0x00000001>;
+		};
+	};
+	randomnode {
+		string =  "foo", "stuff";
+		bytes = [61 62 63 64 65];
+		nbytes = [80 ff];
+		child {
+		};
+	};
+	memory@0 {
+		device_type = "memory";
+		reg = <0x00000000 0x00000123 0x00000456 0x87654321>;
+	};
+	chosen {
+		bootargs = "root=/dev/sda2";
+		linux,platform = <0x00000600>;
+	};
+};
diff --git a/dtc/tests/fdtget-runtest.sh b/dtc/tests/fdtget-runtest.sh
new file mode 100755
index 0000000..18b7404
--- /dev/null
+++ b/dtc/tests/fdtget-runtest.sh
@@ -0,0 +1,25 @@
+#! /bin/sh
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+LOG=tmp.log.$$
+EXPECT=tmp.expect.$$
+rm -f $LOG $EXPECT
+trap "rm -f $LOG $EXPECT" 0
+
+expect="$1"
+printf '%b\n' "$expect" > $EXPECT
+shift
+
+verbose_run_log_check "$LOG" $VALGRIND $DTGET "$@"
+
+if cmp $EXPECT $LOG>/dev/null; then
+    PASS
+else
+    if [ -z "$QUIET_TEST" ]; then
+	echo "EXPECTED :-:"
+	cat $EXPECT
+    fi
+    FAIL "Results differ from expected"
+fi
diff --git a/dtc/tests/fdtoverlay-runtest.sh b/dtc/tests/fdtoverlay-runtest.sh
new file mode 100755
index 0000000..0c648f4
--- /dev/null
+++ b/dtc/tests/fdtoverlay-runtest.sh
@@ -0,0 +1,41 @@
+#! /bin/sh
+
+# Run script for fdtoverlay tests
+# We run fdtoverlay to generate a target device tree, then fdtget to check it
+
+# Usage
+#    fdtoverlay-runtest.sh name expected_output dtb_file node property flags value
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+LOG=tmp.log.$$
+EXPECT=tmp.expect.$$
+rm -f $LOG $EXPECT
+trap "rm -f $LOG $EXPECT" 0
+
+expect="$1"
+echo $expect >$EXPECT
+node="$2"
+property="$3"
+flags="$4"
+basedtb="$5"
+targetdtb="$6"
+shift 6
+overlays="$@"
+
+# First run fdtoverlay
+verbose_run_check $VALGRIND "$FDTOVERLAY" -i "$basedtb" -o "$targetdtb" $overlays
+
+# Now fdtget to read the value
+verbose_run_log_check "$LOG" $VALGRIND "$DTGET" "$targetdtb" "$node" "$property" $flags
+
+if cmp $EXPECT $LOG >/dev/null; then
+    PASS
+else
+    if [ -z "$QUIET_TEST" ]; then
+	echo "EXPECTED :-:"
+	cat $EXPECT
+    fi
+    FAIL "Results differ from expected"
+fi
diff --git a/dtc/tests/fdtput-runtest.sh b/dtc/tests/fdtput-runtest.sh
new file mode 100755
index 0000000..1210eab
--- /dev/null
+++ b/dtc/tests/fdtput-runtest.sh
@@ -0,0 +1,40 @@
+#! /bin/sh
+
+# Run script for fdtput tests
+# We run fdtput to update the device tree, then fdtget to check it
+
+# Usage
+#    fdtput-runtest.sh name expected_output dtb_file node property flags value
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+LOG=tmp.log.$$
+EXPECT=tmp.expect.$$
+rm -f $LOG $EXPECT
+trap "rm -f $LOG $EXPECT" 0
+
+expect="$1"
+echo $expect >$EXPECT
+dtb="$2"
+node="$3"
+property="$4"
+flags="$5"
+shift 5
+value="$@"
+
+# First run fdtput
+verbose_run_check $VALGRIND "$DTPUT" "$dtb" "$node" "$property" $value $flags
+
+# Now fdtget to read the value
+verbose_run_log_check "$LOG" $VALGRIND "$DTGET" "$dtb" "$node" "$property" $flags
+
+if cmp $EXPECT $LOG >/dev/null; then
+    PASS
+else
+    if [ -z "$QUIET_TEST" ]; then
+	echo "EXPECTED :-:"
+	cat $EXPECT
+    fi
+    FAIL "Results differ from expected"
+fi
diff --git a/dtc/tests/find_property.c b/dtc/tests/find_property.c
new file mode 100644
index 0000000..0404ea0
--- /dev/null
+++ b/dtc/tests/find_property.c
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_property_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_property_cell(fdt, 0, "prop-int", TEST_VALUE_1);
+	check_property(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1, TEST_STRING_1);
+
+	PASS();
+}
diff --git a/dtc/tests/fs_tree1.c b/dtc/tests/fs_tree1.c
new file mode 100644
index 0000000..dff3880
--- /dev/null
+++ b/dtc/tests/fs_tree1.c
@@ -0,0 +1,155 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase/tool constructing an fs tree for further test
+ * Copyright (C) 2018 David Gibson, Red Hat Inc.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void start_dir(const char *name)
+{
+	int rc;
+
+	rc = mkdir(name, 0777);
+	if (rc != 0)
+		FAIL("mkdir(\"%s\"): %s", name, strerror(errno));
+
+	rc = chdir(name);
+	if (rc != 0)
+		FAIL("chdir(\"%s\"): %s", name, strerror(errno));
+}
+
+static void end_dir(void)
+{
+	int rc;
+
+	rc = chdir("..");
+	if (rc != 0)
+		FAIL("chdir(..): %s", strerror(errno));
+}
+	
+static void mkfile(const char *name, void *data, size_t len)
+{
+	int fd;
+	int rc;
+
+	fd = open(name, O_WRONLY|O_CREAT, 0666);
+	if (fd < 0)
+		FAIL("open(\"%s\"): %s", name, strerror(errno));
+
+	rc = write(fd, data, len);
+	if (rc < 0)
+		FAIL("write(\"%s\"): %s", name, strerror(errno));
+	if (rc != len)
+		FAIL("write(\"%s\"): short write", name);
+	
+	rc = close(fd);
+	if (rc != 0)
+		FAIL("close(\"%s\"): %s", name, strerror(errno));
+}
+
+#define mkfile_str(name, s)			  \
+	do {					  \
+		char str[] = s;			  \
+		mkfile((name), str, sizeof(str)); \
+	} while (0)
+
+static void mkfile_u32(const char *name, uint32_t val)
+{
+	val = cpu_to_fdt32(val);
+	mkfile(name, &val, sizeof(val));
+}
+
+static void mkfile_u64(const char *name, uint64_t val)
+{
+	val = cpu_to_fdt64(val);
+	mkfile(name, &val, sizeof(val));
+}
+
+int main(int argc, char *argv[])
+{
+	const char *base;
+
+	test_init(argc, argv);
+	if (argc != 2)
+		CONFIG("Usage: %s <path>", argv[0]);
+
+	base = argv[1];
+
+	start_dir(base);
+	mkfile_str("compatible", "test_tree1");
+	mkfile_u32("prop-int", TEST_VALUE_1);
+	mkfile_u64("prop-int64", 0xdeadbeef01abcdefULL);
+	mkfile_str("prop-str", "hello world");
+	mkfile_u32("#address-cells", 1);
+	mkfile_u32("#size-cells", 0);
+
+	{
+		start_dir("subnode@1");
+
+		mkfile_str("compatible", "subnode1");
+		mkfile_u32("reg", 1);
+		mkfile_u32("prop-int", TEST_VALUE_1);
+
+		{
+			start_dir("subsubnode");
+
+			mkfile_str("compatible", "subsubnode1\0subsubnode");
+			mkfile_str("placeholder", "this is a placeholder string\0string2");
+			mkfile_u32("prop-int", TEST_VALUE_1);
+			
+			end_dir();
+		}
+
+		{
+			start_dir("ss1");
+			end_dir();
+		}
+		
+		end_dir();
+	}
+
+	{
+		start_dir("subnode@2");
+
+		mkfile_u32("reg", 2);
+		mkfile_u32("linux,phandle", 0x2000);
+		mkfile_u32("prop-int", TEST_VALUE_2);
+		mkfile_u32("#address-cells", 1);
+		mkfile_u32("#size-cells", 0);
+
+		{
+			start_dir("subsubnode@0");
+
+			mkfile_u32("reg", 0);
+			mkfile_u32("phandle", 0x2001);
+			mkfile_str("compatible", "subsubnode2\0subsubnode");
+			mkfile_u32("prop-int", TEST_VALUE_2);
+			
+			end_dir();
+		}
+
+		{
+			start_dir("ss2");
+			end_dir();
+		}
+		
+		end_dir();
+	}
+
+	PASS();
+}
diff --git a/dtc/tests/get_alias.c b/dtc/tests/get_alias.c
new file mode 100644
index 0000000..fb2c38c
--- /dev/null
+++ b/dtc/tests/get_alias.c
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_get_alias()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_alias(void *fdt, const char *path, const char *alias)
+{
+	const char *aliaspath;
+
+	aliaspath = fdt_get_alias(fdt, alias);
+
+	if (path && !aliaspath)
+		FAIL("fdt_get_alias(%s) failed\n", alias);
+
+	if (strcmp(aliaspath, path) != 0)
+		FAIL("fdt_get_alias(%s) returned %s instead of %s\n",
+		     alias, aliaspath, path);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_alias(fdt, "/subnode@1", "s1");
+	check_alias(fdt, "/subnode@1/subsubnode", "ss1");
+	check_alias(fdt, "/subnode@1/subsubnode/subsubsubnode", "sss1");
+
+	PASS();
+}
diff --git a/dtc/tests/get_mem_rsv.c b/dtc/tests/get_mem_rsv.c
new file mode 100644
index 0000000..f977d19
--- /dev/null
+++ b/dtc/tests/get_mem_rsv.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_get_mem_rsv() and fdt_num_mem_rsv()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int rc;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	rc = fdt_num_mem_rsv(fdt);
+	if (rc < 0)
+		FAIL("fdt_num_mem_rsv(): %s", fdt_strerror(rc));
+	if (rc != 2)
+		FAIL("fdt_num_mem_rsv() returned %d instead of 2", rc);
+
+	check_mem_rsv(fdt, 0, TEST_ADDR_1, TEST_SIZE_1);
+	check_mem_rsv(fdt, 1, TEST_ADDR_2, TEST_SIZE_2);
+	PASS();
+}
diff --git a/dtc/tests/get_name.c b/dtc/tests/get_name.c
new file mode 100644
index 0000000..5a35103
--- /dev/null
+++ b/dtc/tests/get_name.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_get_name()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_name(void *fdt, const char *path)
+{
+	int offset;
+	const char *getname, *getname2, *checkname;
+	int len;
+
+	checkname = strrchr(path, '/');
+	if (!checkname)
+		TEST_BUG();
+	checkname += 1;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find %s", path);
+
+	getname = fdt_get_name(fdt, offset, &len);
+	verbose_printf("fdt_get_name(%d) returns \"%s\" (len=%d)\n",
+		       offset, getname, len);
+	if (!getname)
+		FAIL("fdt_get_name(%d): %s", offset, fdt_strerror(len));
+
+	if (strcmp(getname, checkname) != 0)
+		FAIL("fdt_get_name(%s) returned \"%s\" instead of \"%s\"",
+		     path, getname, checkname);
+
+	if (len != strlen(getname))
+		FAIL("fdt_get_name(%s) returned length %d instead of %zd",
+		     path, len, strlen(getname));
+
+	/* Now check that it doesn't break if we omit len */
+	getname2 = fdt_get_name(fdt, offset, NULL);
+	if (!getname2)
+		FAIL("fdt_get_name(%d, NULL) failed", offset);
+	if (strcmp(getname2, getname) != 0)
+		FAIL("fdt_get_name(%d, NULL) returned \"%s\" instead of \"%s\"",
+		     offset, getname2, getname);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_name(fdt, "/");
+	check_name(fdt, "/subnode@1");
+	check_name(fdt, "/subnode@2");
+	check_name(fdt, "/subnode@1/subsubnode");
+	check_name(fdt, "/subnode@2/subsubnode@0");
+
+	PASS();
+}
diff --git a/dtc/tests/get_path.c b/dtc/tests/get_path.c
new file mode 100644
index 0000000..7349898
--- /dev/null
+++ b/dtc/tests/get_path.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_get_path()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define POISON	('\xff')
+
+static void check_path_buf(void *fdt, const char *path, int pathlen, int buflen)
+{
+	int offset;
+	char buf[buflen+1];
+	int len;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find path \"%s\": %s", path, fdt_strerror(offset));
+
+	memset(buf, POISON, sizeof(buf)); /* poison the buffer */
+
+	len = fdt_get_path(fdt, offset, buf, buflen);
+	verbose_printf("get_path() %s -> %d -> %s\n", path, offset,
+		       len >= 0 ? buf : "<error>");
+
+	if (buflen <= pathlen) {
+		if (len != -FDT_ERR_NOSPACE)
+			FAIL("fdt_get_path([%d bytes]) returns %d with "
+			     "insufficient buffer space", buflen, len);
+	} else {
+		if (len < 0)
+			FAIL("fdt_get_path([%d bytes]): %s", buflen,
+			     fdt_strerror(len));
+		if (len != 0)
+			FAIL("fdt_get_path([%d bytes]) returns %d "
+			     "instead of 0", buflen, len);
+		if (strcmp(buf, path) != 0)
+			FAIL("fdt_get_path([%d bytes]) returns \"%s\" "
+			     "instead of \"%s\"", buflen, buf, path);
+	}
+
+	if (buf[buflen] != POISON)
+		FAIL("fdt_get_path([%d bytes]) overran buffer", buflen);
+}
+
+static void check_path(void *fdt, const char *path)
+{
+	int pathlen = strlen(path);
+
+	check_path_buf(fdt, path, pathlen, 1024);
+	check_path_buf(fdt, path, pathlen, pathlen+1);
+	check_path_buf(fdt, path, pathlen, pathlen);
+	check_path_buf(fdt, path, pathlen, 0);
+	check_path_buf(fdt, path, pathlen, 2);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_path(fdt, "/");
+	check_path(fdt, "/subnode@1");
+	check_path(fdt, "/subnode@2");
+	check_path(fdt, "/subnode@1/subsubnode");
+	check_path(fdt, "/subnode@2/subsubnode@0");
+
+	PASS();
+}
diff --git a/dtc/tests/get_phandle.c b/dtc/tests/get_phandle.c
new file mode 100644
index 0000000..157b522
--- /dev/null
+++ b/dtc/tests/get_phandle.c
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_get_phandle()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_phandle(void *fdt, const char *path, uint32_t checkhandle)
+{
+	int offset;
+	uint32_t phandle;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find %s", path);
+
+	phandle = fdt_get_phandle(fdt, offset);
+	if (phandle != checkhandle)
+		FAIL("fdt_get_phandle(%s) returned 0x%x instead of 0x%x\n",
+		     path, phandle, checkhandle);
+}
+
+static void check_phandle_unique(const void *fdt, uint32_t checkhandle)
+{
+	uint32_t phandle;
+	int offset = -1;
+
+	while (true) {
+		offset = fdt_next_node(fdt, offset, NULL);
+		if (offset < 0) {
+			if (offset == -FDT_ERR_NOTFOUND)
+				break;
+
+			FAIL("error looking for phandle %#x", checkhandle);
+		}
+
+		phandle = fdt_get_phandle(fdt, offset);
+
+		if (phandle == checkhandle)
+			FAIL("generated phandle already exists");
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	uint32_t max, phandle;
+	void *fdt;
+	int err;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_phandle(fdt, "/", 0);
+	check_phandle(fdt, "/subnode@2", PHANDLE_1);
+	check_phandle(fdt, "/subnode@2/subsubnode@0", PHANDLE_2);
+
+	err = fdt_find_max_phandle(fdt, &max);
+	if (err < 0)
+		FAIL("fdt_find_max_phandle returned %d instead of 0\n", err);
+
+	if (max != PHANDLE_2)
+		FAIL("fdt_find_max_phandle found 0x%x instead of 0x%x", max,
+		     PHANDLE_2);
+
+	max = fdt_get_max_phandle(fdt);
+	if (max != PHANDLE_2)
+		FAIL("fdt_get_max_phandle returned 0x%x instead of 0x%x\n",
+		     max, PHANDLE_2);
+
+	err = fdt_generate_phandle(fdt, &phandle);
+	if (err < 0)
+		FAIL("failed to generate phandle: %d", err);
+
+	check_phandle_unique(fdt, phandle);
+
+	PASS();
+}
diff --git a/dtc/tests/get_prop_offset.c b/dtc/tests/get_prop_offset.c
new file mode 100644
index 0000000..cff3c18
--- /dev/null
+++ b/dtc/tests/get_prop_offset.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_getprop_by_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	bool found_prop_int = false;
+	bool found_prop_str = false;
+	int poffset;
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	fdt_for_each_property_offset(poffset, fdt, 0) {
+		if (check_get_prop_offset_cell(fdt, poffset, "prop-int",
+					       TEST_VALUE_1))
+			found_prop_int = true;
+		if (check_get_prop_offset(fdt, poffset, "prop-str",
+					  strlen(TEST_STRING_1) + 1,
+					  TEST_STRING_1))
+			found_prop_str = true;
+	}
+	if (!found_prop_int)
+		FAIL("Property 'prop-int' not found");
+	if (!found_prop_str)
+		FAIL("Property 'prop-str' not found");
+
+	PASS();
+}
diff --git a/dtc/tests/getprop.c b/dtc/tests/getprop.c
new file mode 100644
index 0000000..cccc8e2
--- /dev/null
+++ b/dtc/tests/getprop.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_getprop()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_getprop_cell(fdt, 0, "prop-int", TEST_VALUE_1);
+	check_getprop(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1, TEST_STRING_1);
+
+	PASS();
+}
diff --git a/dtc/tests/good-gpio.dts b/dtc/tests/good-gpio.dts
new file mode 100644
index 0000000..65d1c17
--- /dev/null
+++ b/dtc/tests/good-gpio.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	gpio: gpio-controller {
+		#gpio-cells = <3>;
+	};
+
+	node {
+		foo,nr-gpios = <1>;
+		foo-gpios = <&gpio 1 2 3>;
+	};
+};
diff --git a/dtc/tests/incbin.bin b/dtc/tests/incbin.bin
new file mode 100644
index 0000000..e6e3e48
--- /dev/null
+++ b/dtc/tests/incbin.bin
@@ -0,0 +1 @@
+abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
\ No newline at end of file
diff --git a/dtc/tests/incbin.c b/dtc/tests/incbin.c
new file mode 100644
index 0000000..36ff669
--- /dev/null
+++ b/dtc/tests/incbin.c
@@ -0,0 +1,65 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for string escapes in dtc
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define CHUNKSIZE	1024
+
+static char *load_file(const char *name, int *len)
+{
+	FILE *f;
+	char *buf = NULL;
+	int bufsize = 0, n;
+
+	*len = 0;
+
+	f = fopen(name, "r");
+	if (!f)
+		FAIL("Couldn't open \"%s\": %s", name, strerror(errno));
+
+	while (!feof(f)) {
+		if (bufsize < (*len + CHUNKSIZE)) {
+			buf = xrealloc(buf, *len + CHUNKSIZE);
+			bufsize = *len + CHUNKSIZE;
+		}
+
+		n = fread(buf + *len, 1, CHUNKSIZE, f);
+		if (ferror(f))
+			FAIL("Error reading \"%s\": %s", name, strerror(errno));
+		*len += n;
+	}
+
+	return buf;
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	char *incbin;
+	int len;
+
+	test_init(argc, argv);
+
+	if (argc != 3)
+		CONFIG("Usage: %s <incbin file> <dtb file>", argv[0]);
+
+	incbin = load_file(argv[1], &len);
+	fdt = load_blob(argv[2]);
+
+	check_getprop(fdt, 0, "incbin", len, incbin);
+	check_getprop(fdt, 0, "incbin-partial", 17, incbin + 13);
+
+	PASS();
+}
diff --git a/dtc/tests/incbin.dts b/dtc/tests/incbin.dts
new file mode 100644
index 0000000..7c30e0e
--- /dev/null
+++ b/dtc/tests/incbin.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	incbin = /incbin/("incbin.bin");
+	incbin-partial = /incbin/("incbin.bin", 13, 17);
+};
diff --git a/dtc/tests/include0.dts b/dtc/tests/include0.dts
new file mode 100644
index 0000000..355ed6a
--- /dev/null
+++ b/dtc/tests/include0.dts
@@ -0,0 +1 @@
+/include/ "include1.dts"
diff --git a/dtc/tests/include1.dts b/dtc/tests/include1.dts
new file mode 100644
index 0000000..0b4b773
--- /dev/null
+++ b/dtc/tests/include1.dts
@@ -0,0 +1,32 @@
+/dts-v1/;
+
+/include/ "include2.dts"
+/memreserve/ /include/ "include3.dts";
+
+/ {
+	/include/ "include4.dts"
+	/include/ "include5.dts" = <0xdeadbeef>;
+	prop-int64 /include/ "include5a.dts";
+	prop-str = /include/ "include6.dts";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	/include/ "include7.dts"
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/include/ "include8.dts"
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/include2.dts b/dtc/tests/include2.dts
new file mode 100644
index 0000000..7e189dd
--- /dev/null
+++ b/dtc/tests/include2.dts
@@ -0,0 +1 @@
+/memreserve/ 0xdeadbeef00000000 0x100000;
diff --git a/dtc/tests/include3.dts b/dtc/tests/include3.dts
new file mode 100644
index 0000000..ee9d277
--- /dev/null
+++ b/dtc/tests/include3.dts
@@ -0,0 +1 @@
+123456789 010000
diff --git a/dtc/tests/include4.dts b/dtc/tests/include4.dts
new file mode 100644
index 0000000..b2ddbe5
--- /dev/null
+++ b/dtc/tests/include4.dts
@@ -0,0 +1 @@
+	compatible = "test_tree1";
diff --git a/dtc/tests/include5.dts b/dtc/tests/include5.dts
new file mode 100644
index 0000000..9a35dc5
--- /dev/null
+++ b/dtc/tests/include5.dts
@@ -0,0 +1 @@
+prop-int
diff --git a/dtc/tests/include5a.dts b/dtc/tests/include5a.dts
new file mode 100644
index 0000000..39ddba4
--- /dev/null
+++ b/dtc/tests/include5a.dts
@@ -0,0 +1 @@
+= /bits/ 64 <0xdeadbeef01abcdef>
\ No newline at end of file
diff --git a/dtc/tests/include6.dts b/dtc/tests/include6.dts
new file mode 100644
index 0000000..cd4bc1a
--- /dev/null
+++ b/dtc/tests/include6.dts
@@ -0,0 +1 @@
+"hello world"
diff --git a/dtc/tests/include7.dts b/dtc/tests/include7.dts
new file mode 100644
index 0000000..ab2c948
--- /dev/null
+++ b/dtc/tests/include7.dts
@@ -0,0 +1,14 @@
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			placeholder = "this is a placeholder string", "string2";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
diff --git a/dtc/tests/include8.dts b/dtc/tests/include8.dts
new file mode 100644
index 0000000..7532ef5
--- /dev/null
+++ b/dtc/tests/include8.dts
@@ -0,0 +1,2 @@
+subsubnode@0 {
+	reg = <0>;
diff --git a/dtc/tests/integer-expressions.c b/dtc/tests/integer-expressions.c
new file mode 100644
index 0000000..6f33d81
--- /dev/null
+++ b/dtc/tests/integer-expressions.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Testcase for dtc expression support
+ *
+ * Copyright (C) 2008 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static struct test_expr {
+	const char *expr;
+	uint32_t result;
+} expr_table[] = {
+#define TE(expr)	{ #expr, (expr) }
+	TE(0xdeadbeef),
+	TE(-0x21524111),
+	TE(1+1),
+	TE(2*3),
+	TE(4/2),
+	TE(10/3),
+	TE(19%4),
+	TE(1 << 13),
+	TE(0x1000 >> 4),
+	TE(3*2+1), TE(3*(2+1)),
+	TE(1+2*3), TE((1+2)*3),
+	TE(1 < 2), TE(2 < 1), TE(1 < 1),
+	TE(1 <= 2), TE(2 <= 1), TE(1 <= 1),
+	TE(1 > 2), TE(2 > 1), TE(1 > 1),
+	TE(1 >= 2), TE(2 >= 1), TE(1 >= 1),
+	TE(1 == 1), TE(1 == 2),
+	TE(1 != 1), TE(1 != 2),
+	TE(0xabcdabcd & 0xffff0000),
+	TE(0xdead4110 ^ 0xf0f0f0f0),
+	TE(0xabcd0000 | 0x0000abcd),
+	TE(~0x21524110),
+	TE(~~0xdeadbeef),
+	TE(0 && 0), TE(17 && 0), TE(0 && 17), TE(17 && 17),
+	TE(0 || 0), TE(17 || 0), TE(0 || 17), TE(17 || 17),
+	TE(!0), TE(!1), TE(!17), TE(!!0), TE(!!17),
+	TE(0 ? 17 : 39), TE(1 ? 17 : 39), TE(17 ? 0xdeadbeef : 0xabcd1234),
+	TE(11 * 257 * 1321517ULL),
+	TE(123456790 - 4/2 + 17%4),
+};
+
+#define ARRAY_SIZE(x)	(sizeof(x) / sizeof((x)[0]))
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	const fdt32_t *res;
+	int reslen;
+	int i;
+
+	test_init(argc, argv);
+
+	if ((argc == 3) && (strcmp(argv[1], "-g") == 0)) {
+		FILE *f = fopen(argv[2], "w");
+
+		if (!f)
+			FAIL("Couldn't open \"%s\" for output: %s\n",
+			     argv[2], strerror(errno));
+
+		fprintf(f, "/dts-v1/;\n");
+		fprintf(f, "/ {\n");
+		fprintf(f, "\texpressions = <\n");
+		for (i = 0; i < ARRAY_SIZE(expr_table); i++)
+			fprintf(f, "\t\t(%s)\n", expr_table[i].expr);
+		fprintf(f, "\t>;\n");
+		fprintf(f, "};\n");
+		fclose(f);
+	} else {
+		fdt = load_blob_arg(argc, argv);
+
+		res = fdt_getprop(fdt, 0, "expressions", &reslen);
+
+		if (!res)
+			FAIL("Error retrieving expression results: %s\n",
+		     fdt_strerror(reslen));
+
+		if (reslen != (ARRAY_SIZE(expr_table) * sizeof(uint32_t)))
+			FAIL("Unexpected length of results %d instead of %zd\n",
+			     reslen, ARRAY_SIZE(expr_table) * sizeof(uint32_t));
+
+		for (i = 0; i < ARRAY_SIZE(expr_table); i++)
+			if (fdt32_to_cpu(res[i]) != expr_table[i].result)
+				FAIL("Incorrect result for expression \"%s\","
+				     " 0x%x instead of 0x%x\n",
+				     expr_table[i].expr, fdt32_to_cpu(res[i]),
+				     expr_table[i].result);
+	}
+
+	PASS();
+}
diff --git a/dtc/tests/label01.dts b/dtc/tests/label01.dts
new file mode 100644
index 0000000..a895803
--- /dev/null
+++ b/dtc/tests/label01.dts
@@ -0,0 +1,63 @@
+/dts-v1/;
+
+/memreserve/ 0x1000000000000000 0x0000000002000000;
+memrsv2: /memreserve/ 0x2000000000000000 0x0100000000000000;
+/memreserve/ 0x0000000000000000 0x0000000000000014;
+
+/ {
+	model = "MyBoardName";
+	compatible = "MyBoardName", "MyBoardFamilyName";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		linux,phandle = <0x1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		PowerPC,970@0 {
+			name = "PowerPC,970";
+			device_type = "cpu";
+			reg = <0x00000000>;
+			clock-frequency = <1600000000>;
+			timebase-frequency = <33333333>;
+			linux,boot-cpu;
+			i-cache-size = <65536>;
+			d-cache-size = <32768>;
+		};
+
+		PowerPC,970@1 {
+			name = "PowerPC,970";
+			device_type = "cpu";
+			reg = <0x00000001>;
+			clock-frequency = <1600000000>;
+			timebase-frequency = <33333333>;
+			i-cache-size = <65536>;
+			d-cache-size = <32768>;
+		};
+
+	};
+
+	node: randomnode {
+		prop: string = str: "foo", str_mid: "stuffstuff\t\t\t\n\n\n" str_end: ;
+		blob = [byte: 0a 0b 0c 0d byte_mid: de ea ad be ef byte_end: ];
+		ref = < cell: &{/memory@0} 0x0 cell_mid: 0xffffffff cell_end: >;
+		mixed = "abc", pre: [1234] post: , gap: < aligned: 0xa 0xb 0xc>;
+		tricky1 = [61 lt1: 62 63 00];
+		subnode: child {
+		};
+		/* subnode_end: is auto-generated by node emit */
+	};
+	/* node_end: is auto-generated by node emit */
+
+	memory@0 {
+		device_type = "memory";
+		memreg: reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
+	};
+
+	chosen {
+		bootargs = "root=/dev/sda2";
+		linux,platform = <0x600>;
+	};
+
+};
+
diff --git a/dtc/tests/label_repeated.dts b/dtc/tests/label_repeated.dts
new file mode 100644
index 0000000..34225d3
--- /dev/null
+++ b/dtc/tests/label_repeated.dts
@@ -0,0 +1,15 @@
+/dts-v1/;
+
+/ {
+	l0: prop = "foo";
+
+	l1: node {
+	};
+};
+
+/ {
+	l0: prop = "foo";
+
+	l1: node {
+	};
+};
diff --git a/dtc/tests/line_directives.dts b/dtc/tests/line_directives.dts
new file mode 100644
index 0000000..67b5e08
--- /dev/null
+++ b/dtc/tests/line_directives.dts
@@ -0,0 +1,26 @@
+/dts-v1/;
+
+/* common format */
+#line 3 "foo.dts"
+/* newer gcc format */
+# 9 "baz.dts" 1
+/* flags are optional */
+# 6 "bar.dts"
+
+/ {
+/*
+ * Make sure optional flags don't consume integer data on next line. The issue
+ * was that the {WS} in the trailing ({WS}+[0-9]+)? could cross the * line-
+ * break, and consume the leading "0" of the hex constant, leaving "x12345678"
+ * to be parsed as a number, which is invalid syntax.
+ */
+	prop1 = <
+# 10 "qux.dts"
+		0x12345678
+	>;
+/*
+ * Check processing of escapes in filenames
+ */
+# 100 "\".dts"
+# 200 "\\.dts"
+};
diff --git a/dtc/tests/lorem.txt b/dtc/tests/lorem.txt
new file mode 100644
index 0000000..acff698
--- /dev/null
+++ b/dtc/tests/lorem.txt
@@ -0,0 +1,35 @@
+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris eros
+arcu, egestas non pellentesque non, euismod eu nibh. Proin arcu metus,
+dapibus vitae sodales rhoncus, suscipit vel nulla. Etiam lorem est,
+aliquam ut fringilla sit amet, condimentum et quam. Duis eu arcu odio,
+at pulvinar nisi. Morbi condimentum eros ut turpis rhoncus
+pharetra. Pellentesque habitant morbi tristique senectus et netus et
+malesuada fames ac turpis egestas. Nam et nulla enim. Etiam fringilla
+eleifend neque, at posuere ante lacinia a. Duis orci tortor, dictum ac
+gravida ac, euismod eu leo. Sed eget dolor tortor. Pellentesque
+venenatis, lectus eu vulputate porta, libero ipsum convallis mi, sit
+amet vehicula arcu elit sit amet odio.
+
+Fusce iaculis massa metus, id sagittis diam. Praesent molestie ante
+vel odio tincidunt auctor. Cum sociis natoque penatibus et magnis dis
+parturient montes, nascetur ridiculus mus. Duis rutrum vehicula nisl
+eget condimentum. In in justo nisl. Nullam id arcu at nisl eleifend
+pretium. Nulla interdum ligula id elit mollis dictum a sit amet
+quam. Nullam iaculis laoreet ipsum at tempus. Vestibulum in cursus
+dui. Curabitur porta lectus eget urna bibendum congue eget elementum
+nisi. Proin sit amet lectus ut neque iaculis consectetur eu sit amet
+nibh. Maecenas rhoncus dolor ac nunc gravida blandit. Fusce sem felis,
+aliquam a porttitor a, porta quis odio.
+
+Nunc purus lorem, sollicitudin non ultricies id, porta vitae
+enim. Nulla tristique gravida leo ut suscipit. Phasellus vitae turpis
+libero. Proin ac purus dolor, in suscipit magna. Sed et enim
+arcu. Morbi semper aliquet suscipit. Aenean laoreet condimentum massa,
+eu pharetra magna fermentum ut. Morbi euismod convallis tortor, eget
+fringilla lacus sagittis non. Nullam bibendum posuere feugiat.
+
+In at pulvinar massa. Mauris nunc lectus, mollis et malesuada
+pharetra, cursus sed lacus. Integer dolor urna, interdum a mollis at,
+vestibulum non nisl. Sed in urna tortor. Mauris arcu felis, volutpat
+quis euismod vel, congue sit amet ipsum. Morbi in aliquet purus. Duis
+cras amet.
diff --git a/dtc/tests/mangle-layout.c b/dtc/tests/mangle-layout.c
new file mode 100644
index 0000000..59b1604
--- /dev/null
+++ b/dtc/tests/mangle-layout.c
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase/tool for rearranging blocks of a dtb
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+struct bufstate {
+	char *buf;
+	int size;
+};
+
+static void expand_buf(struct bufstate *buf, int newsize)
+{
+	buf->buf = realloc(buf->buf, newsize);
+	if (!buf->buf)
+		CONFIG("Allocation failure");
+	buf->size = newsize;
+}
+
+static void new_header(struct bufstate *buf, int version, const void *fdt)
+{
+	int hdrsize = fdt_header_size_(version);
+
+	if ((version != 16) && (version != 17))
+		CONFIG("Bad version %d", version);
+
+	expand_buf(buf, hdrsize);
+	memset(buf->buf, 0, hdrsize);
+
+	fdt_set_magic(buf->buf, FDT_MAGIC);
+	fdt_set_version(buf->buf, version);
+	fdt_set_last_comp_version(buf->buf, 16);
+	fdt_set_boot_cpuid_phys(buf->buf, fdt_boot_cpuid_phys(fdt));
+}
+
+static void add_block(struct bufstate *buf, int version, char block, const void *fdt)
+{
+	int align, size, oldsize;
+	const void *src;
+	int offset;
+
+	switch (block) {
+	case 'm':
+		/* Memory reserve map */
+		align = 8;
+		src = (const char *)fdt + fdt_off_mem_rsvmap(fdt);
+		size = (fdt_num_mem_rsv(fdt) + 1)
+			* sizeof(struct fdt_reserve_entry);
+		break;
+
+	case 't':
+		/* Structure block */
+		align = 4;
+		src = (const char *)fdt + fdt_off_dt_struct(fdt);
+		size = fdt_size_dt_struct(fdt);
+		break;
+
+	case 's':
+		/* Strings block */
+		align = 1;
+		src = (const char *)fdt + fdt_off_dt_strings(fdt);
+		size = fdt_size_dt_strings(fdt);
+		break;
+	default:
+		CONFIG("Bad block '%c'", block);
+	}
+
+	oldsize = buf->size;
+	offset = ALIGN(oldsize, align);
+	expand_buf(buf, offset+size);
+	memset(buf->buf + oldsize, 0, offset - oldsize);
+
+	memcpy(buf->buf + offset, src, size);
+
+	switch (block) {
+	case 'm':
+		fdt_set_off_mem_rsvmap(buf->buf, offset);
+		break;
+
+	case 't':
+		fdt_set_off_dt_struct(buf->buf, offset);
+		if (version >= 17)
+			fdt_set_size_dt_struct(buf->buf, size);
+		break;
+
+	case 's':
+		fdt_set_off_dt_strings(buf->buf, offset);
+		fdt_set_size_dt_strings(buf->buf, size);
+		break;
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int version;
+	const char *blockorder;
+	struct bufstate buf = {NULL, 0};
+	int err;
+	const char *inname;
+	char outname[PATH_MAX];
+
+	test_init(argc, argv);
+	if (argc != 4)
+		CONFIG("Usage: %s <dtb file> <version> <block order>", argv[0]);
+
+	inname = argv[1];
+	fdt = load_blob(argv[1]);
+	version = atoi(argv[2]);
+	blockorder = argv[3];
+	sprintf(outname, "v%d.%s.%s", version, blockorder, inname);
+
+	if ((version != 16) && (version != 17))
+		CONFIG("Version must be 16 or 17");
+
+	if (fdt_version(fdt) < 17)
+		CONFIG("Input tree must be v17");
+
+	new_header(&buf, version, fdt);
+
+	while (*blockorder) {
+		add_block(&buf, version, *blockorder, fdt);
+		blockorder++;
+	}
+
+	fdt_set_totalsize(buf.buf, buf.size);
+
+	err = fdt_check_header(buf.buf);
+	if (err)
+		FAIL("Output tree fails check: %s", fdt_strerror(err));
+
+	save_blob(outname, buf.buf);
+
+	PASS();
+}
diff --git a/dtc/tests/meson.build b/dtc/tests/meson.build
new file mode 100644
index 0000000..fa06824
--- /dev/null
+++ b/dtc/tests/meson.build
@@ -0,0 +1,131 @@
+trees = static_library('trees', files('trees.S'), c_args: '-D__ASSEMBLY__',
+                       include_directories: libfdt_inc)
+
+dumptrees = executable('dumptrees', files('dumptrees.c'),
+                       link_with: trees, dependencies: libfdt_dep)
+
+dumptrees_dtb = custom_target(
+  'dumptrees',
+  command: [dumptrees, meson.current_build_dir()],
+  output: [
+    'test_tree1.dtb',
+    'bad_node_char.dtb',
+    'bad_node_format.dtb',
+    'bad_prop_char.dtb',
+    'ovf_size_strings.dtb',
+    'truncated_property.dtb',
+    'truncated_string.dtb',
+    'truncated_memrsv.dtb',
+  ]
+)
+
+testutil_dep = declare_dependency(sources: ['testutils.c'], link_with: trees)
+
+tests = [
+  'add_subnode_with_nops',
+  'addr_size_cells',
+  'addr_size_cells2',
+  'appendprop1',
+  'appendprop2',
+  'appendprop_addrrange',
+  'boot-cpuid',
+  'char_literal',
+  'check_full',
+  'check_header',
+  'check_path',
+  'del_node',
+  'del_property',
+  'dtb_reverse',
+  'dtbs_equal_ordered',
+  'dtbs_equal_unordered',
+  'extra-terminating-null',
+  'find_property',
+  'fs_tree1',
+  'get_alias',
+  'get_mem_rsv',
+  'get_name',
+  'get_path',
+  'get_phandle',
+  'get_prop_offset',
+  'getprop',
+  'incbin',
+  'integer-expressions',
+  'mangle-layout',
+  'move_and_save',
+  'node_check_compatible',
+  'node_offset_by_compatible',
+  'node_offset_by_phandle',
+  'node_offset_by_prop_value',
+  'nop_node',
+  'nop_property',
+  'nopulate',
+  'notfound',
+  'open_pack',
+  'overlay',
+  'overlay_bad_fixup',
+  'parent_offset',
+  'path-references',
+  'path_offset',
+  'path_offset_aliases',
+  'phandle_format',
+  'property_iterate',
+  'propname_escapes',
+  'references',
+  'root_node',
+  'rw_oom',
+  'rw_tree1',
+  'set_name',
+  'setprop',
+  'setprop_inplace',
+  'sized_cells',
+  'string_escapes',
+  'stringlist',
+  'subnode_iterate',
+  'subnode_offset',
+  'supernode_atdepth_offset',
+  'sw_states',
+  'sw_tree1',
+  'utilfdt_test',
+]
+
+tests += [
+  'truncated_memrsv',
+  'truncated_property',
+  'truncated_string',
+]
+
+dl = cc.find_library('dl', required: false)
+if dl.found()
+  tests += [
+    'asm_tree_dump',
+    'value-labels',
+  ]
+endif
+
+foreach t: tests
+  executable(t, files(t + '.c'), dependencies: [testutil_dep, util_dep, libfdt_dep, dl])
+endforeach
+
+run_tests = find_program('run_tests.sh')
+
+env = []
+if not py.found()
+  env += 'NO_PYTHON=1'
+else
+  env += [
+    'PYTHON=' + py.path(),
+    'PYTHONPATH=' + meson.source_root() / 'pylibfdt',
+  ]
+endif
+if not yaml.found()
+  env += 'NO_YAML=1'
+endif
+
+test(
+  'run-test',
+  run_tests,
+  workdir: meson.current_build_dir(),
+  depends: dumptrees_dtb,
+  env: env,
+  timeout: 1800, # mostly for valgrind
+)
diff --git a/dtc/tests/minusone-phandle.dts b/dtc/tests/minusone-phandle.dts
new file mode 100644
index 0000000..21d9986
--- /dev/null
+++ b/dtc/tests/minusone-phandle.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	node {
+		linux,phandle = <0xffffffff>;
+	};
+};
diff --git a/dtc/tests/move_and_save.c b/dtc/tests/move_and_save.c
new file mode 100644
index 0000000..a89f8de
--- /dev/null
+++ b/dtc/tests/move_and_save.c
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Basic testcase for read-only access
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt, *fdt1, *fdt2, *fdt3;
+	char *buf;
+	int shuntsize;
+	int bufsize;
+	int err;
+	const char *inname;
+	char outname[PATH_MAX];
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+	inname = argv[1];
+
+	shuntsize = ALIGN(fdt_totalsize(fdt) / 2, sizeof(uint64_t));
+	bufsize = fdt_totalsize(fdt) + shuntsize;
+	buf = xmalloc(bufsize);
+
+	fdt1 = buf;
+	err = fdt_move(fdt, fdt1, bufsize);
+	if (err)
+		FAIL("Failed to move tree into new buffer: %s",
+		     fdt_strerror(err));
+	sprintf(outname, "moved.%s", inname);
+	save_blob(outname, fdt1);
+
+	fdt2 = buf + shuntsize;
+	err = fdt_move(fdt1, fdt2, bufsize-shuntsize);
+	if (err)
+		FAIL("Failed to shunt tree %d bytes: %s",
+		     shuntsize, fdt_strerror(err));
+	sprintf(outname, "shunted.%s", inname);
+	save_blob(outname, fdt2);
+
+	fdt3 = buf;
+	err = fdt_move(fdt2, fdt3, bufsize);
+	if (err)
+		FAIL("Failed to deshunt tree %d bytes: %s",
+		     shuntsize, fdt_strerror(err));
+	sprintf(outname, "deshunted.%s", inname);
+	save_blob(outname, fdt3);
+
+	PASS();
+}
diff --git a/dtc/tests/multilabel.dts b/dtc/tests/multilabel.dts
new file mode 100644
index 0000000..d80ebe1
--- /dev/null
+++ b/dtc/tests/multilabel.dts
@@ -0,0 +1,49 @@
+/dts-v1/;
+
+m1: mq: /memreserve/ 0 0x1000;
+
+/ {
+	p0: pw: prop = "foo";
+
+	rref = <&{/}>;
+
+	/* Explicit phandles */
+	n1: nx: node1 {
+		linux,phandle = <0x2000>;
+		ref = <&{/node2}>; /* reference precedes target */
+		p1: px: lref = <&ny>;
+	};
+	ny: n2: node2 {
+		p2: py: phandle = <0x1>;
+		ref = <&{/node1}>; /* reference after target */
+		lref = <&nx>;
+	};
+
+	/* Implicit phandles */
+	n3: node3 {
+		p3: ref = <&{/node4}>;
+		lref = <&n4>;
+	};
+	n4: node4 {
+		p4: prop;
+	};
+
+	/* Explicit phandle with implicit value */
+	/* This self-reference is the standard way to tag a node as requiring
+	 * a phandle (perhaps for reference by nodes that will be dynamically
+	 * added) without explicitly allocating it a phandle.
+	 * The self-reference requires some special internal handling, though
+	 * so check it actually works */
+	n5: nz: node5 {
+		linux,phandle = <&n5>;
+		phandle = <&nz>;
+		n1 = &n1;
+		n2 = &n2;
+		n3 = &n3;
+	};
+
+	node6 {
+		linux,phandle = <0xfffffffe>;
+		phandle = <0xfffffffe>;
+	};
+};
diff --git a/dtc/tests/multilabel_merge.dts b/dtc/tests/multilabel_merge.dts
new file mode 100644
index 0000000..a27d856
--- /dev/null
+++ b/dtc/tests/multilabel_merge.dts
@@ -0,0 +1,75 @@
+/dts-v1/;
+
+m1: mq: /memreserve/ 0 0x1000;
+
+/ {
+	p0: pw: prop = "foo";
+
+	/* Explicit phandles */
+	n1: node1 {
+		linux,phandle = <0x2000>;
+		ref = <&{/node2}>; /* reference precedes target */
+		p1: lref;
+	};
+	node2 {
+		phandle = <0x1>;
+		ref = <&{/node1}>; /* reference after target */
+		lref = <&nx>;
+	};
+
+	/* Implicit phandles */
+	n3: node3 {
+		p3: ref = <&{/node4}>;
+		lref = <&n4>;
+	};
+	n4: node4 {
+		p4: prop = "foo";
+	};
+
+	/* Explicit phandle with implicit value */
+	/* This self-reference is the standard way to tag a node as requiring
+	 * a phandle (perhaps for reference by nodes that will be dynamically
+	 * added) without explicitly allocating it a phandle.
+	 * The self-reference requires some special internal handling, though
+	 * so check it actually works */
+	n5: nz: node5 {
+		linux,phandle = <&n5>;
+		phandle = <&nz>;
+		n1 = &n1;
+		n2 = &n2;
+		n3 = &n3;
+	};
+
+	node6 {
+		linux,phandle = <0xfffffffe>;
+		phandle = <0xfffffffe>;
+	};
+};
+
+/ {
+	/* Append labels (also changes property content) */
+	nx: node1 {
+		px: lref = <&ny>;
+	};
+
+	/* Add multiple labels */
+	ny: n2: node2 {
+		/* Add a label to a property */
+		p2: py: phandle = <0x1>;
+	};
+
+	/* Reassigning the same label should be a no-op */
+	n3: node3 {
+		p3: ref = <&{/node4}>;
+	};
+
+	/* Redefining a node/property should not remove labels */
+	node4 {
+		prop;
+	};
+
+};
+
+/ {
+	rref = <&{/}>;
+};
diff --git a/dtc/tests/node_check_compatible.c b/dtc/tests/node_check_compatible.c
new file mode 100644
index 0000000..81efe62
--- /dev/null
+++ b/dtc/tests/node_check_compatible.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_node_check_compatible()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_compatible(const void *fdt, const char *path,
+			     const char *compat)
+{
+	int offset, err;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("fdt_path_offset(%s): %s", path, fdt_strerror(offset));
+
+	err = fdt_node_check_compatible(fdt, offset, compat);
+	if (err < 0)
+		FAIL("fdt_node_check_compatible(%s): %s", path,
+		     fdt_strerror(err));
+	if (err != 0)
+		FAIL("%s is not compatible with \"%s\"", path, compat);
+}
+
+static void check_not_compatible(const void *fdt, const char *path,
+				 const char *compat)
+{
+	int offset, err;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("fdt_path_offset(%s): %s", path, fdt_strerror(offset));
+
+	err = fdt_node_check_compatible(fdt, offset, compat);
+	if (err < 0)
+		FAIL("fdt_node_check_compatible(%s): %s", path,
+		     fdt_strerror(err));
+	if (err == 0)
+		FAIL("%s is incorrectly compatible with \"%s\"", path, compat);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_compatible(fdt, "/", "test_tree1");
+	check_compatible(fdt, "/subnode@1/subsubnode", "subsubnode1");
+	check_compatible(fdt, "/subnode@1/subsubnode", "subsubnode");
+	check_not_compatible(fdt, "/subnode@1/subsubnode", "subsubnode2");
+	check_compatible(fdt, "/subnode@2/subsubnode", "subsubnode2");
+	check_compatible(fdt, "/subnode@2/subsubnode", "subsubnode");
+	check_not_compatible(fdt, "/subnode@2/subsubnode", "subsubnode1");
+
+	PASS();
+}
diff --git a/dtc/tests/node_offset_by_compatible.c b/dtc/tests/node_offset_by_compatible.c
new file mode 100644
index 0000000..a9e6783
--- /dev/null
+++ b/dtc/tests/node_offset_by_compatible.c
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_node_offset_by_compatible()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_search(void *fdt, const char *compat, ...)
+{
+	va_list ap;
+	int offset = -1, target;
+
+	va_start(ap, compat);
+	do {
+		target = va_arg(ap, int);
+		verbose_printf("Searching (target = %d): %d ->",
+			       target, offset);
+		offset = fdt_node_offset_by_compatible(fdt, offset, compat);
+		verbose_printf("%d\n", offset);
+
+		if (offset != target)
+			FAIL("fdt_node_offset_by_compatible(%s) returns %d "
+			     "instead of %d", compat, offset, target);
+	} while (target >= 0);
+
+	va_end(ap);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode1_offset, subnode2_offset;
+	int subsubnode1_offset, subsubnode2_offset;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	subsubnode1_offset = fdt_path_offset(fdt, "/subnode@1/subsubnode");
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode@0");
+
+	if ((subnode1_offset < 0) || (subnode2_offset < 0)
+	    || (subsubnode1_offset < 0) || (subsubnode2_offset < 0))
+		FAIL("Can't find required nodes");
+
+	check_search(fdt, "test_tree1", 0, -FDT_ERR_NOTFOUND);
+	check_search(fdt, "subnode1", subnode1_offset, -FDT_ERR_NOTFOUND);
+	check_search(fdt, "subsubnode1", subsubnode1_offset, -FDT_ERR_NOTFOUND);
+	check_search(fdt, "subsubnode2", subsubnode2_offset, -FDT_ERR_NOTFOUND);
+	/* Eek.. HACK to make this work whatever the order in the
+	 * example tree */
+	if (subsubnode1_offset < subsubnode2_offset)
+		check_search(fdt, "subsubnode", subsubnode1_offset,
+			     subsubnode2_offset, -FDT_ERR_NOTFOUND);
+	else
+		check_search(fdt, "subsubnode", subsubnode2_offset,
+			     subsubnode1_offset, -FDT_ERR_NOTFOUND);
+	check_search(fdt, "nothing-like-this", -FDT_ERR_NOTFOUND);
+
+	PASS();
+}
diff --git a/dtc/tests/node_offset_by_phandle.c b/dtc/tests/node_offset_by_phandle.c
new file mode 100644
index 0000000..60af78a
--- /dev/null
+++ b/dtc/tests/node_offset_by_phandle.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_node_offset_by_phandle()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_search(void *fdt, uint32_t phandle, int target)
+{
+	int offset;
+
+	offset = fdt_node_offset_by_phandle(fdt, phandle);
+
+	if (offset != target)
+		FAIL("fdt_node_offset_by_phandle(0x%x) returns %d "
+		     "instead of %d", phandle, offset, target);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode2_offset, subsubnode2_offset;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode@0");
+
+	if ((subnode2_offset < 0) || (subsubnode2_offset < 0))
+		FAIL("Can't find required nodes");
+
+	check_search(fdt, PHANDLE_1, subnode2_offset);
+	check_search(fdt, PHANDLE_2, subsubnode2_offset);
+	check_search(fdt, ~PHANDLE_1, -FDT_ERR_NOTFOUND);
+	check_search(fdt, 0, -FDT_ERR_BADPHANDLE);
+	check_search(fdt, -1, -FDT_ERR_BADPHANDLE);
+
+	PASS();
+}
diff --git a/dtc/tests/node_offset_by_prop_value.c b/dtc/tests/node_offset_by_prop_value.c
new file mode 100644
index 0000000..48ab1d9
--- /dev/null
+++ b/dtc/tests/node_offset_by_prop_value.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_path_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void vcheck_search(void *fdt, const char *propname, const void *propval,
+		  int proplen, va_list ap)
+{
+	int offset = -1, target;
+
+	do {
+		target = va_arg(ap, int);
+		verbose_printf("Searching (target = %d): %d ->",
+			       target, offset);
+		offset = fdt_node_offset_by_prop_value(fdt, offset, propname,
+						       propval, proplen);
+		verbose_printf("%d\n", offset);
+
+		if (offset != target)
+			FAIL("fdt_node_offset_by_prop_value() returns %d "
+			     "instead of %d", offset, target);
+	} while (target >= 0);
+}
+
+static void check_search(void *fdt, const char *propname, const void *propval,
+		  int proplen, ...)
+{
+	va_list ap;
+
+	va_start(ap, proplen);
+	vcheck_search(fdt, propname, propval, proplen, ap);
+	va_end(ap);
+}
+
+static void check_search_str(void *fdt, const char *propname,
+			     const char *propval, ...)
+{
+	va_list ap;
+
+	va_start(ap, propval);
+	vcheck_search(fdt, propname, propval, strlen(propval)+1, ap);
+	va_end(ap);
+}
+
+#define check_search_cell(fdt, propname, propval, ...) \
+	{ \
+		fdt32_t val = cpu_to_fdt32(propval); \
+		check_search((fdt), (propname), &val, sizeof(val), \
+			     ##__VA_ARGS__); \
+	}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode1_offset, subnode2_offset;
+	int subsubnode1_offset, subsubnode2_offset;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	subsubnode1_offset = fdt_path_offset(fdt, "/subnode@1/subsubnode");
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode@0");
+
+	if ((subnode1_offset < 0) || (subnode2_offset < 0)
+	    || (subsubnode1_offset < 0) || (subsubnode2_offset < 0))
+		FAIL("Can't find required nodes");
+
+	check_search_cell(fdt, "prop-int", TEST_VALUE_1, 0, subnode1_offset,
+			  subsubnode1_offset, -FDT_ERR_NOTFOUND);
+
+	check_search_cell(fdt, "prop-int", TEST_VALUE_2, subnode2_offset,
+			  subsubnode2_offset, -FDT_ERR_NOTFOUND);
+
+	check_search_str(fdt, "prop-str", TEST_STRING_1, 0, -FDT_ERR_NOTFOUND);
+
+	check_search_str(fdt, "prop-str", "no such string", -FDT_ERR_NOTFOUND);
+
+	check_search_cell(fdt, "prop-int", TEST_VALUE_1+1, -FDT_ERR_NOTFOUND);
+
+	check_search(fdt, "no-such-prop", NULL, 0, -FDT_ERR_NOTFOUND);
+
+	PASS();
+}
diff --git a/dtc/tests/nonexist-label-ref.dts b/dtc/tests/nonexist-label-ref.dts
new file mode 100644
index 0000000..25927a1
--- /dev/null
+++ b/dtc/tests/nonexist-label-ref.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/ {
+	ref = <&label>;
+	badref = <&nosuchlabel>;
+	label: node {
+	};
+};
diff --git a/dtc/tests/nonexist-node-ref.dts b/dtc/tests/nonexist-node-ref.dts
new file mode 100644
index 0000000..efd4140
--- /dev/null
+++ b/dtc/tests/nonexist-node-ref.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/ {
+	ref = < &{/node} >;
+	badref = < &{/nosuchnode} >;
+	label: node {
+	};
+};
diff --git a/dtc/tests/nonexist-node-ref2.dts b/dtc/tests/nonexist-node-ref2.dts
new file mode 100644
index 0000000..44b4ebe
--- /dev/null
+++ b/dtc/tests/nonexist-node-ref2.dts
@@ -0,0 +1,10 @@
+/dts-v1/;
+
+/ {
+	label: node {
+	};
+};
+
+/* Try to redefine a node using a non-existent label */
+&nosuchnode {
+};
diff --git a/dtc/tests/nop_node.c b/dtc/tests/nop_node.c
new file mode 100644
index 0000000..ee972d2
--- /dev/null
+++ b/dtc/tests/nop_node.c
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_node()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode1_offset, subnode2_offset, subsubnode2_offset;
+	int err;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	if (subnode1_offset < 0)
+		FAIL("Couldn't find \"/subnode1\": %s",
+		     fdt_strerror(subnode1_offset));
+	check_getprop_cell(fdt, subnode1_offset, "prop-int", TEST_VALUE_1);
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	if (subnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode2\": %s",
+		     fdt_strerror(subnode2_offset));
+	check_getprop_cell(fdt, subnode2_offset, "prop-int", TEST_VALUE_2);
+
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode");
+	if (subsubnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode@2/subsubnode\": %s",
+		     fdt_strerror(subsubnode2_offset));
+	check_getprop_cell(fdt, subsubnode2_offset, "prop-int", TEST_VALUE_2);
+
+	err = fdt_nop_node(fdt, subnode1_offset);
+	if (err)
+		FAIL("fdt_nop_node(subnode1): %s", fdt_strerror(err));
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	if (subnode1_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subnode1) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subnode1_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	if (subnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode2\": %s",
+		     fdt_strerror(subnode2_offset));
+	check_getprop_cell(fdt, subnode2_offset, "prop-int", TEST_VALUE_2);
+
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode");
+	if (subsubnode2_offset < 0)
+		FAIL("Couldn't find \"/subnode@2/subsubnode\": %s",
+		     fdt_strerror(subsubnode2_offset));
+	check_getprop_cell(fdt, subsubnode2_offset, "prop-int", TEST_VALUE_2);
+
+	err = fdt_nop_node(fdt, subnode2_offset);
+	if (err)
+		FAIL("fdt_nop_node(subnode2): %s", fdt_strerror(err));
+
+	subnode1_offset = fdt_path_offset(fdt, "/subnode@1");
+	if (subnode1_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subnode1) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subnode1_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	subnode2_offset = fdt_path_offset(fdt, "/subnode@2");
+	if (subnode2_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subnode2) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subnode2_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	subsubnode2_offset = fdt_path_offset(fdt, "/subnode@2/subsubnode");
+	if (subsubnode2_offset != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_path_offset(subsubnode2) returned \"%s\" instead of \"%s\"",
+		     fdt_strerror(subsubnode2_offset),
+		     fdt_strerror(-FDT_ERR_NOTFOUND));
+
+	PASS();
+}
diff --git a/dtc/tests/nop_property.c b/dtc/tests/nop_property.c
new file mode 100644
index 0000000..6593828
--- /dev/null
+++ b/dtc/tests/nop_property.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_property()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	const uint32_t *intp;
+	const char *strp;
+	int err;
+	int lenerr;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	intp = check_getprop_cell(fdt, 0, "prop-int", TEST_VALUE_1);
+	verbose_printf("int value was 0x%08x\n", *intp);
+
+	err = fdt_nop_property(fdt, 0, "prop-int");
+	if (err)
+		FAIL("Failed to nop \"prop-int\": %s", fdt_strerror(err));
+
+	intp = fdt_getprop(fdt, 0, "prop-int", &lenerr);
+	if (intp)
+		FAIL("prop-int still present after nopping");
+	if (lenerr != -FDT_ERR_NOTFOUND)
+		FAIL("Unexpected error on second getprop: %s", fdt_strerror(err));
+
+	strp = check_getprop(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1,
+			     TEST_STRING_1);
+	verbose_printf("string value was \"%s\"\n", strp);
+	err = fdt_nop_property(fdt, 0, "prop-str");
+	if (err)
+		FAIL("Failed to nop \"prop-str\": %s", fdt_strerror(err));
+
+	strp = fdt_getprop(fdt, 0, "prop-str", &lenerr);
+	if (strp)
+		FAIL("prop-str still present after nopping");
+	if (lenerr != -FDT_ERR_NOTFOUND)
+		FAIL("Unexpected error on second getprop: %s", fdt_strerror(err));
+
+	PASS();
+}
diff --git a/dtc/tests/nopulate.c b/dtc/tests/nopulate.c
new file mode 100644
index 0000000..2ae1753
--- /dev/null
+++ b/dtc/tests/nopulate.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase/tool for rearranging blocks of a dtb
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int nopulate_struct(char *buf, const char *fdt)
+{
+	int offset, nextoffset = 0;
+	uint32_t tag;
+	char *p;
+
+	p = buf;
+
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		memcpy(p, (const char *)fdt + fdt_off_dt_struct(fdt) + offset,
+		       nextoffset - offset);
+		p += nextoffset - offset;
+
+		*((fdt32_t *)p) = cpu_to_fdt32(FDT_NOP);
+		p += FDT_TAGSIZE;
+
+	} while (tag != FDT_END);
+
+	return p - buf;
+}
+
+int main(int argc, char *argv[])
+{
+	char *fdt, *fdt2, *buf;
+	int newsize, struct_start, struct_end_old, struct_end_new, delta;
+	const char *inname;
+	char outname[PATH_MAX];
+
+	test_init(argc, argv);
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>", argv[0]);
+
+	inname = argv[1];
+	fdt = load_blob(argv[1]);
+	sprintf(outname, "noppy.%s", inname);
+
+	if (fdt_version(fdt) < 17)
+		FAIL("Can't deal with version <17");
+
+	buf = xmalloc(2 * fdt_size_dt_struct(fdt));
+
+	newsize = nopulate_struct(buf, fdt);
+
+	verbose_printf("Nopulated structure block has new size %d\n", newsize);
+
+	/* Replace old strcutre block with the new */
+
+	fdt2 = xmalloc(fdt_totalsize(fdt) + newsize);
+
+	struct_start = fdt_off_dt_struct(fdt);
+	delta = newsize - fdt_size_dt_struct(fdt);
+	struct_end_old = struct_start + fdt_size_dt_struct(fdt);
+	struct_end_new = struct_start + newsize;
+
+	memcpy(fdt2, fdt, struct_start);
+	memcpy(fdt2 + struct_start, buf, newsize);
+	memcpy(fdt2 + struct_end_new, fdt + struct_end_old,
+	       fdt_totalsize(fdt) - struct_end_old);
+
+	fdt_set_totalsize(fdt2, fdt_totalsize(fdt) + delta);
+	fdt_set_size_dt_struct(fdt2, newsize);
+
+	if (fdt_off_mem_rsvmap(fdt) > struct_start)
+		fdt_set_off_mem_rsvmap(fdt2, fdt_off_mem_rsvmap(fdt) + delta);
+	if (fdt_off_dt_strings(fdt) > struct_start)
+		fdt_set_off_dt_strings(fdt2, fdt_off_dt_strings(fdt) + delta);
+
+	save_blob(outname, fdt2);
+
+	PASS();
+}
diff --git a/dtc/tests/notfound.c b/dtc/tests/notfound.c
new file mode 100644
index 0000000..70acbcd
--- /dev/null
+++ b/dtc/tests/notfound.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for behaviour on searching for a non-existent node
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_error(const char *s, int err)
+{
+	if (err != -FDT_ERR_NOTFOUND)
+		FAIL("%s return error %s instead of -FDT_ERR_NOTFOUND", s,
+		     fdt_strerror(err));
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int offset;
+	int subnode1_offset;
+	int lenerr;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	fdt_get_property(fdt, 0, "nonexistant-property", &lenerr);
+	check_error("fdt_get_property(\"nonexistant-property\")", lenerr);
+
+	fdt_getprop(fdt, 0, "nonexistant-property", &lenerr);
+	check_error("fdt_getprop(\"nonexistant-property\"", lenerr);
+
+	subnode1_offset = fdt_subnode_offset(fdt, 0, "subnode@1");
+	if (subnode1_offset < 0)
+		FAIL("Couldn't find subnode1: %s", fdt_strerror(subnode1_offset));
+
+	fdt_getprop(fdt, subnode1_offset, "prop-str", &lenerr);
+	check_error("fdt_getprop(\"prop-str\")", lenerr);
+
+	offset = fdt_subnode_offset(fdt, 0, "nonexistant-subnode");
+	check_error("fdt_subnode_offset(\"nonexistant-subnode\")", offset);
+
+	offset = fdt_subnode_offset(fdt, 0, "subsubnode");
+	check_error("fdt_subnode_offset(\"subsubnode\")", offset);
+
+	offset = fdt_path_offset(fdt, "/nonexistant-subnode");
+	check_error("fdt_path_offset(\"/nonexistant-subnode\")", offset);
+
+	PASS();
+}
diff --git a/dtc/tests/nul-in-escape.dts b/dtc/tests/nul-in-escape.dts
new file mode 100644
index 0000000000000000000000000000000000000000..9bed351cf021b252cd5e72fe6ade6c14b697c0e7
GIT binary patch
literal 36
lcmdN-DJj-1Gt{@{;?h^B=2C!y3I$sQr5FY!Ypz;rE&!6l2R#4)

literal 0
HcmV?d00001

diff --git a/dtc/tests/nul-in-line-info1.dts b/dtc/tests/nul-in-line-info1.dts
new file mode 100644
index 0000000000000000000000000000000000000000..ceb7261b7ef61529b9809e5a934770dd4ef2be19
GIT binary patch
literal 8
PcmY#ZFi=opP~rjr1eO5e

literal 0
HcmV?d00001

diff --git a/dtc/tests/nul-in-line-info2.dts b/dtc/tests/nul-in-line-info2.dts
new file mode 100644
index 0000000..1157d23
--- /dev/null
+++ b/dtc/tests/nul-in-line-info2.dts
@@ -0,0 +1 @@
+# 0 "\0"
diff --git a/dtc/tests/obsolete-chosen-interrupt-controller.dts b/dtc/tests/obsolete-chosen-interrupt-controller.dts
new file mode 100644
index 0000000..36dd6e8
--- /dev/null
+++ b/dtc/tests/obsolete-chosen-interrupt-controller.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	PIC: pic@0 {
+		reg = <0x0 0x10>;
+		interrupt-controller;
+	};
+	chosen {
+		interrupt-controller = <&PIC>;
+	};
+};
diff --git a/dtc/tests/omit-no-ref.dts b/dtc/tests/omit-no-ref.dts
new file mode 100644
index 0000000..8ace232
--- /dev/null
+++ b/dtc/tests/omit-no-ref.dts
@@ -0,0 +1,26 @@
+/dts-v1/;
+
+/ {
+	test-phandle = <&node3>;
+	test-path = &node4;
+
+	/omit-if-no-ref/ node1: node1 {
+		bar = <0xdeadbeef>;
+	};
+
+	node2: node2 {
+		foo = <0x42>;
+	};
+
+	node3: node3 {
+		test = "test";
+	};
+
+	node4: node4 {
+		test;
+	};
+};
+
+/omit-if-no-ref/ &node2;
+/omit-if-no-ref/ &node3;
+/omit-if-no-ref/ &node4;
diff --git a/dtc/tests/open_pack.c b/dtc/tests/open_pack.c
new file mode 100644
index 0000000..6ed4df7
--- /dev/null
+++ b/dtc/tests/open_pack.c
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Basic testcase for read-only access
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt, *fdt1;
+	void *buf;
+	int oldsize, bufsize, packsize;
+	int err;
+	const char *inname;
+	char outname[PATH_MAX];
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+	inname = argv[1];
+
+	oldsize = fdt_totalsize(fdt);
+
+	bufsize = oldsize * 2;
+
+	buf = xmalloc(bufsize);
+	/* don't leak uninitialized memory into our output */
+	memset(buf, 0, bufsize);
+
+	fdt1 = buf;
+	err = fdt_open_into(fdt, fdt1, bufsize);
+	if (err)
+		FAIL("fdt_open_into(): %s", fdt_strerror(err));
+	sprintf(outname, "opened.%s", inname);
+	save_blob(outname, fdt1);
+
+	err = fdt_pack(fdt1);
+	if (err)
+		FAIL("fdt_pack(): %s", fdt_strerror(err));
+	sprintf(outname, "repacked.%s", inname);
+	save_blob(outname, fdt1);
+
+	packsize = fdt_totalsize(fdt1);
+
+	verbose_printf("oldsize = %d, bufsize = %d, packsize = %d\n",
+		       oldsize, bufsize, packsize);
+	PASS();
+}
diff --git a/dtc/tests/overlay.c b/dtc/tests/overlay.c
new file mode 100644
index 0000000..91afa72
--- /dev/null
+++ b/dtc/tests/overlay.c
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for DT overlays()
+ * Copyright (C) 2016 Free Electrons
+ * Copyright (C) 2016 NextThing Co.
+ */
+
+#include <stdio.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+
+#define CHECK(code) \
+	{ \
+		int err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+/* 4k ought to be enough for anybody */
+#define FDT_COPY_SIZE	(4 * 1024)
+
+static int fdt_getprop_u32_by_poffset(void *fdt, const char *path,
+				      const char *name, int poffset,
+				      unsigned long *out)
+{
+	const fdt32_t *val;
+	int node_off;
+	int len;
+
+	node_off = fdt_path_offset(fdt, path);
+	if (node_off < 0)
+		return node_off;
+
+	val = fdt_getprop(fdt, node_off, name, &len);
+	if (!val || (len < (sizeof(uint32_t) * (poffset + 1))))
+		return -FDT_ERR_NOTFOUND;
+
+	*out = fdt32_to_cpu(*(val + poffset));
+
+	return 0;
+}
+
+static int check_getprop_string_by_name(void *fdt, const char *path,
+					const char *name, const char *val)
+{
+	int node_off;
+
+	node_off = fdt_path_offset(fdt, path);
+	if (node_off < 0)
+		return node_off;
+
+	check_getprop_string(fdt, node_off, name, val);
+
+	return 0;
+}
+
+static int check_getprop_u32_by_name(void *fdt, const char *path,
+				     const char *name, uint32_t val)
+{
+	int node_off;
+
+	node_off = fdt_path_offset(fdt, path);
+	CHECK(node_off < 0);
+
+	check_getprop_cell(fdt, node_off, name, val);
+
+	return 0;
+}
+
+static int check_getprop_null_by_name(void *fdt, const char *path,
+				      const char *name)
+{
+	int node_off;
+
+	node_off = fdt_path_offset(fdt, path);
+	CHECK(node_off < 0);
+
+	check_property(fdt, node_off, name, 0, NULL);
+
+	return 0;
+}
+
+static int fdt_overlay_change_int_property(void *fdt)
+{
+	return check_getprop_u32_by_name(fdt, "/test-node", "test-int-property",
+					 43);
+}
+
+static int fdt_overlay_change_str_property(void *fdt)
+{
+	return check_getprop_string_by_name(fdt, "/test-node",
+					    "test-str-property", "foobar");
+}
+
+static int fdt_overlay_add_str_property(void *fdt)
+{
+	return check_getprop_string_by_name(fdt, "/test-node",
+					    "test-str-property-2", "foobar2");
+}
+
+static int fdt_overlay_add_node(void *fdt)
+{
+	return check_getprop_null_by_name(fdt, "/test-node/new-node",
+					  "new-property");
+}
+
+static int fdt_overlay_add_subnode_property(void *fdt)
+{
+	check_getprop_null_by_name(fdt, "/test-node/sub-test-node",
+				   "sub-test-property");
+	check_getprop_null_by_name(fdt, "/test-node/sub-test-node",
+				   "new-sub-test-property");
+
+	return 0;
+}
+
+static int fdt_overlay_local_phandle(void *fdt)
+{
+	uint32_t local_phandle;
+	unsigned long val = 0;
+	int off;
+
+	off = fdt_path_offset(fdt, "/test-node/new-local-node");
+	CHECK(off < 0);
+
+	local_phandle = fdt_get_phandle(fdt, off);
+	CHECK(!local_phandle);
+
+	CHECK(fdt_getprop_u32_by_poffset(fdt, "/test-node",
+					 "test-several-phandle",
+					 0, &val));
+	CHECK(val != local_phandle);
+
+	CHECK(fdt_getprop_u32_by_poffset(fdt, "/test-node",
+					 "test-several-phandle",
+					 1, &val));
+	CHECK(val != local_phandle);
+
+	return 0;
+}
+
+static int fdt_overlay_local_phandles(void *fdt)
+{
+	uint32_t local_phandle, test_phandle;
+	unsigned long val = 0;
+	int off;
+
+	off = fdt_path_offset(fdt, "/test-node/new-local-node");
+	CHECK(off < 0);
+
+	local_phandle = fdt_get_phandle(fdt, off);
+	CHECK(!local_phandle);
+
+	off = fdt_path_offset(fdt, "/test-node");
+	CHECK(off < 0);
+
+	test_phandle = fdt_get_phandle(fdt, off);
+	CHECK(!test_phandle);
+
+	CHECK(fdt_getprop_u32_by_poffset(fdt, "/test-node",
+					 "test-phandle", 0, &val));
+	CHECK(test_phandle != val);
+
+	CHECK(fdt_getprop_u32_by_poffset(fdt, "/test-node",
+					 "test-phandle", 1, &val));
+	CHECK(local_phandle != val);
+
+	return 0;
+}
+
+static void *open_dt(char *path)
+{
+	void *dt, *copy;
+
+	dt = load_blob(path);
+	copy = xmalloc(FDT_COPY_SIZE);
+
+	/*
+	 * Resize our DTs to 4k so that we have room to operate on
+	 */
+	CHECK(fdt_open_into(dt, copy, FDT_COPY_SIZE));
+
+	return copy;
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt_base, *fdt_overlay;
+
+	test_init(argc, argv);
+	if (argc != 3)
+		CONFIG("Usage: %s <base dtb> <overlay dtb>", argv[0]);
+
+	fdt_base = open_dt(argv[1]);
+	fdt_overlay = open_dt(argv[2]);
+
+	/* Apply the overlay */
+	CHECK(fdt_overlay_apply(fdt_base, fdt_overlay));
+
+	fdt_overlay_change_int_property(fdt_base);
+	fdt_overlay_change_str_property(fdt_base);
+	fdt_overlay_add_str_property(fdt_base);
+	fdt_overlay_add_node(fdt_base);
+	fdt_overlay_add_subnode_property(fdt_base);
+
+	/*
+	 * If the base tree has a __symbols__ node, do the tests that
+	 * are only successful with a proper phandle support, and thus
+	 * dtc -@
+	 */
+	if (fdt_path_offset(fdt_base, "/__symbols__") >= 0) {
+		fdt_overlay_local_phandle(fdt_base);
+		fdt_overlay_local_phandles(fdt_base);
+	}
+
+	PASS();
+}
diff --git a/dtc/tests/overlay_bad_fixup.c b/dtc/tests/overlay_bad_fixup.c
new file mode 100644
index 0000000..029bc79
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for DT overlays()
+ * Copyright (C) 2016 Free Electrons
+ * Copyright (C) 2016 NextThing Co.
+ */
+
+#include <stdio.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+
+#define CHECK(code, expected)					\
+	{							\
+		err = (code);					\
+		if (err != expected)				\
+			FAIL(#code ": %s", fdt_strerror(err));	\
+	}
+
+/* 4k ought to be enough for anybody */
+#define FDT_COPY_SIZE	(4 * 1024)
+
+static void *open_dt(char *path)
+{
+	void *dt, *copy;
+	int err;
+
+	dt = load_blob(path);
+	copy = xmalloc(FDT_COPY_SIZE);
+
+	/*
+	 * Resize our DTs to 4k so that we have room to operate on
+	 */
+	CHECK(fdt_open_into(dt, copy, FDT_COPY_SIZE), 0);
+
+	return copy;
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt_base, *fdt_overlay;
+	int err;
+
+	test_init(argc, argv);
+	if (argc != 3)
+		CONFIG("Usage: %s <base dtb> <overlay dtb>", argv[0]);
+
+	fdt_base = open_dt(argv[1]);
+	fdt_overlay = open_dt(argv[2]);
+
+	/* Apply the overlay */
+	CHECK(fdt_overlay_apply(fdt_base, fdt_overlay), -FDT_ERR_BADOVERLAY);
+
+	PASS();
+}
diff --git a/dtc/tests/overlay_bad_fixup_bad_index.dts b/dtc/tests/overlay_bad_fixup_bad_index.dts
new file mode 100644
index 0000000..b5cf131
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_bad_index.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0:target:ab";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_base.dtsi b/dtc/tests/overlay_bad_fixup_base.dtsi
new file mode 100644
index 0000000..216bcab
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_base.dtsi
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+/ {
+	fragment@0 {
+		target = <0xffffffff>;
+
+		__overlay__ {
+			test-property;
+		};
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_empty.dts b/dtc/tests/overlay_bad_fixup_empty.dts
new file mode 100644
index 0000000..e111db4
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_empty.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_empty_index.dts b/dtc/tests/overlay_bad_fixup_empty_index.dts
new file mode 100644
index 0000000..9e12e21
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_empty_index.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0:target:";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_index_trailing.dts b/dtc/tests/overlay_bad_fixup_index_trailing.dts
new file mode 100644
index 0000000..f586bef
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_index_trailing.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0:target:0a";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_path_empty_prop.dts b/dtc/tests/overlay_bad_fixup_path_empty_prop.dts
new file mode 100644
index 0000000..608b5f9
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_path_empty_prop.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0::";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_path_only.dts b/dtc/tests/overlay_bad_fixup_path_only.dts
new file mode 100644
index 0000000..2485dd9
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_path_only.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_path_only_sep.dts b/dtc/tests/overlay_bad_fixup_path_only_sep.dts
new file mode 100644
index 0000000..3cbf6c4
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_path_only_sep.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0:";
+	};
+};
diff --git a/dtc/tests/overlay_bad_fixup_path_prop.dts b/dtc/tests/overlay_bad_fixup_path_prop.dts
new file mode 100644
index 0000000..ca79b52
--- /dev/null
+++ b/dtc/tests/overlay_bad_fixup_path_prop.dts
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/include/ "overlay_bad_fixup_base.dtsi"
+
+/ {
+	__fixups__ {
+		test = "/fragment@0:target";
+	};
+};
diff --git a/dtc/tests/overlay_base.dts b/dtc/tests/overlay_base.dts
new file mode 100644
index 0000000..a5e55b2
--- /dev/null
+++ b/dtc/tests/overlay_base.dts
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+/ {
+	test: test-node {
+		test-int-property = <42>;
+		test-str-property = "foo";
+
+		subtest: sub-test-node {
+			sub-test-property;
+
+			subtest_with_long_path: sub-test-node-with-very-long-target-path {
+				long-test-path-property;
+			};
+		};
+	};
+};
+
+
diff --git a/dtc/tests/overlay_base_manual_symbols.dts b/dtc/tests/overlay_base_manual_symbols.dts
new file mode 100644
index 0000000..7e4d17d
--- /dev/null
+++ b/dtc/tests/overlay_base_manual_symbols.dts
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+/ {
+	test: test-node {
+		phandle = <&test>; /* Force phandle generation */
+		test-int-property = <42>;
+		test-str-property = "foo";
+
+		subtest: sub-test-node {
+			sub-test-property;
+		};
+	};
+	__symbols__ {
+		test = &test;
+	};
+};
+
+
diff --git a/dtc/tests/overlay_overlay.dts b/dtc/tests/overlay_overlay.dts
new file mode 100644
index 0000000..c4ef1d4
--- /dev/null
+++ b/dtc/tests/overlay_overlay.dts
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ * Copyright (c) 2016 Konsulko Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+/plugin/;
+
+/* Test that we can change an int by another */
+&test {
+	test-int-property = <43>;
+};
+
+/* Test that we can replace a string by a longer one */
+&test {
+	test-str-property = "foobar";
+};
+
+/* Test that we add a new property */
+&test {
+	test-str-property-2 = "foobar2";
+};
+
+/* Test that we add a new node (by phandle) */
+&test {
+	new-node {
+		new-property;
+	};
+};
+
+&test {
+	local: new-local-node {
+		new-property;
+	};
+};
+
+&test {
+	test-phandle = <&test>, <&local>;
+};
+
+&test {
+	test-several-phandle = <&local>, <&local>;
+};
+
+&test {
+	sub-test-node {
+		new-sub-test-property;
+	};
+};
diff --git a/dtc/tests/overlay_overlay_bypath.dts b/dtc/tests/overlay_overlay_bypath.dts
new file mode 100644
index 0000000..f23e7b6
--- /dev/null
+++ b/dtc/tests/overlay_overlay_bypath.dts
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ * Copyright (c) 2016 Konsulko Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+/plugin/;
+
+/* Test that we can change an int by another */
+&{/test-node} {
+	test-int-property = <43>;
+};
+
+/* Test that we can replace a string by a longer one */
+&{/test-node} {
+	test-str-property = "foobar";
+};
+
+/* Test that we add a new property */
+&{/test-node} {
+	test-str-property-2 = "foobar2";
+};
+
+/* Test that we add a new node (by phandle) */
+&{/test-node} {
+	new-node {
+		new-property;
+	};
+};
+
+&{/} {
+	local: new-local-node {
+		new-property;
+	};
+};
+
+&{/} {
+	test-several-phandle = <&local>, <&local>;
+};
+
+&{/test-node} {
+	sub-test-node {
+		new-sub-test-property;
+	};
+};
diff --git a/dtc/tests/overlay_overlay_local_merge.dts b/dtc/tests/overlay_overlay_local_merge.dts
new file mode 100644
index 0000000..3ee622d
--- /dev/null
+++ b/dtc/tests/overlay_overlay_local_merge.dts
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ * Copyright (c) 2016 Konsulko Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+/plugin/;
+
+&test {
+	parent: new-node {
+		parent-property;
+	};
+};
+
+&parent {
+	new-merged-property;
+	new-merged-node {
+		new-property;
+	};
+};
+
+&{/} {
+	new-root-node {
+		new-root-node-property;
+	};
+};
diff --git a/dtc/tests/overlay_overlay_long_path.dts b/dtc/tests/overlay_overlay_long_path.dts
new file mode 100644
index 0000000..4f0d40b
--- /dev/null
+++ b/dtc/tests/overlay_overlay_long_path.dts
@@ -0,0 +1,32 @@
+/dts-v1/;
+/plugin/;
+
+&subtest_with_long_path {
+	lpath_0: test-0 {
+		prop = "lpath";
+	};
+
+	lpath_1: test-1 {
+		prop = "lpath";
+	};
+
+	lpath_2: test-2 {
+		prop = "lpath";
+	};
+
+	lpath_3: test-3 {
+		prop = "lpath";
+	};
+
+	lpath_4: test-4 {
+		prop = "lpath";
+	};
+
+	lpath_5: test-5 {
+		prop = "lpath";
+	};
+
+	lpath_6: test-6 {
+		prop = "lpath";
+	};
+};
diff --git a/dtc/tests/overlay_overlay_manual_fixups.dts b/dtc/tests/overlay_overlay_manual_fixups.dts
new file mode 100644
index 0000000..a5715b6
--- /dev/null
+++ b/dtc/tests/overlay_overlay_manual_fixups.dts
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ * Copyright (c) 2016 Konsulko Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+/* Note no /plugin/ tag - we're manually generating the metadata for
+   testing purposes */
+
+/ {
+	/* Test that we can change an int by another */
+	fragment@0 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			test-int-property = <43>;
+		};
+	};
+
+	/* Test that we can replace a string by a longer one */
+	fragment@1 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			test-str-property = "foobar";
+		};
+	};
+
+	/* Test that we add a new property */
+	fragment@2 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			test-str-property-2 = "foobar2";
+		};
+	};
+
+	/* Test that we add a new node (by phandle) */
+	fragment@3 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			new-node {
+				new-property;
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			local: new-local-node {
+				new-property;
+			};
+		};
+	};
+
+	fragment@5 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			test-phandle = <0xffffffff /*&test*/>, <&local>;
+		};
+	};
+
+	fragment@6 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			test-several-phandle = <&local>, <&local>;
+		};
+	};
+
+	fragment@7 {
+		target = <0xffffffff /*&test*/>;
+
+		__overlay__ {
+			sub-test-node {
+				new-sub-test-property;
+			};
+		};
+	};
+
+	__fixups__ {
+		test = "/fragment@0:target:0",
+		       "/fragment@1:target:0",
+		       "/fragment@2:target:0",
+		       "/fragment@3:target:0",
+		       "/fragment@4:target:0",
+		       "/fragment@5:target:0",
+		       "/fragment@5/__overlay__:test-phandle:0",
+		       "/fragment@6:target:0",
+		       "/fragment@7:target:0";
+	};
+	__local_fixups__ {
+		fragment@5 {
+			__overlay__ {
+				test-phandle = <4>;
+			};
+		};
+		fragment@6 {
+			__overlay__ {
+				test-several-phandle = <0 4>;
+			};
+		};
+	};
+};
diff --git a/dtc/tests/overlay_overlay_no_fixups.dts b/dtc/tests/overlay_overlay_no_fixups.dts
new file mode 100644
index 0000000..e8d0f96
--- /dev/null
+++ b/dtc/tests/overlay_overlay_no_fixups.dts
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+/ {
+	fragment@0 {
+		target-path = "/test-node";
+
+		__overlay__ {
+			test-int-property = <43>;
+		};
+	};
+
+	/* Test that we can replace a string by a longer one */
+	fragment@1 {
+		target-path = "/test-node";
+
+		__overlay__ {
+			test-str-property = "foobar";
+		};
+	};
+
+	/* Test that we add a new property */
+	fragment@2 {
+		target-path = "/test-node";
+
+		__overlay__ {
+			test-str-property-2 = "foobar2";
+		};
+	};
+
+	fragment@3 {
+		target-path = "/test-node";
+
+		__overlay__ {
+			new-node {
+				new-property;
+			};
+		};
+	};
+
+	fragment@4 {
+		target-path = "/";
+
+		__overlay__ {
+			local: new-local-node {
+				new-property;
+			};
+		};
+	};
+
+	fragment@5 {
+		target-path = "/";
+
+		__overlay__ {
+			test-several-phandle = <&local>, <&local>;
+		};
+	};
+
+	fragment@6 {
+		target-path = "/test-node";
+
+		__overlay__ {
+			sub-test-node {
+				new-sub-test-property;
+			};
+		};
+	};
+
+	__local_fixups__ {
+		fragment@5 {
+			__overlay__ {
+				test-several-phandle = <0 4>;
+			};
+		};
+	};
+};
diff --git a/dtc/tests/overlay_overlay_nosugar.dts b/dtc/tests/overlay_overlay_nosugar.dts
new file mode 100644
index 0000000..b5947e9
--- /dev/null
+++ b/dtc/tests/overlay_overlay_nosugar.dts
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2016 NextThing Co
+ * Copyright (c) 2016 Free Electrons
+ * Copyright (c) 2016 Konsulko Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	/* Test that we can change an int by another */
+	fragment@0 {
+		target = <&test>;
+
+		__overlay__ {
+			test-int-property = <43>;
+		};
+	};
+
+	/* Test that we can replace a string by a longer one */
+	fragment@1 {
+		target = <&test>;
+
+		__overlay__ {
+			test-str-property = "foobar";
+		};
+	};
+
+	/* Test that we add a new property */
+	fragment@2 {
+		target = <&test>;
+
+		__overlay__ {
+			test-str-property-2 = "foobar2";
+		};
+	};
+
+	/* Test that we add a new node (by phandle) */
+	fragment@3 {
+		target = <&test>;
+
+		__overlay__ {
+			new-node {
+				new-property;
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&test>;
+
+		__overlay__ {
+			local: new-local-node {
+				new-property;
+			};
+		};
+	};
+
+	fragment@5 {
+		target = <&test>;
+
+		__overlay__ {
+			test-phandle = <&test>, <&local>;
+		};
+	};
+
+	fragment@6 {
+		target = <&test>;
+
+		__overlay__ {
+			test-several-phandle = <&local>, <&local>;
+		};
+	};
+
+	fragment@7 {
+		target = <&test>;
+
+		__overlay__ {
+			sub-test-node {
+				new-sub-test-property;
+			};
+		};
+	};
+};
diff --git a/dtc/tests/overlay_overlay_simple.dts b/dtc/tests/overlay_overlay_simple.dts
new file mode 100644
index 0000000..8657e1e
--- /dev/null
+++ b/dtc/tests/overlay_overlay_simple.dts
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2016 Konsulko Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+/plugin/;
+
+&test {
+	test-int-property = <43>;
+};
diff --git a/dtc/tests/parent_offset.c b/dtc/tests/parent_offset.c
new file mode 100644
index 0000000..a935a53
--- /dev/null
+++ b/dtc/tests/parent_offset.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_parent_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int path_parent_len(const char *path)
+{
+	const char *p = strrchr(path, '/');
+
+	if (!p)
+		TEST_BUG();
+	if (p == path)
+		return 1;
+	else
+		return p - path;
+}
+
+static void check_path(struct fdt_header *fdt, const char *path)
+{
+	char *parentpath;
+	int nodeoffset, parentoffset, parentpathoffset, pathparentlen;
+
+	pathparentlen = path_parent_len(path);
+	parentpath = alloca(pathparentlen + 1);
+	strncpy(parentpath, path, pathparentlen);
+	parentpath[pathparentlen] = '\0';
+
+	verbose_printf("Path: \"%s\"\tParent: \"%s\"\n", path, parentpath);
+
+	nodeoffset = fdt_path_offset(fdt, path);
+	if (nodeoffset < 0)
+		FAIL("fdt_path_offset(%s): %s", path, fdt_strerror(nodeoffset));
+
+	parentpathoffset = fdt_path_offset(fdt, parentpath);
+	if (parentpathoffset < 0)
+		FAIL("fdt_path_offset(%s): %s", parentpath,
+		     fdt_strerror(parentpathoffset));
+
+	parentoffset = fdt_parent_offset(fdt, nodeoffset);
+	if (parentoffset < 0)
+		FAIL("fdt_parent_offset(): %s", fdt_strerror(parentoffset));
+
+	if (parentoffset != parentpathoffset)
+		FAIL("fdt_parent_offset() returns %d instead of %d",
+		     parentoffset, parentpathoffset);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int err;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_path(fdt, "/subnode@1");
+	check_path(fdt, "/subnode@2");
+	check_path(fdt, "/subnode@1/subsubnode");
+	check_path(fdt, "/subnode@2/subsubnode@0");
+	err = fdt_parent_offset(fdt, 0);
+	if (err != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_parent_offset(/) returns %d instead of "
+		     "-FDT_ERR_NOTFOUND", err);
+
+	PASS();
+}
diff --git a/dtc/tests/path-references.c b/dtc/tests/path-references.c
new file mode 100644
index 0000000..4db61a5
--- /dev/null
+++ b/dtc/tests/path-references.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for string references in dtc
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_ref(const void *fdt, int node, const char *checkpath)
+{
+	const char *p;
+	int len;
+
+	p = fdt_getprop(fdt, node, "ref", &len);
+	if (!p)
+		FAIL("fdt_getprop(%d, \"ref\"): %s", node, fdt_strerror(len));
+	if (!streq(p, checkpath))
+		FAIL("'ref' in node at %d has value \"%s\" instead of \"%s\"",
+		     node, p, checkpath);
+
+	p = fdt_getprop(fdt, node, "lref", &len);
+	if (!p)
+		FAIL("fdt_getprop(%d, \"lref\"): %s", node, fdt_strerror(len));
+	if (!streq(p, checkpath))
+		FAIL("'lref' in node at %d has value \"%s\" instead of \"%s\"",
+		     node, p, checkpath);
+}
+
+static void check_rref(const void *fdt)
+{
+	const char *p;
+	int len;
+
+	/* Check reference to root node */
+	p = fdt_getprop(fdt, 0, "rref", &len);
+	if (!p)
+		FAIL("fdt_getprop(0, \"rref\"): %s", fdt_strerror(len));
+	if (!streq(p, "/"))
+		FAIL("'rref' in root node has value \"%s\" instead of \"/\"",
+		     p);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	const char *p;
+	int len, multilen;
+	int n1, n2, n3, n4;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	n1 = fdt_path_offset(fdt, "/node1");
+	if (n1 < 0)
+		FAIL("fdt_path_offset(/node1): %s", fdt_strerror(n1));
+	n2 = fdt_path_offset(fdt, "/node2");
+	if (n2 < 0)
+		FAIL("fdt_path_offset(/node2): %s", fdt_strerror(n2));
+
+	check_ref(fdt, n1, "/node2");
+	check_ref(fdt, n2, "/node1");
+
+	/* Check multiple reference */
+	multilen = strlen("/node1") + strlen("/node2") + 2;
+	p = fdt_getprop(fdt, 0, "multiref", &len);
+	if (!p)
+		FAIL("fdt_getprop(0, \"multiref\"): %s", fdt_strerror(len));
+	if (len != multilen)
+		FAIL("multiref has wrong length, %d instead of %d",
+		     len, multilen);
+	if ((!streq(p, "/node1") || !streq(p + strlen("/node1") + 1, "/node2")))
+		FAIL("multiref has wrong value");
+
+	/* Check reference to nested nodes with common prefix */
+	n3 = fdt_path_offset(fdt, "/foo/baz");
+	if (n3 < 0)
+		FAIL("fdt_path_offset(/foo/baz): %s", fdt_strerror(n3));
+	n4 = fdt_path_offset(fdt, "/foobar/baz");
+	if (n4 < 0)
+		FAIL("fdt_path_offset(/foobar/baz): %s", fdt_strerror(n4));
+	check_ref(fdt, n3, "/foobar/baz");
+	check_ref(fdt, n4, "/foo/baz");
+
+	check_rref(fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/path-references.dts b/dtc/tests/path-references.dts
new file mode 100644
index 0000000..1fb7d70
--- /dev/null
+++ b/dtc/tests/path-references.dts
@@ -0,0 +1,28 @@
+/dts-v1/;
+
+/ {
+	rref = &{/};
+	/* Check multiple references case */
+	multiref = &n1 , &n2;
+	n1: node1 {
+		ref = &{/node2}; /* reference precedes target */
+		lref = &n2;
+	};
+	n2: node2 {
+		ref = &{/node1}; /* reference after target */
+		lref = &n1;
+	};
+	/* Check references to nested nodes with common prefix */
+	foobar {
+		n3: baz {
+			ref = &{/foo/baz};
+			lref = start: &n4 end:;
+		};
+	};
+	foo {
+		n4: baz {
+			ref = &{/foobar/baz};
+			lref = &n3;
+		};
+	};
+};
diff --git a/dtc/tests/path_offset.c b/dtc/tests/path_offset.c
new file mode 100644
index 0000000..82527d4
--- /dev/null
+++ b/dtc/tests/path_offset.c
@@ -0,0 +1,124 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_path_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int check_subnode(void *fdt, int parent, const char *name)
+{
+	int offset;
+	const struct fdt_node_header *nh;
+	uint32_t tag;
+
+	verbose_printf("Checking subnode \"%s\" of %d...", name, parent);
+	offset = fdt_subnode_offset(fdt, parent, name);
+	verbose_printf("offset %d...", offset);
+	if (offset < 0)
+		FAIL("fdt_subnode_offset(\"%s\"): %s", name, fdt_strerror(offset));
+	nh = fdt_offset_ptr(fdt, offset, sizeof(*nh));
+	verbose_printf("pointer %p\n", nh);
+	if (! nh)
+		FAIL("NULL retrieving subnode \"%s\"", name);
+
+	tag = fdt32_to_cpu(nh->tag);
+
+	if (tag != FDT_BEGIN_NODE)
+		FAIL("Incorrect tag 0x%08x on property \"%s\"", tag, name);
+	if (!nodename_eq(nh->name, name))
+		FAIL("Subnode name mismatch \"%s\" instead of \"%s\"",
+		     nh->name, name);
+
+	return offset;
+}
+
+static void check_path_offset(void *fdt, char *path, int offset)
+{
+	int rc;
+
+	verbose_printf("Checking offset of \"%s\" is %d...\n", path, offset);
+
+	rc = fdt_path_offset(fdt, path);
+	if (rc < 0)
+		FAIL("fdt_path_offset(\"%s\") failed: %s",
+		     path,  fdt_strerror(rc));
+	if (rc != offset)
+		FAIL("fdt_path_offset(\"%s\") returned incorrect offset"
+		     " %d instead of %d", path, rc, offset);
+}
+
+static void check_path_offset_namelen(void *fdt, char *path, int namelen,
+				      int offset)
+{
+	int rc;
+
+	verbose_printf("Checking offset of \"%s\" [first %d characters]"
+		       " is %d...\n", path, namelen, offset);
+
+	rc = fdt_path_offset_namelen(fdt, path, namelen);
+	if (rc == offset)
+		return;
+
+	if (rc < 0)
+		FAIL("fdt_path_offset_namelen(\"%s\", %d) failed: %s",
+		     path, namelen, fdt_strerror(rc));
+	else
+		FAIL("fdt_path_offset_namelen(\"%s\", %d) returned incorrect"
+		     " offset %d instead of %d", path, namelen, rc, offset);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode1_offset, subnode2_offset;
+	int subsubnode1_offset, subsubnode2_offset, subsubnode2_offset2;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_path_offset(fdt, "/", 0);
+
+	subnode1_offset = check_subnode(fdt, 0, "subnode@1");
+	subnode2_offset = check_subnode(fdt, 0, "subnode@2");
+
+	check_path_offset(fdt, "/subnode@1", subnode1_offset);
+	check_path_offset(fdt, "/subnode@2", subnode2_offset);
+
+	subsubnode1_offset = check_subnode(fdt, subnode1_offset, "subsubnode");
+	subsubnode2_offset = check_subnode(fdt, subnode2_offset, "subsubnode@0");
+	subsubnode2_offset2 = check_subnode(fdt, subnode2_offset, "subsubnode");
+
+	check_path_offset(fdt, "/subnode@1/subsubnode", subsubnode1_offset);
+	check_path_offset(fdt, "/subnode@2/subsubnode@0", subsubnode2_offset);
+	check_path_offset(fdt, "/subnode@2/subsubnode", subsubnode2_offset2);
+
+	/* Test paths with extraneous separators */
+	check_path_offset(fdt, "//", 0);
+	check_path_offset(fdt, "///", 0);
+	check_path_offset(fdt, "//subnode@1", subnode1_offset);
+	check_path_offset(fdt, "/subnode@1/", subnode1_offset);
+	check_path_offset(fdt, "//subnode@1///", subnode1_offset);
+	check_path_offset(fdt, "/subnode@2////subsubnode", subsubnode2_offset2);
+
+	/* Test fdt_path_offset_namelen() */
+	check_path_offset_namelen(fdt, "/subnode@1", 1, 0);
+	check_path_offset_namelen(fdt, "/subnode@1/subsubnode", 10, subnode1_offset);
+	check_path_offset_namelen(fdt, "/subnode@1/subsubnode", 11, subnode1_offset);
+	check_path_offset_namelen(fdt, "/subnode@2TRAILINGGARBAGE", 10, subnode2_offset);
+	check_path_offset_namelen(fdt, "/subnode@2TRAILINGGARBAGE", 11, -FDT_ERR_NOTFOUND);
+	check_path_offset_namelen(fdt, "/subnode@2/subsubnode@0/more", 23, subsubnode2_offset2);
+	check_path_offset_namelen(fdt, "/subnode@2/subsubnode@0/more", 22, -FDT_ERR_NOTFOUND);
+	check_path_offset_namelen(fdt, "/subnode@2/subsubnode@0/more", 24, subsubnode2_offset2);
+	check_path_offset_namelen(fdt, "/subnode@2/subsubnode@0/more", 25, -FDT_ERR_NOTFOUND);
+
+	PASS();
+}
diff --git a/dtc/tests/path_offset_aliases.c b/dtc/tests/path_offset_aliases.c
new file mode 100644
index 0000000..0112e72
--- /dev/null
+++ b/dtc/tests/path_offset_aliases.c
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_path_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright 2008 Kumar Gala, Freescale Semiconductor, Inc.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_alias(void *fdt, const char *full_path, const char *alias_path)
+{
+	int offset, offset_a;
+
+	offset = fdt_path_offset(fdt, full_path);
+	offset_a = fdt_path_offset(fdt, alias_path);
+
+	if (offset != offset_a)
+		FAIL("Mismatch between %s path_offset (%d) and %s path_offset alias (%d)",
+		     full_path, offset, alias_path, offset_a);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_alias(fdt, "/subnode@1", "s1");
+	check_alias(fdt, "/subnode@1/subsubnode", "ss1");
+	check_alias(fdt, "/subnode@1/subsubnode", "s1/subsubnode");
+	check_alias(fdt, "/subnode@1/subsubnode/subsubsubnode", "sss1");
+	check_alias(fdt, "/subnode@1/subsubnode/subsubsubnode", "ss1/subsubsubnode");
+	check_alias(fdt, "/subnode@1/subsubnode/subsubsubnode", "s1/subsubnode/subsubsubnode");
+
+	PASS();
+}
diff --git a/dtc/tests/pci-bridge-bad1.dts b/dtc/tests/pci-bridge-bad1.dts
new file mode 100644
index 0000000..17aac04
--- /dev/null
+++ b/dtc/tests/pci-bridge-bad1.dts
@@ -0,0 +1,16 @@
+/dts-v1/;
+
+/ {
+	compatible = "example,pci-bridge-ok";
+	#address-cells = < 2 >;
+	#size-cells = < 2 >;
+	abadname@0 {
+		device_type = "pci";
+		compatible = "example,pci-bridge";
+		#address-cells = < 3 >;
+		#size-cells = < 2 >;
+		reg = <0 0 0 0x1000>;
+		bus-range = <0 0xff>;
+		ranges = <0 0 0 0 0 0 0x10000>;
+	};
+};
diff --git a/dtc/tests/pci-bridge-bad2.dts b/dtc/tests/pci-bridge-bad2.dts
new file mode 100644
index 0000000..a7e5c05
--- /dev/null
+++ b/dtc/tests/pci-bridge-bad2.dts
@@ -0,0 +1,16 @@
+/dts-v1/;
+
+/ {
+	compatible = "example,pci-bridge-ok";
+	#address-cells = < 2 >;
+	#size-cells = < 2 >;
+	p@0 {
+		device_type = "pci";
+		compatible = "example,pci-bridge";
+		#address-cells = < 3 >;
+		#size-cells = < 2 >;
+		reg = <0 0 0 0x1000>;
+		bus-range = <0 0xff>;
+		ranges = <0 0 0 0 0 0 0x10000>;
+	};
+};
diff --git a/dtc/tests/pci-bridge-ok.dts b/dtc/tests/pci-bridge-ok.dts
new file mode 100644
index 0000000..02e32e0
--- /dev/null
+++ b/dtc/tests/pci-bridge-ok.dts
@@ -0,0 +1,25 @@
+/dts-v1/;
+
+/ {
+	compatible = "example,pci-bridge-ok";
+	#address-cells = < 2 >;
+	#size-cells = < 2 >;
+	pci@0 {
+		device_type = "pci";
+		compatible = "example,pci-bridge";
+		#address-cells = < 3 >;
+		#size-cells = < 2 >;
+		reg = <0 0 0 0x1000>;
+		bus-range = <0 0xff>;
+		ranges = <0 0 0 0 0 0 0x10000>;
+	};
+	pcie@10000000000 {
+		device_type = "pci";
+		compatible = "example,pcie-bridge";
+		#address-cells = < 3 >;
+		#size-cells = < 2 >;
+		reg = <0x10 0x00000000 0 0x1000>;
+		bus-range = <0 0xff>;
+		ranges = <0 0 0 0 0 0 0x10000>;
+	};
+};
diff --git a/dtc/tests/phandle_format.c b/dtc/tests/phandle_format.c
new file mode 100644
index 0000000..d00618f
--- /dev/null
+++ b/dtc/tests/phandle_format.c
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for phandle format options
+ * Copyright (C) 2009 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define PHANDLE_LEGACY	0x1
+#define PHANDLE_EPAPR	0x2
+#define PHANDLE_BOTH	0x3
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int phandle_format;
+	int n4;
+	uint32_t h4;
+
+	if (argc != 3)
+		CONFIG("Usage: %s <dtb file> <legacy|epapr|both>\n", argv[0]);
+
+	test_init(argc, argv);
+	fdt = load_blob(argv[1]);
+
+	if (streq(argv[2], "legacy"))
+		phandle_format = PHANDLE_LEGACY;
+	else if (streq(argv[2], "epapr"))
+		phandle_format = PHANDLE_EPAPR;
+	else if (streq(argv[2], "both"))
+		phandle_format = PHANDLE_BOTH;
+	else
+		CONFIG("Usage: %s <dtb file> <legacy|epapr|both>\n", argv[0]);
+
+	n4 = fdt_path_offset(fdt, "/node4");
+	if (n4 < 0)
+		FAIL("fdt_path_offset(/node4): %s", fdt_strerror(n4));
+
+	h4 = fdt_get_phandle(fdt, n4);
+	if ((h4 == 0) || (h4 == -1))
+		FAIL("/node4 has bad phandle 0x%x\n", h4);
+
+	if (phandle_format & PHANDLE_LEGACY)
+		check_getprop_cell(fdt, n4, "linux,phandle", h4);
+	else
+		if (fdt_getprop(fdt, n4, "linux,phandle", NULL))
+			FAIL("linux,phandle property present in non-legacy mode");
+
+	if (phandle_format & PHANDLE_EPAPR)
+		check_getprop_cell(fdt, n4, "phandle", h4);
+	else
+		if (fdt_getprop(fdt, n4, "phandle", NULL))
+			FAIL("phandle property present in legacy-only mode");
+
+	PASS();
+}
diff --git a/dtc/tests/prop-after-subnode.dts b/dtc/tests/prop-after-subnode.dts
new file mode 100644
index 0000000..6dd0b66
--- /dev/null
+++ b/dtc/tests/prop-after-subnode.dts
@@ -0,0 +1,9 @@
+/dts-v1/;
+
+/ {
+	node1 {
+	};
+	prop;
+	node2 {
+	};
+};
diff --git a/dtc/tests/property_iterate.c b/dtc/tests/property_iterate.c
new file mode 100644
index 0000000..9a67f49
--- /dev/null
+++ b/dtc/tests/property_iterate.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests that fdt_next_subnode() works as expected
+ *
+ * Copyright (C) 2013 Google, Inc
+ *
+ * Copyright (C) 2007 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void test_node(void *fdt, int parent_offset)
+{
+	uint32_t properties;
+	const fdt32_t *prop;
+	int offset, property;
+	int count;
+	int len;
+
+	/*
+	 * This property indicates the number of properties in our
+	 * test node to expect
+	 */
+	prop = fdt_getprop(fdt, parent_offset, "test-properties", &len);
+	if (!prop || len != sizeof(fdt32_t)) {
+		FAIL("Missing/invalid test-properties property at '%s'",
+		     fdt_get_name(fdt, parent_offset, NULL));
+	}
+	properties = fdt32_to_cpu(*prop);
+
+	count = 0;
+	offset = fdt_first_subnode(fdt, parent_offset);
+	if (offset < 0)
+		FAIL("Missing test node\n");
+
+	fdt_for_each_property_offset(property, fdt, offset)
+		count++;
+
+	if (count != properties) {
+		FAIL("Node '%s': Expected %d properties, got %d\n",
+		     fdt_get_name(fdt, parent_offset, NULL), properties,
+		     count);
+	}
+}
+
+static void check_fdt_next_subnode(void *fdt)
+{
+	int offset;
+	int count = 0;
+
+	fdt_for_each_subnode(offset, fdt, 0) {
+		test_node(fdt, offset);
+		count++;
+	}
+
+	if (count != 2)
+		FAIL("Expected %d tests, got %d\n", 2, count);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>", argv[0]);
+
+	fdt = load_blob(argv[1]);
+	if (!fdt)
+		FAIL("No device tree available");
+
+	check_fdt_next_subnode(fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/property_iterate.dts b/dtc/tests/property_iterate.dts
new file mode 100644
index 0000000..e8f5f8f
--- /dev/null
+++ b/dtc/tests/property_iterate.dts
@@ -0,0 +1,23 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	test1 {
+		test-properties = <3>;
+
+		test {
+			linux,phandle = <0x1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+
+	test2 {
+		test-properties = <0>;
+
+		test {
+		};
+	};
+};
diff --git a/dtc/tests/propname_escapes.c b/dtc/tests/propname_escapes.c
new file mode 100644
index 0000000..3e41e63
--- /dev/null
+++ b/dtc/tests/propname_escapes.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_getprop()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright (C) 2012 NVIDIA CORPORATION. All rights reserved.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_getprop_cell(fdt, 0, "#address-cells", 1);
+	check_getprop_cell(fdt, 0, "#gpio-cells", 2);
+
+	PASS();
+}
diff --git a/dtc/tests/propname_escapes.dts b/dtc/tests/propname_escapes.dts
new file mode 100644
index 0000000..9f70618
--- /dev/null
+++ b/dtc/tests/propname_escapes.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	\#gpio-cells = <2>;
+};
diff --git a/dtc/tests/pylibfdt_tests.py b/dtc/tests/pylibfdt_tests.py
new file mode 100644
index 0000000..64b5bd1
--- /dev/null
+++ b/dtc/tests/pylibfdt_tests.py
@@ -0,0 +1,592 @@
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+# pylibfdt - Tests for Flat Device Tree manipulation in Python
+# Copyright (C) 2017 Google, Inc.
+# Written by Simon Glass <sjg@chromium.org>
+#
+
+import struct
+import sys
+import types
+import unittest
+
+sys.path.insert(0, '../pylibfdt')
+import libfdt
+from libfdt import Fdt, FdtSw, FdtException, QUIET_NOTFOUND, QUIET_ALL
+
+TEST_ADDR_1H = 0xdeadbeef
+TEST_ADDR_1L = 0x00000000
+TEST_ADDR_1 = (TEST_ADDR_1H << 32) | TEST_ADDR_1L
+TEST_ADDR_1 = 0x8000000000000000
+TEST_SIZE_1H = 0x00000000
+TEST_SIZE_1L = 0x00100000
+TEST_SIZE_1 = (TEST_SIZE_1H << 32) | TEST_SIZE_1L
+TEST_ADDR_2H = 0
+TEST_ADDR_2L = 123456789
+TEST_ADDR_2 = (TEST_ADDR_2H << 32) | TEST_ADDR_2L
+TEST_SIZE_2H = 0
+TEST_SIZE_2L = 0o10000
+TEST_SIZE_2 = (TEST_SIZE_2H << 32) | TEST_SIZE_2L
+
+TEST_VALUE_1 = 0xdeadbeef
+TEST_VALUE_2 = 123456789
+
+TEST_VALUE64_1H = 0xdeadbeef
+TEST_VALUE64_1L = 0x01abcdef
+TEST_VALUE64_1 = (TEST_VALUE64_1H << 32) | TEST_VALUE64_1L
+
+PHANDLE_1 = 0x2000
+PHANDLE_2 = 0x2001
+
+TEST_BYTES_1 = b'hello world'
+
+TEST_STRING_1 = 'hello world'
+TEST_STRING_2 = 'hi world'
+TEST_STRING_3 = u'unicode \u01d3'
+
+
+def get_err(err_code):
+    """Convert an error code into an error message
+
+    Args:
+        err_code: Error code value (FDT_ERR_...)
+
+    Returns:
+        String error code
+    """
+    return 'pylibfdt error %d: %s' % (-err_code, libfdt.strerror(-err_code))
+
+def _ReadFdt(fname):
+    """Read a device tree file into an Fdt object, ready for use
+
+    Args:
+        fname: Filename to read from
+
+    Returns:
+        Fdt bytearray suitable for passing to libfdt functions
+    """
+    with open(fname, mode='rb') as f:
+        return libfdt.Fdt(f.read())
+
+class PyLibfdtBasicTests(unittest.TestCase):
+    """Test class for basic pylibfdt access functions
+
+    Properties:
+        fdt: Device tree file used for testing
+    """
+
+    def setUp(self):
+        """Read in the device tree we use for testing"""
+        self.fdt = _ReadFdt('test_tree1.dtb')
+        self.fdt2 = _ReadFdt('test_props.dtb')
+        self.fdt3 = _ReadFdt('aliases.dtb')
+
+    def GetPropList(self, node_path):
+        """Read a list of properties from a node
+
+        Args:
+            node_path: Full path to node, e.g. '/subnode@1/subsubnode'
+
+        Returns:
+            List of property names for that node, e.g. ['compatible', 'reg']
+        """
+        prop_list = []
+        node = self.fdt.path_offset(node_path)
+        poffset = self.fdt.first_property_offset(node, QUIET_NOTFOUND)
+        while poffset > 0:
+            prop = self.fdt.get_property_by_offset(poffset)
+            prop_list.append(prop.name)
+            poffset = self.fdt.next_property_offset(poffset, QUIET_NOTFOUND)
+        return prop_list
+
+    def GetSubnodes(self, node_path):
+        """Read a list of subnodes from a node
+
+        Args:
+            node_path: Full path to node, e.g. '/subnode@1/subsubnode'
+
+        Returns:
+            List of subnode names for that node, e.g. ['subsubnode', 'ss1']
+        """
+        subnode_list = []
+        node = self.fdt.path_offset(node_path)
+        offset = self.fdt.first_subnode(node, QUIET_NOTFOUND)
+        while offset > 0:
+            name = self.fdt.get_name(offset)
+            subnode_list.append(name)
+            offset = self.fdt.next_subnode(offset, QUIET_NOTFOUND)
+        return subnode_list
+
+    def testImport(self):
+        """Check that we can import the library correctly"""
+        self.assertEqual(type(libfdt), types.ModuleType)
+
+    def testBadFdt(self):
+        """Check that a filename provided accidentally is not accepted"""
+        with self.assertRaises(FdtException) as e:
+            fdt = libfdt.Fdt(b'a string')
+        self.assertEqual(e.exception.err, -libfdt.BADMAGIC)
+
+    def testSubnodeOffset(self):
+        """check that we can locate a subnode by name"""
+        node1 = self.fdt.path_offset('/subnode@1')
+        self.assertEqual(self.fdt.subnode_offset(0, 'subnode@1'), node1)
+
+        with self.assertRaises(FdtException) as e:
+            self.fdt.subnode_offset(0, 'missing')
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+
+        node2 = self.fdt.path_offset('/subnode@1/subsubnode')
+        self.assertEqual(self.fdt.subnode_offset(node1, 'subsubnode'), node2)
+
+    def testPathOffset(self):
+        """Check that we can find the offset of a node"""
+        self.assertEqual(self.fdt.path_offset('/'), 0)
+        self.assertTrue(self.fdt.path_offset('/subnode@1') > 0)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.path_offset('/wibble')
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+        self.assertEqual(self.fdt.path_offset('/wibble', QUIET_NOTFOUND),
+                          -libfdt.NOTFOUND)
+
+    def testPropertyOffset(self):
+        """Walk through all the properties in the root node"""
+        offset = self.fdt.first_property_offset(0)
+        self.assertTrue(offset > 0)
+        for i in range(5):
+            next_offset = self.fdt.next_property_offset(offset)
+            self.assertTrue(next_offset > offset)
+            offset = next_offset
+        self.assertEqual(self.fdt.next_property_offset(offset, QUIET_NOTFOUND),
+                          -libfdt.NOTFOUND)
+
+    def testPropertyOffsetExceptions(self):
+        """Check that exceptions are raised as expected"""
+        with self.assertRaises(FdtException) as e:
+            self.fdt.first_property_offset(107)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+
+        # Quieten the NOTFOUND exception and check that a BADOFFSET
+        # exception is still raised.
+        with self.assertRaises(FdtException) as e:
+            self.fdt.first_property_offset(107, QUIET_NOTFOUND)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.next_property_offset(107, QUIET_NOTFOUND)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+
+        # Check that NOTFOUND can be quietened.
+        node = self.fdt.path_offset('/subnode@1/ss1')
+        self.assertEqual(self.fdt.first_property_offset(node, QUIET_NOTFOUND),
+                          -libfdt.NOTFOUND)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.first_property_offset(node)
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+
+    def testGetName(self):
+        """Check that we can get the name of a node"""
+        self.assertEqual(self.fdt.get_name(0), '')
+        node = self.fdt.path_offset('/subnode@1/subsubnode')
+        self.assertEqual(self.fdt.get_name(node), 'subsubnode')
+
+        with self.assertRaises(FdtException) as e:
+            self.fdt.get_name(-2)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+
+    def testGetPropertyByOffset(self):
+        """Check that we can read the name and contents of a property"""
+        root = 0
+        poffset = self.fdt.first_property_offset(root)
+        prop = self.fdt.get_property_by_offset(poffset)
+        self.assertEqual(prop.name, 'compatible')
+        self.assertEqual(prop, b'test_tree1\0')
+
+        with self.assertRaises(FdtException) as e:
+            self.fdt.get_property_by_offset(-2)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+        self.assertEqual(
+                -libfdt.BADOFFSET,
+                self.fdt.get_property_by_offset(-2, [libfdt.BADOFFSET]))
+
+    def testGetProp(self):
+        """Check that we can read the contents of a property by name"""
+        root = self.fdt.path_offset('/')
+        value = self.fdt.getprop(root, "compatible")
+        self.assertEqual(value, b'test_tree1\0')
+        self.assertEqual(-libfdt.NOTFOUND, self.fdt.getprop(root, 'missing',
+                                                             QUIET_NOTFOUND))
+
+        with self.assertRaises(FdtException) as e:
+            self.fdt.getprop(root, 'missing')
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+
+        node = self.fdt.path_offset('/subnode@1/subsubnode')
+        value = self.fdt.getprop(node, "compatible")
+        self.assertEqual(value, b'subsubnode1\0subsubnode\0')
+
+    def testStrError(self):
+        """Check that we can get an error string"""
+        self.assertEqual(libfdt.strerror(-libfdt.NOTFOUND),
+                          'FDT_ERR_NOTFOUND')
+
+    def testNextNodeOffset(self):
+        """Check that we can walk through nodes"""
+        node_list = []
+        node = 0
+        depth = 0
+        while depth >= 0:
+            node_list.append([depth, self.fdt.get_name(node)])
+            node, depth = self.fdt.next_node(node, depth, (libfdt.BADOFFSET,))
+        self.assertEqual(node_list, [
+            [0, ''],
+            [1, 'subnode@1'],
+            [2, 'subsubnode'],
+            [2, 'ss1'],
+            [1, 'subnode@2'],
+            [2, 'subsubnode@0'],
+            [2, 'ss2'],
+            ])
+
+    def testFirstNextSubnodeOffset(self):
+        """Check that we can walk through subnodes"""
+        node_list = []
+        node = self.fdt.first_subnode(0, QUIET_NOTFOUND)
+        while node >= 0:
+            node_list.append(self.fdt.get_name(node))
+            node = self.fdt.next_subnode(node, QUIET_NOTFOUND)
+        self.assertEqual(node_list, ['subnode@1', 'subnode@2'])
+
+    def testFirstNextSubnodeOffsetExceptions(self):
+        """Check except handling for first/next subnode functions"""
+        node = self.fdt.path_offset('/subnode@1/subsubnode', QUIET_NOTFOUND)
+        self.assertEqual(self.fdt.first_subnode(node, QUIET_NOTFOUND),
+                          -libfdt.NOTFOUND)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.first_subnode(node)
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+
+        node = self.fdt.path_offset('/subnode@1/ss1', QUIET_NOTFOUND)
+        self.assertEqual(self.fdt.next_subnode(node, QUIET_NOTFOUND),
+                          -libfdt.NOTFOUND)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.next_subnode(node)
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+
+    def testDeleteProperty(self):
+        """Test that we can delete a property"""
+        node_name = '/subnode@1'
+        self.assertEqual(self.GetPropList(node_name),
+                          ['compatible', 'reg', 'prop-int'])
+        node = self.fdt.path_offset('/%s' % node_name)
+        self.assertEqual(self.fdt.delprop(node, 'reg'), 0)
+        self.assertEqual(self.GetPropList(node_name),
+                          ['compatible', 'prop-int'])
+
+    def testHeader(self):
+        """Test that we can access the header values"""
+        self.assertEqual(self.fdt.magic(), 0xd00dfeed)
+        self.assertEqual(self.fdt.totalsize(), len(self.fdt._fdt))
+        self.assertEqual(self.fdt.off_dt_struct(), 88)
+        self.assertEqual(self.fdt.off_dt_strings(), 652)
+        self.assertEqual(self.fdt.off_mem_rsvmap(), 40)
+        self.assertEqual(self.fdt.version(), 17)
+        self.assertEqual(self.fdt.last_comp_version(), 16)
+        self.assertEqual(self.fdt.boot_cpuid_phys(), 0)
+        self.assertEqual(self.fdt.size_dt_strings(), 105)
+        self.assertEqual(self.fdt.size_dt_struct(), 564)
+
+    def testPack(self):
+        """Test that we can pack the tree after deleting something"""
+        orig_size = self.fdt.totalsize()
+        node = self.fdt.path_offset('/subnode@2', QUIET_NOTFOUND)
+        self.assertEqual(self.fdt.delprop(node, 'prop-int'), 0)
+        self.assertEqual(orig_size, self.fdt.totalsize())
+        self.assertEqual(self.fdt.pack(), 0)
+        self.assertTrue(self.fdt.totalsize() < orig_size)
+        self.assertEqual(self.fdt.totalsize(), len(self.fdt.as_bytearray()))
+
+    def testBadPropertyOffset(self):
+        """Test that bad property offsets are detected"""
+        with self.assertRaises(FdtException) as e:
+            self.fdt.get_property_by_offset(13)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.first_property_offset(3)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+        with self.assertRaises(FdtException) as e:
+            self.fdt.next_property_offset(3)
+        self.assertEqual(e.exception.err, -libfdt.BADOFFSET)
+
+    def testBadPathOffset(self):
+        """Test that bad path names are detected"""
+        with self.assertRaisesRegex(FdtException, get_err(libfdt.BADPATH)):
+            self.fdt.path_offset('not-present')
+
+    def testQuietAll(self):
+        """Check that exceptions can be masked by QUIET_ALL"""
+        self.assertEqual(-libfdt.NOTFOUND,
+                          self.fdt.path_offset('/missing', QUIET_ALL))
+        self.assertEqual(-libfdt.BADOFFSET,
+                          self.fdt.get_property_by_offset(13, QUIET_ALL))
+        self.assertEqual(-libfdt.BADPATH,
+                          self.fdt.path_offset('missing', QUIET_ALL))
+
+    def testIntegers(self):
+        """Check that integers can be passed and returned"""
+        self.assertEqual(0, libfdt.fdt_get_phandle(self.fdt._fdt, 0))
+        node2 = self.fdt.path_offset('/subnode@2')
+        self.assertEqual(0x2000, libfdt.fdt_get_phandle(self.fdt._fdt, node2))
+
+    def testGetPhandle(self):
+        """Test for the get_phandle() method"""
+        self.assertEqual(0, self.fdt.get_phandle(0))
+        node2 = self.fdt.path_offset('/subnode@2')
+        self.assertEqual(0x2000, self.fdt.get_phandle(node2))
+
+    def testGetAlias(self):
+        """Test for the get_alias() method"""
+        self.assertEqual("/subnode@1", self.fdt3.get_alias('s1'))
+        self.assertEqual("/subnode@1/subsubnode", self.fdt3.get_alias('ss1'))
+        self.assertEqual("/subnode@1/subsubnode/subsubsubnode", self.fdt3.get_alias('sss1'))
+
+    def testParentOffset(self):
+        """Test for the parent_offset() method"""
+        self.assertEqual(-libfdt.NOTFOUND,
+                          self.fdt.parent_offset(0, QUIET_NOTFOUND))
+        with self.assertRaises(FdtException) as e:
+            self.fdt.parent_offset(0)
+        self.assertEqual(e.exception.err, -libfdt.NOTFOUND)
+
+        node1 = self.fdt.path_offset('/subnode@2')
+        self.assertEqual(0, self.fdt.parent_offset(node1))
+        node2 = self.fdt.path_offset('/subnode@2/subsubnode@0')
+        self.assertEqual(node1, self.fdt.parent_offset(node2))
+
+    def testNodeOffsetByPhandle(self):
+        """Test for the node_offset_by_phandle() method"""
+        self.assertEqual(-libfdt.NOTFOUND,
+                          self.fdt.node_offset_by_phandle(1, QUIET_NOTFOUND))
+        node1 = self.fdt.path_offset('/subnode@2')
+        self.assertEqual(node1, self.fdt.node_offset_by_phandle(0x2000))
+        node2 = self.fdt.path_offset('/subnode@2/subsubnode@0')
+        self.assertEqual(node2, self.fdt.node_offset_by_phandle(0x2001))
+
+    def get_prop(self, name):
+        return self.fdt2.getprop(0, name)
+
+    def testGetIntProperties(self):
+        """Test that we can access properties as integers"""
+        self.assertEqual(0xdeadbeef, self.get_prop("prop-hex32").as_uint32())
+        self.assertEqual(123, self.get_prop("prop-uint32").as_uint32())
+        self.assertEqual(-2, self.get_prop("prop-int32").as_int32())
+        self.assertEqual(9223372036854775807,
+                          self.get_prop("prop-uint64").as_uint64())
+        self.assertEqual(-2, self.get_prop("prop-int64").as_int64())
+
+    def testReserveMap(self):
+        """Test that we can access the memory reserve map"""
+        self.assertEqual(2, self.fdt.num_mem_rsv())
+        self.assertEqual([ 0xdeadbeef00000000, 0x100000],
+                          self.fdt.get_mem_rsv(0))
+        self.assertEqual([123456789, 0o10000], self.fdt.get_mem_rsv(1))
+
+    def testEmpty(self):
+        """Test that we can create an empty tree"""
+        self.assertEqual(-libfdt.NOSPACE,
+                          Fdt.create_empty_tree(1, (libfdt.NOSPACE,)))
+        fdt = Fdt.create_empty_tree(128)
+        self.assertEqual(128, fdt.totalsize())
+
+    def testOpenInto(self):
+        """Test that we can resize a tree"""
+        fdt = Fdt.create_empty_tree(128)
+        self.assertEqual(128, fdt.totalsize())
+        fdt.resize(256)
+        self.assertEqual(256, fdt.totalsize())
+        fdt.pack()
+        self.assertTrue(fdt.totalsize() < 128)
+
+    def testSetProp(self):
+        """Test that we can update and create properties"""
+        node = self.fdt.path_offset('/subnode@1')
+        self.fdt.setprop(node, 'compatible', TEST_BYTES_1)
+        self.assertEqual(TEST_BYTES_1, self.fdt.getprop(node, 'compatible'))
+
+        # Check that this property is missing, and that we don't have space to
+        # add it
+        self.assertEqual(-libfdt.NOTFOUND,
+                          self.fdt.getprop(node, 'missing', QUIET_NOTFOUND))
+        self.assertEqual(-libfdt.NOSPACE,
+                          self.fdt.setprop(node, 'missing', TEST_BYTES_1,
+                                           quiet=(libfdt.NOSPACE,)))
+
+        # Expand the device tree so we now have room
+        self.fdt.resize(self.fdt.totalsize() + 50)
+        self.fdt.setprop(node, 'missing', TEST_BYTES_1)
+        self.assertEqual(TEST_BYTES_1, self.fdt.getprop(node, 'missing'))
+
+    def testSetPropU32(self):
+        """Test that we can update and create integer properties"""
+        node = 0
+        prop = 'prop-int'
+        self.fdt.setprop_u32(node, prop, TEST_VALUE_1)
+        self.assertEqual(struct.pack('>I', TEST_VALUE_1),
+                          self.fdt.getprop(node, prop))
+
+    def testSetPropU64(self):
+        """Test that we can update and create integer properties"""
+        node = 0
+        prop = 'prop-int64'
+        self.fdt.setprop_u64(node, prop, TEST_VALUE64_1)
+        self.assertEqual(struct.pack('>Q', TEST_VALUE64_1),
+                          self.fdt.getprop(node, prop))
+
+    def testSetPropStr(self):
+        """Test that we can set a property to a particular string"""
+        node = 0
+        prop = 'prop-str'
+        self.assertEqual(TEST_STRING_1, self.fdt.getprop(node, prop).as_str())
+        self.fdt.setprop_str(node, prop, TEST_STRING_2)
+        self.assertEqual(TEST_STRING_2, self.fdt.getprop(node, prop).as_str())
+        with self.assertRaises(ValueError) as e:
+            self.fdt.getprop(node, 'prop-int').as_str()
+        self.assertIn('lacks nul termination', str(e.exception))
+
+        node2 = self.fdt.path_offset('/subnode@1/subsubnode')
+        with self.assertRaises(ValueError) as e:
+            self.fdt.getprop(node2, 'compatible').as_str()
+        self.assertIn('embedded nul', str(e.exception))
+
+        # Expand the device tree so we now have room
+        self.fdt.resize(self.fdt.totalsize() + 50)
+        prop = 'prop-unicode'
+        self.fdt.setprop_str(node, prop, TEST_STRING_3)
+        self.assertEqual(TEST_STRING_3,
+                          self.fdt.getprop(node, prop).as_str())
+
+    def testSetName(self):
+        """Test that we can update a node name"""
+        node = self.fdt.path_offset('/subnode@1')
+        old_val = self.fdt.get_name(node)
+        self.fdt.set_name(node, 'test')
+        self.assertEqual('test', self.fdt.get_name(node))
+
+        with self.assertRaises(ValueError) as e:
+            self.fdt.set_name(node, 'some\0name')
+        self.assertIn('embedded nul', str(e.exception))
+
+        with self.assertRaises(ValueError) as e:
+            self.fdt.set_name(node, 'name\0')
+        self.assertIn('embedded nul', str(e.exception))
+
+    def testAddDeleteNodes(self):
+        """Test that we can add and delete nodes"""
+        node_name = '/subnode@1'
+        self.assertEqual(self.GetSubnodes(node_name), ['subsubnode', 'ss1'])
+        node = self.fdt.path_offset('%s/subsubnode' % node_name)
+        self.assertEqual(self.fdt.del_node(node, 'subsubnode'), 0)
+        self.assertEqual(self.GetSubnodes(node_name), ['ss1'])
+
+        node = self.fdt.path_offset(node_name)
+        offset = self.fdt.add_subnode(node, 'more')
+        self.assertTrue(offset > 0)
+        self.assertEqual(self.GetSubnodes(node_name), ['more', 'ss1'])
+
+
+class PyLibfdtSwTests(unittest.TestCase):
+    """Test class for pylibfdt sequential-write DT creation
+    """
+    def assertOk(self, err_code):
+        self.assertEqual(0, err_code)
+
+    def testCreate(self):
+        # First check the minimum size and also the FdtSw() constructor
+        with self.assertRaisesRegex(FdtException, get_err(libfdt.NOSPACE)):
+            self.assertEqual(-libfdt.NOSPACE, FdtSw(3))
+
+        sw = FdtSw()
+        sw.add_reservemap_entry(TEST_ADDR_1, TEST_SIZE_1)
+        sw.add_reservemap_entry(TEST_ADDR_2, TEST_SIZE_2)
+        sw.finish_reservemap()
+
+        sw.begin_node('')
+        sw.property_string('compatible', 'test_tree1')
+        sw.property_u32('prop-int', TEST_VALUE_1)
+
+        sw.property_u32('prop-int', TEST_VALUE_1)
+        sw.property_u64('prop-int64', TEST_VALUE64_1)
+        sw.property_string('prop-str', TEST_STRING_1)
+        sw.property_u32('#address-cells', 1)
+        sw.property_u32('#size-cells', 0)
+
+        sw.begin_node('subnode@1')
+        sw.property_string('compatible', 'subnode1')
+        sw.property_u32('reg', 1)
+        sw.property_cell('prop-int', TEST_VALUE_1)
+        sw.property('data', b'\x00data\x01')
+        sw.begin_node('subsubnode')
+        sw.property('compatible', b'subsubnode1\0subsubnode')
+        sw.property_cell('prop-int', TEST_VALUE_1)
+        sw.end_node()
+        sw.begin_node('ss1')
+        sw.end_node()
+        sw.end_node()
+
+        for i in range(2, 11):
+            with sw.add_node('subnode@%d' % i):
+                sw.property_u32('reg', 2)
+                sw.property_cell('linux,phandle', PHANDLE_1)
+                sw.property_cell('prop-int', TEST_VALUE_2)
+                sw.property_u32('#address-cells', 1)
+                sw.property_u32('#size-cells', 0)
+                with sw.add_node('subsubnode@0'):
+                    sw.property_u32('reg', 0)
+                    sw.property_cell('phandle', PHANDLE_2)
+                    sw.property('compatible', b'subsubnode2\0subsubnode')
+                    sw.property_cell('prop-int', TEST_VALUE_2)
+                with sw.add_node('ss2'):
+                    pass
+        sw.end_node()
+
+        fdt = sw.as_fdt()
+        self.assertEqual(2, fdt.num_mem_rsv())
+        self.assertEqual([TEST_ADDR_1, TEST_SIZE_1], fdt.get_mem_rsv(0))
+
+        # Make sure we can add a few more things
+        with sw.add_node('another'):
+            sw.property_u32('reg', 3)
+
+        # Make sure we can read from the tree too
+        node = sw.path_offset('/subnode@1')
+        self.assertEqual(b'subnode1\0', sw.getprop(node, 'compatible'))
+
+        # Make sure we did at least two resizes
+        self.assertTrue(len(fdt.as_bytearray()) > FdtSw.INC_SIZE * 2)
+
+
+class PyLibfdtRoTests(unittest.TestCase):
+    """Test class for read-only pylibfdt access functions
+
+    This just tests a few simple cases. Most of the tests are in
+    PyLibfdtBasicTests.
+
+    Properties:
+        fdt: Device tree file used for testing
+    """
+
+    def setUp(self):
+        """Read in the device tree we use for testing"""
+        with open('test_tree1.dtb', mode='rb') as f:
+            self.fdt = libfdt.FdtRo(f.read())
+
+    def testAccess(self):
+        """Basic sanity check for the FdtRo class"""
+        node = self.fdt.path_offset('/subnode@1')
+        self.assertEqual(b'subnode1\0',
+                         self.fdt.getprop(node, 'compatible'))
+        node = self.fdt.first_subnode(node)
+        self.assertEqual(b'this is a placeholder string\0string2\0',
+                         self.fdt.getprop(node, 'placeholder'))
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/dtc/tests/references.c b/dtc/tests/references.c
new file mode 100644
index 0000000..d18e722
--- /dev/null
+++ b/dtc/tests/references.c
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for phandle references in dtc
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_ref(const void *fdt, int node, uint32_t checkref)
+{
+	const fdt32_t *p;
+	uint32_t ref;
+	int len;
+
+	p = fdt_getprop(fdt, node, "ref", &len);
+	if (!p)
+		FAIL("fdt_getprop(%d, \"ref\"): %s", node, fdt_strerror(len));
+	if (len != sizeof(*p))
+		FAIL("'ref' in node at %d has wrong size (%d instead of %zd)",
+		     node, len, sizeof(*p));
+	ref = fdt32_to_cpu(*p);
+	if (ref != checkref)
+		FAIL("'ref' in node at %d has value 0x%x instead of 0x%x",
+		     node, ref, checkref);
+
+	p = fdt_getprop(fdt, node, "lref", &len);
+	if (!p)
+		FAIL("fdt_getprop(%d, \"lref\"): %s", node, fdt_strerror(len));
+	if (len != sizeof(*p))
+		FAIL("'lref' in node at %d has wrong size (%d instead of %zd)",
+		     node, len, sizeof(*p));
+	ref = fdt32_to_cpu(*p);
+	if (ref != checkref)
+		FAIL("'lref' in node at %d has value 0x%x instead of 0x%x",
+		     node, ref, checkref);
+}
+
+static void check_rref(const void *fdt)
+{
+	const fdt32_t *p;
+	uint32_t ref;
+	int len;
+
+	p = fdt_getprop(fdt, 0, "rref", &len);
+	if (!p)
+		FAIL("fdt_getprop(0, \"rref\"): %s", fdt_strerror(len));
+	if (len != sizeof(*p))
+		FAIL("'rref' in root node has wrong size (%d instead of %zd)",
+		     len, sizeof(*p));
+	ref = fdt32_to_cpu(*p);
+	if (ref != fdt_get_phandle(fdt, 0))
+		FAIL("'rref' in root node has value 0x%x instead of 0x0", ref);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int n1, n2, n3, n4, n5, n6, err;
+	uint32_t h1, h2, h4, h5, h6, hn;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	n1 = fdt_path_offset(fdt, "/node1");
+	if (n1 < 0)
+		FAIL("fdt_path_offset(/node1): %s", fdt_strerror(n1));
+	n2 = fdt_path_offset(fdt, "/node2");
+	if (n2 < 0)
+		FAIL("fdt_path_offset(/node2): %s", fdt_strerror(n2));
+	n3 = fdt_path_offset(fdt, "/node3");
+	if (n3 < 0)
+		FAIL("fdt_path_offset(/node3): %s", fdt_strerror(n3));
+	n4 = fdt_path_offset(fdt, "/node4");
+	if (n4 < 0)
+		FAIL("fdt_path_offset(/node4): %s", fdt_strerror(n4));
+	n5 = fdt_path_offset(fdt, "/node5");
+	if (n5 < 0)
+		FAIL("fdt_path_offset(/node5): %s", fdt_strerror(n5));
+	n6 = fdt_path_offset(fdt, "/node6");
+	if (n6 < 0)
+		FAIL("fdt_path_offset(/node6): %s", fdt_strerror(n6));
+
+	h1 = fdt_get_phandle(fdt, n1);
+	h2 = fdt_get_phandle(fdt, n2);
+	h4 = fdt_get_phandle(fdt, n4);
+	h5 = fdt_get_phandle(fdt, n5);
+	h6 = fdt_get_phandle(fdt, n6);
+
+	if (h1 != 0x2000)
+		FAIL("/node1 has wrong phandle, 0x%x instead of 0x%x",
+		     h1, 0x2000);
+	if (h2 != 0x1)
+		FAIL("/node2 has wrong phandle, 0x%x instead of 0x%x",
+		     h2, 0x1);
+	if (h6 != FDT_MAX_PHANDLE)
+		FAIL("/node6 has wrong phandle, 0x%x instead of 0x%x",
+		     h6, FDT_MAX_PHANDLE);
+	if ((h4 == 0x2000) || (h4 == 0x1) || (h4 == 0))
+		FAIL("/node4 has bad phandle, 0x%x", h4);
+
+	if ((h5 == 0) || (h5 == -1))
+		FAIL("/node5 has bad phandle, 0x%x", h5);
+	if ((h5 == h4) || (h5 == h2) || (h5 == h1))
+		FAIL("/node5 has duplicate phandle, 0x%x", h5);
+
+	/*
+	 * /node6 has phandle FDT_MAX_PHANDLE, so fdt_generate_phandle() is
+	 * expected to fail.
+	 */
+	err = fdt_generate_phandle(fdt, &hn);
+	if (err != -FDT_ERR_NOPHANDLES)
+		FAIL("generated invalid phandle 0x%x\n", hn);
+
+	check_ref(fdt, n1, h2);
+	check_ref(fdt, n2, h1);
+	check_ref(fdt, n3, h4);
+
+	check_rref(fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/references.dts b/dtc/tests/references.dts
new file mode 100644
index 0000000..b390639
--- /dev/null
+++ b/dtc/tests/references.dts
@@ -0,0 +1,41 @@
+/dts-v1/;
+
+/ {
+	rref = <&{/}>;
+
+	/* Explicit phandles */
+	n1: node1 {
+		linux,phandle = <0x2000>;
+		ref = <&{/node2}>; /* reference precedes target */
+		lref = <&n2>;
+	};
+	n2: node2 {
+		phandle = <0x1>;
+		ref = <&{/node1}>; /* reference after target */
+		lref = <&n1>;
+	};
+
+	/* Implicit phandles */
+	n3: node3 {
+		ref = <&{/node4}>;
+		lref = <&n4>;
+	};
+	n4: node4 {
+	};
+
+	/* Explicit phandle with implicit value */
+	/* This self-reference is the standard way to tag a node as requiring
+	 * a phandle (perhaps for reference by nodes that will be dynamically
+	 * added) without explicitly allocating it a phandle.
+	 * The self-reference requires some special internal handling, though
+	 * so check it actually works */
+	n5: node5 {
+		linux,phandle = <&n5>;
+		phandle = <&n5>;
+	};
+
+	node6 {
+		linux,phandle = <0xfffffffe>;
+		phandle = <0xfffffffe>;
+	};
+};
diff --git a/dtc/tests/reg-ranges-root.dts b/dtc/tests/reg-ranges-root.dts
new file mode 100644
index 0000000..9935b41
--- /dev/null
+++ b/dtc/tests/reg-ranges-root.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	reg = <0x1000 0x10>;
+	ranges = <0x1000 0x2000 0x1000>;
+};
diff --git a/dtc/tests/reg-without-unit-addr.dts b/dtc/tests/reg-without-unit-addr.dts
new file mode 100644
index 0000000..aaf8af7
--- /dev/null
+++ b/dtc/tests/reg-without-unit-addr.dts
@@ -0,0 +1,10 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	node {
+		reg = <0 1>;
+	};
+};
diff --git a/dtc/tests/reuse-label.dts b/dtc/tests/reuse-label.dts
new file mode 100644
index 0000000..98b5ca9
--- /dev/null
+++ b/dtc/tests/reuse-label.dts
@@ -0,0 +1,15 @@
+/dts-v1/;
+
+/ {
+	label: property1 = "foo";
+	label: property2 = "bar";
+
+	test1 = &label;
+
+	label: node1 {
+		prop = "foo";
+	};
+	label: node2 {
+		prop = "bar";
+	};
+};
diff --git a/dtc/tests/reuse-label1.dts b/dtc/tests/reuse-label1.dts
new file mode 100644
index 0000000..f229569
--- /dev/null
+++ b/dtc/tests/reuse-label1.dts
@@ -0,0 +1,10 @@
+/dts-v1/;
+
+/ {
+	label: node1 {
+		prop = "foo";
+	};
+	label: node2 {
+		prop = "bar";
+	};
+};
diff --git a/dtc/tests/reuse-label2.dts b/dtc/tests/reuse-label2.dts
new file mode 100644
index 0000000..01ea6b2
--- /dev/null
+++ b/dtc/tests/reuse-label2.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	label: property1 = "foo";
+	label: property2 = "bar";
+};
diff --git a/dtc/tests/reuse-label3.dts b/dtc/tests/reuse-label3.dts
new file mode 100644
index 0000000..fa3d2c7
--- /dev/null
+++ b/dtc/tests/reuse-label3.dts
@@ -0,0 +1,9 @@
+/dts-v1/;
+
+/ {
+	label: property = "foo";
+
+	label: node {
+		property = "foo";
+	};
+};
diff --git a/dtc/tests/reuse-label4.dts b/dtc/tests/reuse-label4.dts
new file mode 100644
index 0000000..6805de3
--- /dev/null
+++ b/dtc/tests/reuse-label4.dts
@@ -0,0 +1,5 @@
+/dts-v1/;
+
+/ {
+	property = label: "foo" label:;
+};
diff --git a/dtc/tests/reuse-label5.dts b/dtc/tests/reuse-label5.dts
new file mode 100644
index 0000000..b7238e6
--- /dev/null
+++ b/dtc/tests/reuse-label5.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	prop1 = label: "foo";
+	prop2 = "bar" label:;
+};
diff --git a/dtc/tests/reuse-label6.dts b/dtc/tests/reuse-label6.dts
new file mode 100644
index 0000000..f5d507c
--- /dev/null
+++ b/dtc/tests/reuse-label6.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/ {
+	label: prop1 = "foo";
+	prop2 = "bar" label:;
+};
diff --git a/dtc/tests/root_node.c b/dtc/tests/root_node.c
new file mode 100644
index 0000000..37e6f05
--- /dev/null
+++ b/dtc/tests/root_node.c
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Basic testcase for read-only access
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	const struct fdt_node_header *nh;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	nh = fdt_offset_ptr(fdt, 0, sizeof(*nh));
+
+	if (! nh)
+		FAIL("NULL retrieving root node");
+
+	if (fdt32_to_cpu(nh->tag) != FDT_BEGIN_NODE)
+		FAIL("Wrong tag on root node");
+
+	if (strlen(nh->name) != 0)
+		FAIL("Wrong name for root node, \"%s\" instead of empty",
+		     nh->name);
+
+	PASS();
+}
diff --git a/dtc/tests/run_tests.sh b/dtc/tests/run_tests.sh
new file mode 100755
index 0000000..0e270fe
--- /dev/null
+++ b/dtc/tests/run_tests.sh
@@ -0,0 +1,1104 @@
+#! /bin/sh
+
+SRCDIR=`dirname "$0"`
+. "$SRCDIR/testutils.sh"
+
+if [ -z "$CC" ]; then
+    CC=cc
+fi
+
+if [ -z "$PYTHON" ]; then
+    PYTHON=python3
+fi
+
+if [ -n "$NO_PYTHON" ]; then
+    if [ "$NO_PYTHON" != "0" ]; then
+        no_python=true
+    else
+        no_python=false
+    fi
+else
+    if [ -f ../pylibfdt/_libfdt.so ] || [ -f ../pylibfdt/_libfdt.cpython-3*.so ]; then
+        no_python=false
+    else
+        no_python=true
+    fi
+fi
+
+if [ -n "$NO_YAML" ]; then
+    if [ "$NO_YAML" != "0" ]; then
+        no_yaml=true
+    else
+        no_yaml=false
+    fi
+else
+    if pkg-config --exists yaml-0.1; then
+        no_yaml=false
+    else
+        no_yaml=true
+    fi
+fi
+
+# stat differs between platforms
+if [ -z "$STATSZ" ]; then
+	stat --version 2>/dev/null | grep -q 'GNU'
+	GNUSTAT=$?
+	if [ "$GNUSTAT" -ne 0 ]; then
+		# Assume BSD stat if we can't detect as GNU stat
+		STATSZ="stat -f %Uz"
+	else
+		STATSZ="stat -c %s"
+	fi
+fi
+
+# Help things find the libfdt shared object
+if [ -z "$TEST_LIBDIR" ]; then
+    TEST_LIBDIR=../libfdt
+fi
+export LD_LIBRARY_PATH="$TEST_LIBDIR"
+
+export QUIET_TEST=1
+STOP_ON_FAIL=0
+
+export VALGRIND=
+VGCODE=126
+
+tot_tests=0
+tot_pass=0
+tot_fail=0
+tot_config=0
+tot_vg=0
+tot_strange=0
+
+base_run_test() {
+    tot_tests=$((tot_tests + 1))
+    if VALGRIND="$VALGRIND" "$@"; then
+	tot_pass=$((tot_pass + 1))
+    else
+	ret="$?"
+	if [ "$STOP_ON_FAIL" -eq 1 ]; then
+	    exit 1
+	fi
+	if [ "$ret" -eq 1 ]; then
+	    tot_config=$((tot_config + 1))
+	elif [ "$ret" -eq 2 ]; then
+	    tot_fail=$((tot_fail + 1))
+	elif [ "$ret" -eq $VGCODE ]; then
+	    tot_vg=$((tot_vg + 1))
+	else
+	    tot_strange=$((tot_strange + 1))
+	fi
+    fi
+}
+
+shorten_echo () {
+    limit=32
+    printf "$1"
+    shift
+    for x; do
+	if [ ${#x} -le $limit ]; then
+	    printf " $x"
+	else
+	    short=$(echo "$x" | head -c$limit)
+	    printf " \"$short\"...<${#x} bytes>"
+	fi
+    done
+}
+
+run_test () {
+    printf "$*:	"
+    if [ -n "$VALGRIND" -a -f $1.supp ]; then
+	VGSUPP="--suppressions=$1.supp"
+    fi
+    base_run_test $VALGRIND $VGSUPP "./$@"
+}
+
+run_sh_test () {
+    printf "$*:	"
+    base_run_test sh "$@"
+}
+
+wrap_test () {
+    (
+	if verbose_run "$@"; then
+	    PASS
+	else
+	    ret="$?"
+	    if [ "$ret" -gt 127 ]; then
+		signame=$(kill -l $((ret - 128)))
+		FAIL "Killed by SIG$signame"
+	    elif [ "$ret" -eq $VGCODE ]; then
+		echo "VALGRIND ERROR"
+		exit $VGCODE
+	    else
+		FAIL "Returned error code $ret"
+	    fi
+	fi
+    )
+}
+
+run_wrap_test () {
+    shorten_echo "$@:	"
+    base_run_test wrap_test "$@"
+}
+
+wrap_error () {
+    (
+	if verbose_run "$@"; then
+	    FAIL "Expected non-zero return code"
+	else
+	    ret="$?"
+	    if [ "$ret" -gt 127 ]; then
+		signame=$(kill -l $((ret - 128)))
+		FAIL "Killed by SIG$signame"
+	    else
+		PASS
+	    fi
+	fi
+    )
+}
+
+run_wrap_error_test () {
+    shorten_echo "$@"
+    printf " {!= 0}:	"
+    base_run_test wrap_error "$@"
+}
+
+# $1: dtb file
+# $2: align base
+check_align () {
+    shorten_echo "check_align $@:	"
+    local size=$($STATSZ "$1")
+    local align="$2"
+    (
+	if [ $(($size % $align)) -eq 0 ] ;then
+	    PASS
+	else
+	    FAIL "Output size $size is not $align-byte aligned"
+	fi
+    )
+}
+
+run_dtc_test () {
+    printf "dtc $*:	"
+    base_run_test wrap_test $VALGRIND $DTC "$@"
+}
+
+asm_to_so () {
+    $CC -shared -o $1.test.so "$SRCDIR/data.S" $1.test.s
+}
+
+asm_to_so_test () {
+    run_wrap_test asm_to_so "$@"
+}
+
+run_fdtget_test () {
+    expect="$1"
+    shift
+    printf "fdtget-runtest.sh %s $*:	" "$(echo $expect)"
+    base_run_test sh "$SRCDIR/fdtget-runtest.sh" "$expect" "$@"
+}
+
+run_fdtput_test () {
+    expect="$1"
+    shift
+    shorten_echo fdtput-runtest.sh "$expect" "$@"
+    printf ":	"
+    base_run_test sh "$SRCDIR/fdtput-runtest.sh" "$expect" "$@"
+}
+
+run_fdtdump_test() {
+    file="$1"
+    shorten_echo fdtdump-runtest.sh "$file"
+    printf ":	"
+    base_run_test sh "$SRCDIR/fdtdump-runtest.sh" "$file" 2>/dev/null
+}
+
+run_fdtoverlay_test() {
+    expect="$1"
+    shift
+    shorten_echo fdtoverlay-runtest.sh "$expect" "$@"
+    printf ":	"
+    base_run_test sh "$SRCDIR/fdtoverlay-runtest.sh" "$expect" "$@"
+}
+
+BAD_FIXUP_TREES="bad_index \
+		empty \
+		empty_index \
+		index_trailing \
+		path_empty_prop \
+		path_only \
+		path_only_sep \
+		path_prop"
+
+# Test to exercise libfdt overlay application without dtc's overlay support
+libfdt_overlay_tests () {
+    # First test a doctored overlay which requires only local fixups
+    run_dtc_test -I dts -O dtb -o overlay_base_no_symbols.test.dtb "$SRCDIR/overlay_base.dts"
+    run_test check_path overlay_base_no_symbols.test.dtb not-exists "/__symbols__"
+    run_test check_path overlay_base_no_symbols.test.dtb not-exists "/__fixups__"
+    run_test check_path overlay_base_no_symbols.test.dtb not-exists "/__local_fixups__"
+
+    run_dtc_test -I dts -O dtb -o overlay_overlay_no_fixups.test.dtb "$SRCDIR/overlay_overlay_no_fixups.dts"
+    run_test check_path overlay_overlay_no_fixups.test.dtb not-exists "/__symbols__"
+    run_test check_path overlay_overlay_no_fixups.test.dtb not-exists "/__fixups__"
+    run_test check_path overlay_overlay_no_fixups.test.dtb exists "/__local_fixups__"
+
+    run_test overlay overlay_base_no_symbols.test.dtb overlay_overlay_no_fixups.test.dtb
+
+    # Then test with manually constructed fixups
+    run_dtc_test -I dts -O dtb -o overlay_base_manual_symbols.test.dtb "$SRCDIR/overlay_base_manual_symbols.dts"
+    run_test check_path overlay_base_manual_symbols.test.dtb exists "/__symbols__"
+    run_test check_path overlay_base_manual_symbols.test.dtb not-exists "/__fixups__"
+    run_test check_path overlay_base_manual_symbols.test.dtb not-exists "/__local_fixups__"
+
+    run_dtc_test -I dts -O dtb -o overlay_overlay_manual_fixups.test.dtb "$SRCDIR/overlay_overlay_manual_fixups.dts"
+    run_test check_path overlay_overlay_manual_fixups.test.dtb not-exists "/__symbols__"
+    run_test check_path overlay_overlay_manual_fixups.test.dtb exists "/__fixups__"
+    run_test check_path overlay_overlay_manual_fixups.test.dtb exists "/__local_fixups__"
+
+    run_test overlay overlay_base_manual_symbols.test.dtb overlay_overlay_manual_fixups.test.dtb
+
+    # test simplified plugin syntax
+    run_dtc_test -@ -I dts -O dtb -o overlay_overlay_simple.dtb "$SRCDIR/overlay_overlay_simple.dts"
+
+    # verify non-generation of local fixups
+    run_test check_path overlay_overlay_simple.dtb not-exists "/__local_fixups__"
+
+    # Bad fixup tests
+    for test in $BAD_FIXUP_TREES; do
+	tree="overlay_bad_fixup_$test"
+	run_dtc_test -I dts -O dtb -o $tree.test.dtb "$SRCDIR/$tree.dts"
+	run_test overlay_bad_fixup overlay_base_no_symbols.test.dtb $tree.test.dtb
+    done
+}
+
+# Tests to exercise dtc's overlay generation support
+dtc_overlay_tests () {
+    # Overlay tests for dtc
+    run_dtc_test -@ -I dts -O dtb -o overlay_base.test.dtb "$SRCDIR/overlay_base.dts"
+    run_test check_path overlay_base.test.dtb exists "/__symbols__"
+    run_test check_path overlay_base.test.dtb not-exists "/__fixups__"
+    run_test check_path overlay_base.test.dtb not-exists "/__local_fixups__"
+
+    # With syntactic sugar
+    run_dtc_test -I dts -O dtb -o overlay_overlay.test.dtb "$SRCDIR/overlay_overlay.dts"
+    run_test check_path overlay_overlay.test.dtb not-exists "/__symbols__"
+    run_test check_path overlay_overlay.test.dtb exists "/__fixups__"
+    run_test check_path overlay_overlay.test.dtb exists "/__local_fixups__"
+
+    # Without syntactic sugar
+    run_dtc_test -I dts -O dtb -o overlay_overlay_nosugar.test.dtb "$SRCDIR/overlay_overlay_nosugar.dts"
+    run_test check_path overlay_overlay_nosugar.test.dtb not-exists "/__symbols__"
+    run_test check_path overlay_overlay_nosugar.test.dtb exists "/__fixups__"
+    run_test check_path overlay_overlay_nosugar.test.dtb exists "/__local_fixups__"
+
+    # Using target-path
+    run_dtc_test -I dts -O dtb -o overlay_overlay_bypath.test.dtb "$SRCDIR/overlay_overlay_bypath.dts"
+    run_test check_path overlay_overlay_bypath.test.dtb not-exists "/__symbols__"
+    run_test check_path overlay_overlay_bypath.test.dtb not-exists "/__fixups__"
+    run_test check_path overlay_overlay_bypath.test.dtb exists "/__local_fixups__"
+
+    # Make sure local target references are resolved and nodes are merged and that path references are not
+    run_dtc_test -I dts -O dtb -o overlay_overlay_local_merge.test.dtb "$SRCDIR/overlay_overlay_local_merge.dts"
+    run_test check_path overlay_overlay_local_merge.test.dtb exists "/fragment@0/__overlay__/new-node/new-merged-node"
+    run_test check_path overlay_overlay_local_merge.test.dtb exists "/fragment@1/__overlay__/new-root-node"
+
+    # Check building works the same as manual constructions
+    run_test dtbs_equal_ordered overlay_overlay.test.dtb overlay_overlay_nosugar.test.dtb
+
+    run_dtc_test -I dts -O dtb -o overlay_overlay_manual_fixups.test.dtb "$SRCDIR/overlay_overlay_manual_fixups.dts"
+    run_test dtbs_equal_ordered overlay_overlay.test.dtb overlay_overlay_manual_fixups.test.dtb
+
+    run_dtc_test -I dts -O dtb -o overlay_overlay_no_fixups.test.dtb "$SRCDIR/overlay_overlay_no_fixups.dts"
+    run_test dtbs_equal_ordered overlay_overlay_bypath.test.dtb overlay_overlay_no_fixups.test.dtb
+
+    # Check we can actually apply the result
+    run_dtc_test -I dts -O dtb -o overlay_base_no_symbols.test.dtb "$SRCDIR/overlay_base.dts"
+    run_test overlay overlay_base.test.dtb overlay_overlay.test.dtb
+    run_test overlay overlay_base_no_symbols.test.dtb overlay_overlay_bypath.test.dtb
+
+    # test plugin source to dtb and back
+    run_dtc_test -I dtb -O dts -o overlay_overlay_decompile.test.dts overlay_overlay.test.dtb
+    run_dtc_test -I dts -O dtb -o overlay_overlay_decompile.test.dtb overlay_overlay_decompile.test.dts
+    run_test dtbs_equal_ordered overlay_overlay.test.dtb overlay_overlay_decompile.test.dtb
+
+    # Test generation of aliases instead of symbols
+    run_dtc_test -A -I dts -O dtb -o overlay_base_with_aliases.dtb "$SRCDIR/overlay_base.dts"
+    run_test check_path overlay_base_with_aliases.dtb exists "/aliases"
+    run_test check_path overlay_base_with_aliases.dtb not-exists "/__symbols__"
+    run_test check_path overlay_base_with_aliases.dtb not-exists "/__fixups__"
+    run_test check_path overlay_base_with_aliases.dtb not-exists "/__local_fixups__"
+}
+
+tree1_tests () {
+    TREE=$1
+
+    # Read-only tests
+    run_test get_mem_rsv $TREE
+    run_test root_node $TREE
+    run_test find_property $TREE
+    run_test subnode_offset $TREE
+    run_test path_offset $TREE
+    run_test get_name $TREE
+    run_test getprop $TREE
+    run_test get_prop_offset $TREE
+    run_test get_phandle $TREE
+    run_test get_path $TREE
+    run_test supernode_atdepth_offset $TREE
+    run_test parent_offset $TREE
+    run_test node_offset_by_prop_value $TREE
+    run_test node_offset_by_phandle $TREE
+    run_test node_check_compatible $TREE
+    run_test node_offset_by_compatible $TREE
+    run_test notfound $TREE
+
+    # Write-in-place tests
+    run_test setprop_inplace $TREE
+    run_test nop_property $TREE
+    run_test nop_node $TREE
+}
+
+tree1_tests_rw () {
+    TREE=$1
+
+    # Read-write tests
+    run_test set_name $TREE
+    run_test setprop $TREE
+    run_test del_property $TREE
+    run_test del_node $TREE
+}
+
+check_tests () {
+    tree="$1"
+    shift
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" "$@" -- -I dts -O dtb $tree
+    run_dtc_test -I dts -O dtb -o $tree.test.dtb -f $tree
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" "$@" -- -I dtb -O dtb $tree.test.dtb
+}
+
+ALL_LAYOUTS="mts mst tms tsm smt stm"
+
+libfdt_tests () {
+    tree1_tests test_tree1.dtb
+
+    run_dtc_test -I dts -O dtb -o addresses.test.dtb "$SRCDIR/addresses.dts"
+    run_test addr_size_cells addresses.test.dtb
+    run_dtc_test -I dts -O dtb -o addresses2.test.dtb "$SRCDIR/empty.dts"
+    run_test addr_size_cells2 addresses2.test.dtb
+
+    run_dtc_test -I dts -O dtb -o stringlist.test.dtb "$SRCDIR/stringlist.dts"
+    run_test stringlist stringlist.test.dtb
+
+    for flags in default no_name_dedup; do
+        # Sequential write tests
+        run_test sw_tree1 fixed $flags
+        tree1_tests sw_tree1.test.dtb
+        tree1_tests unfinished_tree1.test.dtb
+        run_test dtbs_equal_ordered test_tree1.dtb sw_tree1.test.dtb
+        run_test sw_states
+
+        # Resizing tests
+        for mode in resize realloc newalloc; do
+            run_test sw_tree1 $mode $flags
+            tree1_tests sw_tree1.test.dtb
+            tree1_tests unfinished_tree1.test.dtb
+            run_test dtbs_equal_ordered test_tree1.dtb sw_tree1.test.dtb
+        done
+    done
+
+    # fdt_move tests
+    for tree in test_tree1.dtb sw_tree1.test.dtb unfinished_tree1.test.dtb; do
+	rm -f moved.$tree shunted.$tree deshunted.$tree
+	run_test move_and_save $tree
+	run_test dtbs_equal_ordered $tree moved.$tree
+	run_test dtbs_equal_ordered $tree shunted.$tree
+	run_test dtbs_equal_ordered $tree deshunted.$tree
+    done
+
+    # v16 and alternate layout tests
+    for tree in test_tree1.dtb; do
+	for version in 17 16; do
+	    for layout in $ALL_LAYOUTS; do
+		run_test mangle-layout $tree $version $layout
+		tree1_tests v$version.$layout.$tree
+		run_test dtbs_equal_ordered $tree v$version.$layout.$tree
+	    done
+	done
+    done
+
+    # Read-write tests
+    for basetree in test_tree1.dtb; do
+	for version in 17 16; do
+	    for layout in $ALL_LAYOUTS; do
+		tree=v$version.$layout.$basetree
+		rm -f opened.$tree repacked.$tree
+		run_test open_pack $tree
+		tree1_tests opened.$tree
+		tree1_tests repacked.$tree
+
+		tree1_tests_rw $tree
+		tree1_tests_rw opened.$tree
+		tree1_tests_rw repacked.$tree
+	    done
+	done
+    done
+    run_test rw_tree1
+    tree1_tests rw_tree1.test.dtb
+    tree1_tests_rw rw_tree1.test.dtb
+    run_test appendprop1
+    run_test appendprop2 appendprop1.test.dtb
+    run_dtc_test -I dts -O dtb -o appendprop.test.dtb "$SRCDIR/appendprop.dts"
+    run_test dtbs_equal_ordered appendprop2.test.dtb appendprop.test.dtb
+    libfdt_overlay_tests
+
+    for basetree in test_tree1.dtb sw_tree1.test.dtb rw_tree1.test.dtb; do
+	run_test nopulate $basetree
+	run_test dtbs_equal_ordered $basetree noppy.$basetree
+	tree1_tests noppy.$basetree
+	tree1_tests_rw noppy.$basetree
+    done
+
+    run_test rw_oom
+
+    run_dtc_test -I dts -O dtb -o subnode_iterate.dtb "$SRCDIR/subnode_iterate.dts"
+    run_test subnode_iterate subnode_iterate.dtb
+
+    run_dtc_test -I dts -O dtb -o property_iterate.dtb "$SRCDIR/property_iterate.dts"
+    run_test property_iterate property_iterate.dtb
+
+    run_dtc_test -I dts -O dtb -o unit-addr-without-reg.dtb "$SRCDIR/unit-addr-without-reg.dts"
+    run_test appendprop_addrrange unit-addr-without-reg.dtb 1 1 1
+    run_test appendprop_addrrange unit-addr-without-reg.dtb 2 2 2
+    run_test appendprop_addrrange unit-addr-without-reg.dtb 2 1 3
+
+    # Tests for behaviour on various sorts of corrupted trees
+    run_test truncated_property
+    run_test truncated_string
+    run_test truncated_memrsv
+
+    # Check aliases support in fdt_path_offset
+    run_dtc_test -I dts -O dtb -o aliases.dtb "$SRCDIR/aliases.dts"
+    run_test get_alias aliases.dtb
+    run_test path_offset_aliases aliases.dtb
+
+    # Specific bug tests
+    run_test add_subnode_with_nops
+    run_dtc_test -I dts -O dts -o sourceoutput.test.dts "$SRCDIR/sourceoutput.dts"
+    run_dtc_test -I dts -O dtb -o sourceoutput.test.dtb "$SRCDIR/sourceoutput.dts"
+    run_dtc_test -I dts -O dtb -o sourceoutput.test.dts.test.dtb sourceoutput.test.dts
+    run_test dtbs_equal_ordered sourceoutput.test.dtb sourceoutput.test.dts.test.dtb
+
+    run_dtc_test -I dts -O dtb -o embedded_nul.test.dtb "$SRCDIR/embedded_nul.dts"
+    run_dtc_test -I dts -O dtb -o embedded_nul_equiv.test.dtb "$SRCDIR/embedded_nul_equiv.dts"
+    run_test dtbs_equal_ordered embedded_nul.test.dtb embedded_nul_equiv.test.dtb
+
+    run_dtc_test -I dts -O dtb "$SRCDIR/bad-size-cells.dts"
+
+    run_wrap_error_test $DTC division-by-zero.dts
+    run_wrap_error_test $DTC bad-octal-literal.dts
+    run_dtc_test -I dts -O dtb "$SRCDIR/nul-in-escape.dts"
+    run_wrap_error_test $DTC nul-in-line-info1.dts
+    run_wrap_error_test $DTC nul-in-line-info2.dts
+
+    run_wrap_error_test $DTC -I dtb -O dts -o /dev/null ovf_size_strings.dtb
+
+    run_test check_header test_tree1.dtb
+
+    FSBASE=fs
+    rm -rf $FSBASE
+    mkdir -p $FSBASE
+    run_test fs_tree1 $FSBASE/test_tree1
+    run_dtc_test -I fs -O dts -o fs.test_tree1.test.dts $FSBASE/test_tree1
+    run_dtc_test -I fs -O dtb -o fs.test_tree1.test.dtb $FSBASE/test_tree1
+    run_test dtbs_equal_unordered -m fs.test_tree1.test.dtb test_tree1.dtb
+
+    # check full tests
+    for good in test_tree1.dtb; do
+	run_test check_full $good
+    done
+    for bad in truncated_property.dtb truncated_string.dtb \
+		truncated_memrsv.dtb two_roots.dtb named_root.dtb; do
+	run_test check_full -n $bad
+    done
+}
+
+dtc_tests () {
+    run_dtc_test -I dts -O dtb -o dtc_tree1.test.dtb "$SRCDIR/test_tree1.dts"
+    tree1_tests dtc_tree1.test.dtb
+    tree1_tests_rw dtc_tree1.test.dtb
+    run_test dtbs_equal_ordered dtc_tree1.test.dtb test_tree1.dtb
+
+    run_dtc_test -I dts -O dtb -o dtc_escapes.test.dtb "$SRCDIR/propname_escapes.dts"
+    run_test propname_escapes dtc_escapes.test.dtb
+
+    run_dtc_test -I dts -O dtb -o line_directives.test.dtb "$SRCDIR/line_directives.dts"
+
+    run_dtc_test -I dts -O dtb -o dtc_escapes.test.dtb "$SRCDIR/escapes.dts"
+    run_test string_escapes dtc_escapes.test.dtb
+
+    run_dtc_test -I dts -O dtb -o dtc_char_literal.test.dtb "$SRCDIR/char_literal.dts"
+    run_test char_literal dtc_char_literal.test.dtb
+
+    run_dtc_test -I dts -O dtb -o dtc_sized_cells.test.dtb "$SRCDIR/sized_cells.dts"
+    run_test sized_cells dtc_sized_cells.test.dtb
+
+    run_dtc_test -I dts -O dtb -o dtc_extra-terminating-null.test.dtb "$SRCDIR/extra-terminating-null.dts"
+    run_test extra-terminating-null dtc_extra-terminating-null.test.dtb
+
+    run_dtc_test -I dts -O dtb -o dtc_references.test.dtb "$SRCDIR/references.dts"
+    run_test references dtc_references.test.dtb
+
+    run_dtc_test -I dts -O dtb -o dtc_path-references.test.dtb "$SRCDIR/path-references.dts"
+    run_test path-references dtc_path-references.test.dtb
+
+    run_test phandle_format dtc_references.test.dtb epapr
+    for f in legacy epapr both; do
+	    run_dtc_test -I dts -O dtb -H $f -o dtc_references.test.$f.dtb "$SRCDIR/references.dts"
+	run_test phandle_format dtc_references.test.$f.dtb $f
+    done
+
+    run_dtc_test -I dts -O dtb -o multilabel.test.dtb "$SRCDIR/multilabel.dts"
+    run_test references multilabel.test.dtb
+
+    run_dtc_test -I dts -O dtb -o label_repeated.test.dtb "$SRCDIR/label_repeated.dts"
+
+    run_dtc_test -I dts -O dtb -o dtc_comments.test.dtb "$SRCDIR/comments.dts"
+    run_dtc_test -I dts -O dtb -o dtc_comments-cmp.test.dtb "$SRCDIR/comments-cmp.dts"
+    run_test dtbs_equal_ordered dtc_comments.test.dtb dtc_comments-cmp.test.dtb
+
+    # Check /include/ directive
+    run_dtc_test -I dts -O dtb -o includes.test.dtb "$SRCDIR/include0.dts"
+    run_test dtbs_equal_ordered includes.test.dtb test_tree1.dtb
+
+    # Check /incbin/ directive
+    run_dtc_test -I dts -O dtb -o incbin.test.dtb "$SRCDIR/incbin.dts"
+    run_test incbin "$SRCDIR/incbin.bin" incbin.test.dtb
+
+    # Check boot_cpuid_phys handling
+    run_dtc_test -I dts -O dtb -o boot_cpuid.test.dtb "$SRCDIR/boot-cpuid.dts"
+    run_test boot-cpuid boot_cpuid.test.dtb 16
+
+    run_dtc_test -I dts -O dtb -b 17 -o boot_cpuid_17.test.dtb "$SRCDIR/boot-cpuid.dts"
+    run_test boot-cpuid boot_cpuid_17.test.dtb 17
+
+    run_dtc_test -I dtb -O dtb -o preserve_boot_cpuid.test.dtb boot_cpuid.test.dtb
+    run_test boot-cpuid preserve_boot_cpuid.test.dtb 16
+    run_test dtbs_equal_ordered preserve_boot_cpuid.test.dtb boot_cpuid.test.dtb
+
+    run_dtc_test -I dtb -O dtb -o preserve_boot_cpuid_17.test.dtb boot_cpuid_17.test.dtb
+    run_test boot-cpuid preserve_boot_cpuid_17.test.dtb 17
+    run_test dtbs_equal_ordered preserve_boot_cpuid_17.test.dtb boot_cpuid_17.test.dtb
+
+    run_dtc_test -I dtb -O dtb -b17 -o override17_boot_cpuid.test.dtb boot_cpuid.test.dtb
+    run_test boot-cpuid override17_boot_cpuid.test.dtb 17
+
+    run_dtc_test -I dtb -O dtb -b0 -o override0_boot_cpuid_17.test.dtb boot_cpuid_17.test.dtb
+    run_test boot-cpuid override0_boot_cpuid_17.test.dtb 0
+
+
+    # Check -Oasm mode
+    for tree in test_tree1.dts escapes.dts references.dts path-references.dts \
+	comments.dts aliases.dts include0.dts incbin.dts \
+	value-labels.dts ; do
+	run_dtc_test -I dts -O asm -o oasm_$tree.test.s "$SRCDIR/$tree"
+	asm_to_so_test oasm_$tree
+	run_dtc_test -I dts -O dtb -o $tree.test.dtb "$SRCDIR/$tree"
+	run_test asm_tree_dump ./oasm_$tree.test.so oasm_$tree.test.dtb
+	run_wrap_test cmp oasm_$tree.test.dtb $tree.test.dtb
+    done
+
+    run_test value-labels ./oasm_value-labels.dts.test.so
+
+    # Check -Odts mode preserve all dtb information
+    for tree in test_tree1.dtb dtc_tree1.test.dtb dtc_escapes.test.dtb \
+	dtc_extra-terminating-null.test.dtb dtc_references.test.dtb; do
+	run_dtc_test -I dtb -O dts -o odts_$tree.test.dts $tree
+	run_dtc_test -I dts -O dtb -o odts_$tree.test.dtb odts_$tree.test.dts
+	run_test dtbs_equal_ordered $tree odts_$tree.test.dtb
+    done
+
+    # Check -Odts preserving type information
+    for tree in type-preservation.dts; do
+        run_dtc_test -I dts -O dts -o $tree.test.dts "$SRCDIR/$tree"
+        run_dtc_test -I dts -O dts $tree.test.dts
+        run_wrap_test cmp "$SRCDIR/$tree" $tree.test.dts
+    done
+    for tree in path-references; do
+        run_dtc_test -I dts -O dtb -o $tree.test.dtb "$SRCDIR/$tree.dts"
+        run_dtc_test -I dts -O dts -o $tree.test.dts "$SRCDIR/$tree.dts"
+        run_dtc_test -I dts -O dtb -o $tree.test.dts.test.dtb $tree.test.dts
+        run_test dtbs_equal_ordered $tree.test.dtb $tree.test.dts.test.dtb
+    done
+
+    # Check -Oyaml output
+    if ! $no_yaml; then
+            for tree in type-preservation; do
+                run_dtc_test -I dts -O yaml -o $tree.test.dt.yaml "$SRCDIR/$tree.dts"
+                run_wrap_test cmp "$SRCDIR/$tree.dt.yaml" $tree.test.dt.yaml
+            done
+    fi
+
+    # Check version conversions
+    for tree in test_tree1.dtb ; do
+	 for aver in 1 2 3 16 17; do
+	     atree="ov${aver}_$tree.test.dtb"
+	     run_dtc_test -I dtb -O dtb -V$aver -o $atree $tree
+	     for bver in 16 17; do
+		 btree="ov${bver}_$atree"
+		 run_dtc_test -I dtb -O dtb -V$bver -o $btree $atree
+		 run_test dtbs_equal_ordered $btree $tree
+	     done
+	 done
+    done
+
+    # Check merge/overlay functionality
+    run_dtc_test -I dts -O dtb -o dtc_tree1_merge.test.dtb "$SRCDIR/test_tree1_merge.dts"
+    tree1_tests dtc_tree1_merge.test.dtb test_tree1.dtb
+    run_dtc_test -I dts -O dtb -o dtc_tree1_merge_labelled.test.dtb "$SRCDIR/test_tree1_merge_labelled.dts"
+    tree1_tests dtc_tree1_merge_labelled.test.dtb test_tree1.dtb
+    run_dtc_test -I dts -O dtb -o dtc_tree1_label_noderef.test.dtb "$SRCDIR/test_tree1_label_noderef.dts"
+    run_test dtbs_equal_unordered dtc_tree1_label_noderef.test.dtb test_tree1.dtb
+    run_dtc_test -I dts -O dtb -o multilabel_merge.test.dtb "$SRCDIR/multilabel_merge.dts"
+    run_test references multilabel.test.dtb
+    run_test dtbs_equal_ordered multilabel.test.dtb multilabel_merge.test.dtb
+    run_dtc_test -I dts -O dtb -o dtc_tree1_merge_path.test.dtb "$SRCDIR/test_tree1_merge_path.dts"
+    tree1_tests dtc_tree1_merge_path.test.dtb test_tree1.dtb
+    run_wrap_error_test $DTC -I dts -O dtb -o /dev/null "$SRCDIR/test_label_ref.dts"
+
+    # Check prop/node delete functionality
+    run_dtc_test -I dts -O dtb -o dtc_tree1_delete.test.dtb "$SRCDIR/test_tree1_delete.dts"
+    tree1_tests dtc_tree1_delete.test.dtb
+
+    # Check omit-if-no-ref functionality
+    run_dtc_test -I dts -O dtb -o omit-no-ref.test.dtb "$SRCDIR/omit-no-ref.dts"
+    run_test check_path omit-no-ref.test.dtb not-exists "/node1"
+    run_test check_path omit-no-ref.test.dtb not-exists "/node2"
+    run_test check_path omit-no-ref.test.dtb exists "/node3"
+    run_test check_path omit-no-ref.test.dtb exists "/node4"
+
+    run_dtc_test -I dts -O dts -o delete_reinstate_multilabel.dts.test.dts "$SRCDIR/delete_reinstate_multilabel.dts"
+    run_wrap_test cmp delete_reinstate_multilabel.dts.test.dts "$SRCDIR/delete_reinstate_multilabel_ref.dts"
+
+    # Check some checks
+    check_tests "$SRCDIR/dup-nodename.dts" duplicate_node_names
+    check_tests "$SRCDIR/dup-propname.dts" duplicate_property_names
+    check_tests "$SRCDIR/dup-phandle.dts" explicit_phandles
+    check_tests "$SRCDIR/zero-phandle.dts" explicit_phandles
+    check_tests "$SRCDIR/minusone-phandle.dts" explicit_phandles
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" phandle_references -- -I dts -O dtb "$SRCDIR/nonexist-node-ref.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" phandle_references -- -I dts -O dtb "$SRCDIR/nonexist-label-ref.dts"
+    run_sh_test "$SRCDIR/dtc-fatal.sh" -I dts -O dtb "$SRCDIR/nonexist-node-ref2.dts"
+    check_tests "$SRCDIR/bad-name-property.dts" name_properties
+
+    check_tests "$SRCDIR/bad-ncells.dts" address_cells_is_cell size_cells_is_cell interrupts_extended_is_cell
+    check_tests "$SRCDIR/bad-string-props.dts" device_type_is_string model_is_string status_is_string label_is_string compatible_is_string_list names_is_string_list
+    check_tests "$SRCDIR/bad-chosen.dts" chosen_node_is_root
+    check_tests "$SRCDIR/bad-chosen.dts" chosen_node_bootargs
+    check_tests "$SRCDIR/bad-chosen.dts" chosen_node_stdout_path
+    check_tests "$SRCDIR/bad-reg-ranges.dts" reg_format ranges_format
+    check_tests "$SRCDIR/bad-empty-ranges.dts" ranges_format
+    check_tests "$SRCDIR/reg-ranges-root.dts" reg_format ranges_format
+    check_tests "$SRCDIR/bad-dma-ranges.dts" dma_ranges_format
+    check_tests "$SRCDIR/default-addr-size.dts" avoid_default_addr_size
+    check_tests "$SRCDIR/obsolete-chosen-interrupt-controller.dts" obsolete_chosen_interrupt_controller
+    check_tests "$SRCDIR/reg-without-unit-addr.dts" unit_address_vs_reg
+    check_tests "$SRCDIR/unit-addr-without-reg.dts" unit_address_vs_reg
+    check_tests "$SRCDIR/unit-addr-leading-0x.dts" unit_address_format
+    check_tests "$SRCDIR/unit-addr-leading-0s.dts" unit_address_format
+    check_tests "$SRCDIR/unit-addr-unique.dts" unique_unit_address
+    check_tests "$SRCDIR/bad-phandle-cells.dts" interrupts_extended_property
+    check_tests "$SRCDIR/bad-gpio.dts" gpios_property
+    check_tests "$SRCDIR/good-gpio.dts" -n gpios_property
+    check_tests "$SRCDIR/bad-graph.dts" graph_child_address
+    check_tests "$SRCDIR/bad-graph.dts" graph_port
+    check_tests "$SRCDIR/bad-graph.dts" graph_endpoint
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" deprecated_gpio_property -- -Wdeprecated_gpio_property -I dts -O dtb "$SRCDIR/bad-gpio.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" -n deprecated_gpio_property -- -Wdeprecated_gpio_property -I dts -O dtb "$SRCDIR/good-gpio.dts"
+    check_tests "$SRCDIR/bad-interrupt-cells.dts" interrupts_property
+    check_tests "$SRCDIR/bad-interrupt-controller.dts" interrupt_provider
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" node_name_chars -- -I dtb -O dtb bad_node_char.dtb
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" node_name_format -- -I dtb -O dtb bad_node_format.dtb
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" property_name_chars -- -I dtb -O dtb bad_prop_char.dtb
+
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" duplicate_label -- -I dts -O dtb "$SRCDIR/reuse-label1.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" duplicate_label -- -I dts -O dtb "$SRCDIR/reuse-label2.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" duplicate_label -- -I dts -O dtb "$SRCDIR/reuse-label3.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" duplicate_label -- -I dts -O dtb "$SRCDIR/reuse-label4.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" duplicate_label -- -I dts -O dtb "$SRCDIR/reuse-label5.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" duplicate_label -- -I dts -O dtb "$SRCDIR/reuse-label6.dts"
+
+    run_test check_path test_tree1.dtb exists "/subnode@1"
+    run_test check_path test_tree1.dtb not-exists "/subnode@10"
+
+    check_tests "$SRCDIR/pci-bridge-ok.dts" -n pci_bridge
+    check_tests "$SRCDIR/pci-bridge-bad1.dts" pci_bridge
+    check_tests "$SRCDIR/pci-bridge-bad2.dts" pci_bridge
+
+    check_tests "$SRCDIR/unit-addr-simple-bus-reg-mismatch.dts" simple_bus_reg
+    check_tests "$SRCDIR/unit-addr-simple-bus-compatible.dts" simple_bus_reg
+
+
+    # Check warning options
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" address_cells_is_cell interrupts_extended_is_cell -n size_cells_is_cell -- -Wno_size_cells_is_cell -I dts -O dtb "$SRCDIR/bad-ncells.dts"
+    run_sh_test "$SRCDIR/dtc-fails.sh" -n test-warn-output.test.dtb -I dts -O dtb "$SRCDIR/bad-ncells.dts"
+    run_sh_test "$SRCDIR/dtc-fails.sh" test-error-output.test.dtb -I dts -O dtb bad-ncells.dts -Esize_cells_is_cell
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" always_fail -- -Walways_fail -I dts -O dtb "$SRCDIR/test_tree1.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" -n always_fail -- -Walways_fail -Wno_always_fail -I dts -O dtb "$SRCDIR/test_tree1.dts"
+    run_sh_test "$SRCDIR/dtc-fails.sh" test-negation-1.test.dtb -Ealways_fail -I dts -O dtb "$SRCDIR/test_tree1.dts"
+    run_sh_test "$SRCDIR/dtc-fails.sh" -n test-negation-2.test.dtb -Ealways_fail -Eno_always_fail -I dts -O dtb "$SRCDIR/test_tree1.dts"
+    run_sh_test "$SRCDIR/dtc-fails.sh" test-negation-3.test.dtb -Ealways_fail -Wno_always_fail -I dts -O dtb "$SRCDIR/test_tree1.dts"
+    run_sh_test "$SRCDIR/dtc-fails.sh" -n test-negation-4.test.dtb -Esize_cells_is_cell -Eno_size_cells_is_cell -I dts -O dtb "$SRCDIR/bad-ncells.dts"
+    run_sh_test "$SRCDIR/dtc-checkfails.sh" size_cells_is_cell -- -Esize_cells_is_cell -Eno_size_cells_is_cell -I dts -O dtb "$SRCDIR/bad-ncells.dts"
+
+    # Check for proper behaviour reading from stdin
+    run_dtc_test -I dts -O dtb -o stdin_dtc_tree1.test.dtb - < "$SRCDIR/test_tree1.dts"
+    run_wrap_test cmp stdin_dtc_tree1.test.dtb dtc_tree1.test.dtb
+    run_dtc_test -I dtb -O dts -o stdin_odts_test_tree1.dtb.test.dts - < test_tree1.dtb
+    run_wrap_test cmp stdin_odts_test_tree1.dtb.test.dts odts_test_tree1.dtb.test.dts
+
+    # Check integer expresisons
+    run_test integer-expressions -g integer-expressions.test.dts
+    run_dtc_test -I dts -O dtb -o integer-expressions.test.dtb integer-expressions.test.dts
+    run_test integer-expressions integer-expressions.test.dtb
+
+    # Check for graceful failure in some error conditions
+    run_sh_test "$SRCDIR/dtc-fatal.sh" -I dts -O dtb nosuchfile.dts
+    run_sh_test "$SRCDIR/dtc-fatal.sh" -I dtb -O dtb nosuchfile.dtb
+    run_sh_test "$SRCDIR/dtc-fatal.sh" -I fs -O dtb nosuchfile
+
+    # Dependencies
+    run_dtc_test -I dts -O dtb -o dependencies.test.dtb -d dependencies.test.d "$SRCDIR/dependencies.dts"
+    sed -i.bak "s,$SRCDIR/,,g" dependencies.test.d
+    run_wrap_test cmp dependencies.test.d "$SRCDIR/dependencies.cmp"
+
+    # Search paths
+    run_wrap_error_test $DTC -I dts -O dtb -o search_paths.dtb "$SRCDIR/search_paths.dts"
+    run_dtc_test -i "$SRCDIR/search_dir" -I dts -O dtb -o search_paths.dtb \
+	"$SRCDIR/search_paths.dts"
+    run_wrap_error_test $DTC -i "$SRCDIR/search_dir_b" -I dts -O dtb \
+	-o search_paths_b.dtb "$SRCDIR/search_paths_b.dts"
+    run_dtc_test -i "$SRCDIR/search_dir_b" -i "$SRCDIR/search_dir" -I dts -O dtb \
+	-o search_paths_b.dtb "$SRCDIR/search_paths_b.dts"
+    run_dtc_test -I dts -O dtb -o search_paths_subdir.dtb \
+	"$SRCDIR/search_dir_b/search_paths_subdir.dts"
+
+    # Check -a option
+    for align in 2 4 8 16 32 64; do
+	# -p -a
+	run_dtc_test -O dtb -p 1000 -a $align -o align0.dtb "$SRCDIR/subnode_iterate.dts"
+	base_run_test check_align align0.dtb $align
+	# -S -a
+	run_dtc_test -O dtb -S 1999 -a $align -o align1.dtb "$SRCDIR/subnode_iterate.dts"
+	base_run_test check_align align1.dtb $align
+    done
+
+    # Tests for overlay/plugin generation
+    dtc_overlay_tests
+}
+
+cmp_tests () {
+    basetree="$1"
+    shift
+    wrongtrees="$@"
+
+    run_test dtb_reverse $basetree
+
+    # First dtbs_equal_ordered
+    run_test dtbs_equal_ordered $basetree $basetree
+    run_test dtbs_equal_ordered -n $basetree $basetree.reversed.test.dtb
+    for tree in $wrongtrees; do
+	run_test dtbs_equal_ordered -n $basetree $tree
+    done
+
+    # now unordered
+    run_test dtbs_equal_unordered $basetree $basetree
+    run_test dtbs_equal_unordered $basetree $basetree.reversed.test.dtb
+    run_test dtbs_equal_unordered $basetree.reversed.test.dtb $basetree
+    for tree in $wrongtrees; do
+	run_test dtbs_equal_unordered -n $basetree $tree
+    done
+
+    # now dtc --sort
+    run_dtc_test -I dtb -O dtb -s -o $basetree.sorted.test.dtb $basetree
+    run_test dtbs_equal_unordered $basetree $basetree.sorted.test.dtb
+    run_dtc_test -I dtb -O dtb -s -o $basetree.reversed.sorted.test.dtb $basetree.reversed.test.dtb
+    run_test dtbs_equal_unordered $basetree.reversed.test.dtb $basetree.reversed.sorted.test.dtb
+    run_test dtbs_equal_ordered $basetree.sorted.test.dtb $basetree.reversed.sorted.test.dtb
+}
+
+dtbs_equal_tests () {
+    WRONG_TREE1=""
+    for x in 1 2 3 4 5 6 7 8 9; do
+	run_dtc_test -I dts -O dtb -o test_tree1_wrong$x.test.dtb "$SRCDIR/test_tree1_wrong$x.dts"
+	WRONG_TREE1="$WRONG_TREE1 test_tree1_wrong$x.test.dtb"
+    done
+    cmp_tests test_tree1.dtb $WRONG_TREE1
+}
+
+fdtget_tests () {
+    dts=label01.dts
+    dtb=$dts.fdtget.test.dtb
+    run_dtc_test -O dtb -o $dtb "$SRCDIR/$dts"
+
+    # run_fdtget_test <expected-result> [<flags>] <file> <node> <property>
+    run_fdtget_test "MyBoardName" $dtb / model
+    run_fdtget_test "MyBoardName MyBoardFamilyName" $dtb / compatible
+    run_fdtget_test "77 121 66 111 \
+97 114 100 78 97 109 101 0 77 121 66 111 97 114 100 70 97 109 105 \
+108 121 78 97 109 101 0" -t bu $dtb / compatible
+    run_fdtget_test "MyBoardName MyBoardFamilyName" -t s $dtb / compatible
+    run_fdtget_test 32768 $dtb /cpus/PowerPC,970@1 d-cache-size
+    run_fdtget_test 8000 -tx $dtb /cpus/PowerPC,970@1 d-cache-size
+    run_fdtget_test "61 62 63 0" -tbx $dtb /randomnode tricky1
+    run_fdtget_test "a b c d de ea ad be ef" -tbx $dtb /randomnode blob
+
+    # Here the property size is not a multiple of 4 bytes, so it should fail
+    run_wrap_error_test $DTGET -tlx $dtb /randomnode mixed
+    run_fdtget_test "6162 6300 1234 0 a 0 b 0 c" -thx $dtb /randomnode mixed
+    run_fdtget_test "61 62 63 0 12 34 0 0 0 a 0 0 0 b 0 0 0 c" \
+	-thhx $dtb /randomnode mixed
+    run_wrap_error_test $DTGET -ts $dtb /randomnode doctor-who
+
+    # Test multiple arguments
+    run_fdtget_test "MyBoardName\nmemory" -ts $dtb / model /memory device_type
+
+    # Test defaults
+    run_wrap_error_test $DTGET -tx $dtb /randomnode doctor-who
+    run_fdtget_test "<the dead silence>" -tx \
+	-d "<the dead silence>" $dtb /randomnode doctor-who
+    run_fdtget_test "<blink>" -tx -d "<blink>" $dtb /memory doctor-who
+}
+
+fdtput_tests () {
+    dts=label01.dts
+    dtb=$dts.fdtput.test.dtb
+    text="$SRCDIR/lorem.txt"
+
+    # Allow just enough space for $text
+    run_dtc_test -O dtb -p $($STATSZ $text) -o $dtb "$SRCDIR/$dts"
+
+    # run_fdtput_test <expected-result> <file> <node> <property> <flags> <value>
+    run_fdtput_test "a_model" $dtb / model -ts "a_model"
+    run_fdtput_test "board1 board2" $dtb / compatible -ts board1 board2
+    run_fdtput_test "board1 board2" $dtb / compatible -ts "board1 board2"
+    run_fdtput_test "32768" $dtb /cpus/PowerPC,970@1 d-cache-size "" "32768"
+    run_fdtput_test "8001" $dtb /cpus/PowerPC,970@1 d-cache-size -tx 0x8001
+    run_fdtput_test "2 3 12" $dtb /randomnode tricky1 -tbi "02 003 12"
+    run_fdtput_test "a b c ea ad be ef" $dtb /randomnode blob \
+	-tbx "a b c ea ad be ef"
+    run_fdtput_test "a0b0c0d deeaae ef000000" $dtb /randomnode blob \
+	-tx "a0b0c0d deeaae ef000000"
+    run_fdtput_test "$(cat $text)" $dtb /randomnode blob -ts "$(cat $text)"
+
+    # Test expansion of the blob when insufficient room for property
+    run_fdtput_test "$(cat $text $text)" $dtb /randomnode blob -ts "$(cat $text $text)"
+
+    # Start again with a fresh dtb
+    run_dtc_test -O dtb -p $($STATSZ $text) -o $dtb "$SRCDIR/$dts"
+
+    # Node creation
+    run_wrap_error_test $DTPUT $dtb -c /baldrick sod
+    run_wrap_test $DTPUT $dtb -c /chosen/son /chosen/daughter
+    run_fdtput_test "eva" $dtb /chosen/daughter name "" -ts "eva"
+    run_fdtput_test "adam" $dtb /chosen/son name "" -ts "adam"
+
+    # Not allowed to create an existing node
+    run_wrap_error_test $DTPUT $dtb -c /chosen
+    run_wrap_error_test $DTPUT $dtb -c /chosen/son
+
+    # Automatic node creation
+    run_wrap_test $DTPUT $dtb -cp /blackadder/the-second/turnip \
+	/blackadder/the-second/potato
+    run_fdtput_test 1000 $dtb /blackadder/the-second/turnip cost "" 1000
+    run_fdtput_test "fine wine" $dtb /blackadder/the-second/potato drink \
+	"-ts" "fine wine"
+    run_wrap_test $DTPUT $dtb -p /you/are/drunk/sir/winston slurp -ts twice
+
+    # Test expansion of the blob when insufficient room for a new node
+    run_wrap_test $DTPUT $dtb -cp "$(cat $text $text)/longish"
+
+    # Allowed to create an existing node with -p
+    run_wrap_test $DTPUT $dtb -cp /chosen
+    run_wrap_test $DTPUT $dtb -cp /chosen/son
+
+    # Start again with a fresh dtb
+    run_dtc_test -O dtb -p $($STATSZ $text) -o $dtb "$SRCDIR/$dts"
+
+    # Node delete
+    run_wrap_test $DTPUT $dtb -c /chosen/node1 /chosen/node2 /chosen/node3
+    run_fdtget_test "node3\nnode2\nnode1" $dtb -l  /chosen
+    run_wrap_test $DTPUT $dtb -r /chosen/node1 /chosen/node2
+    run_fdtget_test "node3" $dtb -l  /chosen
+
+    # Delete the non-existent node
+    run_wrap_error_test $DTPUT $dtb -r /non-existent/node
+
+    # Property delete
+    run_fdtput_test "eva" $dtb /chosen/ name "" -ts "eva"
+    run_fdtput_test "016" $dtb /chosen/ age  "" -ts "016"
+    run_fdtget_test "age\nname\nbootargs\nlinux,platform" $dtb -p  /chosen
+    run_wrap_test $DTPUT $dtb -d /chosen/ name age
+    run_fdtget_test "bootargs\nlinux,platform" $dtb -p  /chosen
+
+    # Delete the non-existent property
+    run_wrap_error_test $DTPUT $dtb -d /chosen   non-existent-prop
+
+    # TODO: Add tests for verbose mode?
+}
+
+utilfdt_tests () {
+    run_test utilfdt_test
+}
+
+fdtdump_tests () {
+    run_fdtdump_test "$SRCDIR/fdtdump.dts"
+}
+
+fdtoverlay_tests() {
+    base="$SRCDIR/overlay_base.dts"
+    basedtb=overlay_base.fdoverlay.test.dtb
+    overlay="$SRCDIR/overlay_overlay_manual_fixups.dts"
+    overlaydtb=overlay_overlay_manual_fixups.fdoverlay.test.dtb
+    targetdtb=target.fdoverlay.test.dtb
+
+    run_dtc_test -@ -I dts -O dtb -o $basedtb $base
+    run_dtc_test -@ -I dts -O dtb -o $overlaydtb $overlay
+
+    # test that the new property is installed
+    run_fdtoverlay_test foobar "/test-node" "test-str-property" "-ts" ${basedtb} ${targetdtb} ${overlaydtb}
+
+    stacked_base="$SRCDIR/stacked_overlay_base.dts"
+    stacked_basedtb=stacked_overlay_base.fdtoverlay.test.dtb
+    stacked_bar="$SRCDIR/stacked_overlay_bar.dts"
+    stacked_bardtb=stacked_overlay_bar.fdtoverlay.test.dtb
+    stacked_baz="$SRCDIR/stacked_overlay_baz.dts"
+    stacked_bazdtb=stacked_overlay_baz.fdtoverlay.test.dtb
+    stacked_targetdtb=stacked_overlay_target.fdtoverlay.test.dtb
+
+    run_dtc_test -@ -I dts -O dtb -o $stacked_basedtb $stacked_base
+    run_dtc_test -@ -I dts -O dtb -o $stacked_bardtb $stacked_bar
+    run_dtc_test -@ -I dts -O dtb -o $stacked_bazdtb $stacked_baz
+
+    # test that baz correctly inserted the property
+    run_fdtoverlay_test baz "/foonode/barnode/baznode" "baz-property" "-ts" ${stacked_basedtb} ${stacked_targetdtb} ${stacked_bardtb} ${stacked_bazdtb}
+
+    # test that bar and baz are correctly appended to __symbols__
+    run_fdtoverlay_test "/foonode/barnode" "/__symbols__"  "bar" "-ts" ${stacked_basedtb} ${stacked_targetdtb} ${stacked_bardtb}
+    run_fdtoverlay_test "/foonode/barnode/baznode" "/__symbols__"  "baz" "-ts" ${stacked_basedtb} ${stacked_targetdtb} ${stacked_bardtb} ${stacked_bazdtb}
+
+    overlay_long_path="$SRCDIR/overlay_overlay_long_path.dts"
+    overlay_long_pathdtb=overlay_overlay_long_path.fdoverlay.test.dtb
+    target_long_pathdtb=overlay_overlay_long_path_target.fdoverlay.test.dtb
+    run_dtc_test -@ -I dts -O dtb -o $overlay_long_pathdtb $overlay_long_path
+
+    # test that fdtoverlay manages to apply overlays with long target path
+    run_fdtoverlay_test lpath "/test-node/sub-test-node/sub-test-node-with-very-long-target-path/test-0" "prop" "-ts" ${basedtb} ${target_long_pathdtb} ${overlay_long_pathdtb}
+
+    # test adding a label to the root of a fragment
+    stacked_base_nolabel="$SRCDIR/stacked_overlay_base_nolabel.dts"
+    stacked_base_nolabeldtb=stacked_overlay_base_nolabel.test.dtb
+    stacked_addlabel="$SRCDIR/stacked_overlay_addlabel.dts"
+    stacked_addlabeldtb=stacked_overlay_addlabel.test.dtb
+    stacked_addlabel_targetdtb=stacked_overlay_target_nolabel.fdtoverlay.test.dtb
+
+    run_dtc_test -@ -I dts -O dtb -o $stacked_base_nolabeldtb $stacked_base_nolabel
+    run_dtc_test -@ -I dts -O dtb -o $stacked_addlabeldtb $stacked_addlabel
+
+    run_fdtoverlay_test baz "/foonode/barnode/baznode" "baz-property" "-ts" ${stacked_base_nolabeldtb} ${stacked_addlabel_targetdtb} ${stacked_addlabeldtb} ${stacked_bardtb} ${stacked_bazdtb}
+}
+
+pylibfdt_tests () {
+    run_dtc_test -I dts -O dtb -o test_props.dtb "$SRCDIR/test_props.dts"
+    TMP=/tmp/tests.stderr.$$
+    $PYTHON "$SRCDIR/pylibfdt_tests.py" -v 2> $TMP
+
+    # Use the 'ok' message meaning the test passed, 'ERROR' meaning it failed
+    # and the summary line for total tests (e.g. 'Ran 17 tests in 0.002s').
+    # We could add pass + fail to get total tests, but this provides a useful
+    # sanity check.
+    pass_count=$(grep "ok$" $TMP | wc -l)
+    fail_count=$(grep "^ERROR: " $TMP | wc -l)
+    total_tests=$(sed -n 's/^Ran \([0-9]*\) tests.*$/\1/p' $TMP)
+    cat $TMP
+    rm $TMP
+
+    # Extract the test results and add them to our totals
+    tot_fail=$((tot_fail + $fail_count))
+    tot_pass=$((tot_pass + $pass_count))
+    tot_tests=$((tot_tests + $total_tests))
+}
+
+while getopts "vt:me" ARG ; do
+    case $ARG in
+	"v")
+	    unset QUIET_TEST
+	    ;;
+	"t")
+	    TESTSETS=$OPTARG
+	    ;;
+	"m")
+	    VALGRIND="valgrind --tool=memcheck -q --error-exitcode=$VGCODE"
+	    ;;
+	"e")
+	    STOP_ON_FAIL=1
+	    ;;
+    esac
+done
+
+if [ -z "$TESTSETS" ]; then
+    TESTSETS="libfdt utilfdt dtc dtbs_equal fdtget fdtput fdtdump fdtoverlay"
+
+    # Test pylibfdt if the libfdt Python module is available.
+    if ! $no_python; then
+        TESTSETS="$TESTSETS pylibfdt"
+    fi
+fi
+
+# Make sure we don't have stale blobs lying around
+rm -f *.test.dtb *.test.dts
+
+for set in $TESTSETS; do
+    case $set in
+	"libfdt")
+	    libfdt_tests
+	    ;;
+	"utilfdt")
+	    utilfdt_tests
+	    ;;
+	"dtc")
+	    dtc_tests
+	    ;;
+	"dtbs_equal")
+	    dtbs_equal_tests
+	    ;;
+	"fdtget")
+	    fdtget_tests
+	    ;;
+	"fdtput")
+	    fdtput_tests
+	    ;;
+	"fdtdump")
+	    fdtdump_tests
+	    ;;
+	"pylibfdt")
+	    pylibfdt_tests
+	    ;;
+        "fdtoverlay")
+	    fdtoverlay_tests
+	    ;;
+    esac
+done
+
+echo "********** TEST SUMMARY"
+echo "*     Total testcases:	$tot_tests"
+echo "*                PASS:	$tot_pass"
+echo "*                FAIL:	$tot_fail"
+echo "*   Bad configuration:	$tot_config"
+if [ -n "$VALGRIND" ]; then
+    echo "*    valgrind errors:	$tot_vg"
+fi
+echo "* Strange test result:	$tot_strange"
+echo "**********"
+
+[ "$tot_tests" -eq "$tot_pass" ] || exit 1
diff --git a/dtc/tests/rw_oom.c b/dtc/tests/rw_oom.c
new file mode 100644
index 0000000..39fc312
--- /dev/null
+++ b/dtc/tests/rw_oom.c
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_node()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+/* This is not derived programmatically. May require adjustment to changes. */
+#define SPACE	285
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+#define OFF_CHECK(off, code) \
+	{ \
+		(off) = (code); \
+		if (off < 0) \
+			FAIL(#code ": %s", fdt_strerror(off)); \
+	}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int err;
+	int offset, s1;
+	int strsize1, strsize2;
+
+	/*
+	 * Check OOM path, and check that property is cleaned up if it fails
+	 * with OOM, rather than adding an orphan name.
+	 *
+	 * SW OOM is tested with the realloc/resize strategies.
+	 */
+	test_init(argc, argv);
+
+	fdt = xmalloc(SPACE);
+
+	/* First create empty tree with SW */
+	CHECK(fdt_create_empty_tree(fdt, SPACE));
+
+	CHECK(fdt_add_mem_rsv(fdt, TEST_ADDR_1, TEST_SIZE_1));
+	CHECK(fdt_add_mem_rsv(fdt, TEST_ADDR_2, TEST_SIZE_2));
+
+	CHECK(fdt_setprop_string(fdt, 0, "compatible", "test_oom"));
+	CHECK(fdt_setprop_u32(fdt, 0, "prop-int", TEST_VALUE_1));
+	CHECK(fdt_setprop_u64(fdt, 0, "prop-int64", TEST_VALUE64_1));
+	CHECK(fdt_setprop_string(fdt, 0, "prop-str", TEST_STRING_1));
+
+	OFF_CHECK(offset, fdt_add_subnode(fdt, 0, "subnode@1"));
+	s1 = offset;
+
+	strsize1 = fdt_size_dt_strings(fdt);
+	err = fdt_setprop_string(fdt, s1, "unique", "subnode1");
+	if (err != -FDT_ERR_NOSPACE)
+		FAIL("fdt_setprop_string(fdt, s1, \"compatible\", \"subnode1\"): %s", fdt_strerror(err));
+	strsize2 = fdt_size_dt_strings(fdt);
+
+	if (strsize1 != strsize2)
+		FAIL("fdt_setprop NOSPACE error failed to clean up allocated string\n");
+	err = 0;
+
+	/* Ensure we failed in the right place */
+	CHECK(fdt_setprop_string(fdt, s1, "unique", ""));
+
+	CHECK(fdt_pack(fdt));
+
+	PASS();
+}
diff --git a/dtc/tests/rw_tree1.c b/dtc/tests/rw_tree1.c
new file mode 100644
index 0000000..1fe2351
--- /dev/null
+++ b/dtc/tests/rw_tree1.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_node()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE	65536
+
+#define CHECK(code) \
+	{ \
+		err = (code); \
+		if (err) \
+			FAIL(#code ": %s", fdt_strerror(err)); \
+	}
+
+#define OFF_CHECK(off, code) \
+	{ \
+		(off) = (code); \
+		if (off < 0) \
+			FAIL(#code ": %s", fdt_strerror(off)); \
+	}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int err;
+	int offset, s1, s2;
+
+	test_init(argc, argv);
+
+	fdt = xmalloc(SPACE);
+
+	/* First create empty tree with SW */
+	CHECK(fdt_create_empty_tree(fdt, SPACE));
+
+	CHECK(fdt_add_mem_rsv(fdt, TEST_ADDR_1, TEST_SIZE_1));
+	CHECK(fdt_add_mem_rsv(fdt, TEST_ADDR_2, TEST_SIZE_2));
+
+	CHECK(fdt_setprop_string(fdt, 0, "compatible", "test_tree1"));
+	CHECK(fdt_setprop_u32(fdt, 0, "prop-int", TEST_VALUE_1));
+	CHECK(fdt_setprop_u64(fdt, 0, "prop-int64", TEST_VALUE64_1));
+	CHECK(fdt_setprop_string(fdt, 0, "prop-str", TEST_STRING_1));
+
+	OFF_CHECK(offset, fdt_add_subnode(fdt, 0, "subnode@1"));
+	s1 = offset;
+	CHECK(fdt_setprop_string(fdt, s1, "compatible", "subnode1"));
+	CHECK(fdt_setprop_cell(fdt, s1, "prop-int", TEST_VALUE_1));
+	OFF_CHECK(offset, fdt_add_subnode(fdt, s1, "subsubnode"));
+	CHECK(fdt_setprop(fdt, offset, "compatible",
+			  "subsubnode1\0subsubnode", 23));
+	CHECK(fdt_setprop_cell(fdt, offset, "prop-int", TEST_VALUE_1));
+	OFF_CHECK(offset, fdt_add_subnode(fdt, s1, "ss1"));
+
+	OFF_CHECK(offset, fdt_add_subnode(fdt, 0, "subnode@2"));
+	s2 = offset;
+	CHECK(fdt_setprop_cell(fdt, s2, "linux,phandle", PHANDLE_1));
+	CHECK(fdt_setprop_cell(fdt, s2, "prop-int", TEST_VALUE_2));
+	OFF_CHECK(offset, fdt_add_subnode(fdt, s2, "subsubnode@0"));
+	CHECK(fdt_setprop_cell(fdt, offset, "linux,phandle", PHANDLE_2));
+	CHECK(fdt_setprop(fdt, offset, "compatible",
+			  "subsubnode2\0subsubnode", 23));
+	CHECK(fdt_setprop_cell(fdt, offset, "prop-int", TEST_VALUE_2));
+	OFF_CHECK(offset, fdt_add_subnode(fdt, s2, "ss2"));
+
+	CHECK(fdt_pack(fdt));
+
+	save_blob("rw_tree1.test.dtb", fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/search_dir/search_test.dtsi b/dtc/tests/search_dir/search_test.dtsi
new file mode 100644
index 0000000..217fb80
--- /dev/null
+++ b/dtc/tests/search_dir/search_test.dtsi
@@ -0,0 +1,4 @@
+/include/ "search_test2.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/search_dir/search_test2.dtsi b/dtc/tests/search_dir/search_test2.dtsi
new file mode 100644
index 0000000..7b9099e
--- /dev/null
+++ b/dtc/tests/search_dir/search_test2.dtsi
@@ -0,0 +1,3 @@
+
+/ {
+};
diff --git a/dtc/tests/search_dir_b/search_paths_subdir.dts b/dtc/tests/search_dir_b/search_paths_subdir.dts
new file mode 100644
index 0000000..5c5c962
--- /dev/null
+++ b/dtc/tests/search_dir_b/search_paths_subdir.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/include/ "search_test_c.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/search_dir_b/search_test_b.dtsi b/dtc/tests/search_dir_b/search_test_b.dtsi
new file mode 100644
index 0000000..b06a7d6
--- /dev/null
+++ b/dtc/tests/search_dir_b/search_test_b.dtsi
@@ -0,0 +1,4 @@
+/include/ "search_test_b2.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/search_dir_b/search_test_b2.dtsi b/dtc/tests/search_dir_b/search_test_b2.dtsi
new file mode 100644
index 0000000..2526b43
--- /dev/null
+++ b/dtc/tests/search_dir_b/search_test_b2.dtsi
@@ -0,0 +1,5 @@
+
+/include/ "search_test.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/search_dir_b/search_test_c.dtsi b/dtc/tests/search_dir_b/search_test_c.dtsi
new file mode 100644
index 0000000..336d7a2
--- /dev/null
+++ b/dtc/tests/search_dir_b/search_test_c.dtsi
@@ -0,0 +1,2 @@
+/ {
+};
diff --git a/dtc/tests/search_paths.dts b/dtc/tests/search_paths.dts
new file mode 100644
index 0000000..a2bf179
--- /dev/null
+++ b/dtc/tests/search_paths.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/include/ "search_test.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/search_paths_b.dts b/dtc/tests/search_paths_b.dts
new file mode 100644
index 0000000..6ace6e2
--- /dev/null
+++ b/dtc/tests/search_paths_b.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+
+/include/ "search_test_b.dtsi"
+
+/ {
+};
diff --git a/dtc/tests/set_name.c b/dtc/tests/set_name.c
new file mode 100644
index 0000000..a62cb58
--- /dev/null
+++ b/dtc/tests/set_name.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_set_name()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_set_name(void *fdt, const char *path, const char *newname)
+{
+	int offset;
+	const char *getname, *oldname;
+	int len, err;
+
+	oldname = strrchr(path, '/');
+	if (!oldname)
+		TEST_BUG();
+	oldname += 1;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find %s", path);
+
+	getname = fdt_get_name(fdt, offset, &len);
+	verbose_printf("fdt_get_name(%d) returns \"%s\" (len=%d)\n",
+		       offset, getname, len);
+	if (!getname)
+		FAIL("fdt_get_name(%d): %s", offset, fdt_strerror(len));
+
+	if (strcmp(getname, oldname) != 0)
+		FAIL("fdt_get_name(%s) returned \"%s\" instead of \"%s\"",
+		     path, getname, oldname);
+
+	if (len != strlen(getname))
+		FAIL("fdt_get_name(%s) returned length %d instead of %zd",
+		     path, len, strlen(getname));
+
+	err = fdt_set_name(fdt, offset, newname);
+	if (err)
+		FAIL("fdt_set_name(%d, \"%s\"): %s", offset, newname,
+		     fdt_strerror(err));
+
+	getname = fdt_get_name(fdt, offset, &len);
+	if (!getname)
+		FAIL("fdt_get_name(%d): %s", offset, fdt_strerror(len));
+
+	if (strcmp(getname, newname) != 0)
+		FAIL("fdt_get_name(%s) returned \"%s\" instead of \"%s\"",
+		     path, getname, newname);
+
+	if (len != strlen(getname))
+		FAIL("fdt_get_name(%s) returned length %d instead of %zd",
+		     path, len, strlen(getname));
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+	fdt = open_blob_rw(fdt);
+
+	check_set_name(fdt, "/subnode@1", "subnode@17");
+	check_set_name(fdt, "/subnode@2/subsubnode@0", "fred@0");
+	check_set_name(fdt, "/subnode@17/subsubnode", "something@0");
+
+	PASS();
+}
diff --git a/dtc/tests/setprop.c b/dtc/tests/setprop.c
new file mode 100644
index 0000000..fa3938d
--- /dev/null
+++ b/dtc/tests/setprop.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_setprop()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE		65536
+#define NEW_STRING	"here is quite a long test string, blah blah blah"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	void *buf;
+	const uint32_t *intp;
+	const char *strp;
+	int err;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	buf = xmalloc(SPACE);
+
+	err = fdt_open_into(fdt, buf, SPACE);
+	if (err)
+		FAIL("fdt_open_into(): %s", fdt_strerror(err));
+
+	fdt = buf;
+
+	intp = check_getprop_cell(fdt, 0, "prop-int", TEST_VALUE_1);
+
+	verbose_printf("Old int value was 0x%08x\n", *intp);
+	err = fdt_setprop_string(fdt, 0, "prop-int", NEW_STRING);
+	if (err)
+		FAIL("Failed to set \"prop-int\" to \"%s\": %s",
+		     NEW_STRING, fdt_strerror(err));
+
+	strp = check_getprop_string(fdt, 0, "prop-int", NEW_STRING);
+	verbose_printf("New value is \"%s\"\n", strp);
+
+	strp = check_getprop(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1,
+			     TEST_STRING_1);
+
+	verbose_printf("Old string value was \"%s\"\n", strp);
+	err = fdt_setprop_empty(fdt, 0, "prop-str");
+	if (err)
+		FAIL("Failed to empty \"prop-str\": %s",
+		     fdt_strerror(err));
+
+	check_getprop(fdt, 0, "prop-str", 0, NULL);
+
+	err = fdt_setprop_u32(fdt, 0, "prop-u32", TEST_VALUE_2);
+	if (err)
+		FAIL("Failed to set \"prop-u32\" to 0x%08x: %s",
+		     TEST_VALUE_2, fdt_strerror(err));
+	check_getprop_cell(fdt, 0, "prop-u32", TEST_VALUE_2);
+
+	err = fdt_setprop_cell(fdt, 0, "prop-cell", TEST_VALUE_2);
+	if (err)
+		FAIL("Failed to set \"prop-cell\" to 0x%08x: %s",
+		     TEST_VALUE_2, fdt_strerror(err));
+	check_getprop_cell(fdt, 0, "prop-cell", TEST_VALUE_2);
+
+	err = fdt_setprop_u64(fdt, 0, "prop-u64", TEST_VALUE64_1);
+	if (err)
+		FAIL("Failed to set \"prop-u64\" to 0x%016llx: %s",
+		     TEST_VALUE64_1, fdt_strerror(err));
+	check_getprop_64(fdt, 0, "prop-u64", TEST_VALUE64_1);
+	
+	PASS();
+}
diff --git a/dtc/tests/setprop_inplace.c b/dtc/tests/setprop_inplace.c
new file mode 100644
index 0000000..7e1198d
--- /dev/null
+++ b/dtc/tests/setprop_inplace.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_setprop_inplace()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <inttypes.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	const uint32_t *intp;
+	const uint64_t *int64p;
+	const char *strp;
+	char *xstr;
+	int xlen, i;
+	int err;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	intp = check_getprop_cell(fdt, 0, "prop-int", TEST_VALUE_1);
+
+	verbose_printf("Old int value was 0x%08x\n", *intp);
+	err = fdt_setprop_inplace_cell(fdt, 0, "prop-int", ~TEST_VALUE_1);
+	if (err)
+		FAIL("Failed to set \"prop-int\" to 0x%08x: %s",
+		     ~TEST_VALUE_1, fdt_strerror(err));
+	intp = check_getprop_cell(fdt, 0, "prop-int", ~TEST_VALUE_1);
+	verbose_printf("New int value is 0x%08x\n", *intp);
+
+	strp = check_getprop(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1,
+			     TEST_STRING_1);
+
+
+	int64p = check_getprop_64(fdt, 0, "prop-int64", TEST_VALUE64_1);
+
+	verbose_printf("Old int64 value was 0x%016" PRIx64 "\n", *int64p);
+	err = fdt_setprop_inplace_u64(fdt, 0, "prop-int64", ~TEST_VALUE64_1);
+	if (err)
+		FAIL("Failed to set \"prop-int64\" to 0x%016llx: %s",
+		     ~TEST_VALUE64_1, fdt_strerror(err));
+	int64p = check_getprop_64(fdt, 0, "prop-int64", ~TEST_VALUE64_1);
+	verbose_printf("New int64 value is 0x%016" PRIx64 "\n", *int64p);
+
+	strp = check_getprop(fdt, 0, "prop-str", strlen(TEST_STRING_1)+1,
+			     TEST_STRING_1);
+
+	verbose_printf("Old string value was \"%s\"\n", strp);
+	xstr = strdup(strp);
+	xlen = strlen(xstr);
+	for (i = 0; i < xlen; i++)
+		xstr[i] = toupper(xstr[i]);
+	err = fdt_setprop_inplace(fdt, 0, "prop-str", xstr, xlen+1);
+	if (err)
+		FAIL("Failed to set \"prop-str\" to \"%s\": %s",
+		     xstr, fdt_strerror(err));
+
+	strp = check_getprop(fdt, 0, "prop-str", xlen+1, xstr);
+	verbose_printf("New string value is \"%s\"\n", strp);
+
+	err = fdt_setprop_inplace_namelen_partial(fdt, 0, "compatible",
+						  strlen("compatible"), 4,
+						  TEST_STRING_4_PARTIAL,
+						  strlen(TEST_STRING_4_PARTIAL));
+	if (err)
+		FAIL("Failed to set \"compatible\": %s\n", fdt_strerror(err));
+
+	check_getprop(fdt, 0, "compatible", strlen(TEST_STRING_4_RESULT) + 1,
+		      TEST_STRING_4_RESULT);
+
+	PASS();
+}
diff --git a/dtc/tests/sized_cells.c b/dtc/tests/sized_cells.c
new file mode 100644
index 0000000..9ca5a59
--- /dev/null
+++ b/dtc/tests/sized_cells.c
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for variable sized cells in dtc
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ * Copyright (C) 2011 The Chromium Authors. All rights reserved.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_compare_properties(void *fdt,
+				     char const *name_one,
+				     char const *name_two)
+{
+	const void *propval;
+	int proplen;
+
+	propval = fdt_getprop(fdt, 0, name_one, &proplen);
+
+	if (!propval)
+		FAIL("fdt_getprop(\"%s\"): %s",
+		     name_one,
+		     fdt_strerror(proplen));
+
+	check_getprop(fdt, 0, name_two, proplen, propval);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	uint8_t expected_8[6] = {TEST_CHAR1,
+				 TEST_CHAR2,
+				 TEST_CHAR3,
+				 TEST_CHAR4,
+				 TEST_CHAR5,
+				 TEST_VALUE_1 >> 24};
+	fdt16_t expected_16[6];
+	fdt32_t expected_32[6];
+	fdt64_t expected_64[6];
+	int i;
+
+	for (i = 0; i < 5; ++i) {
+		expected_16[i] = cpu_to_fdt16(expected_8[i]);
+		expected_32[i] = cpu_to_fdt32(expected_8[i]);
+		expected_64[i] = cpu_to_fdt64(expected_8[i]);
+	}
+
+	expected_16[5] = cpu_to_fdt16(TEST_VALUE_1 >> 16);
+	expected_32[5] = cpu_to_fdt32(TEST_VALUE_1);
+	expected_64[5] = cpu_to_fdt64(TEST_ADDR_1);
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_getprop(fdt, 0, "cells-8b", sizeof(expected_8), expected_8);
+	check_getprop(fdt, 0, "cells-16b", sizeof(expected_16), expected_16);
+	check_getprop(fdt, 0, "cells-32b", sizeof(expected_32), expected_32);
+	check_getprop(fdt, 0, "cells-64b", sizeof(expected_64), expected_64);
+
+	check_compare_properties(fdt, "cells-one-16b", "cells-one-32b");
+
+	PASS();
+}
diff --git a/dtc/tests/sized_cells.dts b/dtc/tests/sized_cells.dts
new file mode 100644
index 0000000..efea9f5
--- /dev/null
+++ b/dtc/tests/sized_cells.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+
+/ {
+	cells-8b = /bits/ 8 <'\r' 'b' '\0' '\'' '\xff' 0xde>;
+	cells-16b = /bits/ 16 <'\r' 'b' '\0' '\'' '\xff' 0xdead>;
+	cells-32b = /bits/ 32 <'\r' 'b' '\0' '\'' '\xff' 0xdeadbeef>;
+	cells-64b = /bits/ 64 <'\r' 'b' '\0' '\'' '\xff' 0xdeadbeef00000000>;
+
+	cells-one-16b = /bits/ 16 <0x1234 0x5678 0x0 0xffff>;
+	cells-one-32b = <0x12345678 0x0000ffff>;
+};
diff --git a/dtc/tests/sourceoutput.dts b/dtc/tests/sourceoutput.dts
new file mode 100644
index 0000000..5a7459b
--- /dev/null
+++ b/dtc/tests/sourceoutput.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+
+/ {
+	/* Some versions had an off-by-2 bug which caused an abort
+	 * when outputting labels within strings like this in source
+	 * format */
+	prop1: prop1 = start1: "foo", mid1: "bar" end1: ;
+
+	/* Make sure that we correctly handle source output of things
+	 * which could almost be expressed as strings, except for the
+	 * embedded labels */
+	prop2 = start2: [66 6f 6f], mid2: "bar" end2: ;
+};
+
diff --git a/dtc/tests/stacked_overlay_addlabel.dts b/dtc/tests/stacked_overlay_addlabel.dts
new file mode 100644
index 0000000..e7187a3
--- /dev/null
+++ b/dtc/tests/stacked_overlay_addlabel.dts
@@ -0,0 +1,15 @@
+/dts-v1/;
+/plugin/;
+/ {
+	frag1: fragment@1 {
+		target-path = "/foonode";
+		local: localinfo {
+		};
+		foo: __overlay__ {
+			overlay-1-property;
+			bar: barnode {
+				bar-property = "bar";
+			};
+		};
+	};
+};
diff --git a/dtc/tests/stacked_overlay_bar.dts b/dtc/tests/stacked_overlay_bar.dts
new file mode 100644
index 0000000..c646399
--- /dev/null
+++ b/dtc/tests/stacked_overlay_bar.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+/ {
+	fragment@1 {
+		target = <&foo>;
+		__overlay__ {
+			overlay-1-property;
+			bar: barnode {
+				bar-property = "bar";
+			};
+		};
+	};
+};
diff --git a/dtc/tests/stacked_overlay_base.dts b/dtc/tests/stacked_overlay_base.dts
new file mode 100644
index 0000000..2916423
--- /dev/null
+++ b/dtc/tests/stacked_overlay_base.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+/ {
+	foo: foonode {
+		foo-property = "foo";
+	};
+};
diff --git a/dtc/tests/stacked_overlay_base_nolabel.dts b/dtc/tests/stacked_overlay_base_nolabel.dts
new file mode 100644
index 0000000..0c47f0d
--- /dev/null
+++ b/dtc/tests/stacked_overlay_base_nolabel.dts
@@ -0,0 +1,6 @@
+/dts-v1/;
+/ {
+	foonode {
+		foo-property = "foo";
+	};
+};
diff --git a/dtc/tests/stacked_overlay_baz.dts b/dtc/tests/stacked_overlay_baz.dts
new file mode 100644
index 0000000..a52f0cc
--- /dev/null
+++ b/dtc/tests/stacked_overlay_baz.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+/ {
+	fragment@1 {
+		target = <&bar>;
+		__overlay__ {
+			overlay-2-property;
+			baz: baznode {
+				baz-property = "baz";
+			};
+		};
+	};
+};
diff --git a/dtc/tests/string_escapes.c b/dtc/tests/string_escapes.c
new file mode 100644
index 0000000..53c9dfc
--- /dev/null
+++ b/dtc/tests/string_escapes.c
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for string escapes in dtc
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_getprop(fdt, 0, "escape-str",
+		      strlen(TEST_STRING_2)+1, TEST_STRING_2);
+	check_getprop(fdt, 0, "escape-str-2",
+		      strlen(TEST_STRING_3)+1, TEST_STRING_3);
+
+	PASS();
+}
diff --git a/dtc/tests/stringlist.c b/dtc/tests/stringlist.c
new file mode 100644
index 0000000..bbc3020
--- /dev/null
+++ b/dtc/tests/stringlist.c
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for string handling
+ * Copyright (C) 2015 NVIDIA Corporation
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check_expected_failure(const void *fdt, const char *path,
+				   const char *property)
+{
+	int offset, err;
+
+	offset = fdt_path_offset(fdt, "/");
+	if (offset < 0)
+		FAIL("Couldn't find path %s", path);
+
+	err = fdt_stringlist_count(fdt, offset, "#address-cells");
+	if (err != -FDT_ERR_BADVALUE)
+		FAIL("unexpectedly succeeded in parsing #address-cells\n");
+
+	err = fdt_stringlist_search(fdt, offset, "#address-cells", "foo");
+	if (err != -FDT_ERR_BADVALUE)
+		FAIL("found string in #address-cells: %d\n", err);
+
+	/*
+	 * Note that the #address-cells property contains a small 32-bit
+	 * unsigned integer, hence some bytes will be zero, and searching for
+	 * the empty string will succeed.
+	 *
+	 * The reason for this oddity is that the function will exit when the
+	 * first occurrence of the string is found, but in order to determine
+	 * that the property does not contain a valid string list it would
+	 * need to process the whole value.
+	 */
+	err = fdt_stringlist_search(fdt, offset, "#address-cells", "");
+	if (err != 0)
+		FAIL("empty string not found in #address-cells: %d\n", err);
+
+	/*
+	 * fdt_getprop_string() can successfully extract strings from
+	 * non-string properties. This is because it doesn't
+	 * necessarily parse the whole property value, which would be
+	 * necessary for it to determine if a valid string or string
+	 * list is present.
+	 */
+}
+
+static void check_string_count(const void *fdt, const char *path,
+			       const char *property, int count)
+{
+	int offset, err;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find path %s", path);
+
+	err = fdt_stringlist_count(fdt, offset, property);
+	if (err < 0)
+		FAIL("Couldn't count strings in property %s of node %s: %d\n",
+		     property, path, err);
+
+	if (err != count)
+		FAIL("String count for property %s of node %s is %d instead of %d\n",
+		     path, property, err, count);
+}
+
+static void check_string_index(const void *fdt, const char *path,
+			       const char *property, const char *string,
+			       int idx)
+{
+	int offset, err;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find path %s", path);
+
+	err = fdt_stringlist_search(fdt, offset, property, string);
+
+	if (err != idx)
+		FAIL("Index of %s in property %s of node %s is %d, expected %d\n",
+		     string, property, path, err, idx);
+}
+
+static void check_string(const void *fdt, const char *path,
+			 const char *property, int idx,
+			 const char *string)
+{
+	const char *result;
+	int offset, len;
+
+	offset = fdt_path_offset(fdt, path);
+	if (offset < 0)
+		FAIL("Couldn't find path %s", path);
+
+	result = fdt_stringlist_get(fdt, offset, property, idx, &len);
+	if (!result)
+		FAIL("Couldn't extract string %d from property %s of node %s: %d\n",
+		     idx, property, path, len);
+
+	if (strcmp(string, result) != 0)
+		FAIL("String %d in property %s of node %s is %s, expected %s\n",
+		     idx, property, path, result, string);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>\n", argv[0]);
+
+	test_init(argc, argv);
+	fdt = load_blob(argv[1]);
+
+	check_expected_failure(fdt, "/", "#address-cells");
+	check_expected_failure(fdt, "/", "#size-cells");
+
+	check_string_count(fdt, "/", "compatible", 1);
+	check_string_count(fdt, "/device", "compatible", 2);
+	check_string_count(fdt, "/device", "big-endian", 0);
+
+	check_string_index(fdt, "/", "compatible", "test-strings", 0);
+	check_string_index(fdt, "/device", "compatible", "foo", 0);
+	check_string_index(fdt, "/device", "compatible", "bar", 1);
+	check_string_index(fdt, "/device", "big-endian", "baz", -1);
+
+	check_string(fdt, "/", "compatible", 0, "test-strings");
+	check_string(fdt, "/device", "compatible", 0, "foo");
+	check_string(fdt, "/device", "compatible", 1, "bar");
+
+	PASS();
+}
diff --git a/dtc/tests/stringlist.dts b/dtc/tests/stringlist.dts
new file mode 100644
index 0000000..1e4d314
--- /dev/null
+++ b/dtc/tests/stringlist.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	compatible = "test-strings";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	device {
+		compatible = "foo", "bar";
+		big-endian;
+	};
+};
diff --git a/dtc/tests/subnode_iterate.c b/dtc/tests/subnode_iterate.c
new file mode 100644
index 0000000..2dc9b2d
--- /dev/null
+++ b/dtc/tests/subnode_iterate.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Tests that fdt_next_subnode() works as expected
+ *
+ * Copyright (C) 2013 Google, Inc
+ *
+ * Copyright (C) 2007 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void test_node(void *fdt, int parent_offset)
+{
+	uint32_t subnodes;
+	const fdt32_t *prop;
+	int offset;
+	int count;
+	int len;
+
+	/* This property indicates the number of subnodes to expect */
+	prop = fdt_getprop(fdt, parent_offset, "subnodes", &len);
+	if (!prop || len != sizeof(fdt32_t)) {
+		FAIL("Missing/invalid subnodes property at '%s'",
+		     fdt_get_name(fdt, parent_offset, NULL));
+	}
+	subnodes = fdt32_to_cpu(*prop);
+
+	count = 0;
+	fdt_for_each_subnode(offset, fdt, parent_offset)
+		count++;
+
+	if (count != subnodes) {
+		FAIL("Node '%s': Expected %d subnodes, got %d\n",
+		     fdt_get_name(fdt, parent_offset, NULL), subnodes,
+		     count);
+	}
+}
+
+static void check_fdt_next_subnode(void *fdt)
+{
+	int offset;
+	int count = 0;
+
+	fdt_for_each_subnode(offset, fdt, 0) {
+		test_node(fdt, offset);
+		count++;
+	}
+
+	if (count != 2)
+		FAIL("Expected %d tests, got %d\n", 2, count);
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>", argv[0]);
+
+	fdt = load_blob(argv[1]);
+	if (!fdt)
+		FAIL("No device tree available");
+
+	check_fdt_next_subnode(fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/subnode_iterate.dts b/dtc/tests/subnode_iterate.dts
new file mode 100644
index 0000000..14a0d3a
--- /dev/null
+++ b/dtc/tests/subnode_iterate.dts
@@ -0,0 +1,44 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	test1 {
+		subnodes = <2>;
+		linux,phandle = <0x1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		PowerPC,970@0 {
+			name = "PowerPC,970";
+			device_type = "cpu";
+			reg = <0x00000000>;
+			clock-frequency = <1600000000>;
+			timebase-frequency = <33333333>;
+			linux,boot-cpu;
+			i-cache-size = <65536>;
+			d-cache-size = <32768>;
+			another-sub-node {
+				should-be-ignored;
+				yet-another {
+					should-also-be-ignored;
+				};
+			};
+		};
+
+		PowerPC,970@1 {
+			name = "PowerPC,970";
+			device_type = "cpu";
+			reg = <0x00000001>;
+			clock-frequency = <1600000000>;
+			timebase-frequency = <33333333>;
+			i-cache-size = <65536>;
+			d-cache-size = <32768>;
+		};
+	};
+
+	test2 {
+		subnodes = <0>;
+	};
+};
+
diff --git a/dtc/tests/subnode_offset.c b/dtc/tests/subnode_offset.c
new file mode 100644
index 0000000..1362f99
--- /dev/null
+++ b/dtc/tests/subnode_offset.c
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_subnode_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int check_subnode(struct fdt_header *fdt, int parent, const char *name)
+{
+	int offset;
+	const struct fdt_node_header *nh;
+	uint32_t tag;
+
+	verbose_printf("Checking subnode \"%s\" of %d...", name, parent);
+	offset = fdt_subnode_offset(fdt, parent, name);
+	verbose_printf("offset %d...", offset);
+	if (offset < 0)
+		FAIL("fdt_subnode_offset(\"%s\"): %s", name, fdt_strerror(offset));
+	nh = fdt_offset_ptr(fdt, offset, sizeof(*nh));
+	verbose_printf("pointer %p\n", nh);
+	if (! nh)
+		FAIL("NULL retrieving subnode \"%s\"", name);
+
+	tag = fdt32_to_cpu(nh->tag);
+
+	if (tag != FDT_BEGIN_NODE)
+		FAIL("Incorrect tag 0x%08x on property \"%s\"", tag, name);
+	if (!nodename_eq(nh->name, name))
+		FAIL("Subnode name mismatch \"%s\" instead of \"%s\"",
+		     nh->name, name);
+
+	return offset;
+}
+
+int main(int argc, char *argv[])
+{
+	void *fdt;
+	int subnode1_offset, subnode2_offset;
+	int subsubnode1_offset, subsubnode2_offset, subsubnode2_offset2;
+	int ss12_off, ss21_off;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	subnode1_offset = check_subnode(fdt, 0, "subnode@1");
+	subnode2_offset = check_subnode(fdt, 0, "subnode@2");
+
+	if (subnode1_offset == subnode2_offset)
+		FAIL("Different subnodes have same offset");
+
+	check_property_cell(fdt, subnode1_offset, "prop-int", TEST_VALUE_1);
+	check_property_cell(fdt, subnode2_offset, "prop-int", TEST_VALUE_2);
+
+	subsubnode1_offset = check_subnode(fdt, subnode1_offset, "subsubnode");
+	subsubnode2_offset = check_subnode(fdt, subnode2_offset, "subsubnode@0");
+	subsubnode2_offset2 = check_subnode(fdt, subnode2_offset, "subsubnode");
+
+	check_property_cell(fdt, subsubnode1_offset, "prop-int", TEST_VALUE_1);
+	check_property_cell(fdt, subsubnode2_offset, "prop-int", TEST_VALUE_2);
+	check_property_cell(fdt, subsubnode2_offset2, "prop-int", TEST_VALUE_2);
+
+	if (subsubnode2_offset != subsubnode2_offset2)
+		FAIL("Different offsets with and without unit address");
+
+	check_subnode(fdt, subnode1_offset, "ss1");
+	ss21_off = fdt_subnode_offset(fdt, subnode2_offset, "ss1");
+	if (ss21_off != -FDT_ERR_NOTFOUND)
+		FAIL("Incorrectly found ss1 in subnode2");
+
+	ss12_off = fdt_subnode_offset(fdt, subnode1_offset, "ss2");
+	if (ss12_off != -FDT_ERR_NOTFOUND)
+		FAIL("Incorrectly found ss2 in subnode1");
+	check_subnode(fdt, subnode2_offset, "ss2");
+
+	PASS();
+}
diff --git a/dtc/tests/supernode_atdepth_offset.c b/dtc/tests/supernode_atdepth_offset.c
new file mode 100644
index 0000000..4435b49
--- /dev/null
+++ b/dtc/tests/supernode_atdepth_offset.c
@@ -0,0 +1,132 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_supernode_atdepth_offset()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static int path_depth(const char *path)
+{
+	const char *p;
+	int depth = 0;
+
+	if (path[0] != '/')
+		TEST_BUG();
+
+	if (strcmp(path, "/") == 0)
+		return 0;
+	for (p = path; *p; p++)
+		if (*p == '/')
+			depth++;
+
+	/* Special case for path == "/" */
+	if (p == (path + 1))
+		return 0;
+	else
+		return depth;
+}
+
+static int path_prefix(const char *path, int depth)
+{
+	const char *p;
+	int i;
+
+	if (path[0] != '/')
+		TEST_BUG();
+
+	if (depth == 0)
+		return 1;
+
+	p = path;
+	for (i = 0; i < depth; i++)
+		p = p+1 + strcspn(p+1, "/");
+
+	return p - path;
+}
+
+static void check_supernode_atdepth(struct fdt_header *fdt, const char *path,
+			     int depth)
+{
+	int pdepth = path_depth(path);
+	char *superpath;
+	int nodeoffset, supernodeoffset, superpathoffset, pathprefixlen;
+	int nodedepth;
+
+	pathprefixlen = path_prefix(path, depth);
+	superpath = alloca(pathprefixlen + 1);
+	strncpy(superpath, path, pathprefixlen);
+	superpath[pathprefixlen] = '\0';
+
+	verbose_printf("Path %s (%d), depth %d, supernode is %s\n",
+		       path, pdepth, depth, superpath);
+
+	nodeoffset = fdt_path_offset(fdt, path);
+	if (nodeoffset < 0)
+		FAIL("fdt_path_offset(%s): %s", path, fdt_strerror(nodeoffset));
+	superpathoffset = fdt_path_offset(fdt, superpath);
+	if (superpathoffset < 0)
+		FAIL("fdt_path_offset(%s): %s", superpath,
+		     fdt_strerror(superpathoffset));
+
+	supernodeoffset = fdt_supernode_atdepth_offset(fdt, nodeoffset,
+						       depth, &nodedepth);
+	if (supernodeoffset < 0)
+		FAIL("fdt_supernode_atdepth_offset(): %s",
+		     fdt_strerror(supernodeoffset));
+
+	if (supernodeoffset != superpathoffset)
+		FAIL("fdt_supernode_atdepth_offset() returns %d instead of %d",
+		     supernodeoffset, superpathoffset);
+
+	if (nodedepth != pdepth)
+		FAIL("fdt_supernode_atdept_offset() returns node depth %d "
+		     "instead of %d", nodedepth, pdepth);
+}
+
+static void check_supernode_overdepth(struct fdt_header *fdt, const char *path)
+{
+	int pdepth = path_depth(path);
+	int nodeoffset, err;
+
+	nodeoffset = fdt_path_offset(fdt, path);
+	if (nodeoffset < 0)
+		FAIL("fdt_path_offset(%s): %s", path, fdt_strerror(nodeoffset));
+
+	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, pdepth + 1, NULL);
+	if (err != -FDT_ERR_NOTFOUND)
+		FAIL("fdt_supernode_atdept_offset(%s, %d) returns %d instead "
+		     "of FDT_ERR_NOTFOUND", path, pdepth+1, err);
+}
+
+static void check_path(struct fdt_header *fdt, const char *path)
+{
+	int i;
+
+	for (i = 0; i <= path_depth(path); i++)
+		check_supernode_atdepth(fdt, path, i);
+	check_supernode_overdepth(fdt, path);
+}
+int main(int argc, char *argv[])
+{
+	void *fdt;
+
+	test_init(argc, argv);
+	fdt = load_blob_arg(argc, argv);
+
+	check_path(fdt, "/");
+	check_path(fdt, "/subnode@1");
+	check_path(fdt, "/subnode@2");
+	check_path(fdt, "/subnode@1/subsubnode");
+	check_path(fdt, "/subnode@2/subsubnode@0");
+
+	PASS();
+}
diff --git a/dtc/tests/sw_states.c b/dtc/tests/sw_states.c
new file mode 100644
index 0000000..42d57ae
--- /dev/null
+++ b/dtc/tests/sw_states.c
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for error handling with sequential write states
+ * Copyright (C) 2018 David Gibson, Red Hat Inc.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE	65536
+
+#define CHECK_OK(code)							\
+	do {								\
+		verbose_printf(" OK: %s\n", #code);			\
+		err = (code);						\
+		if (err)						\
+			FAIL(#code ": %s", fdt_strerror(err));		\
+	} while (0)
+
+#define CHECK_BADSTATE(code)						\
+	do {								\
+		verbose_printf("BAD: %s\n", #code);			\
+		err = (code);						\
+		if (err == 0)						\
+			FAIL(#code ": succeeded in bad state");		\
+		else if (err != -FDT_ERR_BADSTATE)			\
+			FAIL(#code ": %s", fdt_strerror(err));		\
+	} while (0)
+
+int main(int argc, char *argv[])
+{
+	void *fdt = NULL;
+	int err;
+
+	test_init(argc, argv);
+
+	fdt = xmalloc(SPACE);
+
+	err = fdt_create(fdt, SPACE);
+	if (err)
+		FAIL("fdt_create(): %s", fdt_strerror(err));
+
+	/* Memory reserve state */
+
+	CHECK_BADSTATE(fdt_begin_node(fdt, ""));
+	CHECK_BADSTATE(fdt_property_string(fdt, "bad-str", "TEST_STRING_1"));
+	CHECK_BADSTATE(fdt_end_node(fdt));
+	CHECK_BADSTATE(fdt_finish(fdt));
+
+	CHECK_OK(fdt_add_reservemap_entry(fdt, TEST_ADDR_1, TEST_SIZE_1));
+	CHECK_OK(fdt_add_reservemap_entry(fdt, TEST_ADDR_2, TEST_SIZE_2));
+
+	CHECK_BADSTATE(fdt_begin_node(fdt, ""));
+	CHECK_BADSTATE(fdt_property_string(fdt, "bad-str", "TEST_STRING_1"));
+	CHECK_BADSTATE(fdt_end_node(fdt));
+	CHECK_BADSTATE(fdt_finish(fdt));
+
+	CHECK_OK(fdt_finish_reservemap(fdt));
+
+	/* Structure state */
+
+	CHECK_BADSTATE(fdt_add_reservemap_entry(fdt, TEST_ADDR_1, TEST_SIZE_1));
+	CHECK_BADSTATE(fdt_finish_reservemap(fdt));
+
+	CHECK_OK(fdt_begin_node(fdt, ""));
+	CHECK_OK(fdt_property_string(fdt, "compatible", "test_tree1"));
+	CHECK_OK(fdt_property_u32(fdt, "prop-int", TEST_VALUE_1));
+	CHECK_OK(fdt_property_u64(fdt, "prop-int64", TEST_VALUE64_1));
+	CHECK_OK(fdt_property_string(fdt, "prop-str", TEST_STRING_1));
+	CHECK_OK(fdt_property_u32(fdt, "#address-cells", 1));
+	CHECK_OK(fdt_property_u32(fdt, "#size-cells", 0));
+
+	CHECK_OK(fdt_begin_node(fdt, "subnode@1"));
+	CHECK_OK(fdt_property_string(fdt, "compatible", "subnode1"));
+	CHECK_OK(fdt_property_u32(fdt, "reg", 1));
+	CHECK_OK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_1));
+	CHECK_OK(fdt_begin_node(fdt, "subsubnode"));
+	CHECK_OK(fdt_property(fdt, "compatible", "subsubnode1\0subsubnode",
+			   23));
+	CHECK_OK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_1));
+	CHECK_OK(fdt_end_node(fdt));
+	CHECK_OK(fdt_begin_node(fdt, "ss1"));
+	CHECK_OK(fdt_end_node(fdt));
+	CHECK_OK(fdt_end_node(fdt));
+
+	CHECK_OK(fdt_begin_node(fdt, "subnode@2"));
+	CHECK_OK(fdt_property_u32(fdt, "reg", 2));
+	CHECK_OK(fdt_property_cell(fdt, "linux,phandle", PHANDLE_1));
+	CHECK_OK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_2));
+	CHECK_OK(fdt_property_u32(fdt, "#address-cells", 1));
+	CHECK_OK(fdt_property_u32(fdt, "#size-cells", 0));
+	CHECK_OK(fdt_begin_node(fdt, "subsubnode@0"));
+	CHECK_OK(fdt_property_u32(fdt, "reg", 0));
+	CHECK_OK(fdt_property_cell(fdt, "phandle", PHANDLE_2));
+	CHECK_OK(fdt_property(fdt, "compatible", "subsubnode2\0subsubnode",
+			   23));
+	CHECK_OK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_2));
+	CHECK_OK(fdt_end_node(fdt));
+	CHECK_OK(fdt_begin_node(fdt, "ss2"));
+	CHECK_OK(fdt_end_node(fdt));
+
+	CHECK_OK(fdt_end_node(fdt));
+
+	CHECK_OK(fdt_end_node(fdt));
+
+	CHECK_OK(fdt_finish(fdt));
+
+	/* Completed state */
+
+	CHECK_BADSTATE(fdt_add_reservemap_entry(fdt, TEST_ADDR_1, TEST_SIZE_1));
+	CHECK_BADSTATE(fdt_finish_reservemap(fdt));
+	CHECK_BADSTATE(fdt_begin_node(fdt, ""));
+	CHECK_BADSTATE(fdt_property_string(fdt, "bad-str", "TEST_STRING_1"));
+	CHECK_BADSTATE(fdt_end_node(fdt));
+	CHECK_BADSTATE(fdt_finish(fdt));
+
+	PASS();
+}
diff --git a/dtc/tests/sw_tree1.c b/dtc/tests/sw_tree1.c
new file mode 100644
index 0000000..7069ace
--- /dev/null
+++ b/dtc/tests/sw_tree1.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for fdt_nop_node()
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+#define SPACE	65536
+
+static enum {
+	FIXED = 0,
+	RESIZE,
+	REALLOC,
+	NEWALLOC,
+} alloc_mode;
+
+static void realloc_fdt(void **fdt, size_t *size, bool created)
+{
+	int err;
+
+	switch (alloc_mode) {
+	case FIXED:
+		if (!(*fdt))
+			*fdt = xmalloc(*size);
+		else
+			FAIL("Ran out of space");
+		return;
+
+	case RESIZE:
+		if (!(*fdt)) {
+			*fdt = xmalloc(SPACE);
+		} else if (*size < SPACE) {
+			*size += 1;
+			err = fdt_resize(*fdt, *fdt, *size);
+			if (err < 0)
+				FAIL("fdt_resize() failed: %s",
+				     fdt_strerror(err));
+		} else {
+			FAIL("Ran out of space");
+		}		
+		return;
+
+	case REALLOC:
+		*size += 1;
+		*fdt = xrealloc(*fdt, *size);
+		if (created) {
+			err = fdt_resize(*fdt, *fdt, *size);
+			if (err < 0)
+				FAIL("fdt_resize() failed: %s",
+				     fdt_strerror(err));
+		}
+		return;
+
+	case NEWALLOC: {
+		void *buf;
+
+		*size += 1;
+		buf = xmalloc(*size);
+		if (created) {
+			err = fdt_resize(*fdt, buf, *size);
+			if (err < 0)
+				FAIL("fdt_resize() failed: %s",
+				     fdt_strerror(err));
+		}
+		free(*fdt);
+		*fdt = buf;
+		return;
+	}
+
+	default:
+		CONFIG("Bad allocation mode");
+	}
+}
+
+#define CHECK(code) \
+	do {			      \
+		err = (code);			     \
+		if (err == -FDT_ERR_NOSPACE)			\
+			realloc_fdt(&fdt, &size, created);		\
+		else if (err)						\
+			FAIL(#code ": %s", fdt_strerror(err));		\
+	} while (err != 0)
+
+int main(int argc, char *argv[])
+{
+	void *fdt = NULL;
+	size_t size;
+	int err;
+	bool created = false;
+	void *place;
+	const char place_str[] = "this is a placeholder string\0string2";
+	int place_len = sizeof(place_str);
+	int create_flags;
+
+	test_init(argc, argv);
+
+	alloc_mode = FIXED;
+	size = SPACE;
+	create_flags = 0;
+
+	if (argc == 2 || argc == 3) {
+		if (streq(argv[1], "fixed")) {
+			alloc_mode = FIXED;
+			size = SPACE;
+		} else if (streq(argv[1], "resize")) {
+			alloc_mode = REALLOC;
+			size = 0;
+		} else if (streq(argv[1], "realloc")) {
+			alloc_mode = REALLOC;
+			size = 0;
+		} else if (streq(argv[1], "newalloc")) {
+			alloc_mode = NEWALLOC;
+			size = 0;
+		} else {
+			char *endp;
+
+			size = strtoul(argv[1], &endp, 0);
+			if (*endp == '\0')
+				alloc_mode = FIXED;
+			else 
+				CONFIG("Bad allocation mode \"%s\" specified",
+				       argv[1]);
+		}
+	}
+	if (argc == 3) {
+		char *str = argv[2], *saveptr, *tok;
+		bool default_flag = false;
+
+		while ((tok = strtok_r(str, ",", &saveptr)) != NULL) {
+			str = NULL;
+			if (streq(tok, "default")) {
+				default_flag = true;
+			} else if (streq(tok, "no_name_dedup")) {
+				create_flags |= FDT_CREATE_FLAG_NO_NAME_DEDUP;
+			} else if (streq(tok, "bad")) {
+				create_flags |= 0xffffffff;
+			} else {
+				CONFIG("Bad creation flags \"%s\" specified",
+				       argv[2]);
+			}
+		}
+
+		if (default_flag && create_flags != 0)
+			CONFIG("Bad creation flags \"%s\" specified",
+			       argv[2]);
+	}
+
+	if (argc > 3) {
+		CONFIG("sw_tree1 [<allocation mode>] [<create flags>]");
+	}
+
+	fdt = xmalloc(size);
+	CHECK(fdt_create_with_flags(fdt, size, create_flags));
+
+	created = true;
+
+	CHECK(fdt_add_reservemap_entry(fdt, TEST_ADDR_1, TEST_SIZE_1));
+
+	CHECK(fdt_add_reservemap_entry(fdt, TEST_ADDR_2, TEST_SIZE_2));
+	CHECK(fdt_finish_reservemap(fdt));
+
+	CHECK(fdt_begin_node(fdt, ""));
+	CHECK(fdt_property_string(fdt, "compatible", "test_tree1"));
+	CHECK(fdt_property_u32(fdt, "prop-int", TEST_VALUE_1));
+	CHECK(fdt_property_u64(fdt, "prop-int64", TEST_VALUE64_1));
+	CHECK(fdt_property_string(fdt, "prop-str", TEST_STRING_1));
+	CHECK(fdt_property_u32(fdt, "#address-cells", 1));
+	CHECK(fdt_property_u32(fdt, "#size-cells", 0));
+
+	CHECK(fdt_begin_node(fdt, "subnode@1"));
+	CHECK(fdt_property_string(fdt, "compatible", "subnode1"));
+	CHECK(fdt_property_u32(fdt, "reg", 1));
+	CHECK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_1));
+	CHECK(fdt_begin_node(fdt, "subsubnode"));
+	CHECK(fdt_property(fdt, "compatible", "subsubnode1\0subsubnode",
+			   23));
+	CHECK(fdt_property_placeholder(fdt, "placeholder", place_len, &place));
+	memcpy(place, place_str, place_len);
+	CHECK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_1));
+	CHECK(fdt_end_node(fdt));
+	CHECK(fdt_begin_node(fdt, "ss1"));
+	CHECK(fdt_end_node(fdt));
+	CHECK(fdt_end_node(fdt));
+
+	CHECK(fdt_begin_node(fdt, "subnode@2"));
+	CHECK(fdt_property_u32(fdt, "reg", 2));
+	CHECK(fdt_property_cell(fdt, "linux,phandle", PHANDLE_1));
+	CHECK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_2));
+	CHECK(fdt_property_u32(fdt, "#address-cells", 1));
+	CHECK(fdt_property_u32(fdt, "#size-cells", 0));
+	CHECK(fdt_begin_node(fdt, "subsubnode@0"));
+	CHECK(fdt_property_u32(fdt, "reg", 0));
+	CHECK(fdt_property_cell(fdt, "phandle", PHANDLE_2));
+	CHECK(fdt_property(fdt, "compatible", "subsubnode2\0subsubnode",
+			   23));
+	CHECK(fdt_property_cell(fdt, "prop-int", TEST_VALUE_2));
+	CHECK(fdt_end_node(fdt));
+	CHECK(fdt_begin_node(fdt, "ss2"));
+	CHECK(fdt_end_node(fdt));
+
+	CHECK(fdt_end_node(fdt));
+
+	CHECK(fdt_end_node(fdt));
+
+	save_blob("unfinished_tree1.test.dtb", fdt);
+
+	CHECK(fdt_finish(fdt));
+
+	verbose_printf("Completed tree, totalsize = %d\n",
+		       fdt_totalsize(fdt));
+
+	save_blob("sw_tree1.test.dtb", fdt);
+
+	PASS();
+}
diff --git a/dtc/tests/test01.asm b/dtc/tests/test01.asm
new file mode 100644
index 0000000..bbf66c7
--- /dev/null
+++ b/dtc/tests/test01.asm
@@ -0,0 +1,294 @@
+/* autogenerated by dtc, do not edit */
+
+#define OF_DT_HEADER 0xd00dfeed
+#define OF_DT_BEGIN_NODE 0x1
+#define OF_DT_END_NODE 0x2
+#define OF_DT_PROP 0x3
+#define OF_DT_END 0x9
+
+	.globl	dt_blob_start
+dt_blob_start:
+_dt_blob_start:
+	.globl	dt_header
+dt_header:
+_dt_header:
+	.long	OF_DT_HEADER /* magic */
+	.long	_dt_blob_end - _dt_blob_start /* totalsize */
+	.long	_dt_struct_start - _dt_blob_start /* off_dt_struct */
+	.long	_dt_strings_start - _dt_blob_start /* off_dt_strings */
+	.long	_dt_reserve_map - _dt_blob_start /* off_dt_strings */
+	.long	16 /* version */
+	.long	16 /* last_comp_version */
+	.long	0	/*boot_cpuid_phys*/
+	.long	_dt_strings_end - _dt_strings_start	/* size_dt_strings */
+	.balign	8
+	.globl	dt_reserve_map
+dt_reserve_map:
+_dt_reserve_map:
+/* Memory reserve map from source file */
+	.long	0x10000000
+	.long	0x00000000
+	.long	0x00000000
+	.long	0x02000000
+	.long	0x20000000
+	.long	0x00000000
+	.long	0x01000000
+	.long	0x00000000
+	.long	0x00000000
+	.long	0x00000000
+	.long	0x00000000
+	.long	0x00000014
+	.long	0, 0
+	.long	0, 0
+	.globl	dt_struct_start
+dt_struct_start:
+_dt_struct_start:
+	.long	OF_DT_BEGIN_NODE
+	.string	""
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0xc
+	.long	0x0
+	.long	0x4d79426f
+	.long	0x6172644e
+	.long	0x616d6500
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x1e
+	.long	0x6
+	.long	0x4d79426f
+	.long	0x6172644e
+	.long	0x616d6500
+	.long	0x4d79426f
+	.long	0x61726446
+	.long	0x616d696c
+	.long	0x794e616d
+	.short	0x6500
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x11
+	.long	0x2
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x20
+	.long	0x2
+	.balign	4
+	.long	OF_DT_BEGIN_NODE
+	.string	"cpus"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x2c
+	.long	0x1
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x11
+	.long	0x1
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x20
+	.long	0x0
+	.balign	4
+	.long	OF_DT_BEGIN_NODE
+	.string	"PowerPC,970@0"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0xc
+	.long	0x3a
+	.long	0x506f7765
+	.long	0x7250432c
+	.long	0x39373000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x3f
+	.long	0x63707500
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x4b
+	.long	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x4f
+	.long	0x5f5e1000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x5f
+	.long	0x1fca055
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x0
+	.long	0x72
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x81
+	.long	0x10000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x8e
+	.long	0x8000
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_BEGIN_NODE
+	.string	"PowerPC,970@1"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0xc
+	.long	0x3a
+	.long	0x506f7765
+	.long	0x7250432c
+	.long	0x39373000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x3f
+	.long	0x63707500
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x4b
+	.long	0x1
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x4f
+	.long	0x5f5e1000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x5f
+	.long	0x1fca055
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x81
+	.long	0x10000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x8e
+	.long	0x8000
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_END_NODE
+	.long	OF_DT_BEGIN_NODE
+	.string	"randomnode"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x13
+	.long	0x9b
+	.long	0xff007374
+	.long	0x75666673
+	.long	0x74756666
+	.long	0x909090a
+	.short	0xa0a
+	.byte	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x9
+	.long	0xa2
+	.long	0xa0b0c0d
+	.long	0xdeeaadbe
+	.byte	0xef
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0xa7
+	.long	0x2
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x14
+	.long	0xab
+	.long	0x61626300
+	.long	0x12340000
+	.long	0xa
+	.long	0xb
+	.long	0xc
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_BEGIN_NODE
+	.string	"memory@0"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x7
+	.long	0x3f
+	.long	0x6d656d6f
+	.short	0x7279
+	.byte	0x0
+	.balign	4
+	.globl	memreg
+memreg:
+	.long	OF_DT_PROP
+	.long	0x10
+	.long	0x4b
+	.long	0x0
+	.long	0x0
+	.long	0x0
+	.long	0x20000000
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0x2c
+	.long	0x2
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_BEGIN_NODE
+	.string	"chosen"
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0xf
+	.long	0xb1
+	.long	0x726f6f74
+	.long	0x3d2f6465
+	.long	0x762f7364
+	.short	0x6132
+	.byte	0x0
+	.balign	4
+	.long	OF_DT_PROP
+	.long	0x4
+	.long	0xba
+	.long	0x600
+	.balign	4
+	.long	OF_DT_END_NODE
+	.long	OF_DT_END_NODE
+	.long	OF_DT_END
+	.globl	dt_struct_end
+dt_struct_end:
+_dt_struct_end:
+	.globl	dt_strings_start
+dt_strings_start:
+_dt_strings_start:
+	.string "model"
+	.string "compatible"
+	.string "#address-cells"
+	.string "#size-cells"
+	.string "linux,phandle"
+	.string "name"
+	.string "device_type"
+	.string "reg"
+	.string "clock-frequency"
+	.string "timebase-frequency"
+	.string "linux,boot-cpu"
+	.string "i-cache-size"
+	.string "d-cache-size"
+	.string "string"
+	.string "blob"
+	.string "ref"
+	.string "mixed"
+	.string "bootargs"
+	.string "linux,platform"
+	.globl	dt_strings_end
+dt_strings_end:
+_dt_strings_end:
+	.globl	dt_blob_end
+dt_blob_end:
+_dt_blob_end:
diff --git a/dtc/tests/test01.dts b/dtc/tests/test01.dts
new file mode 100644
index 0000000..f9fd165
--- /dev/null
+++ b/dtc/tests/test01.dts
@@ -0,0 +1,57 @@
+/dts-v1/;
+
+/memreserve/ 0x1000000000000000 0x0000000002000000;
+/memreserve/ 0x2000000000000000 0x0100000000000000;
+/memreserve/ 0x0000000000000000 0x0000000000000014;
+
+/ {
+	model = "MyBoardName";
+	compatible = "MyBoardName", "MyBoardFamilyName";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		linux,phandle = <0x1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		PowerPC,970@0 {
+			name = "PowerPC,970";
+			device_type = "cpu";
+			reg = <0x00000000>;
+			clock-frequency = <1600000000>;
+			timebase-frequency = <33333333>;
+			linux,boot-cpu;
+			i-cache-size = <65536>;
+			d-cache-size = <32768>;
+		};
+
+		PowerPC,970@1 {
+			name = "PowerPC,970";
+			device_type = "cpu";
+			reg = <0x00000001>;
+			clock-frequency = <1600000000>;
+			timebase-frequency = <33333333>;
+			i-cache-size = <65536>;
+			d-cache-size = <32768>;
+		};
+
+	};
+
+	randomnode {
+		string = "\xff\0stuffstuff\t\t\t\n\n\n";
+		blob = [0a 0b 0c 0d de ea ad be ef];
+		ref = < &{/memory@0} >;
+		mixed = "abc", [1234], <0xa 0xb 0xc>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		memreg: reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
+	};
+
+	chosen {
+		bootargs = "root=/dev/sda2";
+		linux,platform = <0x600>;
+	};
+
+};
diff --git a/dtc/tests/test01.stderr b/dtc/tests/test01.stderr
new file mode 100644
index 0000000..82ea3f6
--- /dev/null
+++ b/dtc/tests/test01.stderr
@@ -0,0 +1,4 @@
+DTC: dts->asm  on file "test.dts"
+Warning: "linux,boot-cpu" property is deprecated in blob version 2 or higher
+Warning: /chosen has no "linux,stdout-path" property
+Warning: /chosen has no "interrupt-controller" property
diff --git a/dtc/tests/test_kernel_dts b/dtc/tests/test_kernel_dts
new file mode 100755
index 0000000..238f3f7
--- /dev/null
+++ b/dtc/tests/test_kernel_dts
@@ -0,0 +1,86 @@
+#!/usr/bin/perl
+
+my $dtc_old = "/home/jdl/FSL/dtc/dtc-old";
+my $dtc_new = "/home/jdl/FSL/dtc/dtc-new";
+
+my $basic_options = "-b 0 -f -I dts -O dtb";
+
+my $linux_dts_dir = "/usr/src/linux-2.6/arch/powerpc/boot/dts";
+
+# Yeah, sure, we could, like, readdir() this instead...
+my @boards = (
+	      "bamboo",
+	      "ebony",
+	      "ep88xc",
+	      "holly",
+	      "kilauea",
+	      "kuroboxHD",
+	      "kuroboxHG",
+	      "lite5200",
+	      "lite5200b",
+	      "mpc7448hpc2",
+	      "mpc8272ads",
+	      "mpc8313erdb",
+	      "mpc832x_mds",
+	      "mpc832x_rdb",
+	      "mpc8349emitx",
+	      "mpc8349emitxgp",
+	      "mpc834x_mds",
+	      "mpc836x_mds",
+	      "mpc8540ads",
+	      "mpc8541cds",
+	      "mpc8544ds",
+	      "mpc8548cds",
+	      "mpc8555cds",
+	      "mpc8560ads",
+	      "mpc8568mds",
+	      "mpc8572ds",
+	      "mpc8610_hpcd",
+	      "mpc8641_hpcn",
+	      "mpc866ads",	# Feh.  Bad node references...
+	      "mpc885ads",
+	      "pq2fads",
+	      "prpmc2800",
+	      "ps3",
+	      "sequoia",
+	      "walnut",
+);
+
+foreach my $board (@boards) {
+	my $dts_file = "$linux_dts_dir/$board.dts";
+
+	my $old_dtb_file = "/tmp/$board.dtb.old";
+	my $new_dtb_file = "/tmp/$board.dtb.new";
+
+	my $cmd_old = "$dtc_old $basic_options -o $old_dtb_file $dts_file";
+	my $cmd_new = "$dtc_new $basic_options -o $new_dtb_file $dts_file";
+	my $cmd_cmp = "cmp $old_dtb_file $new_dtb_file";
+
+	print "------------------------------------------------\n";
+	print "OLD: $cmd_old\n";
+	unlink($old_dtb_file) if (-f $old_dtb_file);
+	system("$cmd_old >& /dev/null");
+	my $status = $?;
+	if ($status) {
+		print "    FAILED to run old DTC on $board\n";
+	}
+
+	print "NEW: $cmd_new\n";
+	unlink($new_dtb_file) if (-f $new_dtb_file);
+	system("$cmd_new >& /dev/null");
+	$status = $?;
+	if ($status) {
+		print "    FAILED to run new DTC on $board\n";
+	}
+
+	if (-f $old_dtb_file && -f $new_dtb_file) {
+	    print "CMP: $cmd_cmp\n";
+	    system($cmd_cmp);
+	    $status = $?;
+	    if ($status) {
+		print "    FAILED $board\n";
+	    }
+	} else {
+	    printf "    FAILED: Missing dtb file\n";
+	}
+}
diff --git a/dtc/tests/test_label_ref.dts b/dtc/tests/test_label_ref.dts
new file mode 100644
index 0000000..7009c79
--- /dev/null
+++ b/dtc/tests/test_label_ref.dts
@@ -0,0 +1,9 @@
+/dts-v1/;
+
+/ {
+
+};
+
+label: &handle {
+
+};
diff --git a/dtc/tests/test_props.dts b/dtc/tests/test_props.dts
new file mode 100644
index 0000000..7e59bd1
--- /dev/null
+++ b/dtc/tests/test_props.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+
+/ {
+	compatible = "test_props";
+	prop-hex32 = <0xdeadbeef>;
+	prop-uint32 = <123>;
+	prop-int32 = <0xfffffffe>;
+	prop-hex64 = /bits/ 64 <0xdeadbeef01abcdef>;
+	prop-uint64 = /bits/ 64 <9223372036854775807>;
+	prop-int64 = /bits/ 64 <0xfffffffffffffffe>;
+};
diff --git a/dtc/tests/test_tree1.dts b/dtc/tests/test_tree1.dts
new file mode 100644
index 0000000..77ea325
--- /dev/null
+++ b/dtc/tests/test_tree1.dts
@@ -0,0 +1,46 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-int64 = /bits/ 64 <0xdeadbeef01abcdef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			placeholder = "this is a placeholder string", "string2";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ssn0: subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_delete.dts b/dtc/tests/test_tree1_delete.dts
new file mode 100644
index 0000000..b95ef1e
--- /dev/null
+++ b/dtc/tests/test_tree1_delete.dts
@@ -0,0 +1,68 @@
+/dts-v1/;
+
+/include/ "test_tree1.dts"
+
+/ {
+	nonexistant-property = <0xdeadbeef>;
+
+	nonexistant-subnode {
+		prop-int = <1>;
+	};
+
+	dellabel: deleted-by-label {
+		prop-int = <1>;
+	};
+
+	subnode@1 {
+		delete-this-str = "deadbeef";
+	};
+
+};
+
+/ {
+	/delete-property/ nonexistant-property;
+
+	/delete-node/ nonexistant-subnode;
+
+	subnode@1 {
+		/delete-property/ delete-this-str;
+	};
+};
+
+/delete-node/ &dellabel;
+
+/ {
+	/delete-property/ prop-str;
+};
+
+/ {
+	prop-str = "hello world";
+};
+
+/ {
+	subnode@1 {
+		/delete-node/ ss1;
+	};
+};
+
+/ {
+	subnode@1 {
+		ss1 {
+		};
+	};
+};
+
+/{
+	duplabel1: foo1 = "bar";
+	duplabel2: foo2 = "bar";
+};
+
+/{
+	duplabel1: baz1 = "qux";
+	duplabel2: baz2 = "qux";
+};
+
+/{
+	/delete-property/ foo1;
+	/delete-property/ baz2;
+};
diff --git a/dtc/tests/test_tree1_label_noderef.dts b/dtc/tests/test_tree1_label_noderef.dts
new file mode 100644
index 0000000..cfe5946
--- /dev/null
+++ b/dtc/tests/test_tree1_label_noderef.dts
@@ -0,0 +1,56 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-int64 = /bits/ 64 <0xdeadbeef01abcdef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			placeholder = "this is a placeholder string", "string2";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ssn0: subsubnode@0 {
+			phandle = <0x2001>;
+			prop-int = <0xbad>;
+		};
+
+		ss2 {
+		};
+	};
+};
+
+/* Add label to a noderef */
+ssn1: &ssn0 {
+	reg = <0>;
+	prop-int = <123456789>;
+};
+
+/* Use the new label for merging */
+&ssn1 {
+	prop-int = <0726746425>;
+	compatible = "subsubnode2", "subsubnode";
+};
diff --git a/dtc/tests/test_tree1_merge.dts b/dtc/tests/test_tree1_merge.dts
new file mode 100644
index 0000000..b100c12
--- /dev/null
+++ b/dtc/tests/test_tree1_merge.dts
@@ -0,0 +1,51 @@
+/dts-v1/;
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = "wrong!";
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ss2 {
+		};
+	};
+};
+
+/ {
+	prop-int = <0xdeadbeef>;
+	prop-int64 = /bits/ 64 <0xdeadbeef01abcdef>;
+	subnode@1 {
+		prop-int = [deadbeef];
+	};
+	subnode@2 {
+		ssn0: subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_merge_labelled.dts b/dtc/tests/test_tree1_merge_labelled.dts
new file mode 100644
index 0000000..fcf5dc4
--- /dev/null
+++ b/dtc/tests/test_tree1_merge_labelled.dts
@@ -0,0 +1,49 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-int64 = /bits/ 64 <0xdeadbeef01abcdef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ssn0: subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			prop-int = <0xbad>;
+		};
+
+		ss2 {
+		};
+	};
+};
+
+&ssn0 {
+	compatible = "subsubnode2", "subsubnode";
+	prop-int = <0726746425>;
+};
diff --git a/dtc/tests/test_tree1_merge_path.dts b/dtc/tests/test_tree1_merge_path.dts
new file mode 100644
index 0000000..c2ad829
--- /dev/null
+++ b/dtc/tests/test_tree1_merge_path.dts
@@ -0,0 +1,49 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-int64 = /bits/ 64 <0xdeadbeef01abcdef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ssn0: subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			prop-int = <0xbad>;
+		};
+
+		ss2 {
+		};
+	};
+};
+
+&{/subnode@2/subsubnode@0} {
+	compatible = "subsubnode2", "subsubnode";
+	prop-int = <0726746425>;
+};
diff --git a/dtc/tests/test_tree1_wrong1.dts b/dtc/tests/test_tree1_wrong1.dts
new file mode 100644
index 0000000..900d385
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong1.dts
@@ -0,0 +1,43 @@
+/dts-v1/;
+
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong2.dts b/dtc/tests/test_tree1_wrong2.dts
new file mode 100644
index 0000000..099752b
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong2.dts
@@ -0,0 +1,43 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong3.dts b/dtc/tests/test_tree1_wrong3.dts
new file mode 100644
index 0000000..069353a
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong3.dts
@@ -0,0 +1,43 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong4.dts b/dtc/tests/test_tree1_wrong4.dts
new file mode 100644
index 0000000..2c56416
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong4.dts
@@ -0,0 +1,41 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong5.dts b/dtc/tests/test_tree1_wrong5.dts
new file mode 100644
index 0000000..6ddd72d
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong5.dts
@@ -0,0 +1,44 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbefe>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong6.dts b/dtc/tests/test_tree1_wrong6.dts
new file mode 100644
index 0000000..36b4e1f
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong6.dts
@@ -0,0 +1,45 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+			extra-prop;
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong7.dts b/dtc/tests/test_tree1_wrong7.dts
new file mode 100644
index 0000000..54150e6
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong7.dts
@@ -0,0 +1,46 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+			extranode {
+			};
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong8.dts b/dtc/tests/test_tree1_wrong8.dts
new file mode 100644
index 0000000..7a28a9f
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong8.dts
@@ -0,0 +1,44 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010001;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <2>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/test_tree1_wrong9.dts b/dtc/tests/test_tree1_wrong9.dts
new file mode 100644
index 0000000..f6486fa
--- /dev/null
+++ b/dtc/tests/test_tree1_wrong9.dts
@@ -0,0 +1,45 @@
+/dts-v1/;
+
+/memreserve/ 0xdeadbeef00000000 0x100000;
+/memreserve/ 123456789 010000;
+/memreserve/ 0 1;
+
+/ {
+	compatible = "test_tree1";
+	prop-int = <0xdeadbeef>;
+	prop-str = "hello world";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	subnode@1 {
+		compatible = "subnode1";
+		reg = <1>;
+		prop-int = [deadbeef];
+
+		subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+			prop-int = <0xdeadbeef>;
+		};
+
+		ss1 {
+		};
+	};
+
+	subnode@2 {
+		reg = <2>;
+		linux,phandle = <0x2000>;
+		prop-int = <123456789>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		subsubnode@0 {
+			reg = <0>;
+			phandle = <0x2001>;
+			compatible = "subsubnode2", "subsubnode";
+			prop-int = <0726746425>;
+		};
+
+		ss2 {
+		};
+	};
+};
diff --git a/dtc/tests/testdata.h b/dtc/tests/testdata.h
new file mode 100644
index 0000000..4f9e3ba
--- /dev/null
+++ b/dtc/tests/testdata.h
@@ -0,0 +1,60 @@
+#ifdef __ASSEMBLY__
+#define ASM_CONST_LL(x)	(x)
+#else
+#define ASM_CONST_LL(x)	(x##ULL)
+#endif
+
+#define TEST_ADDR_1H	ASM_CONST_LL(0xdeadbeef)
+#define TEST_ADDR_1L	ASM_CONST_LL(0x00000000)
+#define TEST_ADDR_1	((TEST_ADDR_1H << 32) | TEST_ADDR_1L)
+#define TEST_SIZE_1H	ASM_CONST_LL(0x00000000)
+#define TEST_SIZE_1L	ASM_CONST_LL(0x00100000)
+#define TEST_SIZE_1	((TEST_SIZE_1H << 32) | TEST_SIZE_1L)
+#define TEST_ADDR_2H	ASM_CONST_LL(0)
+#define TEST_ADDR_2L	ASM_CONST_LL(123456789)
+#define TEST_ADDR_2	((TEST_ADDR_2H << 32) | TEST_ADDR_2L)
+#define TEST_SIZE_2H	ASM_CONST_LL(0)
+#define TEST_SIZE_2L	ASM_CONST_LL(010000)
+#define TEST_SIZE_2	((TEST_SIZE_2H << 32) | TEST_SIZE_2L)
+
+#define TEST_VALUE_1	0xdeadbeef
+#define TEST_VALUE_2	123456789
+
+#define TEST_VALUE64_1H	ASM_CONST_LL(0xdeadbeef)
+#define TEST_VALUE64_1L	ASM_CONST_LL(0x01abcdef)
+#define TEST_VALUE64_1	((TEST_VALUE64_1H << 32) | TEST_VALUE64_1L)
+
+#define PHANDLE_1	0x2000
+#define PHANDLE_2	0x2001
+
+#define TEST_STRING_1	"hello world"
+#define TEST_STRING_2	"nastystring: \a\b\t\n\v\f\r\\\""
+#define TEST_STRING_3	"\xde\xad\xbe\xef"
+
+#define TEST_STRING_4_PARTIAL	"foobar"
+#define TEST_STRING_4_RESULT	"testfoobar"
+
+#define TEST_CHAR1	'\r'
+#define TEST_CHAR2	'b'
+#define TEST_CHAR3	'\0'
+#define TEST_CHAR4	'\''
+#define TEST_CHAR5	'\xff'
+
+#define TEST_MEMREGION_ADDR	0x12345678
+#define TEST_MEMREGION_ADDR_HI	0x8765432100000000
+#define TEST_MEMREGION_SIZE	0x9abcdef0
+#define TEST_MEMREGION_SIZE_HI	0x0fedcba900000000
+#define TEST_MEMREGION_SIZE_INC	0x1000
+
+#ifndef __ASSEMBLY__
+extern struct fdt_header test_tree1;
+extern struct fdt_header truncated_property;
+extern struct fdt_header bad_node_char;
+extern struct fdt_header bad_node_format;
+extern struct fdt_header bad_prop_char;
+extern struct fdt_header ovf_size_strings;
+extern struct fdt_header truncated_string;
+extern struct fdt_header truncated_memrsv;
+extern struct fdt_header two_roots;
+extern struct fdt_header named_root;
+#endif /* ! __ASSEMBLY */
diff --git a/dtc/tests/tests.h b/dtc/tests/tests.h
new file mode 100644
index 0000000..1017366
--- /dev/null
+++ b/dtc/tests/tests.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#ifndef TESTS_H
+#define TESTS_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase definitions
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#define DEBUG
+
+/* Test return codes */
+#define RC_PASS 	0
+#define RC_CONFIG 	1
+#define RC_FAIL		2
+#define RC_BUG		99
+
+extern int verbose_test;
+extern char *test_name;
+void test_init(int argc, char *argv[]);
+
+#define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
+#define PALIGN(p, a)	((void *)ALIGN((unsigned long)(p), (a)))
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define streq(s1, s2)	(strcmp((s1),(s2)) == 0)
+
+/* Each test case must define this function */
+void cleanup(void);
+
+#define verbose_printf(...) \
+	if (verbose_test) { \
+		printf(__VA_ARGS__); \
+		fflush(stdout); \
+	}
+#define ERR	"ERR: "
+#define ERROR(fmt, args...)	fprintf(stderr, ERR fmt, ## args)
+
+
+#define	PASS()						\
+	do {						\
+		cleanup();				\
+		printf("PASS\n");			\
+		exit(RC_PASS);				\
+	} while (0)
+
+#define	PASS_INCONCLUSIVE()				\
+	do {						\
+		cleanup();				\
+		printf("PASS (inconclusive)\n");	\
+		exit(RC_PASS);				\
+	} while (0)
+
+#define IRRELEVANT()					\
+	do {						\
+		cleanup();				\
+		printf("PASS (irrelevant)\n");		\
+		exit(RC_PASS);				\
+	} while (0)
+
+/* Look out, gcc extension below... */
+#define FAIL(fmt, ...)					\
+	do {						\
+		cleanup();				\
+		printf("FAIL\t" fmt "\n", ##__VA_ARGS__);	\
+		exit(RC_FAIL);				\
+	} while (0)
+
+#define CONFIG(fmt, ...)				\
+	do {						\
+		cleanup();				\
+		printf("Bad configuration: " fmt "\n", ##__VA_ARGS__);	\
+		exit(RC_CONFIG);			\
+	} while (0)
+
+#define TEST_BUG(fmt, ...)				\
+	do {						\
+		cleanup();				\
+		printf("BUG in testsuite: " fmt "\n", ##__VA_ARGS__);	\
+		exit(RC_BUG);				\
+	} while (0)
+
+void check_mem_rsv(void *fdt, int n, uint64_t addr, uint64_t size);
+
+void check_property(void *fdt, int nodeoffset, const char *name,
+		    int len, const void *val);
+#define check_property_cell(fdt, nodeoffset, name, val) \
+	({ \
+		fdt32_t x = cpu_to_fdt32(val);			      \
+		check_property(fdt, nodeoffset, name, sizeof(x), &x); \
+	})
+
+
+const void *check_getprop(void *fdt, int nodeoffset, const char *name,
+			  int len, const void *val);
+#define check_getprop_cell(fdt, nodeoffset, name, val) \
+	({ \
+		fdt32_t x = cpu_to_fdt32(val);			     \
+		check_getprop(fdt, nodeoffset, name, sizeof(x), &x); \
+	})
+#define check_getprop_64(fdt, nodeoffset, name, val) \
+	({ \
+		fdt64_t x = cpu_to_fdt64(val);			     \
+		check_getprop(fdt, nodeoffset, name, sizeof(x), &x); \
+	})
+#define check_getprop_string(fdt, nodeoffset, name, s) \
+	check_getprop((fdt), (nodeoffset), (name), strlen(s)+1, (s))
+
+/* Returns non-NULL if the property at poffset has the name in_name */
+const void *check_get_prop_offset(void *fdt, int poffset, const char *in_name,
+				  int in_len, const void *in_val);
+#define check_get_prop_offset_cell(fdt, poffset, name, val) \
+	({ \
+		fdt32_t x = cpu_to_fdt32(val);			     \
+		check_get_prop_offset(fdt, poffset, name, sizeof(x), &x); \
+	})
+
+const void *check_getprop_addrrange(void *fdt, int parent, int nodeoffset,
+				    const char *name, int num);
+
+int nodename_eq(const char *s1, const char *s2);
+void vg_prepare_blob(void *fdt, size_t bufsize);
+void *load_blob(const char *filename);
+void *load_blob_arg(int argc, char *argv[]);
+void save_blob(const char *filename, void *blob);
+void *open_blob_rw(void *blob);
+
+#include "util.h"
+
+#endif /* TESTS_H */
diff --git a/dtc/tests/testutils.c b/dtc/tests/testutils.c
new file mode 100644
index 0000000..5e494c5
--- /dev/null
+++ b/dtc/tests/testutils.c
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase common utility functions
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#define _GNU_SOURCE /* for strsignal() in glibc.  FreeBSD has it either way */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <limits.h>
+#include <string.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#if NO_VALGRIND
+static inline void VALGRIND_MAKE_MEM_UNDEFINED(void *p, size_t len)
+{
+}
+
+static inline void VALGRIND_MAKE_MEM_DEFINED(void *p, size_t len)
+{
+}
+#else
+#include <valgrind/memcheck.h>
+#endif
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+/* For FDT_SW_MAGIC */
+#include "libfdt_internal.h"
+
+int verbose_test = 1;
+char *test_name;
+
+void  __attribute__((weak)) cleanup(void)
+{
+}
+
+static void sigint_handler(int signum, siginfo_t *si, void *uc)
+{
+	cleanup();
+	fprintf(stderr, "%s: %s (pid=%d)\n", test_name,
+		strsignal(signum), getpid());
+	exit(RC_BUG);
+}
+
+void test_init(int argc, char *argv[])
+{
+	int err;
+	struct sigaction sa_int = {
+		.sa_sigaction = sigint_handler,
+	};
+
+	test_name = argv[0];
+
+	err = sigaction(SIGINT, &sa_int, NULL);
+	if (err)
+		FAIL("Can't install SIGINT handler");
+
+	if (getenv("QUIET_TEST"))
+		verbose_test = 0;
+
+	verbose_printf("Starting testcase \"%s\", pid %d\n",
+		       test_name, getpid());
+}
+
+void check_mem_rsv(void *fdt, int n, uint64_t addr, uint64_t size)
+{
+	int err;
+	uint64_t addr_v, size_v;
+
+	err = fdt_get_mem_rsv(fdt, n, &addr_v, &size_v);
+	if (err < 0)
+		FAIL("fdt_get_mem_rsv(%d): %s", n, fdt_strerror(err));
+	if ((addr_v != addr) || (size_v != size))
+		FAIL("fdt_get_mem_rsv() returned (0x%llx,0x%llx) "
+		     "instead of (0x%llx,0x%llx)",
+		     (unsigned long long)addr_v, (unsigned long long)size_v,
+		     (unsigned long long)addr, (unsigned long long)size);
+}
+
+void check_property(void *fdt, int nodeoffset, const char *name,
+		    int len, const void *val)
+{
+	const struct fdt_property *prop;
+	int retlen, namelen;
+	uint32_t tag, nameoff, proplen;
+	const char *propname;
+
+	verbose_printf("Checking property \"%s\"...", name);
+	prop = fdt_get_property(fdt, nodeoffset, name, &retlen);
+	verbose_printf("pointer %p\n", prop);
+	if (! prop)
+		FAIL("Error retrieving \"%s\" pointer: %s", name,
+		     fdt_strerror(retlen));
+
+	tag = fdt32_to_cpu(prop->tag);
+	nameoff = fdt32_to_cpu(prop->nameoff);
+	proplen = fdt32_to_cpu(prop->len);
+
+	if (tag != FDT_PROP)
+		FAIL("Incorrect tag 0x%08x on property \"%s\"", tag, name);
+
+	propname = fdt_get_string(fdt, nameoff, &namelen);
+	if (!propname)
+		FAIL("Couldn't get property name: %s", fdt_strerror(namelen));
+	if (namelen != strlen(propname))
+		FAIL("Incorrect prop name length: %d instead of %zd",
+		     namelen, strlen(propname));
+	if (!streq(propname, name))
+		FAIL("Property name mismatch \"%s\" instead of \"%s\"",
+		     propname, name);
+	if (proplen != retlen)
+		FAIL("Length retrieved for \"%s\" by fdt_get_property()"
+		     " differs from stored length (%d != %d)",
+		     name, retlen, proplen);
+	if (proplen != len)
+		FAIL("Size mismatch on property \"%s\": %d insead of %d",
+		     name, proplen, len);
+	if (len && memcmp(val, prop->data, len) != 0)
+		FAIL("Data mismatch on property \"%s\"", name);
+}
+
+const void *check_getprop(void *fdt, int nodeoffset, const char *name,
+			  int len, const void *val)
+{
+	const void *propval;
+	int proplen;
+
+	propval = fdt_getprop(fdt, nodeoffset, name, &proplen);
+	if (! propval)
+		FAIL("fdt_getprop(\"%s\"): %s", name, fdt_strerror(proplen));
+
+	if (proplen != len)
+		FAIL("Size mismatch on property \"%s\": %d insead of %d",
+		     name, proplen, len);
+	if (len && memcmp(val, propval, len) != 0)
+		FAIL("Data mismatch on property \"%s\"", name);
+
+	return propval;
+}
+
+const void *check_get_prop_offset(void *fdt, int poffset, const char *exp_name,
+				  int exp_len, const void *exp_val)
+{
+	const void *propval;
+	const char *name;
+	int proplen;
+
+	propval = fdt_getprop_by_offset(fdt, poffset, &name, &proplen);
+	if (!propval)
+		FAIL("fdt_getprop(\"%s\"): %s", name, fdt_strerror(proplen));
+
+	/* Not testing for this field, so ignore */
+	if (strcmp(name, exp_name))
+		return NULL;
+
+	if (proplen != exp_len)
+		FAIL("Size mismatch on property \"%s\": %d insead of %d",
+		     name, proplen, exp_len);
+	if (exp_len && memcmp(exp_val, propval, exp_len))
+		FAIL("Data mismatch on property \"%s\"", name);
+
+	return propval;
+}
+
+const void *check_getprop_addrrange(void *fdt, int parent, int nodeoffset,
+				    const char *name, int num)
+{
+	const void *propval;
+	int xac, xsc, buf_size, cells, i;
+	char *buf, *p;
+	uint64_t addr, size;
+	fdt32_t val;
+
+	xac = fdt_address_cells(fdt, parent);
+	xsc = fdt_size_cells(fdt, parent);
+
+	if (xac <= 0)
+		FAIL("Couldn't identify #address-cells: %s",
+		     fdt_strerror(xac));
+	if (xsc <= 0)
+		FAIL("Couldn't identify #size-cells: %s",
+		     fdt_strerror(xsc));
+
+	buf_size = (xac + xsc) * sizeof(fdt32_t) * num;
+	buf = malloc(buf_size);
+	if (!buf)
+		FAIL("Couldn't allocate temporary buffer");
+
+	/* expected value */
+	addr = TEST_MEMREGION_ADDR;
+	if (xac > 1)
+		addr += TEST_MEMREGION_ADDR_HI;
+	size = TEST_MEMREGION_SIZE;
+	if (xsc > 1)
+		size += TEST_MEMREGION_SIZE_HI;
+	for (p = buf, i = 0; i < num; i++) {
+		cells = xac;
+		while (cells) {
+			val = cpu_to_fdt32(addr >> (32 * (--cells)));
+			memcpy(p, &val, sizeof(val));
+			p += sizeof(val);
+		}
+		cells = xsc;
+		while (cells) {
+			val = cpu_to_fdt32(size >> (32 * (--cells)));
+			memcpy(p, &val, sizeof(val));
+			p += sizeof(val);
+		}
+
+		addr += size;
+		size += TEST_MEMREGION_SIZE_INC;
+	}
+
+	/* check */
+	propval = check_getprop(fdt, nodeoffset, name, buf_size,
+				(const void *)buf);
+
+	free(buf);
+
+	return propval;
+}
+
+int nodename_eq(const char *s1, const char *s2)
+{
+	int len = strlen(s2);
+
+	if (strncmp(s1, s2, len) != 0)
+		return 0;
+	if (s1[len] == '\0')
+		return 1;
+	else if (!memchr(s2, '@', len) && (s1[len] == '@'))
+		return 1;
+	else
+		return 0;
+}
+
+void vg_prepare_blob(void *fdt, size_t bufsize)
+{
+	char *blob = fdt;
+	int off_memrsv, off_strings, off_struct;
+	int num_memrsv;
+	size_t size_memrsv, size_strings, size_struct;
+
+	off_memrsv = fdt_off_mem_rsvmap(fdt);
+	num_memrsv = fdt_num_mem_rsv(fdt);
+	if (num_memrsv < 0)
+		size_memrsv = fdt_totalsize(fdt) - off_memrsv;
+	else
+		size_memrsv = (num_memrsv + 1)
+			* sizeof(struct fdt_reserve_entry);
+
+	VALGRIND_MAKE_MEM_UNDEFINED(blob, bufsize);
+	VALGRIND_MAKE_MEM_DEFINED(blob, FDT_V1_SIZE);
+	VALGRIND_MAKE_MEM_DEFINED(blob, fdt_header_size(fdt));
+
+	if (fdt_magic(fdt) == FDT_MAGIC) {
+		off_strings = fdt_off_dt_strings(fdt);
+		if (fdt_version(fdt) >= 3)
+			size_strings = fdt_size_dt_strings(fdt);
+		else
+			size_strings = fdt_totalsize(fdt) - off_strings;
+
+		off_struct = fdt_off_dt_struct(fdt);
+		if (fdt_version(fdt) >= 17)
+			size_struct = fdt_size_dt_struct(fdt);
+		else
+			size_struct = fdt_totalsize(fdt) - off_struct;
+	} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {
+		size_strings = fdt_size_dt_strings(fdt);
+		off_strings = fdt_off_dt_strings(fdt) - size_strings;
+
+		off_struct = fdt_off_dt_struct(fdt);
+		size_struct = fdt_size_dt_struct(fdt);
+		size_struct = fdt_totalsize(fdt) - off_struct;
+
+	} else {
+		CONFIG("Bad magic on vg_prepare_blob()");
+	}
+
+	VALGRIND_MAKE_MEM_DEFINED(blob + off_memrsv, size_memrsv);
+	VALGRIND_MAKE_MEM_DEFINED(blob + off_strings, size_strings);
+	VALGRIND_MAKE_MEM_DEFINED(blob + off_struct, size_struct);
+}
+
+void *load_blob(const char *filename)
+{
+	char *blob;
+	size_t len;
+	int ret = utilfdt_read_err(filename, &blob, &len);
+
+	if (ret)
+		CONFIG("Couldn't open blob from \"%s\": %s", filename,
+		       strerror(ret));
+
+	vg_prepare_blob(blob, len);
+
+	return blob;
+}
+
+void *load_blob_arg(int argc, char *argv[])
+{
+	if (argc != 2)
+		CONFIG("Usage: %s <dtb file>", argv[0]);
+	return load_blob(argv[1]);
+}
+
+void save_blob(const char *filename, void *fdt)
+{
+	size_t size = fdt_totalsize(fdt);
+	void *tmp;
+	int ret;
+
+	/* Make a temp copy of the blob so that valgrind won't check
+	 * about uninitialized bits in the pieces between blocks */
+	tmp = xmalloc(size);
+	fdt_move(fdt, tmp, size);
+	VALGRIND_MAKE_MEM_DEFINED(tmp, size);
+	ret = utilfdt_write_err(filename, tmp);
+	if (ret)
+		CONFIG("Couldn't write blob to \"%s\": %s", filename,
+		       strerror(ret));
+	free(tmp);
+}
+
+void *open_blob_rw(void *blob)
+{
+	int err;
+	void *buf = blob;
+
+	err = fdt_open_into(blob, buf, fdt_totalsize(blob));
+	if (err == -FDT_ERR_NOSPACE) {
+		/* Ran out of space converting to v17 */
+		int newsize = fdt_totalsize(blob) + 8;
+
+		buf = xmalloc(newsize);
+		err = fdt_open_into(blob, buf, newsize);
+	}
+	if (err)
+		FAIL("fdt_open_into(): %s", fdt_strerror(err));
+	return buf;
+}
diff --git a/dtc/tests/testutils.sh b/dtc/tests/testutils.sh
new file mode 100644
index 0000000..6b2f0d1
--- /dev/null
+++ b/dtc/tests/testutils.sh
@@ -0,0 +1,67 @@
+# Common functions for shell testcases
+
+PASS () {
+    echo "PASS"
+    exit 0
+}
+
+FAIL () {
+    echo "FAIL" "$@"
+    exit 2
+}
+
+FAIL_IF_SIGNAL () {
+    ret="$1"
+    if [ "$ret" -gt 127 ]; then
+	signame=$(kill -l $((ret - 128)))
+	FAIL "Killed by SIG$signame"
+    fi
+}
+
+if [ -z "$TEST_BINDIR" ]; then
+    TEST_BINDIR=..
+fi
+
+DTC=${TEST_BINDIR}/dtc
+DTGET=${TEST_BINDIR}/fdtget
+DTPUT=${TEST_BINDIR}/fdtput
+FDTDUMP=${TEST_BINDIR}/fdtdump
+FDTOVERLAY=${TEST_BINDIR}/fdtoverlay
+
+verbose_run () {
+    if [ -z "$QUIET_TEST" ]; then
+	"$@"
+    else
+	"$@" > /dev/null 2> /dev/null
+    fi
+}
+
+verbose_run_check () {
+    verbose_run "$@"
+    ret="$?"
+    FAIL_IF_SIGNAL $ret
+    if [ $ret != 0 ]; then
+	FAIL "Returned error code $ret"
+    fi
+}
+
+verbose_run_log () {
+    LOG="$1"
+    shift
+    "$@" > "$LOG" 2>&1
+    ret=$?
+    if [ -z "$QUIET_TEST" ]; then
+	cat "$LOG" >&2
+    fi
+    return $ret
+}
+
+verbose_run_log_check () {
+    verbose_run_log "$@"
+    ret="$?"
+    FAIL_IF_SIGNAL $ret
+    if [ $ret != 0 ]; then
+	FAIL "Returned error code $ret"
+    fi
+}
+
diff --git a/dtc/tests/trees.S b/dtc/tests/trees.S
new file mode 100644
index 0000000..95d599d
--- /dev/null
+++ b/dtc/tests/trees.S
@@ -0,0 +1,315 @@
+#include <fdt.h>
+#include "testdata.h"
+
+#define FDTLONG(val) \
+	.byte	((val) >> 24) & 0xff ; \
+	.byte	((val) >> 16) & 0xff ; \
+	.byte	((val) >> 8) & 0xff ; \
+	.byte	(val) & 0xff	;
+
+#define TREE_HDR(tree) \
+	.balign	8		; \
+	.globl	tree		; \
+tree:	\
+	FDTLONG(FDT_MAGIC)	; \
+	FDTLONG(tree##_end - tree) ; \
+	FDTLONG(tree##_struct - tree) ; \
+	FDTLONG(tree##_strings - tree) ; \
+	FDTLONG(tree##_rsvmap - tree) ; \
+	FDTLONG(0x11)		; \
+	FDTLONG(0x10)		; \
+	FDTLONG(0)		; \
+	FDTLONG(tree##_strings_end - tree##_strings) ; \
+	FDTLONG(tree##_struct_end - tree##_struct) ;
+
+#define RSVMAP_ENTRY(addrh, addrl, lenh, lenl) \
+	FDTLONG(addrh)		; \
+	FDTLONG(addrl)		; \
+	FDTLONG(lenh)		; \
+	FDTLONG(lenl)
+
+#define EMPTY_RSVMAP(tree) \
+	.balign	8		; \
+tree##_rsvmap:			; \
+	RSVMAP_ENTRY(0, 0, 0, 0) \
+tree##_rsvmap_end:		;
+
+#define PROPHDR(tree, name, len) \
+	FDTLONG(FDT_PROP)	; \
+	FDTLONG(len)		; \
+	FDTLONG(tree##_##name - tree##_strings) ;
+
+#define PROP_EMPTY(tree, name) \
+	PROPHDR(tree, name, 0)	;
+
+#define PROP_INT(tree, name, val) \
+	PROPHDR(tree, name, 4) \
+	FDTLONG(val)		;
+
+#define PROP_INT64(tree, name, valh, vall) \
+	PROPHDR(tree, name, 8) \
+	FDTLONG(valh)		; \
+	FDTLONG(vall)		;
+
+#define PROP_STR(tree, name, str) \
+	PROPHDR(tree, name, 55f - 54f) \
+54:	\
+	.string	str		; \
+55:	\
+	.balign	4		;
+
+#define BEGIN_NODE(name) \
+	FDTLONG(FDT_BEGIN_NODE)	; \
+	.string	name		; \
+	.balign 4		;
+
+#define END_NODE \
+	FDTLONG(FDT_END_NODE)	;
+
+#define STRING(tree, name, str) \
+tree##_##name:			; \
+	.string	str		;
+
+	.data
+
+	TREE_HDR(test_tree1)
+
+	.balign	8
+test_tree1_rsvmap:
+	RSVMAP_ENTRY(TEST_ADDR_1H, TEST_ADDR_1L, TEST_SIZE_1H, TEST_SIZE_1L)
+	RSVMAP_ENTRY(TEST_ADDR_2H, TEST_ADDR_2L, TEST_SIZE_2H, TEST_SIZE_2L)
+	RSVMAP_ENTRY(0, 0, 0, 0)
+test_tree1_rsvmap_end:
+
+test_tree1_struct:
+	BEGIN_NODE("")
+	PROP_STR(test_tree1, compatible, "test_tree1")
+	PROP_INT(test_tree1, prop_int, TEST_VALUE_1)
+	PROP_INT64(test_tree1, prop_int64, TEST_VALUE64_1H, TEST_VALUE64_1L)
+	PROP_STR(test_tree1, prop_str, TEST_STRING_1)
+	PROP_INT(test_tree1, address_cells, 1)
+	PROP_INT(test_tree1, size_cells, 0)
+
+	BEGIN_NODE("subnode@1")
+	PROP_STR(test_tree1, compatible, "subnode1")
+	PROP_INT(test_tree1, reg, 1)
+	PROP_INT(test_tree1, prop_int, TEST_VALUE_1)
+
+	BEGIN_NODE("subsubnode")
+	PROP_STR(test_tree1, compatible, "subsubnode1\0subsubnode")
+	PROP_STR(test_tree1, placeholder, "this is a placeholder string\0string2")
+	PROP_INT(test_tree1, prop_int, TEST_VALUE_1)
+	END_NODE
+
+	BEGIN_NODE("ss1")
+	END_NODE
+
+	END_NODE
+
+	BEGIN_NODE("subnode@2")
+	PROP_INT(test_tree1, reg, 2)
+	PROP_INT(test_tree1, linux_phandle, PHANDLE_1)
+	PROP_INT(test_tree1, prop_int, TEST_VALUE_2)
+	PROP_INT(test_tree1, address_cells, 1)
+	PROP_INT(test_tree1, size_cells, 0)
+
+	BEGIN_NODE("subsubnode@0")
+	PROP_INT(test_tree1, reg, 0)
+	PROP_INT(test_tree1, phandle, PHANDLE_2)
+	PROP_STR(test_tree1, compatible, "subsubnode2\0subsubnode")
+	PROP_INT(test_tree1, prop_int, TEST_VALUE_2)
+	END_NODE
+
+	BEGIN_NODE("ss2")
+	END_NODE
+
+	END_NODE
+
+	END_NODE
+	FDTLONG(FDT_END)
+test_tree1_struct_end:
+
+test_tree1_strings:
+	STRING(test_tree1, compatible, "compatible")
+	STRING(test_tree1, prop_int, "prop-int")
+	STRING(test_tree1, prop_int64, "prop-int64")
+	STRING(test_tree1, prop_str, "prop-str")
+	STRING(test_tree1, linux_phandle, "linux,phandle")
+	STRING(test_tree1, phandle, "phandle")
+	STRING(test_tree1, reg, "reg")
+	STRING(test_tree1, placeholder, "placeholder")
+	STRING(test_tree1, address_cells, "#address-cells")
+	STRING(test_tree1, size_cells, "#size-cells")
+test_tree1_strings_end:
+test_tree1_end:
+
+
+	TREE_HDR(truncated_property)
+	EMPTY_RSVMAP(truncated_property)
+
+truncated_property_struct:
+	BEGIN_NODE("")
+	PROPHDR(truncated_property, prop_truncated, 4)
+	/* Oops, no actual property data here */
+truncated_property_struct_end:
+
+truncated_property_strings:
+	STRING(truncated_property, prop_truncated, "truncated")
+truncated_property_strings_end:
+
+truncated_property_end:
+
+
+	TREE_HDR(bad_node_char)
+	EMPTY_RSVMAP(bad_node_char)
+
+bad_node_char_struct:
+	BEGIN_NODE("")
+	BEGIN_NODE("sub$node")
+	END_NODE
+	END_NODE
+	FDTLONG(FDT_END)
+bad_node_char_struct_end:
+
+bad_node_char_strings:
+bad_node_char_strings_end:
+bad_node_char_end:
+
+
+	TREE_HDR(bad_node_format)
+	EMPTY_RSVMAP(bad_node_format)
+
+bad_node_format_struct:
+	BEGIN_NODE("")
+	BEGIN_NODE("subnode@1@2")
+	END_NODE
+	END_NODE
+	FDTLONG(FDT_END)
+bad_node_format_struct_end:
+
+bad_node_format_strings:
+bad_node_format_strings_end:
+bad_node_format_end:
+
+
+	TREE_HDR(bad_prop_char)
+	EMPTY_RSVMAP(bad_prop_char)
+
+bad_prop_char_struct:
+	BEGIN_NODE("")
+	PROP_INT(bad_prop_char, prop, TEST_VALUE_1)
+	END_NODE
+	FDTLONG(FDT_END)
+bad_prop_char_struct_end:
+
+bad_prop_char_strings:
+	STRING(bad_prop_char, prop, "prop$erty")
+bad_prop_char_strings_end:
+bad_prop_char_end:
+
+
+	/* overflow_size_strings */
+	.balign	8
+	.globl	ovf_size_strings
+ovf_size_strings:
+	FDTLONG(FDT_MAGIC)
+	FDTLONG(ovf_size_strings_end - ovf_size_strings)
+	FDTLONG(ovf_size_strings_struct - ovf_size_strings) 
+	FDTLONG(ovf_size_strings_strings - ovf_size_strings)
+	FDTLONG(ovf_size_strings_rsvmap - ovf_size_strings)
+	FDTLONG(0x11)
+	FDTLONG(0x10)
+	FDTLONG(0)
+	FDTLONG(0xffffffff)
+	FDTLONG(ovf_size_strings_struct_end - ovf_size_strings_struct)
+	EMPTY_RSVMAP(ovf_size_strings)
+
+ovf_size_strings_struct:
+	BEGIN_NODE("")
+	PROP_INT(ovf_size_strings, bad_string, 0)
+	END_NODE
+	FDTLONG(FDT_END)
+ovf_size_strings_struct_end:
+
+ovf_size_strings_strings:
+	STRING(ovf_size_strings, x, "x")
+	ovf_size_strings_bad_string = ovf_size_strings_strings + 0x10000000
+ovf_size_strings_strings_end:
+ovf_size_strings_end:
+
+
+	/* truncated_string */
+	TREE_HDR(truncated_string)
+	EMPTY_RSVMAP(truncated_string)
+
+truncated_string_struct:
+	BEGIN_NODE("")
+	PROP_EMPTY(truncated_string, good_string)
+	PROP_EMPTY(truncated_string, bad_string)
+	END_NODE
+	FDTLONG(FDT_END)
+truncated_string_struct_end:
+
+truncated_string_strings:
+	STRING(truncated_string, good_string, "good")
+truncated_string_bad_string:
+	.byte	'b'
+	.byte	'a'
+	.byte	'd'
+	/* NOTE: terminating \0 deliberately missing */
+truncated_string_strings_end:
+truncated_string_end:
+
+
+	/* truncated_memrsv */
+	TREE_HDR(truncated_memrsv)
+
+truncated_memrsv_struct:
+	BEGIN_NODE("")
+	END_NODE
+	FDTLONG(FDT_END)
+truncated_memrsv_struct_end:
+
+truncated_memrsv_strings:
+truncated_memrsv_strings_end:
+
+	.balign	8
+truncated_memrsv_rsvmap:
+	RSVMAP_ENTRY(TEST_ADDR_1H, TEST_ADDR_1L, TEST_SIZE_1H, TEST_SIZE_1L)
+truncated_memrsv_rsvmap_end:
+
+truncated_memrsv_end:
+
+
+        /* two root nodes */
+        TREE_HDR(two_roots)
+	EMPTY_RSVMAP(two_roots)
+
+two_roots_struct:
+	BEGIN_NODE("")
+	END_NODE
+	BEGIN_NODE("")
+	END_NODE
+	FDTLONG(FDT_END)
+two_roots_struct_end:
+
+two_roots_strings:
+two_roots_strings_end:
+
+two_roots_end:
+
+
+        /* root node with a non-empty name */
+        TREE_HDR(named_root)
+	EMPTY_RSVMAP(named_root)
+
+named_root_struct:
+	BEGIN_NODE("fake")
+	END_NODE
+	FDTLONG(FDT_END)
+named_root_struct_end:
+
+named_root_strings:
+named_root_strings_end:
+
+named_root_end:
diff --git a/dtc/tests/truncated_memrsv.c b/dtc/tests/truncated_memrsv.c
new file mode 100644
index 0000000..d78036c
--- /dev/null
+++ b/dtc/tests/truncated_memrsv.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for misbehaviour on a truncated string
+ * Copyright (C) 2018 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt = &truncated_memrsv;
+	int err;
+	uint64_t addr, size;
+
+	test_init(argc, argv);
+
+	err = fdt_check_header(fdt);
+	if (err != 0)
+		FAIL("Bad header: %s", fdt_strerror(err));
+
+	err = fdt_num_mem_rsv(fdt);
+	if (err != -FDT_ERR_TRUNCATED)
+		FAIL("fdt_num_mem_rsv() returned %d instead of -FDT_ERR_TRUNCATED",
+		     err);
+
+	err = fdt_get_mem_rsv(fdt, 0, &addr, &size);
+	if (err != 0)
+		FAIL("fdt_get_mem_rsv() failed on first entry: %s",
+		     fdt_strerror(err));
+	if ((addr != TEST_ADDR_1) || (size != TEST_SIZE_1))
+		FAIL("Entry doesn't match: (0x%llx, 0x%llx) != (0x%llx, 0x%llx)",
+		     (unsigned long long)addr, (unsigned long long)size,
+		     TEST_ADDR_1, TEST_SIZE_1);
+
+	err = fdt_get_mem_rsv(fdt, 1, &addr, &size);
+	if (err != -FDT_ERR_BADOFFSET)
+		FAIL("fdt_get_mem_rsv(1) returned %d instead of -FDT_ERR_BADOFFSET",
+		     err);
+
+	PASS();
+}
diff --git a/dtc/tests/truncated_property.c b/dtc/tests/truncated_property.c
new file mode 100644
index 0000000..d9d52b2
--- /dev/null
+++ b/dtc/tests/truncated_property.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for misbehaviour on a truncated property
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt = &truncated_property;
+	const void *prop;
+	int len;
+
+	test_init(argc, argv);
+
+	vg_prepare_blob(fdt, fdt_totalsize(fdt));
+
+	prop = fdt_getprop(fdt, 0, "truncated", &len);
+	if (prop)
+		FAIL("fdt_getprop() succeeded on truncated property");
+	if (len != -FDT_ERR_BADSTRUCTURE)
+		FAIL("fdt_getprop() failed with \"%s\" instead of \"%s\"",
+		     fdt_strerror(len), fdt_strerror(-FDT_ERR_BADSTRUCTURE));
+
+	PASS();
+}
diff --git a/dtc/tests/truncated_string.c b/dtc/tests/truncated_string.c
new file mode 100644
index 0000000..d745414
--- /dev/null
+++ b/dtc/tests/truncated_string.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Testcase for misbehaviour on a truncated string
+ * Copyright (C) 2018 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+int main(int argc, char *argv[])
+{
+	void *fdt = &truncated_string;
+	const struct fdt_property *good, *bad;
+	int off, len;
+	const char *name;
+
+	test_init(argc, argv);
+
+	vg_prepare_blob(fdt, fdt_totalsize(fdt));
+
+	off = fdt_first_property_offset(fdt, 0);
+	good = fdt_get_property_by_offset(fdt, off, NULL);
+
+	off = fdt_next_property_offset(fdt, off);
+	bad = fdt_get_property_by_offset(fdt, off, NULL);
+
+	if (fdt32_to_cpu(good->len) != 0)
+		FAIL("Unexpected length for good property");
+	name = fdt_get_string(fdt, fdt32_to_cpu(good->nameoff), &len);
+	if (!name)
+		FAIL("fdt_get_string() failed on good property: %s",
+		     fdt_strerror(len));
+	if (len != 4)
+		FAIL("fdt_get_string() returned length %d (not 4) on good property",
+		     len);
+	if (!streq(name, "good"))
+		FAIL("fdt_get_string() returned \"%s\" (not \"good\") on good property",
+		     name);
+
+	if (fdt32_to_cpu(bad->len) != 0)
+		FAIL("Unexpected length for bad property\n");
+	name = fdt_get_string(fdt, fdt32_to_cpu(bad->nameoff), &len);
+	if (name)
+		FAIL("fdt_get_string() succeeded incorrectly on bad property");
+	else if (len != -FDT_ERR_TRUNCATED)
+		FAIL("fdt_get_string() gave unexpected error on bad property: %s",
+		     fdt_strerror(len));
+
+	/* Make sure the 'good' property breaks correctly if we
+	 * truncate the strings section */
+	fdt_set_size_dt_strings(fdt, fdt32_to_cpu(good->nameoff) + 4);
+	name = fdt_get_string(fdt, fdt32_to_cpu(good->nameoff), &len);
+	if (name)
+		FAIL("fdt_get_string() succeeded incorrectly on mangled property");
+	else if (len != -FDT_ERR_TRUNCATED)
+		FAIL("fdt_get_string() gave unexpected error on mangled property: %s",
+		     fdt_strerror(len));
+
+	PASS();
+}
diff --git a/dtc/tests/type-preservation.dt.yaml b/dtc/tests/type-preservation.dt.yaml
new file mode 100644
index 0000000..ee8cfde
--- /dev/null
+++ b/dtc/tests/type-preservation.dt.yaml
@@ -0,0 +1,20 @@
+---
+- '#address-cells': [[0x1]]
+  '#size-cells': [[0x0]]
+  subnode@1:
+    compatible: ["subnode1"]
+    reg: [[0x1]]
+    int-array: [[0x0, 0x1], [0x2, 0x3]]
+    int8: [!u8 [0x56]]
+    int8-array: [!u8 [0x0, 0x12, 0x34, 0x56]]
+    int16: [!u16 [0x3210]]
+    int16-array: [!u16 [0x1234, 0x5678, 0x90ab, 0xcdef]]
+    int16-matrix: [!u16 [0x1234, 0x5678], [0x90ab, 0xcdef]]
+    int64: [!u64 [0x200000000]]
+    int64-array: [!u64 [0x100000000, 0x0]]
+    a-string-with-nulls: ["foo\0bar", "baz"]
+    subsubnode:
+      compatible: ["subsubnode1", "subsubnode"]
+      subsubsubnode:
+        compatible: ["subsubsubnode1", [0x1234], "subsubsubnode"]
+...
diff --git a/dtc/tests/type-preservation.dts b/dtc/tests/type-preservation.dts
new file mode 100644
index 0000000..3e380ba
--- /dev/null
+++ b/dtc/tests/type-preservation.dts
@@ -0,0 +1,28 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <0x01>;
+	#size-cells = <0x00>;
+
+	sub1: subnode@1 {
+		prop_label: compatible = value_label: "subnode1";
+		reg = <0x01>;
+		int-array = <0x00 0x01>, int_value_label: <0x02 0x03>;
+		int8 = [56];
+		int8-array = [00 12 34 56] label:;
+		int16 = /bits/ 16 <0x3210>;
+		int16-array = /bits/ 16 <0x1234 0x5678 0x90ab 0xcdef>;
+		int16-matrix = /bits/ 16 <0x1234 0x5678>, <0x90ab 0xcdef>;
+		int64 = /bits/ 64 <0x200000000>;
+		int64-array = /bits/ 64 <0x100000000 0x00> int64_array_label_end:;
+		a-string-with-nulls = "foo\0bar", "baz";
+
+		subsub1: subsubnode {
+			compatible = "subsubnode1", "subsubnode";
+
+			subsubsub1: subsubsubnode {
+				compatible = "subsubsubnode1", <0x1234>, valuea: valueb: "subsubsubnode";
+			};
+		};
+	};
+};
diff --git a/dtc/tests/unit-addr-leading-0s.dts b/dtc/tests/unit-addr-leading-0s.dts
new file mode 100644
index 0000000..cc017e9
--- /dev/null
+++ b/dtc/tests/unit-addr-leading-0s.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	bus {
+		node@001 {
+			reg = <1 0>;
+		};
+	};
+};
diff --git a/dtc/tests/unit-addr-leading-0x.dts b/dtc/tests/unit-addr-leading-0x.dts
new file mode 100644
index 0000000..74f1967
--- /dev/null
+++ b/dtc/tests/unit-addr-leading-0x.dts
@@ -0,0 +1,12 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	bus {
+		node@0x1 {
+			reg = <1 0>;
+		};
+	};
+};
diff --git a/dtc/tests/unit-addr-simple-bus-compatible.dts b/dtc/tests/unit-addr-simple-bus-compatible.dts
new file mode 100644
index 0000000..c8f9341
--- /dev/null
+++ b/dtc/tests/unit-addr-simple-bus-compatible.dts
@@ -0,0 +1,18 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	bus@10000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "foo-bus", "simple-bus";
+		ranges = <0x0 0x10000000 0x10000>;
+
+		node@100 {
+			reg = <0x1000 1>;
+		};
+	};
+
+};
diff --git a/dtc/tests/unit-addr-simple-bus-reg-mismatch.dts b/dtc/tests/unit-addr-simple-bus-reg-mismatch.dts
new file mode 100644
index 0000000..2823377
--- /dev/null
+++ b/dtc/tests/unit-addr-simple-bus-reg-mismatch.dts
@@ -0,0 +1,18 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	bus@10000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		ranges = <0x0 0x10000000 0x10000>;
+
+		node@100 {
+			reg = <0x1000 1>;
+		};
+	};
+
+};
diff --git a/dtc/tests/unit-addr-unique.dts b/dtc/tests/unit-addr-unique.dts
new file mode 100644
index 0000000..7cc650b
--- /dev/null
+++ b/dtc/tests/unit-addr-unique.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	foo@1 {
+		reg = <1>;
+	};
+
+	bar@1 {
+		reg = <1>;
+	};
+};
diff --git a/dtc/tests/unit-addr-without-reg.dts b/dtc/tests/unit-addr-without-reg.dts
new file mode 100644
index 0000000..ac786eb
--- /dev/null
+++ b/dtc/tests/unit-addr-without-reg.dts
@@ -0,0 +1,9 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	node@1 {
+	};
+};
diff --git a/dtc/tests/utilfdt_test.c b/dtc/tests/utilfdt_test.c
new file mode 100644
index 0000000..c621759
--- /dev/null
+++ b/dtc/tests/utilfdt_test.c
@@ -0,0 +1,114 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * Copyright 2011 The Chromium Authors, All Rights Reserved.
+ *
+ * utilfdt_test - Tests for utilfdt library
+ */
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <libfdt.h>
+#include <util.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+static void check(const char *fmt, int expect_type, int expect_size)
+{
+	int type;
+	int size;
+
+	if (utilfdt_decode_type(fmt, &type, &size))
+		FAIL("format '%s': valid format string returned failure", fmt);
+	if (expect_type != type)
+		FAIL("format '%s': expected type='%c', got type='%c'", fmt,
+		     expect_type, type);
+	if (expect_size != size)
+		FAIL("format '%s': expected size=%d, got size=%d", fmt,
+		     expect_size, size);
+}
+
+static void checkfail(const char *fmt)
+{
+	int type;
+	int size;
+
+	if (!utilfdt_decode_type(fmt, &type, &size))
+		FAIL("format '%s': invalid format string returned success",
+		     fmt);
+}
+
+/**
+ * Add the given modifier to each of the valid sizes, and check that we get
+ * correct values.
+ *
+ * \param modifier	Modifer string to use as a prefix
+ * \param expected_size	The size (in bytes) that we expect (ignored for
+ *			strings)
+ */
+static void check_sizes(char *modifier, int expected_size)
+{
+	char fmt[10], *ptr;
+
+	/* set up a string with a hole in it for the format character */
+	if (strlen(modifier) + 2 >= sizeof(fmt))
+		FAIL("modifier string '%s' too long", modifier);
+	strcpy(fmt, modifier);
+	ptr = fmt + strlen(fmt);
+	ptr[1] = '\0';
+
+	/* now try each format character in turn */
+	*ptr = 'i';
+	check(fmt, 'i', expected_size);
+
+	*ptr = 'u';
+	check(fmt, 'u', expected_size);
+
+	*ptr = 'x';
+	check(fmt, 'x', expected_size);
+
+	*ptr = 's';
+	check(fmt, 's', -1);
+}
+
+static void test_utilfdt_decode_type(void)
+{
+	char fmt[10];
+	int ch;
+
+	/* check all the valid modifiers and sizes */
+	check_sizes("", -1);
+	check_sizes("b", 1);
+	check_sizes("hh", 1);
+	check_sizes("h", 2);
+	check_sizes("l", 4);
+
+	/* try every other character */
+	checkfail("");
+	for (ch = ' '; ch < 127; ch++) {
+		if (!strchr("iuxs", ch)) {
+			*fmt = ch;
+			fmt[1] = '\0';
+			checkfail(fmt);
+		}
+	}
+
+	/* try a few modifiers at the end */
+	checkfail("sx");
+	checkfail("ihh");
+	checkfail("xb");
+
+	/* and one for the doomsday archives */
+	checkfail("He has all the virtues I dislike and none of the vices "
+			"I admire.");
+}
+
+int main(int argc, char *argv[])
+{
+	test_utilfdt_decode_type();
+	PASS();
+}
diff --git a/dtc/tests/value-labels.c b/dtc/tests/value-labels.c
new file mode 100644
index 0000000..e318357
--- /dev/null
+++ b/dtc/tests/value-labels.c
@@ -0,0 +1,114 @@
+// SPDX-License-Identifier: LGPL-2.1-or-later
+/*
+ * libfdt - Flat Device Tree manipulation
+ *	Test labels within values
+ * Copyright (C) 2008 David Gibson, IBM Corporation.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+
+#include <dlfcn.h>
+
+#include <libfdt.h>
+
+#include "tests.h"
+#include "testdata.h"
+
+struct val_label {
+	const char *labelname;
+	int propoff;
+};
+
+static struct val_label labels1[] = {
+	{ "start1", 0 },
+	{ "mid1", 2 },
+	{ "end1", -1 },
+};
+
+static struct val_label labels2[] = {
+	{ "start2", 0 },
+	{ "innerstart2", 0 },
+	{ "innermid2", 4 },
+	{ "innerend2", -1 },
+	{ "end2", -1 },
+};
+
+static struct val_label labels3[] = {
+	{ "start3", 0 },
+	{ "innerstart3", 0 },
+	{ "innermid3", 1 },
+	{ "innerend3", -1 },
+	{ "end3", -1 },
+};
+
+static void check_prop_labels(void *sohandle, void *fdt, const char *name,
+			      const struct val_label* labels, int n)
+{
+	const struct fdt_property *prop;
+	const char *p;
+	int len;
+	int i;
+
+	prop = fdt_get_property(fdt, 0, name, &len);
+	if (!prop)
+		FAIL("Couldn't locate property \"%s\"", name);
+
+	p = dlsym(sohandle, name);
+	if (!p)
+		FAIL("Couldn't locate label symbol \"%s\"", name);
+
+	if (p != (const char *)prop)
+		FAIL("Label \"%s\" does not point to correct property", name);
+
+	for (i = 0; i < n; i++) {
+		int off = labels[i].propoff;
+
+		if (off == -1)
+			off = len;
+
+		p = dlsym(sohandle, labels[i].labelname);
+		if (!p)
+			FAIL("Couldn't locate label symbol \"%s\"", name);
+
+		if ((p - prop->data) != off)
+			FAIL("Label \"%s\" points to offset %ld instead of %d"
+			     "in property \"%s\"", labels[i].labelname,
+			     (long)(p - prop->data), off, name);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	void *sohandle;
+	void *fdt;
+	int err;
+
+	test_init(argc, argv);
+	if (argc != 2)
+		CONFIG("Usage: %s <so file>", argv[0]);
+
+	sohandle = dlopen(argv[1], RTLD_NOW);
+	if (!sohandle)
+		FAIL("Couldn't dlopen() %s", argv[1]);
+
+	fdt = dlsym(sohandle, "dt_blob_start");
+	if (!fdt)
+		FAIL("Couldn't locate \"dt_blob_start\" symbol in %s",
+		     argv[1]);
+
+	err = fdt_check_header(fdt);
+	if (err != 0)
+		FAIL("%s contains invalid tree: %s", argv[1],
+		     fdt_strerror(err));
+
+
+	check_prop_labels(sohandle, fdt, "prop1", labels1, ARRAY_SIZE(labels1));
+	check_prop_labels(sohandle, fdt, "prop2", labels2, ARRAY_SIZE(labels2));
+	check_prop_labels(sohandle, fdt, "prop3", labels3, ARRAY_SIZE(labels3));
+
+	PASS();
+}
diff --git a/dtc/tests/value-labels.dts b/dtc/tests/value-labels.dts
new file mode 100644
index 0000000..490c609
--- /dev/null
+++ b/dtc/tests/value-labels.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/ {
+	prop1: prop1 = start1: "a", mid1: "b" end1:;
+	prop2: prop2 = start2: < innerstart2: 0xdeadbeef innermid2: 0xabcd1234 innerend2: > end2:;
+	prop3: prop3 = start3: [ innerstart3: ab innermid3: cd innerend3: ] end3:;
+};
+
diff --git a/dtc/tests/zero-phandle.dts b/dtc/tests/zero-phandle.dts
new file mode 100644
index 0000000..7997d98
--- /dev/null
+++ b/dtc/tests/zero-phandle.dts
@@ -0,0 +1,7 @@
+/dts-v1/;
+
+/ {
+	node {
+		linux,phandle = <0>;
+	};
+};
diff --git a/dtc/treesource.c b/dtc/treesource.c
new file mode 100644
index 0000000..061ba8c
--- /dev/null
+++ b/dtc/treesource.c
@@ -0,0 +1,345 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include "dtc.h"
+#include "srcpos.h"
+
+extern FILE *yyin;
+extern int yyparse(void);
+extern YYLTYPE yylloc;
+
+struct dt_info *parser_output;
+bool treesource_error;
+
+struct dt_info *dt_from_source(const char *fname)
+{
+	parser_output = NULL;
+	treesource_error = false;
+
+	srcfile_push(fname);
+	yyin = current_srcfile->f;
+	yylloc.file = current_srcfile;
+
+	if (yyparse() != 0)
+		die("Unable to parse input tree\n");
+
+	if (treesource_error)
+		die("Syntax error parsing input tree\n");
+
+	return parser_output;
+}
+
+static void write_prefix(FILE *f, int level)
+{
+	int i;
+
+	for (i = 0; i < level; i++)
+		fputc('\t', f);
+}
+
+static bool isstring(char c)
+{
+	return (isprint((unsigned char)c)
+		|| (c == '\0')
+		|| strchr("\a\b\t\n\v\f\r", c));
+}
+
+static void write_propval_string(FILE *f, const char *s, size_t len)
+{
+	const char *end = s + len - 1;
+
+	if (!len)
+		return;
+
+	assert(*end == '\0');
+
+	fprintf(f, "\"");
+	while (s < end) {
+		char c = *s++;
+		switch (c) {
+		case '\a':
+			fprintf(f, "\\a");
+			break;
+		case '\b':
+			fprintf(f, "\\b");
+			break;
+		case '\t':
+			fprintf(f, "\\t");
+			break;
+		case '\n':
+			fprintf(f, "\\n");
+			break;
+		case '\v':
+			fprintf(f, "\\v");
+			break;
+		case '\f':
+			fprintf(f, "\\f");
+			break;
+		case '\r':
+			fprintf(f, "\\r");
+			break;
+		case '\\':
+			fprintf(f, "\\\\");
+			break;
+		case '\"':
+			fprintf(f, "\\\"");
+			break;
+		case '\0':
+			fprintf(f, "\\0");
+			break;
+		default:
+			if (isprint((unsigned char)c))
+				fprintf(f, "%c", c);
+			else
+				fprintf(f, "\\x%02"PRIx8, c);
+		}
+	}
+	fprintf(f, "\"");
+}
+
+static void write_propval_int(FILE *f, const char *p, size_t len, size_t width)
+{
+	const char *end = p + len;
+	assert(len % width == 0);
+
+	for (; p < end; p += width) {
+		switch (width) {
+		case 1:
+			fprintf(f, "%02"PRIx8, *(const uint8_t*)p);
+			break;
+		case 2:
+			fprintf(f, "0x%02"PRIx16, dtb_ld16(p));
+			break;
+		case 4:
+			fprintf(f, "0x%02"PRIx32, dtb_ld32(p));
+			break;
+		case 8:
+			fprintf(f, "0x%02"PRIx64, dtb_ld64(p));
+			break;
+		}
+		if (p + width < end)
+			fputc(' ', f);
+	}
+}
+
+static bool has_data_type_information(struct marker *m)
+{
+	return m->type >= TYPE_UINT8;
+}
+
+static struct marker *next_type_marker(struct marker *m)
+{
+	while (m && !has_data_type_information(m))
+		m = m->next;
+	return m;
+}
+
+size_t type_marker_length(struct marker *m)
+{
+	struct marker *next = next_type_marker(m->next);
+
+	if (next)
+		return next->offset - m->offset;
+	return 0;
+}
+
+static const char *delim_start[] = {
+	[TYPE_UINT8] = "[",
+	[TYPE_UINT16] = "/bits/ 16 <",
+	[TYPE_UINT32] = "<",
+	[TYPE_UINT64] = "/bits/ 64 <",
+	[TYPE_STRING] = "",
+};
+static const char *delim_end[] = {
+	[TYPE_UINT8] = "]",
+	[TYPE_UINT16] = ">",
+	[TYPE_UINT32] = ">",
+	[TYPE_UINT64] = ">",
+	[TYPE_STRING] = "",
+};
+
+static enum markertype guess_value_type(struct property *prop)
+{
+	int len = prop->val.len;
+	const char *p = prop->val.val;
+	struct marker *m = prop->val.markers;
+	int nnotstring = 0, nnul = 0;
+	int nnotstringlbl = 0, nnotcelllbl = 0;
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (! isstring(p[i]))
+			nnotstring++;
+		if (p[i] == '\0')
+			nnul++;
+	}
+
+	for_each_marker_of_type(m, LABEL) {
+		if ((m->offset > 0) && (prop->val.val[m->offset - 1] != '\0'))
+			nnotstringlbl++;
+		if ((m->offset % sizeof(cell_t)) != 0)
+			nnotcelllbl++;
+	}
+
+	if ((p[len-1] == '\0') && (nnotstring == 0) && (nnul <= (len-nnul))
+	    && (nnotstringlbl == 0)) {
+		return TYPE_STRING;
+	} else if (((len % sizeof(cell_t)) == 0) && (nnotcelllbl == 0)) {
+		return TYPE_UINT32;
+	}
+
+	return TYPE_UINT8;
+}
+
+static void write_propval(FILE *f, struct property *prop)
+{
+	size_t len = prop->val.len;
+	struct marker *m = prop->val.markers;
+	struct marker dummy_marker;
+	enum markertype emit_type = TYPE_NONE;
+	char *srcstr;
+
+	if (len == 0) {
+		fprintf(f, ";");
+		if (annotate) {
+			srcstr = srcpos_string_first(prop->srcpos, annotate);
+			if (srcstr) {
+				fprintf(f, " /* %s */", srcstr);
+				free(srcstr);
+			}
+		}
+		fprintf(f, "\n");
+		return;
+	}
+
+	fprintf(f, " =");
+
+	if (!next_type_marker(m)) {
+		/* data type information missing, need to guess */
+		dummy_marker.type = guess_value_type(prop);
+		dummy_marker.next = prop->val.markers;
+		dummy_marker.offset = 0;
+		dummy_marker.ref = NULL;
+		m = &dummy_marker;
+	}
+
+	for_each_marker(m) {
+		size_t chunk_len = (m->next ? m->next->offset : len) - m->offset;
+		size_t data_len = type_marker_length(m) ? : len - m->offset;
+		const char *p = &prop->val.val[m->offset];
+
+		if (has_data_type_information(m)) {
+			emit_type = m->type;
+			fprintf(f, " %s", delim_start[emit_type]);
+		} else if (m->type == LABEL)
+			fprintf(f, " %s:", m->ref);
+		else if (m->offset)
+			fputc(' ', f);
+
+		if (emit_type == TYPE_NONE) {
+			assert(chunk_len == 0);
+			continue;
+		}
+
+		switch(emit_type) {
+		case TYPE_UINT16:
+			write_propval_int(f, p, chunk_len, 2);
+			break;
+		case TYPE_UINT32:
+			write_propval_int(f, p, chunk_len, 4);
+			break;
+		case TYPE_UINT64:
+			write_propval_int(f, p, chunk_len, 8);
+			break;
+		case TYPE_STRING:
+			write_propval_string(f, p, chunk_len);
+			break;
+		default:
+			write_propval_int(f, p, chunk_len, 1);
+		}
+
+		if (chunk_len == data_len) {
+			size_t pos = m->offset + chunk_len;
+			fprintf(f, pos == len ? "%s" : "%s,",
+			        delim_end[emit_type] ? : "");
+			emit_type = TYPE_NONE;
+		}
+	}
+	fprintf(f, ";");
+	if (annotate) {
+		srcstr = srcpos_string_first(prop->srcpos, annotate);
+		if (srcstr) {
+			fprintf(f, " /* %s */", srcstr);
+			free(srcstr);
+		}
+	}
+	fprintf(f, "\n");
+}
+
+static void write_tree_source_node(FILE *f, struct node *tree, int level)
+{
+	struct property *prop;
+	struct node *child;
+	struct label *l;
+	char *srcstr;
+
+	write_prefix(f, level);
+	for_each_label(tree->labels, l)
+		fprintf(f, "%s: ", l->label);
+	if (tree->name && (*tree->name))
+		fprintf(f, "%s {", tree->name);
+	else
+		fprintf(f, "/ {");
+
+	if (annotate) {
+		srcstr = srcpos_string_first(tree->srcpos, annotate);
+		if (srcstr) {
+			fprintf(f, " /* %s */", srcstr);
+			free(srcstr);
+		}
+	}
+	fprintf(f, "\n");
+
+	for_each_property(tree, prop) {
+		write_prefix(f, level+1);
+		for_each_label(prop->labels, l)
+			fprintf(f, "%s: ", l->label);
+		fprintf(f, "%s", prop->name);
+		write_propval(f, prop);
+	}
+	for_each_child(tree, child) {
+		fprintf(f, "\n");
+		write_tree_source_node(f, child, level+1);
+	}
+	write_prefix(f, level);
+	fprintf(f, "};");
+	if (annotate) {
+		srcstr = srcpos_string_last(tree->srcpos, annotate);
+		if (srcstr) {
+			fprintf(f, " /* %s */", srcstr);
+			free(srcstr);
+		}
+	}
+	fprintf(f, "\n");
+}
+
+void dt_to_source(FILE *f, struct dt_info *dti)
+{
+	struct reserve_info *re;
+
+	fprintf(f, "/dts-v1/;\n\n");
+
+	for (re = dti->reservelist; re; re = re->next) {
+		struct label *l;
+
+		for_each_label(re->labels, l)
+			fprintf(f, "%s: ", l->label);
+		fprintf(f, "/memreserve/\t0x%016llx 0x%016llx;\n",
+			(unsigned long long)re->address,
+			(unsigned long long)re->size);
+	}
+
+	write_tree_source_node(f, dti->dt, 0);
+}
diff --git a/dtc/util.c b/dtc/util.c
new file mode 100644
index 0000000..40274fb
--- /dev/null
+++ b/dtc/util.c
@@ -0,0 +1,468 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright 2011 The Chromium Authors, All Rights Reserved.
+ * Copyright 2008 Jon Loeliger, Freescale Semiconductor, Inc.
+ *
+ * util_is_printable_string contributed by
+ *	Pantelis Antoniou <pantelis.antoniou AT gmail.com>
+ */
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <assert.h>
+#include <inttypes.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "libfdt.h"
+#include "util.h"
+#include "version_gen.h"
+
+char *xstrdup(const char *s)
+{
+	int len = strlen(s) + 1;
+	char *d = xmalloc(len);
+
+	memcpy(d, s, len);
+
+	return d;
+}
+
+int xavsprintf_append(char **strp, const char *fmt, va_list ap)
+{
+	int n, size = 0;	/* start with 128 bytes */
+	char *p;
+	va_list ap_copy;
+
+	p = *strp;
+	if (p)
+		size = strlen(p);
+
+	va_copy(ap_copy, ap);
+	n = vsnprintf(NULL, 0, fmt, ap_copy) + 1;
+	va_end(ap_copy);
+
+	p = xrealloc(p, size + n);
+
+	n = vsnprintf(p + size, n, fmt, ap);
+
+	*strp = p;
+	return strlen(p);
+}
+
+int xasprintf_append(char **strp, const char *fmt, ...)
+{
+	int n;
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = xavsprintf_append(strp, fmt, ap);
+	va_end(ap);
+
+	return n;
+}
+
+int xasprintf(char **strp, const char *fmt, ...)
+{
+	int n;
+	va_list ap;
+
+	*strp = NULL;
+
+	va_start(ap, fmt);
+	n = xavsprintf_append(strp, fmt, ap);
+	va_end(ap);
+
+	return n;
+}
+
+char *join_path(const char *path, const char *name)
+{
+	int lenp = strlen(path);
+	int lenn = strlen(name);
+	int len;
+	int needslash = 1;
+	char *str;
+
+	len = lenp + lenn + 2;
+	if ((lenp > 0) && (path[lenp-1] == '/')) {
+		needslash = 0;
+		len--;
+	}
+
+	str = xmalloc(len);
+	memcpy(str, path, lenp);
+	if (needslash) {
+		str[lenp] = '/';
+		lenp++;
+	}
+	memcpy(str+lenp, name, lenn+1);
+	return str;
+}
+
+bool util_is_printable_string(const void *data, int len)
+{
+	const char *s = data;
+	const char *ss, *se;
+
+	/* zero length is not */
+	if (len == 0)
+		return 0;
+
+	/* must terminate with zero */
+	if (s[len - 1] != '\0')
+		return 0;
+
+	se = s + len;
+
+	while (s < se) {
+		ss = s;
+		while (s < se && *s && isprint((unsigned char)*s))
+			s++;
+
+		/* not zero, or not done yet */
+		if (*s != '\0' || s == ss)
+			return 0;
+
+		s++;
+	}
+
+	return 1;
+}
+
+/*
+ * Parse a octal encoded character starting at index i in string s.  The
+ * resulting character will be returned and the index i will be updated to
+ * point at the character directly after the end of the encoding, this may be
+ * the '\0' terminator of the string.
+ */
+static char get_oct_char(const char *s, int *i)
+{
+	char x[4];
+	char *endx;
+	long val;
+
+	x[3] = '\0';
+	strncpy(x, s + *i, 3);
+
+	val = strtol(x, &endx, 8);
+
+	assert(endx > x);
+
+	(*i) += endx - x;
+	return val;
+}
+
+/*
+ * Parse a hexadecimal encoded character starting at index i in string s.  The
+ * resulting character will be returned and the index i will be updated to
+ * point at the character directly after the end of the encoding, this may be
+ * the '\0' terminator of the string.
+ */
+static char get_hex_char(const char *s, int *i)
+{
+	char x[3];
+	char *endx;
+	long val;
+
+	x[2] = '\0';
+	strncpy(x, s + *i, 2);
+
+	val = strtol(x, &endx, 16);
+	if (!(endx  > x))
+		die("\\x used with no following hex digits\n");
+
+	(*i) += endx - x;
+	return val;
+}
+
+char get_escape_char(const char *s, int *i)
+{
+	char	c = s[*i];
+	int	j = *i + 1;
+	char	val;
+
+	switch (c) {
+	case 'a':
+		val = '\a';
+		break;
+	case 'b':
+		val = '\b';
+		break;
+	case 't':
+		val = '\t';
+		break;
+	case 'n':
+		val = '\n';
+		break;
+	case 'v':
+		val = '\v';
+		break;
+	case 'f':
+		val = '\f';
+		break;
+	case 'r':
+		val = '\r';
+		break;
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+		j--; /* need to re-read the first digit as
+		      * part of the octal value */
+		val = get_oct_char(s, &j);
+		break;
+	case 'x':
+		val = get_hex_char(s, &j);
+		break;
+	default:
+		val = c;
+	}
+
+	(*i) = j;
+	return val;
+}
+
+int utilfdt_read_err(const char *filename, char **buffp, size_t *len)
+{
+	int fd = 0;	/* assume stdin */
+	char *buf = NULL;
+	size_t bufsize = 1024, offset = 0;
+	int ret = 0;
+
+	*buffp = NULL;
+	if (strcmp(filename, "-") != 0) {
+		fd = open(filename, O_RDONLY);
+		if (fd < 0)
+			return errno;
+	}
+
+	/* Loop until we have read everything */
+	buf = xmalloc(bufsize);
+	do {
+		/* Expand the buffer to hold the next chunk */
+		if (offset == bufsize) {
+			bufsize *= 2;
+			buf = xrealloc(buf, bufsize);
+		}
+
+		ret = read(fd, &buf[offset], bufsize - offset);
+		if (ret < 0) {
+			ret = errno;
+			break;
+		}
+		offset += ret;
+	} while (ret != 0);
+
+	/* Clean up, including closing stdin; return errno on error */
+	close(fd);
+	if (ret)
+		free(buf);
+	else
+		*buffp = buf;
+	if (len)
+		*len = bufsize;
+	return ret;
+}
+
+char *utilfdt_read(const char *filename, size_t *len)
+{
+	char *buff;
+	int ret = utilfdt_read_err(filename, &buff, len);
+
+	if (ret) {
+		fprintf(stderr, "Couldn't open blob from '%s': %s\n", filename,
+			strerror(ret));
+		return NULL;
+	}
+	/* Successful read */
+	return buff;
+}
+
+int utilfdt_write_err(const char *filename, const void *blob)
+{
+	int fd = 1;	/* assume stdout */
+	int totalsize;
+	int offset;
+	int ret = 0;
+	const char *ptr = blob;
+
+	if (strcmp(filename, "-") != 0) {
+		fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+		if (fd < 0)
+			return errno;
+	}
+
+	totalsize = fdt_totalsize(blob);
+	offset = 0;
+
+	while (offset < totalsize) {
+		ret = write(fd, ptr + offset, totalsize - offset);
+		if (ret < 0) {
+			ret = -errno;
+			break;
+		}
+		offset += ret;
+	}
+	/* Close the file/stdin; return errno on error */
+	if (fd != 1)
+		close(fd);
+	return ret < 0 ? -ret : 0;
+}
+
+
+int utilfdt_write(const char *filename, const void *blob)
+{
+	int ret = utilfdt_write_err(filename, blob);
+
+	if (ret) {
+		fprintf(stderr, "Couldn't write blob to '%s': %s\n", filename,
+			strerror(ret));
+	}
+	return ret ? -1 : 0;
+}
+
+int utilfdt_decode_type(const char *fmt, int *type, int *size)
+{
+	int qualifier = 0;
+
+	if (!*fmt)
+		return -1;
+
+	/* get the conversion qualifier */
+	*size = -1;
+	if (strchr("hlLb", *fmt)) {
+		qualifier = *fmt++;
+		if (qualifier == *fmt) {
+			switch (*fmt++) {
+/* TODO:		case 'l': qualifier = 'L'; break;*/
+			case 'h':
+				qualifier = 'b';
+				break;
+			}
+		}
+	}
+
+	/* we should now have a type */
+	if ((*fmt == '\0') || !strchr("iuxs", *fmt))
+		return -1;
+
+	/* convert qualifier (bhL) to byte size */
+	if (*fmt != 's')
+		*size = qualifier == 'b' ? 1 :
+				qualifier == 'h' ? 2 :
+				qualifier == 'l' ? 4 : -1;
+	*type = *fmt++;
+
+	/* that should be it! */
+	if (*fmt)
+		return -1;
+	return 0;
+}
+
+void utilfdt_print_data(const char *data, int len)
+{
+	int i;
+	const char *s;
+
+	/* no data, don't print */
+	if (len == 0)
+		return;
+
+	if (util_is_printable_string(data, len)) {
+		printf(" = ");
+
+		s = data;
+		do {
+			printf("\"%s\"", s);
+			s += strlen(s) + 1;
+			if (s < data + len)
+				printf(", ");
+		} while (s < data + len);
+
+	} else if ((len % 4) == 0) {
+		const fdt32_t *cell = (const fdt32_t *)data;
+
+		printf(" = <");
+		for (i = 0, len /= 4; i < len; i++)
+			printf("0x%08" PRIx32 "%s", fdt32_to_cpu(cell[i]),
+			       i < (len - 1) ? " " : "");
+		printf(">");
+	} else {
+		const unsigned char *p = (const unsigned char *)data;
+		printf(" = [");
+		for (i = 0; i < len; i++)
+			printf("%02x%s", *p++, i < len - 1 ? " " : "");
+		printf("]");
+	}
+}
+
+void NORETURN util_version(void)
+{
+	printf("Version: %s\n", DTC_VERSION);
+	exit(0);
+}
+
+void NORETURN util_usage(const char *errmsg, const char *synopsis,
+			 const char *short_opts,
+			 struct option const long_opts[],
+			 const char * const opts_help[])
+{
+	FILE *fp = errmsg ? stderr : stdout;
+	const char a_arg[] = "<arg>";
+	size_t a_arg_len = strlen(a_arg) + 1;
+	size_t i;
+	int optlen;
+
+	fprintf(fp,
+		"Usage: %s\n"
+		"\n"
+		"Options: -[%s]\n", synopsis, short_opts);
+
+	/* prescan the --long opt length to auto-align */
+	optlen = 0;
+	for (i = 0; long_opts[i].name; ++i) {
+		/* +1 is for space between --opt and help text */
+		int l = strlen(long_opts[i].name) + 1;
+		if (long_opts[i].has_arg == a_argument)
+			l += a_arg_len;
+		if (optlen < l)
+			optlen = l;
+	}
+
+	for (i = 0; long_opts[i].name; ++i) {
+		/* helps when adding new applets or options */
+		assert(opts_help[i] != NULL);
+
+		/* first output the short flag if it has one */
+		if (long_opts[i].val > '~')
+			fprintf(fp, "      ");
+		else
+			fprintf(fp, "  -%c, ", long_opts[i].val);
+
+		/* then the long flag */
+		if (long_opts[i].has_arg == no_argument)
+			fprintf(fp, "--%-*s", optlen, long_opts[i].name);
+		else
+			fprintf(fp, "--%s %s%*s", long_opts[i].name, a_arg,
+				(int)(optlen - strlen(long_opts[i].name) - a_arg_len), "");
+
+		/* finally the help text */
+		fprintf(fp, "%s\n", opts_help[i]);
+	}
+
+	if (errmsg) {
+		fprintf(fp, "\nError: %s\n", errmsg);
+		exit(EXIT_FAILURE);
+	} else
+		exit(EXIT_SUCCESS);
+}
diff --git a/dtc/util.h b/dtc/util.h
new file mode 100644
index 0000000..c45b2c2
--- /dev/null
+++ b/dtc/util.h
@@ -0,0 +1,247 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef UTIL_H
+#define UTIL_H
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <getopt.h>
+
+/*
+ * Copyright 2011 The Chromium Authors, All Rights Reserved.
+ * Copyright 2008 Jon Loeliger, Freescale Semiconductor, Inc.
+ */
+
+#ifdef __GNUC__
+#if __GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+#define PRINTF(i, j)	__attribute__((format (gnu_printf, i, j)))
+#else
+#define PRINTF(i, j)	__attribute__((format (printf, i, j)))
+#endif
+#define NORETURN	__attribute__((noreturn))
+#else
+#define PRINTF(i, j)
+#define NORETURN
+#endif
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define stringify(s)	stringify_(s)
+#define stringify_(s)	#s
+
+static inline void NORETURN PRINTF(1, 2) die(const char *str, ...)
+{
+	va_list ap;
+
+	va_start(ap, str);
+	fprintf(stderr, "FATAL ERROR: ");
+	vfprintf(stderr, str, ap);
+	va_end(ap);
+	exit(1);
+}
+
+static inline void *xmalloc(size_t len)
+{
+	void *new = malloc(len);
+
+	if (!new)
+		die("malloc() failed\n");
+
+	return new;
+}
+
+static inline void *xrealloc(void *p, size_t len)
+{
+	void *new = realloc(p, len);
+
+	if (!new)
+		die("realloc() failed (len=%zd)\n", len);
+
+	return new;
+}
+
+extern char *xstrdup(const char *s);
+
+extern int PRINTF(2, 3) xasprintf(char **strp, const char *fmt, ...);
+extern int PRINTF(2, 3) xasprintf_append(char **strp, const char *fmt, ...);
+extern int xavsprintf_append(char **strp, const char *fmt, va_list ap);
+extern char *join_path(const char *path, const char *name);
+
+/**
+ * Check a property of a given length to see if it is all printable and
+ * has a valid terminator. The property can contain either a single string,
+ * or multiple strings each of non-zero length.
+ *
+ * @param data	The string to check
+ * @param len	The string length including terminator
+ * @return 1 if a valid printable string, 0 if not
+ */
+bool util_is_printable_string(const void *data, int len);
+
+/*
+ * Parse an escaped character starting at index i in string s.  The resulting
+ * character will be returned and the index i will be updated to point at the
+ * character directly after the end of the encoding, this may be the '\0'
+ * terminator of the string.
+ */
+char get_escape_char(const char *s, int *i);
+
+/**
+ * Read a device tree file into a buffer. This will report any errors on
+ * stderr.
+ *
+ * @param filename	The filename to read, or - for stdin
+ * @param len		If non-NULL, the amount of data we managed to read
+ * @return Pointer to allocated buffer containing fdt, or NULL on error
+ */
+char *utilfdt_read(const char *filename, size_t *len);
+
+/**
+ * Read a device tree file into a buffer. Does not report errors, but only
+ * returns them. The value returned can be passed to strerror() to obtain
+ * an error message for the user.
+ *
+ * @param filename	The filename to read, or - for stdin
+ * @param buffp		Returns pointer to buffer containing fdt
+ * @param len		If non-NULL, the amount of data we managed to read
+ * @return 0 if ok, else an errno value representing the error
+ */
+int utilfdt_read_err(const char *filename, char **buffp, size_t *len);
+
+/**
+ * Write a device tree buffer to a file. This will report any errors on
+ * stderr.
+ *
+ * @param filename	The filename to write, or - for stdout
+ * @param blob		Pointer to buffer containing fdt
+ * @return 0 if ok, -1 on error
+ */
+int utilfdt_write(const char *filename, const void *blob);
+
+/**
+ * Write a device tree buffer to a file. Does not report errors, but only
+ * returns them. The value returned can be passed to strerror() to obtain
+ * an error message for the user.
+ *
+ * @param filename	The filename to write, or - for stdout
+ * @param blob		Pointer to buffer containing fdt
+ * @return 0 if ok, else an errno value representing the error
+ */
+int utilfdt_write_err(const char *filename, const void *blob);
+
+/**
+ * Decode a data type string. The purpose of this string
+ *
+ * The string consists of an optional character followed by the type:
+ *	Modifier characters:
+ *		hh or b	1 byte
+ *		h	2 byte
+ *		l	4 byte, default
+ *
+ *	Type character:
+ *		s	string
+ *		i	signed integer
+ *		u	unsigned integer
+ *		x	hex
+ *
+ * TODO: Implement ll modifier (8 bytes)
+ * TODO: Implement o type (octal)
+ *
+ * @param fmt		Format string to process
+ * @param type		Returns type found(s/d/u/x), or 0 if none
+ * @param size		Returns size found(1,2,4,8) or 4 if none
+ * @return 0 if ok, -1 on error (no type given, or other invalid format)
+ */
+int utilfdt_decode_type(const char *fmt, int *type, int *size);
+
+/*
+ * This is a usage message fragment for the -t option. It is the format
+ * supported by utilfdt_decode_type.
+ */
+
+#define USAGE_TYPE_MSG \
+	"<type>\ts=string, i=int, u=unsigned, x=hex\n" \
+	"\tOptional modifier prefix:\n" \
+	"\t\thh or b=byte, h=2 byte, l=4 byte (default)";
+
+/**
+ * Print property data in a readable format to stdout
+ *
+ * Properties that look like strings will be printed as strings. Otherwise
+ * the data will be displayed either as cells (if len is a multiple of 4
+ * bytes) or bytes.
+ *
+ * If len is 0 then this function does nothing.
+ *
+ * @param data	Pointers to property data
+ * @param len	Length of property data
+ */
+void utilfdt_print_data(const char *data, int len);
+
+/**
+ * Show source version and exit
+ */
+void NORETURN util_version(void);
+
+/**
+ * Show usage and exit
+ *
+ * This helps standardize the output of various utils.  You most likely want
+ * to use the usage() helper below rather than call this.
+ *
+ * @param errmsg	If non-NULL, an error message to display
+ * @param synopsis	The initial example usage text (and possible examples)
+ * @param short_opts	The string of short options
+ * @param long_opts	The structure of long options
+ * @param opts_help	An array of help strings (should align with long_opts)
+ */
+void NORETURN util_usage(const char *errmsg, const char *synopsis,
+			 const char *short_opts,
+			 struct option const long_opts[],
+			 const char * const opts_help[]);
+
+/**
+ * Show usage and exit
+ *
+ * If you name all your usage variables with usage_xxx, then you can call this
+ * help macro rather than expanding all arguments yourself.
+ *
+ * @param errmsg	If non-NULL, an error message to display
+ */
+#define usage(errmsg) \
+	util_usage(errmsg, usage_synopsis, usage_short_opts, \
+		   usage_long_opts, usage_opts_help)
+
+/**
+ * Call getopt_long() with standard options
+ *
+ * Since all util code runs getopt in the same way, provide a helper.
+ */
+#define util_getopt_long() getopt_long(argc, argv, usage_short_opts, \
+				       usage_long_opts, NULL)
+
+/* Helper for aligning long_opts array */
+#define a_argument required_argument
+
+/* Helper for usage_short_opts string constant */
+#define USAGE_COMMON_SHORT_OPTS "hV"
+
+/* Helper for usage_long_opts option array */
+#define USAGE_COMMON_LONG_OPTS \
+	{"help",      no_argument, NULL, 'h'}, \
+	{"version",   no_argument, NULL, 'V'}, \
+	{NULL,        no_argument, NULL, 0x0}
+
+/* Helper for usage_opts_help array */
+#define USAGE_COMMON_OPTS_HELP \
+	"Print this help and exit", \
+	"Print version and exit", \
+	NULL
+
+/* Helper for getopt case statements */
+#define case_USAGE_COMMON_FLAGS \
+	case 'h': usage(NULL); \
+	case 'V': util_version(); \
+	case '?': usage("unknown option");
+
+#endif /* UTIL_H */
diff --git a/dtc/version_gen.h.in b/dtc/version_gen.h.in
new file mode 100644
index 0000000..7771abb
--- /dev/null
+++ b/dtc/version_gen.h.in
@@ -0,0 +1 @@
+#define DTC_VERSION "DTC @VCS_TAG@"
diff --git a/dtc/yamltree.c b/dtc/yamltree.c
new file mode 100644
index 0000000..55908c8
--- /dev/null
+++ b/dtc/yamltree.c
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * (C) Copyright Linaro, Ltd. 2018
+ * (C) Copyright Arm Holdings.  2017
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ */
+
+#include <stdlib.h>
+#include <yaml.h>
+#include "dtc.h"
+#include "srcpos.h"
+
+char *yaml_error_name[] = {
+	[YAML_NO_ERROR] = "no error",
+	[YAML_MEMORY_ERROR] = "memory error",
+	[YAML_READER_ERROR] = "reader error",
+	[YAML_SCANNER_ERROR] = "scanner error",
+	[YAML_PARSER_ERROR] = "parser error",
+	[YAML_COMPOSER_ERROR] = "composer error",
+	[YAML_WRITER_ERROR] = "writer error",
+	[YAML_EMITTER_ERROR] = "emitter error",
+};
+
+#define yaml_emitter_emit_or_die(emitter, event) (			\
+{									\
+	if (!yaml_emitter_emit(emitter, event))				\
+		die("yaml '%s': %s in %s, line %i\n",			\
+		    yaml_error_name[(emitter)->error], 			\
+		    (emitter)->problem, __func__, __LINE__);		\
+})
+
+static void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers,
+	char *data, unsigned int seq_offset, unsigned int len, int width)
+{
+	yaml_event_t event;
+	void *tag;
+	unsigned int off;
+
+	switch(width) {
+		case 1: tag = "!u8"; break;
+		case 2: tag = "!u16"; break;
+		case 4: tag = "!u32"; break;
+		case 8: tag = "!u64"; break;
+		default:
+			die("Invalid width %i", width);
+	}
+	assert(len % width == 0);
+
+	yaml_sequence_start_event_initialize(&event, NULL,
+		(yaml_char_t *)tag, width == 4, YAML_FLOW_SEQUENCE_STYLE);
+	yaml_emitter_emit_or_die(emitter, &event);
+
+	for (off = 0; off < len; off += width) {
+		char buf[32];
+		struct marker *m;
+		bool is_phandle = false;
+
+		switch(width) {
+		case 1:
+			sprintf(buf, "0x%"PRIx8, *(uint8_t*)(data + off));
+			break;
+		case 2:
+			sprintf(buf, "0x%"PRIx16, dtb_ld16(data + off));
+			break;
+		case 4:
+			sprintf(buf, "0x%"PRIx32, dtb_ld32(data + off));
+			m = markers;
+			is_phandle = false;
+			for_each_marker_of_type(m, REF_PHANDLE) {
+				if (m->offset == (seq_offset + off)) {
+					is_phandle = true;
+					break;
+				}
+			}
+			break;
+		case 8:
+			sprintf(buf, "0x%"PRIx64, dtb_ld64(data + off));
+			break;
+		}
+
+		if (is_phandle)
+			yaml_scalar_event_initialize(&event, NULL,
+				(yaml_char_t*)"!phandle", (yaml_char_t *)buf,
+				strlen(buf), 0, 0, YAML_PLAIN_SCALAR_STYLE);
+		else
+			yaml_scalar_event_initialize(&event, NULL,
+				(yaml_char_t*)YAML_INT_TAG, (yaml_char_t *)buf,
+				strlen(buf), 1, 1, YAML_PLAIN_SCALAR_STYLE);
+		yaml_emitter_emit_or_die(emitter, &event);
+	}
+
+	yaml_sequence_end_event_initialize(&event);
+	yaml_emitter_emit_or_die(emitter, &event);
+}
+
+static void yaml_propval_string(yaml_emitter_t *emitter, char *str, int len)
+{
+	yaml_event_t event;
+	int i;
+
+	assert(str[len-1] == '\0');
+
+	/* Make sure the entire string is in the lower 7-bit ascii range */
+	for (i = 0; i < len; i++)
+		assert(isascii(str[i]));
+
+	yaml_scalar_event_initialize(&event, NULL,
+		(yaml_char_t *)YAML_STR_TAG, (yaml_char_t*)str,
+		len-1, 0, 1, YAML_DOUBLE_QUOTED_SCALAR_STYLE);
+	yaml_emitter_emit_or_die(emitter, &event);
+}
+
+static void yaml_propval(yaml_emitter_t *emitter, struct property *prop)
+{
+	yaml_event_t event;
+	unsigned int len = prop->val.len;
+	struct marker *m = prop->val.markers;
+	struct marker *markers = prop->val.markers;
+
+	/* Emit the property name */
+	yaml_scalar_event_initialize(&event, NULL,
+		(yaml_char_t *)YAML_STR_TAG, (yaml_char_t*)prop->name,
+		strlen(prop->name), 1, 1, YAML_PLAIN_SCALAR_STYLE);
+	yaml_emitter_emit_or_die(emitter, &event);
+
+	/* Boolean properties are easiest to deal with. Length is zero, so just emit 'true' */
+	if (len == 0) {
+		yaml_scalar_event_initialize(&event, NULL,
+			(yaml_char_t *)YAML_BOOL_TAG,
+			(yaml_char_t*)"true",
+			strlen("true"), 1, 0, YAML_PLAIN_SCALAR_STYLE);
+		yaml_emitter_emit_or_die(emitter, &event);
+		return;
+	}
+
+	if (!m)
+		die("No markers present in property '%s' value\n", prop->name);
+
+	yaml_sequence_start_event_initialize(&event, NULL,
+		(yaml_char_t *)YAML_SEQ_TAG, 1, YAML_FLOW_SEQUENCE_STYLE);
+	yaml_emitter_emit_or_die(emitter, &event);
+
+	for_each_marker(m) {
+		int chunk_len;
+		char *data = &prop->val.val[m->offset];
+
+		if (m->type < TYPE_UINT8)
+			continue;
+
+		chunk_len = type_marker_length(m) ? : len;
+		assert(chunk_len > 0);
+		len -= chunk_len;
+
+		switch(m->type) {
+		case TYPE_UINT16:
+			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 2);
+			break;
+		case TYPE_UINT32:
+			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 4);
+			break;
+		case TYPE_UINT64:
+			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 8);
+			break;
+		case TYPE_STRING:
+			yaml_propval_string(emitter, data, chunk_len);
+			break;
+		default:
+			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 1);
+			break;
+		}
+	}
+
+	yaml_sequence_end_event_initialize(&event);
+	yaml_emitter_emit_or_die(emitter, &event);
+}
+
+
+static void yaml_tree(struct node *tree, yaml_emitter_t *emitter)
+{
+	struct property *prop;
+	struct node *child;
+	yaml_event_t event;
+
+	if (tree->deleted)
+		return;
+
+	yaml_mapping_start_event_initialize(&event, NULL,
+		(yaml_char_t *)YAML_MAP_TAG, 1, YAML_ANY_MAPPING_STYLE);
+	yaml_emitter_emit_or_die(emitter, &event);
+
+	for_each_property(tree, prop)
+		yaml_propval(emitter, prop);
+
+	/* Loop over all the children, emitting them into the map */
+	for_each_child(tree, child) {
+		yaml_scalar_event_initialize(&event, NULL,
+			(yaml_char_t *)YAML_STR_TAG, (yaml_char_t*)child->name,
+			strlen(child->name), 1, 0, YAML_PLAIN_SCALAR_STYLE);
+		yaml_emitter_emit_or_die(emitter, &event);
+		yaml_tree(child, emitter);
+	}
+
+	yaml_mapping_end_event_initialize(&event);
+	yaml_emitter_emit_or_die(emitter, &event);
+}
+
+void dt_to_yaml(FILE *f, struct dt_info *dti)
+{
+	yaml_emitter_t emitter;
+	yaml_event_t event;
+
+	yaml_emitter_initialize(&emitter);
+	yaml_emitter_set_output_file(&emitter, f);
+	yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);
+	yaml_emitter_emit_or_die(&emitter, &event);
+
+	yaml_document_start_event_initialize(&event, NULL, NULL, NULL, 0);
+	yaml_emitter_emit_or_die(&emitter, &event);
+
+	yaml_sequence_start_event_initialize(&event, NULL, (yaml_char_t *)YAML_SEQ_TAG, 1, YAML_ANY_SEQUENCE_STYLE);
+	yaml_emitter_emit_or_die(&emitter, &event);
+
+	yaml_tree(dti->dt, &emitter);
+
+	yaml_sequence_end_event_initialize(&event);
+	yaml_emitter_emit_or_die(&emitter, &event);
+
+	yaml_document_end_event_initialize(&event, 0);
+	yaml_emitter_emit_or_die(&emitter, &event);
+
+	yaml_stream_end_event_initialize(&event);
+	yaml_emitter_emit_or_die(&emitter, &event);
+
+	yaml_emitter_delete(&emitter);
+}
diff --git a/ebpf/ebpf_rss.c b/ebpf/ebpf_rss.c
index 118c68d..544e24f 100644
--- a/ebpf/ebpf_rss.c
+++ b/ebpf/ebpf_rss.c
@@ -49,7 +49,8 @@ bool ebpf_rss_load(struct EBPFRSSContext *ctx)
         goto error;
     }
 
-    bpf_program__set_socket_filter(rss_bpf_ctx->progs.tun_rss_steering_prog);
+    // deprecated: bpf_program__set_socket_filter(rss_bpf_ctx->progs.tun_rss_steering_prog);
+    bpf_program__set_type(rss_bpf_ctx->progs.tun_rss_steering_prog, BPF_PROG_TYPE_SOCKET_FILTER);
 
     if (rss_bpf__load(rss_bpf_ctx)) {
         trace_ebpf_error("eBPF RSS", "can not load RSS program");
diff --git a/hw/core/numa.c b/hw/core/numa.c
index e6050b2..1aa05dc 100644
--- a/hw/core/numa.c
+++ b/hw/core/numa.c
@@ -784,9 +784,8 @@ static void numa_stat_memory_devices(NumaNodeMem node_mem[])
                 break;
             case MEMORY_DEVICE_INFO_KIND_SGX_EPC:
                 se = value->u.sgx_epc.data;
-                /* TODO: once we support numa, assign to right node */
-                node_mem[0].node_mem += se->size;
-                node_mem[0].node_plugged_mem += se->size;
+                node_mem[se->node].node_mem += se->size;
+                node_mem[se->node].node_plugged_mem = 0;
                 break;
             default:
                 g_assert_not_reached();
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index a99c6e4..8383b83 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -2068,6 +2068,8 @@ build_srat(GArray *table_data, BIOSLinker *linker, MachineState *machine)
         nvdimm_build_srat(table_data);
     }
 
+    sgx_epc_build_srat(table_data);
+
     /*
      * TODO: this part is not in ACPI spec and current linux kernel boots fine
      * without these entries. But I recall there were issues the last time I
diff --git a/hw/i386/multiboot.c b/hw/i386/multiboot.c
index 0a10089..8ce09b8 100644
--- a/hw/i386/multiboot.c
+++ b/hw/i386/multiboot.c
@@ -32,6 +32,8 @@
 #include "sysemu/sysemu.h"
 #include "qemu/error-report.h"
 
+#include "hw/vfio/cni_logger.h"
+
 /* Show multiboot debug output */
 //#define DEBUG_MULTIBOOT
 
@@ -164,6 +166,9 @@ int load_multiboot(X86MachineState *x86ms,
     uint32_t cmdline_len;
     GList *mods = NULL;
 
+    cni_log_info("load_multiboot");
+
+
     /* Ok, let's see if it is a multiboot image.
        The header is 12x32bit long, so the latest entry may be 8192 - 48. */
     for (i = 0; i < (8192 - 48); i += 4) {
@@ -181,6 +186,8 @@ int load_multiboot(X86MachineState *x86ms,
 
     if (!is_multiboot)
         return 0; /* no multiboot */
+    
+    cni_log_info("load_multiboot1");
 
     mb_debug("I believe we found a multiboot image!");
     memset(bootinfo, 0, sizeof(bootinfo));
@@ -284,6 +291,8 @@ int load_multiboot(X86MachineState *x86ms,
         fclose(f);
     }
 
+    cni_log_info("load_multiboot2");
+
     mbs.mb_buf_phys = mh_load_addr;
 
     mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);
@@ -360,6 +369,7 @@ int load_multiboot(X86MachineState *x86ms,
         }
         g_list_free(mods);
     }
+    cni_log_info("load_multiboot3");
 
     /* Commandline support */
     char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];
@@ -398,6 +408,10 @@ int load_multiboot(X86MachineState *x86ms,
     fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,
                      mbs.mb_buf, mbs.mb_buf_size);
 
+    char msg[64];
+    sprintf(msg, "multiboot: entry-addr:%x, load_addr:%x, kernel-size:%u", mh_entry_addr, mh_load_addr, mbs.mb_buf_size);
+    cni_log_info(msg);
+
     fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);
     fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));
     fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index e1e1003..37f86b4 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -55,6 +55,8 @@
 #include "hw/mem/nvdimm.h"
 #include "hw/i386/acpi-build.h"
 
+#include "hw/vfio/cni_logger.h"
+
 /* ICH9 AHCI has 6 ports */
 #define MAX_SATA_PORTS     6
 
@@ -139,6 +141,8 @@ static void pc_q35_init(MachineState *machine)
     bool acpi_pcihp;
     bool keep_pci_slot_hpc;
 
+    cni_log_info("q35 init");
+
     /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory
      * and 256 Mbytes for PCI Express Enhanced Configuration Access Mapping
      * also known as MMCFG).
diff --git a/hw/i386/sgx-epc.c b/hw/i386/sgx-epc.c
index e508827..96b2940 100644
--- a/hw/i386/sgx-epc.c
+++ b/hw/i386/sgx-epc.c
@@ -21,6 +21,7 @@
 
 static Property sgx_epc_properties[] = {
     DEFINE_PROP_UINT64(SGX_EPC_ADDR_PROP, SGXEPCDevice, addr, 0),
+    DEFINE_PROP_UINT32(SGX_EPC_NUMA_NODE_PROP, SGXEPCDevice, node, 0),
     DEFINE_PROP_LINK(SGX_EPC_MEMDEV_PROP, SGXEPCDevice, hostmem,
                      TYPE_MEMORY_BACKEND_EPC, HostMemoryBackendEpc *),
     DEFINE_PROP_END_OF_LIST(),
@@ -139,6 +140,8 @@ static void sgx_epc_md_fill_device_info(const MemoryDeviceState *md,
     se->memaddr = epc->addr;
     se->size = object_property_get_uint(OBJECT(epc), SGX_EPC_SIZE_PROP,
                                         NULL);
+    se->node = object_property_get_uint(OBJECT(epc), SGX_EPC_NUMA_NODE_PROP,
+                                        NULL);
     se->memdev = object_get_canonical_path(OBJECT(epc->hostmem));
 
     info->u.sgx_epc.data = se;
diff --git a/hw/i386/sgx-stub.c b/hw/i386/sgx-stub.c
index c9b379e..26833eb 100644
--- a/hw/i386/sgx-stub.c
+++ b/hw/i386/sgx-stub.c
@@ -6,6 +6,10 @@
 #include "qapi/error.h"
 #include "qapi/qapi-commands-misc-target.h"
 
+void sgx_epc_build_srat(GArray *table_data)
+{
+}
+
 SGXInfo *qmp_query_sgx(Error **errp)
 {
     error_setg(errp, "SGX support is not compiled in");
diff --git a/hw/i386/sgx.c b/hw/i386/sgx.c
index 8fef3dd..5de5dd0 100644
--- a/hw/i386/sgx.c
+++ b/hw/i386/sgx.c
@@ -23,6 +23,7 @@
 #include "sysemu/hw_accel.h"
 #include "sysemu/reset.h"
 #include <sys/ioctl.h>
+#include "hw/acpi/aml-build.h"
 
 #define SGX_MAX_EPC_SECTIONS            8
 #define SGX_CPUID_EPC_INVALID           0x0
@@ -36,17 +37,59 @@
 
 #define RETRY_NUM                       2
 
+static int sgx_epc_device_list(Object *obj, void *opaque)
+{
+    GSList **list = opaque;
+
+    if (object_dynamic_cast(obj, TYPE_SGX_EPC)) {
+        *list = g_slist_append(*list, DEVICE(obj));
+    }
+
+    object_child_foreach(obj, sgx_epc_device_list, opaque);
+    return 0;
+}
+
+static GSList *sgx_epc_get_device_list(void)
+{
+    GSList *list = NULL;
+
+    object_child_foreach(qdev_get_machine(), sgx_epc_device_list, &list);
+    return list;
+}
+
+void sgx_epc_build_srat(GArray *table_data)
+{
+    GSList *device_list = sgx_epc_get_device_list();
+
+    for (; device_list; device_list = device_list->next) {
+        DeviceState *dev = device_list->data;
+        Object *obj = OBJECT(dev);
+        uint64_t addr, size;
+        int node;
+
+        node = object_property_get_uint(obj, SGX_EPC_NUMA_NODE_PROP,
+                                        &error_abort);
+        addr = object_property_get_uint(obj, SGX_EPC_ADDR_PROP, &error_abort);
+        size = object_property_get_uint(obj, SGX_EPC_SIZE_PROP, &error_abort);
+
+        build_srat_memory(table_data, addr, size, node, MEM_AFFINITY_ENABLED);
+    }
+    g_slist_free(device_list);
+}
+
 static uint64_t sgx_calc_section_metric(uint64_t low, uint64_t high)
 {
     return (low & MAKE_64BIT_MASK(12, 20)) +
            ((high & MAKE_64BIT_MASK(0, 20)) << 32);
 }
 
-static uint64_t sgx_calc_host_epc_section_size(void)
+static SGXEPCSectionList *sgx_calc_host_epc_sections(void)
 {
+    SGXEPCSectionList *head = NULL, **tail = &head;
+    SGXEPCSection *section;
     uint32_t i, type;
     uint32_t eax, ebx, ecx, edx;
-    uint64_t size = 0;
+    uint32_t j = 0;
 
     for (i = 0; i < SGX_MAX_EPC_SECTIONS; i++) {
         host_cpuid(0x12, i + 2, &eax, &ebx, &ecx, &edx);
@@ -60,10 +103,13 @@ static uint64_t sgx_calc_host_epc_section_size(void)
             break;
         }
 
-        size += sgx_calc_section_metric(ecx, edx);
+        section = g_new0(SGXEPCSection, 1);
+        section->node = j++;
+        section->size = sgx_calc_section_metric(ecx, edx);
+        QAPI_LIST_APPEND(tail, section);
     }
 
-    return size;
+    return head;
 }
 
 static void sgx_epc_reset(void *opaque)
@@ -127,13 +173,35 @@ SGXInfo *qmp_query_sgx_capabilities(Error **errp)
     info->sgx1 = eax & (1U << 0) ? true : false;
     info->sgx2 = eax & (1U << 1) ? true : false;
 
-    info->section_size = sgx_calc_host_epc_section_size();
+    info->sections = sgx_calc_host_epc_sections();
 
     close(fd);
 
     return info;
 }
 
+static SGXEPCSectionList *sgx_get_epc_sections_list(void)
+{
+    GSList *device_list = sgx_epc_get_device_list();
+    SGXEPCSectionList *head = NULL, **tail = &head;
+    SGXEPCSection *section;
+
+    for (; device_list; device_list = device_list->next) {
+        DeviceState *dev = device_list->data;
+        Object *obj = OBJECT(dev);
+
+        section = g_new0(SGXEPCSection, 1);
+        section->node = object_property_get_uint(obj, SGX_EPC_NUMA_NODE_PROP,
+                                                 &error_abort);
+        section->size = object_property_get_uint(obj, SGX_EPC_SIZE_PROP,
+                                                 &error_abort);
+        QAPI_LIST_APPEND(tail, section);
+    }
+    g_slist_free(device_list);
+
+    return head;
+}
+
 SGXInfo *qmp_query_sgx(Error **errp)
 {
     SGXInfo *info = NULL;
@@ -152,14 +220,13 @@ SGXInfo *qmp_query_sgx(Error **errp)
         return NULL;
     }
 
-    SGXEPCState *sgx_epc = &pcms->sgx_epc;
     info = g_new0(SGXInfo, 1);
 
     info->sgx = true;
     info->sgx1 = true;
     info->sgx2 = true;
     info->flc = true;
-    info->section_size = sgx_epc->size;
+    info->sections = sgx_get_epc_sections_list();
 
     return info;
 }
@@ -167,6 +234,7 @@ SGXInfo *qmp_query_sgx(Error **errp)
 void hmp_info_sgx(Monitor *mon, const QDict *qdict)
 {
     Error *err = NULL;
+    SGXEPCSectionList *section_list, *section;
     g_autoptr(SGXInfo) info = qmp_query_sgx(&err);
 
     if (err) {
@@ -181,8 +249,14 @@ void hmp_info_sgx(Monitor *mon, const QDict *qdict)
                    info->sgx2 ? "enabled" : "disabled");
     monitor_printf(mon, "FLC support: %s\n",
                    info->flc ? "enabled" : "disabled");
-    monitor_printf(mon, "size: %" PRIu64 "\n",
-                   info->section_size);
+
+    section_list = info->sections;
+    for (section = section_list; section; section = section->next) {
+        monitor_printf(mon, "NUMA node #%" PRId64 ": ",
+                       section->value->node);
+        monitor_printf(mon, "size=%" PRIu64 "\n",
+                       section->value->size);
+    }
 }
 
 bool sgx_epc_get_section(int section_nr, uint64_t *addr, uint64_t *size)
@@ -226,6 +300,9 @@ void pc_machine_init_sgx_epc(PCMachineState *pcms)
         /* set the memdev link with memory backend */
         object_property_parse(obj, SGX_EPC_MEMDEV_PROP, list->value->memdev,
                               &error_fatal);
+        /* set the numa node property for sgx epc object */
+        object_property_set_uint(obj, SGX_EPC_NUMA_NODE_PROP, list->value->node,
+                             &error_fatal);
         object_property_set_bool(obj, "realized", true, &error_fatal);
         object_unref(obj);
     }
diff --git a/hw/i386/x86.c b/hw/i386/x86.c
index b84840a..7232247 100644
--- a/hw/i386/x86.c
+++ b/hw/i386/x86.c
@@ -59,6 +59,8 @@
 #include CONFIG_DEVICES
 #include "kvm/kvm_i386.h"
 
+#include "hw/vfio/cni_logger.h"
+
 /* Physical Address of PVH entry point read from kernel ELF NOTE */
 static size_t pvh_start_addr;
 
@@ -758,6 +760,12 @@ static bool load_elfboot(const char *kernel_filename,
     fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);
     fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, elf_kernel_size);
 
+    char msg[256];
+    //sprintf(msg, "pvh_boot: entry-addr:%jx, load_addr:%x, kernel-size:%u", pvh_start_addr, mh_load_addr, elf_kernel_size);
+    sprintf(msg, "pvh_boot: entry-addr:0x%jx, load_addr:0x%x. kernel-size:%u",  pvh_start_addr, mh_load_addr, elf_kernel_size);
+    cni_log_info(msg);
+    //cni_log_info("debug0321");
+
     return true;
 }
 
@@ -783,6 +791,8 @@ void x86_load_linux(X86MachineState *x86ms,
     const char *kernel_cmdline = machine->kernel_cmdline;
     SevKernelLoaderContext sev_load_ctx = {};
 
+    cni_log_info("load_x86_kernel1");
+
     /* Align to 16 bytes as a paranoia measure */
     cmdline_size = (strlen(kernel_cmdline) + 16) & ~15;
 
@@ -803,10 +813,14 @@ void x86_load_linux(X86MachineState *x86ms,
         exit(1);
     }
 
+    cni_log_info("load_x86_kernel2");
+
     /* kernel protocol version */
     if (ldl_p(header + 0x202) == 0x53726448) {
         protocol = lduw_p(header + 0x206);
+        cni_log_info("load_x86_kernel3-1");
     } else {
+        cni_log_info("load_x86_kernel3-2");
         /*
          * This could be a multiboot kernel. If it is, let's stop treating it
          * like a Linux kernel.
@@ -818,6 +832,7 @@ void x86_load_linux(X86MachineState *x86ms,
                            kernel_cmdline, kernel_size, header)) {
             return;
         }
+        cni_log_info("load_x86_kernel3-3");
         /*
          * Check if the file is an uncompressed kernel file (ELF) and load it,
          * saving the PVH entry point used by the x86/HVM direct boot ABI.
@@ -828,6 +843,8 @@ void x86_load_linux(X86MachineState *x86ms,
                          header, pvh_start_addr, fw_cfg)) {
             fclose(f);
 
+            cni_log_info("load_x86_kernel3-4");
+
             fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,
                 strlen(kernel_cmdline) + 1);
             fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, kernel_cmdline);
@@ -838,6 +855,7 @@ void x86_load_linux(X86MachineState *x86ms,
 
             /* load initrd */
             if (initrd_filename) {
+                cni_log_info("load_x86_kernel3-5");
                 GMappedFile *mapped_file;
                 gsize initrd_size;
                 gchar *initrd_data;
@@ -872,12 +890,14 @@ void x86_load_linux(X86MachineState *x86ms,
             option_rom[nb_option_roms].bootindex = 0;
             option_rom[nb_option_roms].name = "pvh.bin";
             nb_option_roms++;
-
+            cni_log_info("load_x86_kernel3-6");
             return;
         }
         protocol = 0;
     }
 
+    cni_log_info("load_x86_kernel4");
+
     if (protocol < 0x200 || !(header[0x211] & 0x01)) {
         /* Low kernel */
         real_addr    = 0x90000;
@@ -1018,6 +1038,8 @@ void x86_load_linux(X86MachineState *x86ms,
         stl_p(header + 0x21c, initrd_size);
     }
 
+    cni_log_info("load_x86_kernel5");
+
     /* load kernel and setup */
     setup_size = header[0x1f1];
     if (setup_size == 0) {
@@ -1082,6 +1104,8 @@ void x86_load_linux(X86MachineState *x86ms,
         memcpy(setup, header, MIN(sizeof(header), setup_size));
     }
 
+    cni_log_info("load_x86_kernel");
+
     fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, prot_addr);
     fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);
     fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA, kernel, kernel_size);
@@ -1140,6 +1164,10 @@ void x86_bios_rom_init(MachineState *ms, const char *default_firmware,
     }
     g_free(filename);
 
+    char msg[128];
+    sprintf(msg, "rom_init:0x%x", bios_size);
+    cni_log_info(msg);
+
     /* map the last 128KB of the BIOS in ISA space */
     isa_bios_size = MIN(bios_size, 128 * KiB);
     isa_bios = g_malloc(sizeof(*isa_bios));
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index c06b30d..06dd93b 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -43,6 +43,8 @@
 #include "hw/acpi/aml-build.h"
 #include "hw/pci/pci_bus.h"
 
+#include "hw/vfio/cni_logger.h"
+
 #define FW_CFG_FILE_SLOTS_DFLT 0x20
 
 /* FW_CFG_VERSION bits */
@@ -352,6 +354,8 @@ static void fw_cfg_dma_transfer(FWCfgState *s)
     FWCfgEntry *e;
     int read = 0, write = 0;
     dma_addr_t dma_addr;
+    // dma_addr_t dma_addr_debug1;
+    // dma_addr_t dma_addr_debug2;
 
     /* Reset the address before the next access */
     dma_addr = s->dma_addr;
@@ -363,6 +367,12 @@ static void fw_cfg_dma_transfer(FWCfgState *s)
         return;
     }
 
+    // char msg[64];
+    // dma_addr_debug1 = dma.address;
+    // dma_addr_debug2 = be64_to_cpu(dma.address);
+    // sprintf(msg, "fw_cfg: dma addr1: 0x%jx,  dma addr2: 0x%jx", (uintmax_t)dma_addr_debug1,  (uintmax_t)dma_addr_debug2);
+    // cni_log_info(msg);
+
     dma.address = be64_to_cpu(dma.address);
     dma.length = be32_to_cpu(dma.length);
     dma.control = be32_to_cpu(dma.control);
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index e5993c1..19fd246 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -50,6 +50,7 @@
 #include "qapi/error.h"
 #include "qapi/qapi-commands-pci.h"
 #include "qemu/cutils.h"
+#include "hw/vfio/cni_logger.h"
 
 //#define DEBUG_PCI
 #ifdef DEBUG_PCI
@@ -114,6 +115,7 @@ static void pcibus_machine_done(Notifier *notifier, void *data)
 
     for (i = 0; i < ARRAY_SIZE(bus->devices); ++i) {
         if (bus->devices[i]) {
+            // cni_log_info("pci_done");
             pci_init_bus_master(bus->devices[i]);
         }
     }
@@ -2748,8 +2750,10 @@ AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
         iommu_bus = parent_bus;
     }
     if (!pci_bus_bypass_iommu(bus) && iommu_bus && iommu_bus->iommu_fn) {
+        // cni_log_info("pci-gen-as-iommu");
         return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, devfn);
     }
+    // cni_log_info("pci-gen-as-global");
     return &address_space_memory;
 }
 
diff --git a/hw/vfio/cni_fastiov_ioctl.c b/hw/vfio/cni_fastiov_ioctl.c
new file mode 100644
index 0000000..3f13ee2
--- /dev/null
+++ b/hw/vfio/cni_fastiov_ioctl.c
@@ -0,0 +1,21 @@
+#include "cni_fastiov_ioctl.h"
+#include "cni_logger.h"
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+static int fastiov_fd = -1;
+
+int get_fastiov_fd(void) 
+{
+    if(fastiov_fd == -1) {
+         fastiov_fd = open(FASTIOV_DEVICE_PATH, O_RDWR);
+         if (fastiov_fd < 0) {
+            cni_log_info("fastiov ioctl: open dev file failed.");
+            fastiov_fd =  -1;
+        }
+    }
+    return fastiov_fd;
+}
\ No newline at end of file
diff --git a/hw/vfio/cni_fastiov_ioctl.h b/hw/vfio/cni_fastiov_ioctl.h
new file mode 100644
index 0000000..7934bb7
--- /dev/null
+++ b/hw/vfio/cni_fastiov_ioctl.h
@@ -0,0 +1,16 @@
+#ifndef CNI_FASTIOV_IOCTL_H
+#define CNI_FASTIOV_IOCTL_H
+
+
+#define FASTIOV_DEVICE_PATH "/dev/dev_fastiov"
+#define FASTIOV_REGISTER_PID 1
+#define FASTIOV_UNREGISTER_PID 0
+
+struct fastiov_user_params{
+    int pid;
+    unsigned long long hva_start;
+};
+
+int get_fastiov_fd(void);
+
+#endif 
\ No newline at end of file
diff --git a/hw/vfio/cni_logger.c b/hw/vfio/cni_logger.c
new file mode 100644
index 0000000..998ccb2
--- /dev/null
+++ b/hw/vfio/cni_logger.c
@@ -0,0 +1,264 @@
+#include "cni_logger.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <semaphore.h>
+#include <curl/curl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <stdarg.h>
+
+
+static CNILogger *logger = NULL;
+
+char *get_time_milliseconds_str(void) {
+    struct timeval tv;
+    gettimeofday(&tv, NULL); // 
+    long long milliseconds = (long long)tv.tv_sec * 1000LL + (long long)tv.tv_usec / 1000LL; // 
+
+    // 
+    // 20641'\0'
+    char *time_str = malloc(21 * sizeof(char));
+    if (time_str == NULL) {
+        perror("Unable to allocate memory for time string");
+        exit(EXIT_FAILURE);
+    }
+
+    // 
+    sprintf(time_str, "%lld", milliseconds);
+
+    return time_str;
+}
+
+char *get_kernel_time_str(void) {
+    static char time_str[64];
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);  // 
+
+    // 
+    snprintf(time_str, sizeof(time_str), "%ld.%06ld", ts.tv_sec, ts.tv_nsec / 1000);
+
+    return time_str;
+}
+
+
+// Function to initialize the logger
+CNILogger *new_cni_logger(LogLevel level, int use_pid_as_name) {
+    CNILogger *logger = (CNILogger *)malloc(sizeof(CNILogger));
+    logger->level = level;
+    pthread_mutex_init(&logger->mutex, NULL);
+
+    char filename[1024];
+    if (use_pid_as_name) {
+        sprintf(filename, "/root/ipu/timeline-kata-qemu/qemu-%d.log", getpid());
+    } else {
+        sprintf(filename, "/root/ipu/timeline-kata-qemu/qemu-%s.log", get_time_milliseconds_str());
+    }
+
+    logger->file = fopen(filename, "a");
+    if (!logger->file) {
+        perror("Error opening log file");
+        free(logger);
+        return NULL;
+    }
+
+    return logger;
+}
+
+// Function to set the logger level
+void set_level(CNILogger *logger, LogLevel level) {
+    if (logger) {
+        logger->level = level;
+    }
+}
+
+// Function to log a message
+void log_msg(CNILogger *logger, LogLevel level, const char *msg) {
+    if (logger && level >= logger->level) {
+        const char *level_str;
+        pid_t pid = getpid();
+        pthread_t tid = syscall(SYS_gettid);
+
+        switch (level) {
+            case DebugLevel: level_str = "DEBUG"; break;
+            case InfoLevel:  level_str = "INFO";  break;
+            case WarnLevel:  level_str = "WARN";  break;
+            case ErrorLevel: level_str = "ERROR"; break;
+            case PanicLevel: level_str = "PANIC"; break;
+            case FatalLevel: level_str = "FATAL"; break;
+            default:         level_str = "UNKNOWN";
+        }
+
+        pthread_mutex_lock(&logger->mutex);
+        fprintf(logger->file, "[%s] [PID: %d] [TID: %lu] %s: %s\n", get_kernel_time_str(), pid, tid, level_str, msg);
+        fflush(logger->file); // Flush the buffer to file
+        pthread_mutex_unlock(&logger->mutex);
+
+        if (level == PanicLevel || level == FatalLevel) {
+            exit(EXIT_FAILURE); // Terminate the program
+        }
+    }
+}
+
+void log_msg2(CNILogger *logger, LogLevel level, bool new_line, const char *format, va_list args) {
+    if (logger && level >= logger->level) {
+        const char *level_str;
+        char buffer[1024];
+        pid_t pid = getpid();
+        pthread_t tid = syscall(SYS_gettid);
+
+        switch (level) {
+            case DebugLevel: level_str = "DEBUG"; break;
+            case InfoLevel:  level_str = "INFO";  break;
+            case WarnLevel:  level_str = "WARN";  break;
+            case ErrorLevel: level_str = "ERROR"; break;
+            case PanicLevel: level_str = "PANIC"; break;
+            case FatalLevel: level_str = "FATAL"; break;
+            default:         level_str = "UNKNOWN";
+        }
+        pthread_mutex_lock(&logger->mutex);
+
+        vsnprintf(buffer, sizeof(buffer), format, args);
+        if (new_line) {
+            fprintf(logger->file, "\n[%s] [PID: %d] [TID: %lu] %s: %s\n", get_kernel_time_str(), pid, tid, level_str, buffer);
+        } else {
+            fprintf(logger->file, "[%s] [PID: %d] [TID: %lu] %s: %s\n", get_kernel_time_str(), pid, tid, level_str, buffer);
+        }
+        fflush(logger->file);
+        pthread_mutex_unlock(&logger->mutex);
+
+        if (level == PanicLevel || level == FatalLevel) {
+            exit(EXIT_FAILURE);
+        }
+    }
+}
+
+// Function to clean up the logger
+void free_cni_logger(CNILogger *logger) {
+    if (logger) {
+        fclose(logger->file);
+        pthread_mutex_destroy(&logger->mutex);
+        free(logger);
+    }
+}
+
+void init_cni_logger(void) {
+     logger = new_cni_logger(InfoLevel, 1);
+}
+
+void cni_log_info(const char *msg) {
+     if (!logger) {
+        init_cni_logger();
+     }
+     log_msg(logger, InfoLevel, msg);
+}
+
+void cni_log_info2(bool new_line, const char *format, ...) {
+    va_list args;
+    va_start(args, format);
+    
+    if (!logger) {
+        init_cni_logger();
+    }
+    log_msg2(logger, InfoLevel, new_line, format, args);
+    va_end(args);
+}
+
+// cni barrier
+
+int cni_obtain_barrier(const char* barrier_name) {
+    CURL *curl;
+    CURLcode res;
+    int ret = 0;
+
+    char url[256] = "http://127.0.0.1:5005";
+    strncat(url, barrier_name, sizeof(url) - strlen(url) - 1);
+
+    curl_global_init(CURL_GLOBAL_DEFAULT);
+
+    curl = curl_easy_init();
+    if (curl) {
+        curl_easy_setopt(curl, CURLOPT_URL, url);
+        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
+
+        res = curl_easy_perform(curl);
+        if(res != CURLE_OK) {
+            fprintf(stderr, "obtain barrier-%s failed: %s\n", barrier_name, curl_easy_strerror(res));
+            char error_info[512];
+            sprintf(error_info, "obtain barrier-%s (%s) failed: %s\n", barrier_name, url, curl_easy_strerror(res));
+            cni_log_info(error_info);
+            ret = 1;
+        }
+
+        curl_easy_cleanup(curl);
+    } else {
+        fprintf(stderr, "CURL initialization failed\n");
+        ret = 2;
+    }
+
+    curl_global_cleanup();
+
+    return ret;
+}
+
+int cni_obtain_barrier_cmd(const char* barrier_name) {
+    int ret = 0;
+
+    debug_log_netns();
+
+    char command[256] = "curl http://127.0.0.1:5005";
+    strncat(command, barrier_name, sizeof(command) - strlen(command) - 1);
+    ret = system(command);
+    if (ret == -1) {
+        char error_info[512];
+        sprintf(error_info, "obtain barrier-%s (%s) failed: %s\n", barrier_name, command, "command execution failed");
+        cni_log_info(error_info);
+    }
+
+    return ret;
+}
+
+int debug_log_netns(void) {
+    char link_target[PATH_MAX];
+    ssize_t len;
+
+    len = readlink(QEMU_NS_PATH, link_target, sizeof(link_target) - 1);
+    if (len == -1) {
+        return -1;
+    }
+
+    link_target[len] = '\0';
+
+    char debug_info[8192];
+    sprintf(debug_info, "Current network namespace name for barrier test: %s\n", link_target);
+    cni_log_info(debug_info);
+
+    return 0;
+}
+
+int cni_obtain_barrier_sem(const char* barrier_name) {
+    sem_t *sem = sem_open(barrier_name, O_CREAT, 0644, 0);
+    if (sem == SEM_FAILED) {
+        return 1;
+    }
+
+    if (sem_post(sem) == -1) {
+        return 2;
+    }
+
+    int sval;
+    do {
+        if (sem_getvalue(sem, &sval) == -1) {
+            return 3;
+        }
+    } while (sval < CNI_SEM_COUNT);
+
+    if (sem_close(sem) == -1) {
+        return 4;
+    }
+
+    return 0;
+}
diff --git a/hw/vfio/cni_logger.h b/hw/vfio/cni_logger.h
new file mode 100644
index 0000000..3353277
--- /dev/null
+++ b/hw/vfio/cni_logger.h
@@ -0,0 +1,75 @@
+#ifndef CNI_LOGGER_H
+#define CNI_LOGGER_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <stdbool.h>
+
+
+// Log levels
+typedef enum {
+    DebugLevel,
+    InfoLevel,
+    WarnLevel,
+    ErrorLevel,
+    PanicLevel,
+    FatalLevel
+} LogLevel;
+
+// Logger structure
+typedef struct {
+    LogLevel level;
+    FILE *file;
+    pthread_mutex_t mutex;
+} CNILogger;
+
+char *get_time_milliseconds_str(void);
+char *get_kernel_time_str(void);
+
+// Function to initialize the logger
+CNILogger *new_cni_logger(LogLevel level, int use_pid_as_name);
+
+// Function to set the logger level
+void set_level(CNILogger *logger, LogLevel level);
+
+// Function to log a message
+void log_msg(CNILogger *logger, LogLevel level, const char *msg);
+
+void log_msg2(CNILogger *logger, LogLevel level, bool new_line, const char *format, va_list args);
+
+// Function to clean up the logger
+void free_cni_logger(CNILogger *logger);
+
+void init_cni_logger(void);
+
+void cni_log_info(const char *msg);
+
+void cni_log_info2(bool new_line, const char *format, ...);
+
+// Example usage
+// int main() {
+//     CNILogger *logger = new_cni_logger(InfoLevel, "cnicmp-%s.log", 1);
+//     if (!logger) {
+//         return EXIT_FAILURE;
+//     }
+
+//     log_msg(logger, InfoLevel, "This is an info message.");
+
+//     free_cni_logger(logger);
+//     return EXIT_SUCCESS;
+// }
+
+#define QEMU_NS_PATH "/proc/self/ns/net"
+#define CNI_BARRIER_INDEX 0
+#define CNI_SEM_COUNT 40
+int cni_obtain_barrier(const char *barrier_name);
+int cni_obtain_barrier_cmd(const char* barrier_name);
+int cni_obtain_barrier_sem(const char* barrier_name);
+int debug_log_netns(void);
+
+#endif 
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index 080046e..4cdff93 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -40,6 +40,10 @@
 #include "trace.h"
 #include "qapi/error.h"
 #include "migration/migration.h"
+#include "cni_logger.h"
+#include <inttypes.h>
+#include <string.h>
+
 
 VFIOGroupList vfio_group_list =
     QLIST_HEAD_INITIALIZER(vfio_group_list);
@@ -493,6 +497,9 @@ static int vfio_dma_unmap(VFIOContainer *container,
 static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
                         ram_addr_t size, void *vaddr, bool readonly)
 {
+    // unsigned long size_kb = int128_get64(size) / 1024;
+    // unsigned long size_mb = size_kb / 1024;
+
     struct vfio_iommu_type1_dma_map map = {
         .argsz = sizeof(map),
         .flags = VFIO_DMA_MAP_FLAG_READ,
@@ -510,9 +517,30 @@ static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
      * again.  This shouldn't be necessary, but we sometimes see it in
      * the VGA ROM space.
      */
-    if (ioctl(container->fd, VFIO_IOMMU_MAP_DMA, &map) == 0 ||
-        (errno == EBUSY && vfio_dma_unmap(container, iova, size, NULL) == 0 &&
-         ioctl(container->fd, VFIO_IOMMU_MAP_DMA, &map) == 0)) {
+    // if (ioctl(container->fd, VFIO_IOMMU_MAP_DMA, &map) == 0 ||
+    //     (errno == EBUSY && vfio_dma_unmap(container, iova, size, NULL) == 0 &&
+    //      ioctl(container->fd, VFIO_IOMMU_MAP_DMA, &map) == 0)) {
+    //     return 0;
+    // }
+
+    /*
+        Fisrt attempt
+    */
+    if (ioctl(container->fd, VFIO_IOMMU_MAP_DMA, &map) == 0) {
+        // char debug_info[512];
+        // sprintf(debug_info, "ioctl VFIO_IOMMU_MAP_DMA from vfio_dma_map first: iova=0x%010" HWADDR_PRIx ", size_mb=%lu MB, size_kb=%lu KB, hva=%p [debug mark]", iova, size_mb, size_kb, vaddr);
+        // cni_log_info(debug_info);
+        return 0;
+    }
+
+    /*
+        Second attempt
+    */
+    if (errno == EBUSY && vfio_dma_unmap(container, iova, size, NULL) == 0 &&
+         ioctl(container->fd, VFIO_IOMMU_MAP_DMA, &map) == 0) {
+        // char debug_info[512];
+        // sprintf(debug_info, "ioctl VFIO_IOMMU_MAP_DMA from vfio_dma_map first: iova=0x%010" HWADDR_PRIx ", size_mb=%lu MB, size_kb=%lu KB, hva=%p [debug mark]", iova, size_mb, size_kb, vaddr);
+        // cni_log_info(debug_info);
         return 0;
     }
 
@@ -861,6 +889,29 @@ static void vfio_unregister_ram_discard_listener(VFIOContainer *container,
     g_free(vrdl);
 }
 
+static bool debug_log_memory_region_section_detail(MemoryRegionSection *section) {
+    // char debug_info[512];
+    // uint64_t mem_size = int128_get64(section->size) / 1024 / 1024;
+    // hwaddr start_addr = section->offset_within_address_space;
+    // hwaddr end_addr = start_addr + mem_size - 1;
+
+    const char *type = section->mr ? section->mr->name : "unknown";
+    // sprintf(debug_info, "Memory Region Section Type: %s, Start: 0x%010" HWADDR_PRIx ", End: 0x%010" HWADDR_PRIx ", Size: %lu MB", type, start_addr, end_addr, mem_size);
+    // cni_log_info(debug_info);
+
+    if (strcmp(type, "dimm1") || strcmp(type, "mem0")) {
+        return true;
+    }
+    return false;
+}
+
+static bool vfio_listener_region_add_skip_mem0(MemoryRegionSection *section) {
+    if (section && section->mr && strcmp(section->mr->name, "mem0") == 0) {
+        return true;
+    }
+    return false;
+}
+
 static void vfio_listener_region_add(MemoryListener *listener,
                                      MemoryRegionSection *section)
 {
@@ -881,6 +932,13 @@ static void vfio_listener_region_add(MemoryListener *listener,
         return;
     }
 
+    if (vfio_listener_region_add_skip_mem0(section)) {
+        return;
+    }
+
+    bool do_sec_log = debug_log_memory_region_section_detail(section);
+    do_sec_log = true;
+
     if (unlikely((section->offset_within_address_space &
                   ~qemu_real_host_page_mask) !=
                  (section->offset_within_region & ~qemu_real_host_page_mask))) {
@@ -977,9 +1035,15 @@ static void vfio_listener_region_add(MemoryListener *listener,
         goto fail;
     }
 
+    // cni_log_info("vfio-mem-ref");
+
     memory_region_ref(section->mr);
 
+    // cni_log_info("vfio-mem-iommu");
+
     if (memory_region_is_iommu(section->mr)) {
+        // cni_log_info("-mem-iommu-int");
+
         VFIOGuestIOMMU *giommu;
         IOMMUMemoryRegion *iommu_mr = IOMMU_MEMORY_REGION(section->mr);
         int iommu_idx;
@@ -1001,12 +1065,16 @@ static void vfio_listener_region_add(MemoryListener *listener,
         llend = int128_sub(llend, int128_one());
         iommu_idx = memory_region_iommu_attrs_to_index(iommu_mr,
                                                        MEMTXATTRS_UNSPECIFIED);
+        // cni_log_info("vfio-mem-iommu-map");
+
         iommu_notifier_init(&giommu->n, vfio_iommu_map_notify,
                             IOMMU_NOTIFIER_IOTLB_EVENTS,
                             section->offset_within_region,
                             int128_get64(llend),
                             iommu_idx);
 
+        // cni_log_info("vfio-mem-iommu-pagesize");
+
         ret = memory_region_iommu_set_page_size_mask(giommu->iommu,
                                                      container->pgsizes,
                                                      &err);
@@ -1015,6 +1083,8 @@ static void vfio_listener_region_add(MemoryListener *listener,
             goto fail;
         }
 
+        // cni_log_info("vfio-mem-iommu-reg");
+
         ret = memory_region_register_iommu_notifier(section->mr, &giommu->n,
                                                     &err);
         if (ret) {
@@ -1024,8 +1094,11 @@ static void vfio_listener_region_add(MemoryListener *listener,
         QLIST_INSERT_HEAD(&container->giommu_list, giommu, giommu_next);
         memory_region_iommu_replay(giommu->iommu, &giommu->n);
 
+        // cni_log_info("vfio-mem-iommu-ok");
         return;
     }
+    
+    // cni_log_info("vfio-mem-ram-discard");
 
     /* Here we assume that memory_region_is_ram(section->mr)==true */
 
@@ -1039,6 +1112,12 @@ static void vfio_listener_region_add(MemoryListener *listener,
         return;
     }
 
+    if (do_sec_log) {
+        char debug_info[512];
+        sprintf(debug_info, "vfio-mem-ram-init-%s", section->mr->name);
+        cni_log_info(debug_info);
+    }
+
     vaddr = memory_region_get_ram_ptr(section->mr) +
             section->offset_within_region +
             (iova - section->offset_within_address_space);
@@ -1060,6 +1139,17 @@ static void vfio_listener_region_add(MemoryListener *listener,
         }
     }
 
+    if (do_sec_log) {
+        char debug_info[512];
+        sprintf(debug_info, "vfio-mem-ram-map-%s", section->mr->name);
+        cni_log_info(debug_info);
+    }
+    if (do_sec_log) {
+        char debug_info[512];
+        sprintf(debug_info, "vfio-mem-ram-map-%s-cmd: iova=0x%010" HWADDR_PRIx ", size_mb=%lu MB, size_kb=%lu KB, hva=%p [debug mark]", section->mr->name, iova, int128_get64(llsize) / 1024 / 1024, int128_get64(llsize) / 1024, vaddr);
+        cni_log_info(debug_info);
+    }
+
     ret = vfio_dma_map(container, iova, int128_get64(llsize),
                        vaddr, section->readonly);
     if (ret) {
@@ -1074,6 +1164,11 @@ static void vfio_listener_region_add(MemoryListener *listener,
         goto fail;
     }
 
+    if (do_sec_log) {
+        char debug_info[512];
+        sprintf(debug_info, "vfio-mem-ram-ok-%s", section->mr->name);
+        cni_log_info(debug_info);
+    }
     return;
 
 fail:
@@ -1984,6 +2079,8 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
     int ret, fd;
     VFIOAddressSpace *space;
 
+    cni_log_info("vfio-cont-init");
+
     space = vfio_get_address_space(as);
 
     /*
@@ -2037,6 +2134,8 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
         }
     }
 
+    cni_log_info("vfio-cont-create");
+
     fd = qemu_open_old("/dev/vfio/vfio", O_RDWR);
     if (fd < 0) {
         error_setg_errno(errp, errno, "failed to open /dev/vfio/vfio");
@@ -2073,6 +2172,8 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
         goto free_container_exit;
     }
 
+    cni_log_info("vfio-cont-iommu");
+
     switch (container->iommu_type) {
     case VFIO_TYPE1v2_IOMMU:
     case VFIO_TYPE1_IOMMU:
@@ -2173,6 +2274,8 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
     }
     }
 
+    cni_log_info("vfio-cont-group");
+
     vfio_kvm_device_add_group(group);
 
     QLIST_INIT(&container->group_list);
@@ -2181,11 +2284,17 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
     group->container = container;
     QLIST_INSERT_HEAD(&container->group_list, group, container_next);
 
+    cni_log_info("vfio-cont-listener");
+
     container->listener = vfio_memory_listener;
 
     memory_listener_register(&container->listener, container->space->as);
 
+    cni_log_info("vfio-cont-listener-error0");
+
     if (container->error) {
+        cni_log_info("vfio-cont-listener-error");
+
         ret = -1;
         error_propagate_prepend(errp, container->error,
             "memory listener initialization failed: ");
@@ -2194,6 +2303,8 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
 
     container->initialized = true;
 
+    cni_log_info("vfio-cont-ok");
+
     return 0;
 listener_release_exit:
     QLIST_REMOVE(group, container_next);
@@ -2271,6 +2382,8 @@ VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
     char path[32];
     struct vfio_group_status status = { .argsz = sizeof(status) };
 
+    cni_log_info("vfio-group-get-search");
+
     QLIST_FOREACH(group, &vfio_group_list, next) {
         if (group->groupid == groupid) {
             /* Found it.  Now is it already in the right context? */
@@ -2284,6 +2397,8 @@ VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
         }
     }
 
+    cni_log_info("vfio-group-get-open");
+
     group = g_malloc0(sizeof(*group));
 
     snprintf(path, sizeof(path), "/dev/vfio/%d", groupid);
@@ -2293,6 +2408,8 @@ VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
         goto free_group_exit;
     }
 
+    cni_log_info("vfio-group-get-status");
+
     if (ioctl(group->fd, VFIO_GROUP_GET_STATUS, &status)) {
         error_setg_errno(errp, errno, "failed to get group %d status", groupid);
         goto close_fd_exit;
@@ -2306,15 +2423,21 @@ VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
         goto close_fd_exit;
     }
 
+    cni_log_info("vfio-group-get-init");
+
     group->groupid = groupid;
     QLIST_INIT(&group->device_list);
 
+    cni_log_info("vfio-group-get-connect");
+
     if (vfio_connect_container(group, as, errp)) {
         error_prepend(errp, "failed to setup container for group %d: ",
                       groupid);
         goto close_fd_exit;
     }
 
+    cni_log_info("vfio-group-get-insert");
+
     if (QLIST_EMPTY(&vfio_group_list)) {
         qemu_register_reset(vfio_reset_handler, NULL);
     }
diff --git a/hw/vfio/meson.build b/hw/vfio/meson.build
index da9af29..5e4e25b 100644
--- a/hw/vfio/meson.build
+++ b/hw/vfio/meson.build
@@ -8,6 +8,8 @@ vfio_ss.add(when: 'CONFIG_VFIO_PCI', if_true: files(
   'display.c',
   'pci-quirks.c',
   'pci.c',
+  'cni_logger.c',
+  'cni_fastiov_ioctl.c',
 ))
 vfio_ss.add(when: 'CONFIG_VFIO_CCW', if_true: files('ccw.c'))
 vfio_ss.add(when: 'CONFIG_VFIO_PLATFORM', if_true: files('platform.c'))
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 7b45353..fd82e5e 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -42,6 +42,7 @@
 #include "qapi/error.h"
 #include "migration/blocker.h"
 #include "migration/qemu-file.h"
+#include "cni_logger.h"
 
 #define TYPE_VFIO_PCI_NOHOTPLUG "vfio-pci-nohotplug"
 
@@ -2799,6 +2800,9 @@ static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
 
 static void vfio_realize(PCIDevice *pdev, Error **errp)
 {
+    cni_log_info("realize-start");
+
+    cni_log_info("vfio-init");
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
     VFIODevice *vbasedev_iter;
     VFIOGroup *group;
@@ -2853,12 +2857,17 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         goto error;
     }
 
+    cni_log_info("vfio-group");
+    cni_log_info("vfio-group-gettt");
+
     trace_vfio_realize(vdev->vbasedev.name, groupid);
 
     group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
     if (!group) {
+        cni_log_info("vfio-group-gettt-error");
         goto error;
     }
+    cni_log_info("vfio-group-put");
 
     QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
         if (strcmp(vbasedev_iter->name, vdev->vbasedev.name) == 0) {
@@ -2868,6 +2877,7 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         }
     }
 
+    cni_log_info("vfio-mdev");
     /*
      * Mediated devices *might* operate compatibly with discarding of RAM, but
      * we cannot know for certain, it depends on whether the mdev vendor driver
@@ -2889,6 +2899,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         goto error;
     }
 
+    cni_log_info("vfio-getdev");
+
     ret = vfio_get_device(group, vdev->vbasedev.name, &vdev->vbasedev, errp);
     if (ret) {
         vfio_put_group(group);
@@ -2901,6 +2913,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         goto error;
     }
 
+    cni_log_info("vfio-config");
+
     /* Get a copy of config space */
     ret = pread(vdev->vbasedev.fd, vdev->pdev.config,
                 MIN(pci_config_size(&vdev->pdev), vdev->config_size),
@@ -2978,6 +2992,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         vdev->pdev.config[PCI_HEADER_TYPE] &= ~PCI_HEADER_TYPE_MULTI_FUNCTION;
     }
 
+    cni_log_info("vfio-bars");
+
     /*
      * Clear host resource mapping info.  If we choose not to register a
      * BAR, such as might be the case with the option ROM, we can get
@@ -2998,6 +3014,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     vfio_bars_register(vdev);
 
+    cni_log_info("vfio-func");
+
     ret = vfio_add_capabilities(vdev, errp);
     if (ret) {
         goto out_teardown;
@@ -3083,6 +3101,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         }
     }
 
+    cni_log_info("vfio-special");
+
     if (vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID)) {
         ret = vfio_pci_nvidia_v100_ram_init(vdev, errp);
         if (ret && ret != -ENODEV) {
@@ -3108,6 +3128,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
     vfio_register_req_notifier(vdev);
     vfio_setup_resetfn_quirk(vdev);
 
+    cni_log_info("realize-end");
+
     return;
 
 out_deregister:
diff --git a/hw/virtio/vhost-user.c b/hw/virtio/vhost-user.c
index bf6e502..867ae79 100644
--- a/hw/virtio/vhost-user.c
+++ b/hw/virtio/vhost-user.c
@@ -32,6 +32,8 @@
 
 #include "standard-headers/linux/vhost_types.h"
 
+#include "hw/vfio/cni_logger.h"
+
 #ifdef CONFIG_LINUX
 #include <linux/userfaultfd.h>
 #endif
@@ -576,6 +578,11 @@ static int vhost_user_fill_set_mem_table_msg(struct vhost_user *u,
         reg = dev->mem->regions + i;
 
         mr = vhost_user_get_mr_data(reg->userspace_addr, &offset, &fd);
+
+        char dbinfo[64];
+        sprintf(dbinfo, "vhost mem register: size-%lu  GPA-0x%lx HVA-0x%lx", reg->memory_size, reg->guest_phys_addr, reg->userspace_addr);
+        cni_log_info(dbinfo);
+
         if (fd > 0) {
             if (track_ramblocks) {
                 assert(*fd_num < VHOST_MEMORY_BASELINE_NREGIONS);
@@ -1056,11 +1063,23 @@ static int vhost_user_set_mem_table(struct vhost_dev *dev,
         virtio_has_feature(dev->protocol_features,
                            VHOST_USER_PROTOCOL_F_CONFIGURE_MEM_SLOTS);
 
+    char dbInfo[256];
+    for (int i = 0; i < mem->nregions; i++) {
+        struct vhost_memory_region *region = &mem->regions[i];
+        sprintf(dbInfo, "Region %d: GPA=0x%" PRIx64 ", Size=%" PRIu64 " bytes\n",
+            i, region->guest_phys_addr, region->memory_size);
+        cni_log_info(dbInfo);
+    }
+
+
+    //cni_log_info("vhost_user_set_mem_table");
+
     if (do_postcopy) {
         /*
          * Postcopy has enough differences that it's best done in it's own
          * version
          */
+        //cni_log_info("vhost_user_set_mem_table1");
         return vhost_user_set_mem_table_postcopy(dev, mem, reply_supported,
                                                  config_mem_slots);
     }
@@ -1074,11 +1093,13 @@ static int vhost_user_set_mem_table(struct vhost_dev *dev,
     }
 
     if (config_mem_slots) {
+        //cni_log_info("vhost_user_set_mem_table2");
         if (vhost_user_add_remove_regions(dev, &msg, reply_supported,
                                           false) < 0) {
             return -1;
         }
     } else {
+        //cni_log_info("vhost_user_set_mem_table3");
         if (vhost_user_fill_set_mem_table_msg(u, dev, &msg, fds, &fd_num,
                                               false) < 0) {
             return -1;
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 750aa47..4100005 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -39,6 +39,8 @@
 #include "qapi/visitor.h"
 #include "sysemu/replay.h"
 
+#include "hw/vfio/cni_logger.h"
+
 #define VIRTIO_PCI_REGION_SIZE(dev)     VIRTIO_PCI_CONFIG_OFF(msix_present(dev))
 
 #undef VIRTIO_PCI_CONFIG
@@ -1125,6 +1127,7 @@ static bool virtio_pci_iommu_enabled(DeviceState *d)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
     PCIDevice *dev = &proxy->pci_dev;
+    //cni_log_info("virtio_pci_iommu");
     AddressSpace *dma_as = pci_device_iommu_address_space(dev);
 
     if (dma_as == &address_space_memory) {
diff --git a/imgs/qemu_trace-detail-cost-kata200-barrier.png b/imgs/qemu_trace-detail-cost-kata200-barrier.png
new file mode 100644
index 0000000000000000000000000000000000000000..fbed1a73f8c2951806e1c8a3488c854d1b887509
GIT binary patch
literal 36172
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
VQfj+9-!Q$XzV7-}X)Emf{}06qVdDS*

literal 0
HcmV?d00001

diff --git a/imgs/qemu_trace-detail-cost-kata400-barrier.png b/imgs/qemu_trace-detail-cost-kata400-barrier.png
new file mode 100644
index 0000000000000000000000000000000000000000..590523f7b81efe5abd8b6d1b23f9b4ff47760bfa
GIT binary patch
literal 35646
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
KM!veu$^QbR`fd9F

literal 0
HcmV?d00001

diff --git a/include/hw/i386/sgx-epc.h b/include/hw/i386/sgx-epc.h
index a6a65be..581fac3 100644
--- a/include/hw/i386/sgx-epc.h
+++ b/include/hw/i386/sgx-epc.h
@@ -25,6 +25,7 @@
 #define SGX_EPC_ADDR_PROP "addr"
 #define SGX_EPC_SIZE_PROP "size"
 #define SGX_EPC_MEMDEV_PROP "memdev"
+#define SGX_EPC_NUMA_NODE_PROP "node"
 
 /**
  * SGXEPCDevice:
@@ -38,6 +39,7 @@ typedef struct SGXEPCDevice {
 
     /* public */
     uint64_t addr;
+    uint32_t node;
     HostMemoryBackendEpc *hostmem;
 } SGXEPCDevice;
 
@@ -56,6 +58,7 @@ typedef struct SGXEPCState {
 } SGXEPCState;
 
 bool sgx_epc_get_section(int section_nr, uint64_t *addr, uint64_t *size);
+void sgx_epc_build_srat(GArray *table_data);
 
 static inline uint64_t sgx_epc_above_4g_end(SGXEPCState *sgx_epc)
 {
diff --git a/kata.cfg b/kata.cfg
new file mode 100644
index 0000000..4d8faf1
--- /dev/null
+++ b/kata.cfg
@@ -0,0 +1 @@
+--disable-live-block-migration --disable-brlapi --disable-docs --disable-curses --disable-gtk --disable-opengl --disable-sdl --disable-spice --disable-vte --disable-vnc --disable-vnc-jpeg --disable-vnc-png --disable-vnc-sasl --disable-auth-pam --disable-glusterfs --disable-libiscsi --disable-libnfs --disable-libssh --disable-bzip2 --disable-lzo --disable-snappy --disable-tpm --disable-slirp --disable-libusb --disable-usb-redir --disable-tcg --disable-debug-tcg --disable-tcg-interpreter --disable-qom-cast-debug --disable-libudev --disable-rdma --disable-tools --enable-virtfs --disable-bsd-user --disable-linux-user --disable-sparse --disable-vde --disable-xfsctl --disable-libxml2 --disable-nettle --disable-xen --disable-linux-aio --disable-capstone --disable-virglrenderer --disable-replication --disable-smartcard --disable-guest-agent --disable-guest-agent-msi --disable-vvfat --disable-vdi --disable-qed --disable-qcow1 --disable-bochs --disable-cloop --disable-dmg --disable-parallels --enable-kvm --enable-vhost-net --enable-rbd --enable-virtfs --enable-attr --enable-cap-ng --enable-seccomp --enable-avx2 --enable-avx512f --enable-libpmem --enable-malloc-trim --target-list=x86_64-softmmu --enable-pie --extra-cflags=" -O2 -fno-semantic-interposition -falign-functions=32 -D_FORTIFY_SOURCE=2" --extra-ldflags=" -z noexecstack -z relro -z now" --prefix=/usr --libdir=/usr/lib/kata-qemu --libexecdir=/usr/libexec/kata-qemu --datadir=/usr/share/kata-qemu 
diff --git a/monitor/hmp-cmds.c b/monitor/hmp-cmds.c
index 9c91bf9..2669156 100644
--- a/monitor/hmp-cmds.c
+++ b/monitor/hmp-cmds.c
@@ -1810,6 +1810,7 @@ void hmp_info_memory_devices(Monitor *mon, const QDict *qdict)
                                se->id ? se->id : "");
                 monitor_printf(mon, "  memaddr: 0x%" PRIx64 "\n", se->memaddr);
                 monitor_printf(mon, "  size: %" PRIu64 "\n", se->size);
+                monitor_printf(mon, "  node: %" PRId64 "\n", se->node);
                 monitor_printf(mon, "  memdev: %s\n", se->memdev);
                 break;
             default:
diff --git a/qapi/machine.json b/qapi/machine.json
index 067e3f5..16e771a 100644
--- a/qapi/machine.json
+++ b/qapi/machine.json
@@ -1207,12 +1207,15 @@
 #
 # @memdev: memory backend linked with device
 #
+# @node: the numa node
+#
 # Since: 6.2
 ##
 { 'struct': 'SgxEPCDeviceInfo',
   'data': { '*id': 'str',
             'memaddr': 'size',
             'size': 'size',
+            'node': 'int',
             'memdev': 'str'
           }
 }
@@ -1285,10 +1288,15 @@
 #
 # @memdev: memory backend linked with device
 #
+# @node: the numa node
+#
 # Since: 6.2
 ##
 { 'struct': 'SgxEPC',
-  'data': { 'memdev': 'str' } }
+  'data': { 'memdev': 'str',
+            'node': 'int'
+          }
+}
 
 ##
 # @SgxEPCProperties:
diff --git a/qapi/misc-target.json b/qapi/misc-target.json
index 5aa2b95..1022aa0 100644
--- a/qapi/misc-target.json
+++ b/qapi/misc-target.json
@@ -337,6 +337,21 @@
   'if': 'TARGET_ARM' }
 
 
+##
+# @SGXEPCSection:
+#
+# Information about intel SGX EPC section info
+#
+# @node: the numa node
+#
+# @size: the size of epc section
+#
+# Since: 6.2
+##
+{ 'struct': 'SGXEPCSection',
+  'data': { 'node': 'int',
+            'size': 'uint64'}}
+
 ##
 # @SGXInfo:
 #
@@ -350,7 +365,7 @@
 #
 # @flc: true if FLC is supported
 #
-# @section-size: The EPC section size for guest
+# @sections: The EPC sections info for guest
 #
 # Since: 6.2
 ##
@@ -359,7 +374,7 @@
             'sgx1': 'bool',
             'sgx2': 'bool',
             'flc': 'bool',
-            'section-size': 'uint64'},
+            'sections': ['SGXEPCSection']},
    'if': 'TARGET_I386' }
 
 ##
diff --git a/qemu-options.hx b/qemu-options.hx
index ae2c6db..489b58e 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -127,11 +127,11 @@ SRST
 ERST
 
 DEF("M", HAS_ARG, QEMU_OPTION_M,
-    "                sgx-epc.0.memdev=memid\n",
+    "                sgx-epc.0.memdev=memid,sgx-epc.0.node=numaid\n",
     QEMU_ARCH_ALL)
 
 SRST
-``sgx-epc.0.memdev=@var{memid}``
+``sgx-epc.0.memdev=@var{memid},sgx-epc.0.node=@var{numaid}``
     Define an SGX EPC section.
 ERST
 
diff --git a/scripts/qapi/__pycache__/__init__.cpython-36.pyc b/scripts/qapi/__pycache__/__init__.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..67c36fc2651e157e5b19d49e1d57ffdb9ff13ad6
GIT binary patch
literal 126
zcmXr!<>h*B)0fHs1dl-k3@`#24nSPY0whuxf*CX!{Z=v*frJsnFKzw&f)f4Af>Qm$
z)Z9|t?8K5p{o>@J%z~0){ldh8O#S%y%)HE!_;|g7%3B;Zx%nxjIjMFaLyCcz0RZfd
B9QXhL

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/commands.cpython-36.pyc b/scripts/qapi/__pycache__/commands.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..1bcc770c89994a223a8044f29d68723ad5ea4d1b
GIT binary patch
literal 7889
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

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/common.cpython-36.pyc b/scripts/qapi/__pycache__/common.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..21e64badf1acc3e7f0303db11b8af397077e1dcd
GIT binary patch
literal 7688
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

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/error.cpython-36.pyc b/scripts/qapi/__pycache__/error.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..6acd0dec9df8a1c0bef5a5969ae8a6f4c0c006c2
GIT binary patch
literal 1593
zcmah}O>f*b5G5t9R+4u&Zd1fHkfOW<h=6n#{Qv?4X<;V_id;4>a@z}|id;u)eVLSi
zda=FK0dngv$REfxKZn<za_YUO&QRXOc3YGJhaxp2&3p4k-;T%epAUam$$*eQ$fd#H
z{s5*q0wc+SNGiR8mfpgnMEa5ye#sV$k{^j2$lw)`ff}6qivadR8NxnP0qlpck7Nw{
zSPfwx%AMyV8Li*NKOG)D<x1;X^Q=gXQ6`Qb*JW8(S5J9ol;rJ8U3bSX>#l`c#hWxc
zNsrZ(^Ft}~Hm|F+=)(*z)3f+z#id&26-4G0uOUS9vX)(;492v)(aNZ*y~kf*9!IG*
z>IvrZg6HN^Xx!ivJ#EgW@q1u`B-Dn_n*M|DX@4-mS3IvfovEkQvd++NJJ96-rr8Cf
z$btfwo}>$3dccEkBaC%lUVrx}HLB-=FM*Y`07$=N%6-l7rLIed-4VAXV4g4=3Q?t{
z62itp^eEweB*bZ#78g&3LdZH3;w{lJWa7+UcV~6e&hn<4ovO0?>LhK`naOnCv}Sgi
zHu=nz2f%BP2iZp$9+;52{S}<(fWtfja|LIlm>TR86~H>&2kpG^Uy~)3Ob%X+7oZXu
zyrE7rY!SUCj4WbcCbl;|vfA_Wy<7g9pj<*h^W|Ay9rKhMR}Ws)S&G$~&Vg)}LwT%U
znq%u{b&;XSao~!;e3*uVX~{WR(Q`t{hHi-PHXc}i<AY_AKzekZ4D7&kjnYVeUgfP2
zdJLg@g60Mos0=fzSYAJ-HWI=~9zt9(b}-}<FkiwnAsE798o;&w{2B|>?Z-fffmUs&
zs|+=UV+-Li+?zR=4Ov0&o<wHS(%)zcAXem@{tA#*KA!6XJXrxG@c9OPHdMN&x5#}0
ze$exK_?E#Qg7)WY|G^!z_8#ygaH#C$5E@q_!LB&gH?4NyEi0h=92tqHKZRth54HFx
zK8>I)$PyxixQi)|zz{m2F<iT_uJ`^4-gzVaJ30VwJw$_y=?D!{ps}3#78vX2RqKe=
zC|*0h;5}1CvE?2MkWhUSV_Y3Di!Wdre1Aw8<AKJrD{}w8wjR06RoN@|&UNJ)Ri>cT
zjHBDde+v}K{uR@Qe!V1?+mO)Lm?Q#*e#HGei5v+wXwMpG0!M}o`bKc1*yzdjf8sjW
g;c~H;>heL6HhkFsOn$)f89Zm+$Q${)Z1=Oj0jcVEHUIzs

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/events.cpython-36.pyc b/scripts/qapi/__pycache__/events.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ffbb9ec529f152aaa59254700569bea93f9a4e73
GIT binary patch
literal 6106
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
LNou2ZiQfMKd3XxO

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/expr.cpython-36.pyc b/scripts/qapi/__pycache__/expr.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..2a19f236aa50f886ad9472d8e0ddc9029a499f73
GIT binary patch
literal 19505
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
U;J%MfRwpMWPfQ-0oSK~cU%k<er2qf`

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/gen.cpython-36.pyc b/scripts/qapi/__pycache__/gen.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..6ee28b3bb81bd20469b40b8fd09a8d0633df0961
GIT binary patch
literal 11025
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

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/introspect.cpython-36.pyc b/scripts/qapi/__pycache__/introspect.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..da028047b0161406b454ea3ef9403eee23cb04e1
GIT binary patch
literal 12142
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
Un+0>OsOj^sfq{QZ`*ueEKh+L{L;wH)

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/main.cpython-36.pyc b/scripts/qapi/__pycache__/main.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..77fc0117efc3e06938aacfe414d15021ee8eaef5
GIT binary patch
literal 2844
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

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/parser.cpython-36.pyc b/scripts/qapi/__pycache__/parser.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..0b41c8ec6e6b56e53e37cbc0c59c9000e2d83122
GIT binary patch
literal 21330
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

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/schema.cpython-36.pyc b/scripts/qapi/__pycache__/schema.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..edb32b9933f6d0afcf551e427f148eb512c32b2d
GIT binary patch
literal 38730
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

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/source.cpython-36.pyc b/scripts/qapi/__pycache__/source.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..eccfb9b90886701503e47c3f14da7a30254b66bd
GIT binary patch
literal 2175
zcmZ`)UvC>l5Z~QfpB=|>OqwQ5S`~wc%1IC-0Rlx)RaB`c5(-7FK)RRJ^>&?}@trSw
zXDPAVr&PSb7ijnZe5HNmsZYH3iJ3XuByO;^vpYNc=Qs14+52*Bt@+R4AEwt}>~D7E
z=fU_9wBitiW||LKh`ku{RD>e+LNAq}<m`K<JuP1|EiXh^1Ffcg(0tH*&7ZNL{uWMP
z$ARbM4@ptF#*cZKjIwCx>d((}^K)clTrmGFF5ZP1!$PiEC^XmNlG8;p^yt`{>-_ZH
z)1zncOOr-VZFG`G#{qY~HRaf5F`u1>y@2)@T5%7A=2NEF2?NPV3X+~?fK?nn31ryP
zqgYvUI!>(7;dVSq(<sv_i&CS^S!@V@;dbYS>dNAZE!;{?`oh@dJpfP^X4wCW*%iR@
zF6fQ&vX|uJ-l<8)pZ^+_QLl(?l9xsAG|H1+F&f+0?C0mMp;VG3rBa*d3D5<8`ShRc
zEC*tLzBZ7!kAN%JR4N_m@z5ycT1uUcqhV#St8f?rx+0o5R|C<3R$vGllJskANtl0x
z3w{GJXUhOXm@2=EP@0<YHQRwCxfELJ+G`osVGfc+*DpQY&?_+0Fw#ifgcYm01^Nou
z*MRS~UI(o?(>nSC&{k*KhQ0+_Yo=}L+n}v!A4uGCZ3+m5?kMYz9Dfdhue}(JGaU$5
z>!aJw&m(KHGRB0%ANGq(`3jUNWeVjBp9;tqF%|aSR1CaKmhu8K2(kubjU>298T1xY
zE~wiL=$srTnX$KU=;xHA6hpV7O+QnqDWlmCAqAdAUTG)oS*8Pd`WRZ#0>QYCf3YEa
zKH0wR@gf1J?C2VaH&`F`-Rv>aTzO2s0)gNSKMsW528+D|VvcVIC$K!1@VQ1|N`;<%
z2F3z&13|tAZoUf6CVvUkykL<6q~b9&D%g?@AjlW|6`yj+23+%RfF}hSh1+610IM<{
z<>&S`DRiup32?s*aV0Znr9xJ|zzgtd#+$s&CwG=YxL6qQDr|Fv*e?(w%Tqx3h8~sy
zf5ZOt2-iD)0REx50>vv|vFs~MSYXZ@j^eLjKn2G5WMc^gn6Eu$7*mSOeHh@qb{7+L
zfDKY~!1~@65T^xT@Qx>)z2cyIly&!t?t{JJ!9mj@iO6Mz45<b8h=nC&^&}%Izl9~$
zb3^$Cf!bQaI9s^DiLqG}(mp5}xdUvk#Myl)p-(jw(tuyEEl9X+1~!4V)7CGb6K?wv
z?3(NX@P0Bh-6V^LV{LS|Z$~Nka?pgxVoljDh*?%T51!$hs>Zcu`&Ay5FCW5=S@}qE
zr~~Xz?!M;|-AFqYej)D*zc7aA6Fvjz%Qp4`d+-3t#<QQm3X9cRq5PjHD^-+MsVA^*
zo&(GAoh=F47R%nQp=hJPWUyGb&VxfN#=UyV@8SqEgs!eY5S%@n`;TZE(L=uuh7X|?
zcwB?G#Ab6tc4}>}?YA2it?;7Z=hOM+d7fk^79&wzNigtBLF;Zh-Zc)ZFV92tfQqic
IH@)`yzlmtP9smFU

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/types.cpython-36.pyc b/scripts/qapi/__pycache__/types.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..8e8a5889006bc2d9f417f0aa8c066e6f02b9ed96
GIT binary patch
literal 9289
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
V5`v2hGlk`XQ&=qQ7!U?S|37fTSZV+O

literal 0
HcmV?d00001

diff --git a/scripts/qapi/__pycache__/visit.cpython-36.pyc b/scripts/qapi/__pycache__/visit.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..438ea7311fb3f9831931728f57e0f4ccc109fade
GIT binary patch
literal 10531
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

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/__pycache__/__init__.cpython-36.pyc b/scripts/tracetool/__pycache__/__init__.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..28f61f2086dc0638640be6d92dbfc6c35152ebd9
GIT binary patch
literal 14367
zcmcIrO>i4WcAgmwehE?(^>1tKi7Z)!OhK~j*c(NWEK9VltW0So*;>QWB180$1PB69
z&p<y2xSKMaN-C*xIhP!g)Fy`<lB&&CQd^a5YV)(Ht>m2Z9CFFYhg2>(`I3C!>%jnI
zD6ckE0g0ZT{_oeX-}~O{#%t5lrT@I}S@4IyVp;!gO?(a@{uaLBmk5+qvy@%4l~Z$6
zrj}7|%~jc2R^?Q_ovY>KnXl#LS*R7{S*(@hIh8!icotOgQ>!+uN@@zv8CCZ8sA+#T
z$hY?Tb81HILFzs=tM=l#U(Km~YQH+54yr@yusWiiQ_riT>TBu+^`i3BFQ{YcC3Re#
zP%p0@s2xxz)jVn)eAiMHb?Q?~o!WA0hw%1_TEN>vaCj?IJEBgjDoQ<v^fT%#($5CZ
zBmJoQMfIvW_o-d`ntDUMrd~(v1(m;TRo)z2EWPhH)|#C_Kk-(&+FK0}^`mBI)r+*>
z!1J^Y+I|!$ui1$Ly%DG;-n^A&I|!?#{s|E9db|JAzX-h#n{B_-edv1^9wxE3{6@9k
zYg7Z(zt}&Il2^LDC%U=17J28+zIyI7f;ShuXR1DU?cJN#y@!Dgo869g&cjgW{m6UL
z?Q5^wi;!6H{LT}PL)D{lgFUySV8!ov@A<7xw=rlA_JxwL=D(!_wdP0FMt9>249r?;
zFyzO^H-qoH_=e9Rh^&^~a+KZ546Q9&*@qC?mU2M9%;5REx(RalUKm7Pcf|{|#?aaz
zXjqNy(o)5ZGvSjk&V`XeUR-*_@{%9Bt!}eZvE!_~{<)<K=<Un1XE2{L&0hb^gJ7e7
zdfkuwGhstFdr^3XOA<ugZu?BV-t07^dcE3v5>H8|b!qu9N9`c699=@VZCXs1X&po)
zvWC`Ym~AAJo0!t^r%wqaR$lP98CAa^nU*RU=|q!WvCE8#t@C)1shFV1ysQlID59Z@
zz;X(<p2ky8AsFN?bh@43VuNk+Gg^Wxh=+3shL(?U4zW$Q9N$qENbfAwoJUb56PLUF
zs7`k5_!~j&c6&i5E=XE;xdrMLMtM8OB!yV~Wp-nR<=UG4rBq`ozc*Oq9)eYC(|LSx
zXkE4Lzp<GC4Z#o>KuhHuVmyPmji-CT8agd!m>Jp!g<V+UP0Zp!>8=%JS`aX;?9c%_
zWfOMFVNQAfk1_Qf<i}Kc{U~9nQpv;Tqi)}8fUWys;H^LM^=jz(`1iuKu8!8YM%>C9
zey_)U{Lt4;e;M1=d$bmGn6=?Yvcvs$TiT1(0xyg-3WwO`+q$}gtdpcBd9>3#Y5Mb;
z=&m1i(NMF2R-SmiQV<bQ*VDmDJ7`26+idi;4m#KuG6m_1iy<9&o&LshpsQZmLnnB=
zTQ}{nyIWt<+M{N)COxrk(#=y^A92CcW+3gES){Edq#sqSN}0GcCWo+ZZ4VPBMz3eU
zD4LsXsgl$C_`;MphXn~bO3yMS%OHoK;>wPRb7m#uoar^T+dCOHgPd1TBV+?s*|ke{
z!7k%FW0xJxogZf)q-$=w+gYt;g&ShGvF7X8U53!875bg9x!MU-EjN0i{MYMIE#DtS
z@O<?Rq!gGUu{<KLof{=dj7e|2K1yONb{}?|((WK&dtum=NRiF-B8{{n9;&&rf~b4v
z%DWHK?M~@Ia>#bSg~-rqajV;#_T#sQHn!UNO-IBO^fNY1X44rWw(jVK2eXK|h`qsB
zlv&T~*$A6!XmQ(pVn3L@3;m9*m0SAK_6E+qQ?XUcHoBcK8vO9GUhQv?Kcgo-aQTVw
zB>B42jXbb)_fep#-i;1;JB+ZUe674IQWC7s9oBpdhUY9rF|I=Eu$hpXu-{hRa=`70
zCa|&kjcCE^cc7#eq;40RLwis?y>{@}>p=@pY3;18f=1hin&RF*N$Ps1PFAvUHte;V
zQS9gdnx(%SPhY-%{l?wJtMxk{-CVpKmp=5{{a}%52*S}dLUFkng>eSqPL`T}=(n2+
zI<wB+zYW@l`w>`RtrFO(U^~gzb@fT4r-G4%xNdLZ8%78M3kb>rg0g|2usXmYuEI*-
znGFO(eTo$UiZUpvkf5ZZDywOfDJA%5D#1r(;v=L_6C>d{L!5-?9%3atXVr69)#u~l
zXc5D~(Zz>cOo&5S)zDLc(VL)qwIMnY<K&<z(S_MABC-m0t6PuH38S4Nqk)l}Ek~as
z8$#(jEs@|4%JS|~YTMR>G8oII9vTcqEKn}r^fh!4)-p_!PN$zVN#ynU^pzE_H$y=W
z^IU}mkBe6EqCVIoB+^Oe=s~4HxB_^w7C%emh&r2$OU<wezV<tfK+j`haSlR}@`fu)
zUI>HsO6*G648onfP#9r~9?FLV4^}=Wj4<mA=F%}#N5#_pyG>nF(nX@ITOiaHNn{V^
zuIPZM(f2yRBQSpNNfppR2I;mjcU?g(K!*i9b`HyB@$Vobfi;7f@lcqR4uc{jUD?m@
z0$puC{*93^ff&&g94&hbI(+Da^O2)4#80r^B23Obm{nNa^_;$kQZNHlcFVcvY-Tpy
zA>Q7!HZwz4YP%f>8<fb6OGGF`z8Koj>nOKkxCG)S$_)(}@`E3|-ETrPP<*6wfb=kH
z=B?=N2J%t{PE>N$=zK2rGxJv+B=yd-fs|2L|F-D(WM3=`#)p;;wr`s;Z+&Sm462J8
zy$I@kBr4|><PcCdVZ<sRFEl<;h{&gtmnxbNFSbvKVqB`^^^1JZVj#_)eu?p%7WpO8
zL^xB}ppvcS(FeyJXLJziD$3RhOyZWPm6{5BySdT?jwDJpfq|CGB<d$f3|~NC6<vE4
zLd(S$;tN2NZzX3Iu{nFNCnbDU>ZNjl@`18J<N^^Pv0VhbsSigEcnC=D2;{(RDkq8G
zHj2dt#Mh@#9<yvWldWg?8Tv`mn;jKA-Z|{4dL8tGEwE9qe-Fh%VgbtC8E0@{JjjVs
zDWh}0akw&6?o&c}Fs9jS$FD&EakF({EeSZ<CRKWVQ-{@x6T9eJf7QmLJV23p{ZG-w
zX!C8C1CsrW<J!L@fR9EJmeq)8jw1u){#C=s*Xt-zum9P^DE3YgNOHFgB3(z)e?%N*
z118MTY*QJSbE29^wyRiGl1>Q%AH14ulCa;5h?)gT8&%8=v(oQ0Xl+i+L32HX@dwU=
zmkxx3ph&unuW%+6&HaNADE1~ym=@S;=&V9a{GRi`rIgfPLrFXY6lP+ldN#JB*zWA$
zoG(ikC^Cs2F8&qUCM)Eu!HG$lU?0IYywL6forf0@8P%Z425*QZ6gOS%E_Ok7Y2^Ft
zLU_}ev0Z1djr39?o$)q3P)0pvllWUOfkaWBT?E?b3sF&#)YL%_n;knFb_8fjt0h_k
z1~Y1|I<Z^lkDUmQRbb9#Q1vOA0u0Lr>-8UU%p{AoLvfkxZ39j>5<#_s6X;WJCfIkf
zoic+%Bi%e=TG7s7HEo3JOtmBHOjRrETsG@Gbj<3G*AVo-ghH`h*T?Z3XJ|?@{WgNX
z#dox-FO64~s36>JO+k*Y(4SeU_cx<9L6Qj>D0%5rwh5MJrib9xXQfBN?c-^W=#gbJ
zb^Q*BuwB9nP5yo~esKB(O-$dr@cGZ6iPZb?sLky(k-VRaCJVds2yAq?o5U&x;BOj)
zznxI2fS}$K#@Rm-5EKt9&OvJ=9tOGj6Jg~<DAY-)rr#sEp2kQ2G@2i1c6`i7W>h~v
zBjrrRe;l<6s?F|fH6<G-#;>@WE+8U~ld9QT_m3yA3ScY(kZJ)ut-x*aJ?Aqkg-!t2
zk+?_%LH^`c5cM_0t{}*?+cA1FM!WVqAsrl~I`|1dIR!xUGe{a;99RzspRnH+Kgcf4
z!SJF3G;PgqG`g@}JF97XKt8EEu9_Ad#{{^H!4y0J+@u0|;$m7;qNbPHOxlXnO@L7X
zA|y}0!6u%%=+}|^Q+y40&k+dihl60SFP-3ccuSSNF$5+BK)oK9>h+DT>bDs$*Xs}Z
zemlv59#Gu|B<mS={VIaE48RJ%4=kOvuF`KZoz7j&W!5yQ^c4n+47mRK8iQYDz!6St
zZ`tS~_vVqYfv<R6f!>_LOu;Q5E#wL={_+wcCNycFT>7DEdJEt1_Yq7Qp@G}V65rQy
zL0$=(r^9|Vi<APK>_t_A8@#BdR2k-EDVS2zYDP@dvf86&kv1(Y>_z#R#2DS9_QUWz
z5X>I3YI}oObr8=vbqG%V!*J*yft&tCy7AHOLAvtM#vxSz`+9L!Y*T*&64qF$leVeh
z(aRBZ;&ML<jPaP-ji-g<xEebUJsH|ycV-$+TiJ-7TFN;7QmcXnK~KZ~siP*$Ojrv+
zG*9K4a`?@0E<hW%jC5yu^67OvKel7iTH|4%NCNXD(|8b32kwq-rJ0eq14nza*`d#q
zj<;l9iGO#O$@P5t0I?Y{zR7CR#h^7mf9d80&NICD@x4d)!uzjO?uD;ZE-{&OyLj&r
zQlu28bn)YFSMHyx+(V&L^Ow%c|IG^^Yh5<r#bec1DhriMk}K(wA_;L`HAAACI1@Ei
z2So&@rP83lXz(~_z)RNX^_LoAT!UZf{U&zcehL2$0fauB5knXpbsJ`+Rd<Fi!VJty
zFfL+Qn3Fk)<%b2l7luWI#i%rNc{Z``>YLG&a*W#<rY%^1y`Wd3a%-AM3}t6JxnZ8q
zXpgZP5Y8U9HcM!ugf?8X@ds!F=U=V8OfjCcXb$C^D7WQ=KSD{wQ8vHMw|$?$@eMXF
z_&)-gN|*N8tkp4NPYPEur`afD-X1Y5*^YRYmIU}U?T`5h%RWg!TAG*ci-o6FHQn`q
zOGPJa+b#29Wh}{`%K03CX=MlJGh<ioX9oAnGwc8s9XX<R?1E7%PumI1=ckLKH&iu4
z1k_%_p-W037Px@|&5qwriYx~p!h{+WkbY)#LI|f?S~;K#!R(N)?BHE<x=8Iz-HO9H
z!2Z)w6S7U3@aB(Us~j82r6&_qH(hWOJ!20n+W*<@r*rs%n{x0=hC1R5UW4OxLnweV
z6&$BLZf^89JP6E<W<*>!T4gx2`kiP=?7+dn4?63e?xW6V4v?+qy%Ql#!!KxSRQ3yA
zi%VnK8)v|t`ZO~25d?A0@QS|5l)X%unjmmo8k549axbw+{!!qs<M4&<la*S5Yt5yE
zy%a=H=^tLce(h@g=B*nyZ;RDuToyBz!;td7+c6H~DdT}7pp3I3G<A)Gkg<Kt7>84H
z*}A^R_xpUG?wdK+O%>7VW7SUJ@E`bwFC(yy<ZSat4>Mv;nXVc*XJ(w7GYhoh!tXqo
zk!9H3)yQ=cfq51YW8E7M4aFOvq}9r{a$B_GAm&;Sk_aIrTcxd{K*`;lkyD!Hn?cfS
zR)54`Ja^(Aof2R?_1!H|fk`hw*C&Sa9DvxMWTqr8%M6<1hek4wOJzE&V9uH;so`wQ
zK%N)F!%+ruoJWR`xNt?fDs#lz%;M=D!BpYQ%psmdS{~0Fo`qq)1*il0d|*8jE)NUI
z+rjmWZbf-j6sKpt1t0vDt%pdNVoFpT7Eq@Q`Tsd|OMcba%txix6k468>ua;9W`;Sq
zM}L4Cdssuw%KJay9WV*+b9m3|I4TeG(e##6wh+&&eQ91!|JNuFvAo(Z{aVB9kUFVI
zlV>ZpS;Cos-JaQ;8cwzLv}UP;Hldrac!&Hvh&1w|CSq!b12qLW>CS#OMZ`__6u;?p
z0u+PTwtG#-63}c}h^9$!Lzyad%~>bG%_Kr$Ha}k>)^8@@X18ifn*L71vkk_`u5mHN
zDg)=lhWKFz*M;?xlV2QkZOB0vg!^(6$F?|>>iJ=40G?c5;9+tH=lnQmYBb^F<*kEM
z+6^-II>!d*wl%rYhdSoL8IBt~vBbnqBT+n_Kl%;&8nJXnluTlyqt`le1~rnGPrQ>U
za5_0gPJ`!nFGneVQh$J!2fr+bbpcfoj=Fg=%$81$8|IPun*R_Q?NN6`4C9Cj2XD%J
zcCRP1drHMG{u>`1p#REVks+~LzjA9a&f;jiv8I=0Nmg~Y-&4&-WZdEI3OvHb8(sjx
zLXOo)a#}&gpgP4E6@XZU=F&%%;8B0b#66-viBak@;YztyAhpTBV>uPu8*xrL4|lMM
zR&1YQ9al3*G5rlD?2z0v?T%B7y^e@AU50cnK~nR`xnLiK)W!jHMh>8nYX0`)IftCN
z49Yo!DIsg(YUld%Lp4a>fJnXf5E%(^INSF_P~+UUb68QB!yR{o;v4w#h(%|}Ch#e)
zP5>FVfOiq%q_>3wmK9fgjJd(j?_<oJ2p6EB4R^|Qlmjy8d0+sf)9Hf8$%=8$=0$ND
z%^>=j_NUPn)S5!ligEm#LOV!Gqxb`ol;>m?lwZL)EK1LvP<qBqIXFCj;^TYjUiJPd
z*eJsj)l-*l-nw@0_A8at%R-7$mk1?2M8=dXTj88&4p2&{G&&!+B+e=vfsZazg}tC5
zCo6LKgJx6;Yy=H&-zrr&GK4urIf||nCU@)ayniRoleKYrzPnyTwp>05If2l{cr6EK
zGSh}hlDq-kAdR4YVxG{y64pv}+}&CW8te6X&8=fg4-VGv+`4>a5k;0RzrR=s>sN2z
zxqN4F@U<PuZ(qLhjm4#_qwE7at1W)GxO8XR2@uC5#N=Y)9*+g%X@*L96YeRn8c%}Y
zu-byB_>aJjP)W`bmYbz(t_;RCQlRwB#rHoj{Yh?|?c?%?{tDKJGk&kxC1J=?7WPrj
z9uy5}kdv-CcMq9LJZoHu(VAmuID$l&K%k)wZ(0h1ws_yq9#psa(WG@FD^r02V0$?=
z+$+VO0gS|<lLDjB^xns?b_x@gjK-Xw!vuMQ#l_!XkC|pVhDv5>X{ll_RSxSVHpS~#
z`X+;KGVl<@d7gm4EudGJ^lJ=!2C1J)^D2pvrs9g~@U_R_0fO4xc!laqH?F+5c;y?l
znTa%9QK?PIyWy_dK6%;BQ#G^B!bmz~+fVgy5n%o+z9E^VFy}g@{G5XWzq5s0`PD)h
zf;DT-EJ+dMW`*)8cT!&PYMOB8_d!QGR6n;L{|T3$_u{TvpWF98PaLZP*^~po_j&~3
znYsg9nC(`0@xdHUvcbgwl@OzP>A~ESxd^Bk&IXjl1)J<$tFz={z1B<m2R0z4Z4J)h
zS`D2NxfZU%LL6rxj`PDj9Jfq?GvGHNtZ@r2SI>W9-L*clR9@vbbKl8*%j!7avQ%N1
zZ503y{{?5~MY=O^i((FGB|zB1u;5y)DOG$E+MzxrZ-A$(w!E`unSBlm^)lvNe0)Bd
z2CRh(qczi--Lir7v#mU7aQ_8Rpakex8cwZ)KKkIWh~5ApZP4ezK{%E74grAC66>(<
z@~|v@PbGcxt)R-=`o`Jsuv|yUR({+oQs{&!11L`qr|&t#Y#sBd@5B7|52wxi?!uXa
zjW;v+w~_5DILqAeN)EgNZ?y>>?9CeqxZo}OjdcQp3V>NtCqC>QD0YW`a0N$ZK%az?
zDeg79d&1K==};T{UDEPP^fB@dD*=INO7e`z;042x+r_k;Tt<;H0yO2$+u%j$P1S`<
z@qYtCaddoXzciQ=d(*=W-V@>Z6N(nHDBvZ5a<!cCB~0K%Tyi1Q8v{avxemm|0N`2<
zyaiEdLKRrh#C5&61W&b&48RftPn^|a&5D7?<2o_c3_KD5of+V&g6v{KqFM=Zpnk6Y
z-i_OL#Q8k7{q!ryuguh3(!Q2mAw_ZLM)0R#uo!n+aGQFABeH`UZ{D1h>a`N0p_yYX
z=Zn~@Wqq-##h@<Ynv4N<JEUklg^M)GWQE_QG$nqrrd^vTf>6wX`Rq6jKp36>2krft
z5`Y-*2*S8_C|ejS@jFVj=LqVY8ApEyZ8g~7=z|`txA2uKhm+oQbNxA<xih+vEDJjD
z79TePxsENo&AXv6EV`p><w2FVC3X|(W0)i{ITQFUI{q=|NUcn5p_$UiAmE3o#A_lE
zDeIqnow5*jHZ0uVf=pbsw_KRf0Flt*FGC7uR^;?QLJSU703u!{WEv!07Lx9|jjPAF
z+MT^^L0)m+=KR0J0Pf&&JSNfH=;3}Xwt+b+k$XJ61H(HzBj>%j#e)md#;O0+n-=ZJ
z0Sq?oq$BfvIf)S$rZF(t`b5En<i@*iZtv2B9BtigLrKoL%xEWCQn(Y3lP~mYZq84%
zb2Z80K|S2*#_K<x+<03*rUQ0I2b01=;)#rs_+^o0r~*3(Za*CU<2EwDrn#b$P!x_d
zb9K^?nm#rdl!T;7fv$1)8p*?}apSSckj*S(T(0RshWe{G&sw_kPQ`f#H*tB$W!l9d
zSAMnKUB=xAhzhwQfrJ33TCkq3f|KH@YqHkHE9TY;=w23}R!rBTR+eZ&%s6L8xO2aj
zBK;)k^(SOys&Q+tgRMz>X+Jij{w<_51oI(6?oVx_zs3u%B($M`c`Xrs5L`{<Q!cX{
zk1`5~58k1iV0@&97m$WaY>Cev7toWkH<1pN`-%Pd_%H)Cc@(NU*UG^%fS)M*5V`Qc
zBzI;%gwkSO9?BjUAvdYqopynKCP^>WOZ3>FL=mc*edB5*&MflSQf~6gh`j&LnC}0t
z&NHGGY)rKzOvbIStB#tKL6l5VS}f!3TW_?F$Z`<N{QZk3#iWAK&pUSO4Rb#~$)gf5
zOgK{FJI9xlPqHTuD&Sl4A!%ep<n3+#`P+dRk^KCln$)f;4l<~|eQoLTt&dE<@WCzz
z@WckVq5OYo3qInv7jNELeCOJ?OoK)-4`xO)gqsIG<-uIy^i9k|adIE%bW`x+jqFM_
z*f%Pg44Y*u)5hh%?Pi=G6z*}(^uoKVSky4iCsk_syPDVMb?vZBnLmQrK?VF$OR{P?
zLyp?i#8l!!a&8e+3i{XCQ&!eh|2E@=q!)+-vj}l{l8k1gzr&G^^^~Zn-(_v?YY!1?
zKmFKL!cfID?V)DNP_#2hg}2+$EDeJZ79+kdiY-H-gkMtNhZ_(|)Ac&t!*H&z;io;6
zV!Tn<33)0%gA;lm&P9BACoeA6>j4tlIGJbP@)I2WZN%c)F@X#*W%%*laq@_!`^HI#
znOg|v2R+klavuW<Ecx{kAglT10<94FwShjy*hvQSQp$*BV=)p+#Kja2i0T$mCsdfA
zqfnH@j0+cx482GJ7;-MI02T@1Pr@H4iN6f41K@Upi_?Qbw(z_I(DMv`PA*f}Gt-#;
Ou64F>VK!TO{(k^X9V0~m

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/__pycache__/transform.cpython-36.pyc b/scripts/tracetool/__pycache__/transform.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..103497340295dc81b876de1ba98833f98c9a7545
GIT binary patch
literal 3441
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
O<8Jj>I=trD>i+@-R(u)&

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/__pycache__/vcpu.cpython-36.pyc b/scripts/tracetool/__pycache__/vcpu.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..77bfa3e75140484c5fdb678e464c3fef65eb1058
GIT binary patch
literal 1884
zcma)7&2Aev5Z*uit!&w?+otJ>2%0!5WT{Qi9s(z@5hUp$NR2uO3ZcM)UQ!b6UGA3T
z%8?*nlJ=TM=)H$NMc-ntJ>}GUPMzUOa$2}RSKx3s9L@~qo1yM*ZiavDzu}Fh<NWEo
z_j$k{z|i|Zm@{;kJ9L>h^q4>NSuhM(ZCGP<)=27UW7tTW!=~%7CTsod3|lN@ZJ0y0
zaqM(A=l$>rmt2XMq*T%|Pq{Q?lqq5+oa|2Hyx1kV%5tvEtRIHOO>p@%DgO9flNTbP
zGMiGeKV5PMH0~F9+~=%#P<#!V53_ux#CT%JoiD%orbqtQ$@$$UM^DL=D=jif?hpv(
zHZ^3H6^dlJ0b!R=IU@-*T&?uxTgQfvs3hOgQ<=qcG2hWvFrf#Evk5i*I7{C`OitG;
zTZd{~;8k@Q8a0bVnrF(yE^fnz2@YU9grQ#oVeY~?b<XO_Fwb%g{i$(Zxy)a#ZsE#!
zEQGZ`_FjX2<g@zn6l0AGcY!tn*1YaqbC!Gy`7v0G0=a#u1N$IZH~>(4e(+pTsR5Cc
z@F{|0G6FZrlNmV|W^xry<hB?AXk3GOw_gT`;=E<z@t#3j^Cq(VC6C|Lr<q{ni?S9)
zpi}y=F>l=f_WsSB+)$X0w@A94s==h{$k)nnSrLNkvU8|46bGR4NU2OI%v~8!HP)p+
zN)05tX5&^Hu<@ItIxxNK4FJf2$cw>GJT3OlsG$QLE0G&LfEZ(LvMd>3-2Hr3ZrQLg
z1(7wi119t*KpZdhJ8s9@c0)ICH{6drq-q;>VvGYn3>jnp4u(Df0$92h%O4Ch%>oc$
z{%h|??;^OUEdu?y@m{%$n(pCj{6!740|qVii+9}_xeM=CZ{fc|8z5r=N)hj4!1OdY
zb{LFqojwNlYv8m62~tv(93rR-0Z2lN>72)6BsjySOQA}`kihpGwkiQhGgc&=q=hyF
z>NHulXdz=vdex&5=6knC&L<+C5XECIrrf%<*6^5!!Q*8NlrivmGP|mNdeC01a;Uf|
zl(gZ}lZ0Dqmqs8$dwvYw<P{fK#V9n%Bou5+lcc(7Rm=K6OL&=vBdTc1q0P1Re1HAf
z<uXC{h&IX!FmsP>8dq79aJ+B#s^+;z9$^z%3FfRv&dzaOA3vf{&I}>4k6(0IdZ@O$
zjO%-wmVX3gEgY^eUfV+;*EYZ~SgER@M}&-%f(bdcIh2{)TjP{Tu9vP9K1A~mz(&;-
z{p!~J;SRRPzv6qQ;J*SoRJCAIK9Ud#HiK#d>DJ47Wk7ANWM#d|LFr{@WiSHJY?D@G
z3$)74`UbYpZh=f=lR4Kyw+X%1gx_cGho1TvWY4<ovJpiri=(Ivqlgw}k}2Rf;gMPW
zAHcF5MNpJnY7UD|6s1&11B0V(D~dP>5@gp`udZQlh2E{V_d>;&McH_p`&H9Cz~;A+
P2JkY#52?THH+TL9DeoB)

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/backend/__pycache__/__init__.cpython-36.pyc b/scripts/tracetool/backend/__pycache__/__init__.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..4b62ce7b5dffa52d8fd6284ff5c5570bd2ffa645
GIT binary patch
literal 4529
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

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/backend/__pycache__/dtrace.cpython-36.pyc b/scripts/tracetool/backend/__pycache__/dtrace.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ef52fee4931ce310c58e0da8d76b5c7dc2e2c043
GIT binary patch
literal 1821
zcmb7ETW{Mo6s9hgWhYM3rAX6sz=&i9BA~I?6xe_*C~|YR44IeZw$123C?XTfktLO)
zf?9B1=DlYBV-Nck`xkoM)1LOerybIE;-D?CQ4sm@@OHlM9P)XkQvQ46SGHb6=ub3J
zbikYNC$FHQsD-H3(x~3jsnIg1*)nONRiG9v23EJ&Dr$(@Et{5FC0eFazo1qb@D!b<
z6~NPUhR#A;p>y;Bv@`SrIuGqEEgd1}VfLiFd(2&r)sK3KVBO=b1AOLsmn@{Ua$1G+
z_k;A0-xGZ52W}W$xp?Dhgf?BTmd0L<(ey?7In3ON;vV-e+5)eC@@#z#s?VO{|Fk@N
z{^h|wzG6J_qY$s-h~rgP;9it+9K`~R4tB#H4qU<bcwRPpB-ptd;;-CJ7<rkW%>x54
zwB1e4XxkMvFY5jUjv+_OjVKkzO;7g5MasMbfASD20YYEed`@Uo8)!dk0)aewGg|~F
za5qf^PME+4hu>~D4h|bH_kM8nd}^YbmrvawWev_F{u|;2*iu#hd|C$vbw5t)uUR);
zyL5$HPdx6&BB=|hyojQpKGM8Sm8ll@@~N0dXDsII+<)^(dTBw0G#fq+34{JWmHB&A
zw)dJ_hd%-fYlyfBo8I|7MDonsI`c!9_dWtV=|o97AvKgmE|y*?Jp%xJ(D72|GgQCU
zLz^0XZ2?{Dpt3p8G^uuB)LNsq*w+^zkq5dOElKN}<v!X)KP_DwFdtHzT79FVb@TzE
z(>JDuUVr^PL=ECpY33%6B9YB2`PPOiu1Qm^ojtf`tR`SuT=CCC%Fgl8?lCzzYLL^d
z!@aHDy`5}n1<ZcP-WtKrGHV5{g@2w^R{YQlQp)ghHCfJ4_Gl%2_ioGMbG~bQb3&@C
zX&f^ix?ScZq|w~k-f!$?&iKUl&slY_;3<PNF5T^5a4CLn%I)%kvO8vOu`3peBrja>
zD2;Qg&0NZOuCa;Gs;JIgu#j=MP^3-H*o7a;%bt7)l}s{Aw=J1!wyv;Q)=W)@kI%#S
zZPcX$GSgMmKL!AC()wr=BfVn)Hamp@8fetGG2o$+(K4G^6+?NO?`n0`<rk7r;v~)&
znf??zI-iD(bNhC{QoMNutb9fenVrZFa}y>2?criQFDM=OoSb!g8M$I!zGJ=#!=s!w
z<;8jo{d??WUMqGB0PeH9flO6=jQ8>x#~9+*@8egFrnor6$lWmjj*GDUJDq)e=PVgL
z5`-oK;`S1jB+@?wvEfV5I&*oE5E^-e<YhwKRJ0=wxI&0Gew(2?MM&U#EKC@5W(euJ
zekkB)a&Czb28KYw+vjPRY1YBX_Ws@uH{dAs1aVs;`3|VGQ0gg1CKOlNE7|RhZbZ|7
by^toAXr^w0>#8=U4bw0o>Ev%ev8{grSOC7u

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/backend/__pycache__/log.cpython-36.pyc b/scripts/tracetool/backend/__pycache__/log.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..c658b793d7a5cc862afbb83bd2530be4f7036459
GIT binary patch
literal 2037
zcma)7TW=dh6yBTH&gN#)HlYQ<$k9e#aO{$xf|4i-1XPf$P?460Ri)8pXKb&t-d$#9
zUA)9k=C%DFJn$>{7yHTs;)!>jIJ3UgjVi=ib31d+ocX?U=J;@Z-TM3F75%fUD1RtR
zp9b?YX#6Yah~g?lbycFd8qr;y7_LD|Zi$$r9GZi&TUHfPaVunnSidOl3Rxv<Fj{1t
zY{0lmHZK*Ynmw>C1)+?gt27A3eh{H6&%dS-X<DfbZrWk``)?fm5QJV74?T1;oXyTW
zznLa}lall_Jp#@1I2o~^+Y{*E;U@?C(0$fG|I0i(eEg)1hLrIjj?e*$8LE2%jpCG{
zI1wOpkQa?m=n2Z^dfDcspdBwl-+28f_Ol?n!wW&rJ7bjeJkj*y!C!DO#ZhxTPQ_DS
z5-2}88qm(6@hWrzs3bt+L<iCoAjY`JKHLo=KTHWlwIAsqZG~}nzZ0{4!91Tfd$sI?
zTMED;Y%`j~Ou&8)ewp;-Xt_y;G!i^7by=JyzbecG`9Fs(K-UVAv?U$vUwgu9ai0Z=
z;H|=oh~uy|i-+{zOh$RNOC!pF3Eab1v>QbCBnWw)q8h5EvI@)=NF~a5p%qA9!Gx%N
z<wohNeQlyl)UhUXxtaj_YlH0(^+wxK#=rzfjcb!VBF0#cwg{vZNJ@QkqU<Q!%2*d=
zQYJ-m$;6ULMK(#5yaTH(81Im~H}Z@Mv=wOy&FZg`dlT?LwqI_~c;30lv<6}-+$=YS
zev;;fU@6V+7x-~O8}3qpxd6y@n>)Gr^!qQ)zsA|82)>|$>UQ0aBjRwhw}&K=7?=vd
zGQ<OqU)S5;J;sHJ<Dj22TUyCaS`H}ZUYFt*f#_ioz*2aFM5;}7W<7^1`2tCWp%)??
z#V?Mty=4`+q1=r-#2eN3q(TE-JZra|<Lu+zFo-C!>r*Up5ycKcwYj7dgf#L7)Zw-4
zbotOZmU_*$$(e0uY16hJKFZP~yFN8QH8{635P-e*JgPOakCyEh^Wq>$qUbT|5gd@Z
z(|FU@LbuL?jAG$P3{5e_ocaxPTbP10+g;c!PwcwKy7G41;efs|M-T50NAxFwmkE%<
zW%$+kNn=DqP9YA*bBP?62zfgJx16ucjmKF@PRF@wIc9FibaB^~<Kb>hSM$r{hJ=vo
zz-?Yx09wn9ejG%(0TOu21<G89=;c<z;)F60P|h}FE|<~-*2VMB%_-!(GC!SdN)?kq
zUImF`<fXznD}j{BYQ)xMC!h4RgZ}{~w_d;d_h8LGhfYze>V{g;EX~xmH2M1f`)5Ff
zFjPxr@`Oc=c%vFVfSqYIgcn;>i5-RLFSXZo@kmnn*5`@I2sjCRd^M6eHc#*X-ll_Y
zZqReK3a2}&TbZ&A8+t)e!5Q0@n;Mfhm~wH8f%~r+z_X%=Nl_P0!Gz0FCrcoEAI1x3
zEiYqCVjtt&!q`hiFJ>@b$Jn3$QNeN*LqhsA;uIDe7%D~(320R6u3$_-5X$MI9?xR>
x<k^?)Z_kTjTd-MpU5Z(8_abnWlR-?<ke<r;^1IL(5Gwe|USHD<y<%2&{{^6|Alm={

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/format/__pycache__/__init__.cpython-36.pyc b/scripts/tracetool/format/__pycache__/__init__.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..90e149e7d745007053ad25cb332d3ecf6bb322c9
GIT binary patch
literal 2359
zcmb_dO^@3|81~qS<9I)4mqJ-oU_h$Uh)ot+B&4cTEnC_is;Z*W7DYnVtY?xq>v-Im
z@oqQrURaKZ|G@!%0}}tjS57@~?}=xeWV=v=5b9X-&g*yH`FP&1xwf_z{&C|+F=#u^
z@6MU#g1?2X?|^V;;BYb^+#R^w8+g1iXz=Es$$j2R{efSPtwD<iy#2j12zba>Ft+(B
zU&9#k)?=r;&VIqB;a#bw%+M*z*hox8X8K_m?kK@bl8tC44(YJg&|&W%S{U9wqeC+`
z6`Xd4Qug+k>d;s!C3G$`uBnmq(UBR;j7}vlQW18HVzDq%rrYx)Fvtk&`uR}@x46AH
zd7)4BSQaU#xsnG77nD&hV{H_!xkV4hQVTjvlr}VzSx-!Jb41f56Z9}iQ@SU@SY{gQ
z6fT$;ZFf_Ka-n0D<R+1sJrSA<v~*fvtC7frVn$Fi7Ks9!%)mmxGFGw}jjfozgwdCU
z=}^qTbi$f(VcTJm#rA|(O&Eq>EE-)h|9=ecF3zEMUZQ%f2b`K?hovd(2$!CU*uru>
zor^dbCNaE`!U{_~uLEFMTt@UiNQ>Wo)^s;XStbt{y>YPMZn3yu<Z)l{;%0FjnmaN-
zQpsp+=+#d?z1jo$Y>WP<<+E$|9zCE3LTUJoUZqmeE69=~Stu&&aOqN(A;J(GYN<DS
z<FOG#meKoclF4|M%-+<sV9ahI?8eOWV>x|}i#ZQtOKoeRH_>;{^{*f!=h$}g>`UWJ
zh;b+0q`}Fib3*Po-)<edr8{YI_k^fRC6a&N!$>ARq%DpjaN^E&iSzW*6X#iGf|ArL
z_l`a6)#iTbUBq6;jk4ZVtEao*nwyT5Ov2-4+2pPLK>ff2%THELoXIM0pAfq*B;I7r
zmXj0r*e@NN>zB<TZiDl7pE#w1!m>KMa!(lKXPO{|<d9ymWnt@Vu61e7kgI(~0C?sh
z;b$vRlw^sCBK%aO|Gb_#e_A5?^StaotelF36^UMuUU$86rLJ1`9G<AEeX3pgbM-2S
zqMVs=6jgyh5jsrFxbj(^<EQeK&eOzHzD6Ywyb6svijrxLzp52Qs4iI6v=t`DP^-3-
z$Ws)pZmaT8*s1`f%z^`FqusJqYay%rd7Y~~>{K=E+)s{r4}f2MzKs~#PV!>=shAeM
zeP-D9ybkH@Qw+<Zc-Ah#NSMgN{TSQmk3bx^K^o*8vO(S@>tx*vh)V+3Cjq1z?keQ!
z18Bw8oVMA~L$AZF55~Z0*17wxI>+6|_?r-p7X=P>Z1C}B>DYkb{-$+qYu5Q%m_lVJ
zxdP=+)irRG9EfaLuEjH4aN*m#%Eq_yL1wQyQ`wtz8<hvsskf|RXvujiMSNS{+G|eU
z2Uq#?&Fv$o0}uxg8)TKJ55dO`D?zjQWceE8H(&q~S)eZ%04>Sefb$*3iOZ2e07{I_
zu|`QQI&}sCYMmbr^5DKfKAf&;luqfE-ib%>2*Vt~!`ViW?Pv0E3I961tp62s1t-p5
zl^Xu+(mYh@m}xv+w6mP;*qyq5jjRfHSz3s%l){7hS3_0nw+%vcuQ2oJZWBg=H;h&*
zKwh=>SiEn;y*a|mlvfS=8vV_z%0|)ybbSuQLGY~N3-MX5p6#xv4NO&G6tM!YxI%8M
zMNz!0u=qs=r%5a_E%37*MN^h!23=U)b`%K+(kN2aZ*xc6$gJ_zN1VA-?e*H>!Hszq
W-L%o5FMu@ah_9&^xPcdJ2Em_UxQlWC

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/format/__pycache__/c.cpython-36.pyc b/scripts/tracetool/format/__pycache__/c.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..777294a41b1ad77a970fc92280c7b2dc0e06444d
GIT binary patch
literal 1949
zcma)7PjlNu6yKF)*>UWoq;2A+1(q;otm4>d%aj=sGA*eG4#5=Sri`JpqiDCW5?NAq
zCDW+(DZQ3~kHLXY!3-ZlS592uo)d4^c9Y=(^1P?F@6T`Fd;3<tSE-c#-ujXMRY2$u
zbm=ibegGslfHBlV4EHcIdIrn&a?I?REZ@sBixqrpQ0NsfVnsIh3iXPtw1@2Z^kyj*
zj>}tzJmA8KIa}9jA)9U~sR8D$pZxZ#B>SH41mVyjTf?dJz;T;N<Tg1=wv$i5b0>^W
zg?HGG$=!`Rch`Y^)FA&WJiYh%<6Sc3LV969?vhZDx)YPrFcBn-Vo=(|2~LR*35uCt
zy0{nf=T1PraE^k|O}+H0)QZ0IKycP~;-(u8{)EJkjk8>s#BNS4;3)zv0__0FZ48Zr
zmc2qF^a!2dagOCi#tLHQ3L2X+V!C~*Z6k9TG3(62=mk-}&#L1**h{1Q5e72O@G`_>
zbaMYGdhxyX=#KMj9&EW|OZcojwgQt?#uh{^utj!-y~UQ;Rd#KPV4mTT1#+HUSNzC2
zL(6Dt19Z0hx(w*wK1C3}GBS<|XNXl_8~@7Z#swN%Ro0W=b;M0}4YJQ+6@81n&E8?}
zGV%rmsv6;=;s|O#Q;4gh98|b8E`WA!RG4Ug!Y9?I%C9u@V+h9Ry^ae_)Q_4+6KD@e
zt^zxRwgL=hDhwSLggL@L8z&}&;jF+s=^XeR#8M=}h>O_c(l#=qxshT13lcEz=zOCE
zQ_%9Fq;<jv$@;MqJ1yx7FN$SLk82!;e(QNC22R{^o6+fcY0LLy4CfzhUsai?lq_W6
z^ww<9n_GV9I=<WnVdk1z8f`r_n*DUMb(?hio+QsbpA&dHNgU3i896v5Z?<j_7Lp*0
z31?p1B)3}`N>|?Z0@qI%Cu=I{Rwx;dn*Fu3`Y*#EWQos}rE+1Z$+fhcctL#UK8;CD
zZf54tjS`{S+`HcW=HX78?(aN)LfiZ8PM3DR>a^2pSKZ|HkOvS^=jv@s@+o<lmI*vf
zkHKQ2k>1oR1xK~2R-ekYY@{pN7&rqC&TF;0l5DxwNN;F^lrh{vFxBc4QN^rk6PuYn
zsMRMj?4BCq&GgD7-<qWD&cn}k+mGygme=`Zh3VFrsW$3a6VRSD0Z8kYO1fREABr%E
zY)N(FsYa0BJyRvZ0OhqcT~x_H3e)-<HWp=QT3R5a^JI6ok={{xdM+7;Q2hky0$K1w
z7zQq;;C1C>pW~P5#|rk+zVwZ!-nM=Lamh*Ao9B3(emGHiffv{RV?*1X7wQUSIVbY6
z`LEkwKB15Hx(~Z;p+-0>X^lQ~v7i+BB!XL$<^AvncrDE4lO8}JK~|itv+_)$JYaS)
zvnJik3I~pR3@V|%hrNp9#@>)mtIw=HcNiDK0-LBPrdp}*<b<gYsi*>50+Rc{5MIcY
z4HFysXJN}I;VMuGBooi{6Ke^4OkBp-z*5$J%C7t-b_29!h+M*YkB&W;6)0t)OKDc3
z6z*d`6d+e9b!Y!Qu$-sV_go%G4vPg!2M*jLAUIW;%~8rh;VV&}h5B^pmg_w()uz5Y
ZLKT=5w<dRVI}a<V+HUGvG|!cD{{Tl$8u|bL

literal 0
HcmV?d00001

diff --git a/scripts/tracetool/format/__pycache__/h.cpython-36.pyc b/scripts/tracetool/format/__pycache__/h.cpython-36.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..88f6dea503b2289b18479baa72cf65d2d17f298d
GIT binary patch
literal 2177
zcma)7OK;mo5aupPJt$dDZ0DV}+c-kSz?Sj=TA&UBJGRgON!2!XokD1_pt&oHGDRxO
zrC~GDNx8b{p@;s39{LY@>%ZW&m!_8jJ@k-MXDP{batKOdm$Sq9X1<x7CGXA6S%2OC
zo_|x)wBNNe7Y2D9Msyn{rnNPO+KAycW_nv^M%!R!+hjSG_jCPxJC8J0V8xeOyTGh%
z%`PR^EGZn9H}-kJg(Epz&DJ8ScdfVzKA-sUZ@)xj*YlkqJaowY!>P3Hxb=A8);WtG
z#GiuYW;i$&-hNk-ySMM$U4`kB74pB}$-U3Md_oSnh`cZ$cS$Hn&5`6dj0Fh?5|lP^
zf@9(XK{2yS=C>v9I01R&^n%b$yks%T6kTUsaMpEX-3|M%fS6{ZR1ah6>S_U30meLx
zO&HNXNYjRxp#v-`43G4{VERax8iUfY+z|KBSi7jP{HbKJ!cYf|Ifil`k)gJweRp|e
z0HQcFdKiX2M$9_FNPE8i>`jZ()WR5}i`p20#U5DfW<FXYgO%aEd5{x7vAK~6Oe!Oj
z%};f|LWFZ5=X!a?X=t+ZCpywVy8zm$u7jt3Up~`@s8<+5Zew6_^mi8H&y1(Z76GA{
z7J=!K@-mH_{{e}sfU}0i1P9(PD4y^%*+q6~iYtu~NM&~U#C!w03)s0c*eeRlu7WLO
z1-^fj6{+$mj}b(!T+v23c1@le=0KNaz^<P_2BSRW{@y4*i^|?-A27nMfE9+!C){To
zKJ1-W9(xO8sOT`yZk&{%u770tFV6A@Ps_6%%s6S#{x@5xA;M55OOr$3hJh5Jzk28n
z;(9lke?tq3wZ<*7)Ab_K@qA9;>BKTTJvn6Wm}CeUhW-j+AqhfBIP+wk+-js+a&y`1
z1dMmc&eM&}Cap&Fvu3OLbYrKvMKjgYZTbkTz{CsqyRGJyy}<Qj#>tIpbR)UWkKkwo
zWJew5<{=Lxsn)o9+R+-cznRI&;?ykm0(s|S3P#adnrB|*?D<^4LC{{QDJe*If0Z9`
zH@Wo|n_A%XxgF7FYvbXQ=9Y>QC@`~`jZ;ItP4iP#a_uef85m10%wAS&&cL&ynoVlt
zTXj@nnOFp_j^jt%PHslhk)BJuz*luS3_S*MCm?u={m72&*XV_fg$3+WL#bY)QEI4-
zOzvcxLbD3ceJ-ieQstA^sx^@9Xk}LHn#aJGjoUitQ|z(SkRs;EqN3w<hysLxvLP>$
zWu;VCMux&isLS00$fTN8NwHc>Ol2@i@Cvcbj9$A0%xA`;tO%Q`Y*A_`*NMH%0|uc~
zuf3yBpr!03p+5hq84m_rOmerrYJUDTZSFQ(J83DCx3+hn!%}M?La>q^1S*8^o%RC9
z7wSuxR%R_s_c*B2#SHgwWAkydwMD1+OaB=;?g3DwEGuEUkXcWtw!YYW)ZBbL$*M3z
zKwCiHrG^JBni|Y=LGFcKAkM4k<(U};r*<LDWg8Wx`MpV;)Z7<gJV<k0?l5qGxF`ay
zU7Tzy?2}l4_0O942p+F*H{g%a@CI??Iq%1-2aa?akt@7`j2fq>v(X7f-;s@O9e!EY
z0j4}e2}~L)pd2=^fiSY*#wZ7C3mIq$=F7U$!Fyz>0k&6h87mp1bGVGkxS%UJ!%o*_
zw16;Hx`nA<B~R`g_%KifaAlnFXxYUyPbmvsN>htc_`q~S0rDKB?(F{x%Mzu&=kg%p
zu&7Ylci=?B;L5g0DF=nG#M6|sR>@*ybviTEAnUYnzaO&L=MPL(i3&`r25_rcFYEsT
DOqf{=

literal 0
HcmV?d00001

diff --git a/softmmu/main.c b/softmmu/main.c
index 639c67f..d87ba64 100644
--- a/softmmu/main.c
+++ b/softmmu/main.c
@@ -26,6 +26,8 @@
 #include "qemu-common.h"
 #include "sysemu/sysemu.h"
 
+#include "hw/vfio/cni_logger.h"
+
 #ifdef CONFIG_SDL
 #if defined(__APPLE__) || defined(main)
 #include <SDL.h>
@@ -47,8 +49,11 @@ int main(int argc, char **argv)
 int main(int argc, char **argv, char **envp)
 {
     qemu_init(argc, argv, envp);
+    // cni_log_info("mainloop-start0321\n\n\n\n");
     qemu_main_loop();
+    // cni_log_info("cleanup-start");
     qemu_cleanup();
+    // cni_log_info("cleanup-end");
 
     return 0;
 }
diff --git a/softmmu/memory.c b/softmmu/memory.c
index 7340e19..fd2f34f 100644
--- a/softmmu/memory.c
+++ b/softmmu/memory.c
@@ -33,6 +33,8 @@
 #include "qemu/accel.h"
 #include "hw/boards.h"
 #include "migration/vmstate.h"
+#include "hw/vfio/cni_logger.h"
+
 
 //#define DEBUG_UNASSIGNED
 
@@ -970,8 +972,8 @@ static void address_space_update_topology_pass(AddressSpace *as,
             ++inew;
         } else {
             /* In new */
-
             if (adding) {
+                // cni_log_info2(true, "address_space_update_topology_pass name=%s, adding=true, calling region_add", as->name);
                 MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
                 flat_range_coalesced_io_add(frnew, as);
             }
@@ -1076,7 +1078,10 @@ static void address_space_update_topology(AddressSpace *as)
     if (!g_hash_table_lookup(flat_views, physmr)) {
         generate_memory_topology(physmr);
     }
+    
+    // cni_log_info("address_space_update_topology begin");
     address_space_set_flatview(as);
+    // cni_log_info("address_space_update_topology end");
 }
 
 void memory_region_transaction_begin(void)
@@ -1099,10 +1104,22 @@ void memory_region_transaction_commit(void)
 
             MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
 
+            // cni_log_info("mem_region_transaction_commit begin");
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+                // if (as->root) {
+                //     cni_log_info2("\taddress_space: name='%s', root_mem_region: name='%s', is_iommu=%d, size=%"PRId64,
+                //         as->name,
+                //         memory_region_name(as->root),
+                //         memory_region_is_iommu(as->root),
+                //         int128_get64(memory_region_size(as->root))
+                //     );
+                // } else {
+                //     cni_log_info2("\taddress_space: name='%s', non_root_mem_region", as->name);
+                // }
                 address_space_set_flatview(as);
                 address_space_update_ioeventfds(as);
             }
+            // cni_log_info("mem_region_transaction_commit end");
             memory_region_update_pending = false;
             ioeventfd_update_pending = false;
             MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
@@ -2843,15 +2860,22 @@ static void listener_add_address_space(MemoryListener *listener,
     FlatView *view;
     FlatRange *fr;
 
+    // cni_log_info("mem-listener-reg-begin");
+
     if (listener->begin) {
         listener->begin(listener);
     }
+
+    // cni_log_info("mem-listener-reg-log");
+
     if (global_dirty_tracking) {
         if (listener->log_global_start) {
             listener->log_global_start(listener);
         }
     }
 
+    // cni_log_info("mem-listener-reg-add");
+
     view = address_space_get_flatview(as);
     FOR_EACH_FLAT_RANGE(fr, view) {
         MemoryRegionSection section = section_from_flat_range(fr, view);
@@ -2863,10 +2887,15 @@ static void listener_add_address_space(MemoryListener *listener,
             listener->log_start(listener, &section, 0, fr->dirty_log_mask);
         }
     }
+
+    // cni_log_info("mem-listener-reg-commit");
+
     if (listener->commit) {
         listener->commit(listener);
     }
     flatview_unref(view);
+
+    // cni_log_info("mem-listener-reg-ok");
 }
 
 static void listener_del_address_space(MemoryListener *listener,
@@ -2899,10 +2928,14 @@ void memory_listener_register(MemoryListener *listener, AddressSpace *as)
 {
     MemoryListener *other = NULL;
 
+    // cni_log_info("mem-listener-init");
+
     /* Only one of them can be defined for a listener */
     assert(!(listener->log_sync && listener->log_sync_global));
-
     listener->address_space = as;
+
+    // cni_log_info("mem-listener-insertmem");
+
     if (QTAILQ_EMPTY(&memory_listeners)
         || listener->priority >= QTAILQ_LAST(&memory_listeners)->priority) {
         QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
@@ -2915,6 +2948,8 @@ void memory_listener_register(MemoryListener *listener, AddressSpace *as)
         QTAILQ_INSERT_BEFORE(other, listener, link);
     }
 
+    // cni_log_info("mem-listener-insertas");
+
     if (QTAILQ_EMPTY(&as->listeners)
         || listener->priority >= QTAILQ_LAST(&as->listeners)->priority) {
         QTAILQ_INSERT_TAIL(&as->listeners, listener, link_as);
@@ -2927,7 +2962,11 @@ void memory_listener_register(MemoryListener *listener, AddressSpace *as)
         QTAILQ_INSERT_BEFORE(other, listener, link_as);
     }
 
+    // cni_log_info("mem-listener-registeras");
+    
     listener_add_address_space(listener, as);
+    
+    // cni_log_info("mem-listener-ok111");
 }
 
 void memory_listener_unregister(MemoryListener *listener)
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 3524c04..b49e03b 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -77,6 +77,8 @@
 #include <daxctl/libdaxctl.h>
 #endif
 
+#include "hw/vfio/cni_logger.h"
+
 //#define DEBUG_SUBPAGE
 
 /* ram_list is read under rcu_read_lock()/rcu_read_unlock().  Writes
@@ -512,6 +514,21 @@ static MemoryRegionSection flatview_do_translate(FlatView *fv,
         *page_mask_out = ~TARGET_PAGE_MASK;
     }
 
+    //char msg[512];
+
+    // //sprintf(msg, "latecreate2-%s", type);
+    // // Before returning from the function, add the print statement
+    // // sprintf(msg, "GPA: 0x%jx, Translated address: 0x%jx, Length: 0x%jx, Page mask: 0x%jx, Write: %s, MMIO: %s\n",
+    // //     (uintmax_t)addr,
+    // //     (xlat)? (uintmax_t)*xlat : (uintmax_t)-1,
+    // //     (plen_out) ? (uintmax_t)*plen_out : (uintmax_t)-1,
+    // //     (page_mask_out) ? (uintmax_t)*page_mask_out : (uintmax_t)-1,
+    // //     is_write ? "true" : "false",
+    // //     is_mmio ? "true" : "false");
+
+    //sprintf(msg, "GPA: 0x%jx, Translated address: 0x%jx, Length: 0x%jx, Page mask: 0x%jx, Write: %s, MMIO: %s", (uintmax_t)(addr)&(uintmax_t)(TARGET_PAGE_MASK), (xlat)? (uintmax_t)(*xlat) & (uintmax_t)(TARGET_PAGE_MASK): (uintmax_t)-1,  (plen_out) ? (uintmax_t)*plen_out : (uintmax_t)-1, (uintmax_t) ~TARGET_PAGE_MASK, is_write ? "true" : "false", is_mmio ? "true" : "false");
+    //cni_log_info(msg);
+
     return *section;
 }
 
@@ -1511,6 +1528,9 @@ static int file_ram_open(const char *path,
 
             filename = g_strdup_printf("%s/qemu_back_mem.%s.XXXXXX", path,
                                        sanitized_name);
+
+            // cni_log_info(filename);
+
             g_free(sanitized_name);
 
             fd = mkstemp(filename);
@@ -2072,6 +2092,11 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
 
     size = HOST_PAGE_ALIGN(size);
     file_size = get_file_size(fd);
+
+    // char msg[64];
+    // sprintf(msg, "ramblock hugepage remaining size: %lu", file_size);
+    // cni_log_info(msg);
+
     if (file_size > 0 && file_size < size) {
         error_setg(errp, "backing store size 0x%" PRIx64
                    " does not match 'size' option 0x" RAM_ADDR_FMT,
diff --git a/softmmu/qdev-monitor.c b/softmmu/qdev-monitor.c
index 01f3834..7e1d8c2 100644
--- a/softmmu/qdev-monitor.c
+++ b/softmmu/qdev-monitor.c
@@ -43,6 +43,8 @@
 #include "hw/qdev-properties.h"
 #include "hw/clock.h"
 #include "hw/boards.h"
+#include "hw/vfio/cni_logger.h"
+#include <strings.h>
 
 /*
  * Aliases were a bad idea from the start.  Let's keep them
@@ -624,6 +626,12 @@ DeviceState *qdev_device_add_from_qdict(const QDict *opts,
         return NULL;
     }
 
+    // cgroup contention debug point 5
+    // if (CNI_BARRIER_INDEX == 1 && strcasecmp(driver, "vfio-pci") == 0) {
+    //     cni_obtain_barrier_sem("/barrierVM");
+    // }
+    cni_log_info(driver);
+
     /* find driver */
     dc = qdev_get_device_class(&driver, errp);
     if (!dc) {
diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index 10d9b73..71af636 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -60,6 +60,8 @@
 #include "sysemu/tpm.h"
 #include "trace.h"
 
+#include "hw/vfio/cni_logger.h"
+
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
@@ -526,6 +528,10 @@ void qemu_system_guest_crashloaded(GuestPanicInformation *info)
 
 void qemu_system_reset_request(ShutdownCause reason)
 {
+    // char msg[64];
+    // sprintf(msg, "qemu_system_shutdown_reset-%d", (int)reason);
+    // cni_log_info(msg);
+
     if (reboot_action == REBOOT_ACTION_SHUTDOWN &&
         reason != SHUTDOWN_CAUSE_SUBSYSTEM_RESET) {
         shutdown_requested = reason;
@@ -607,6 +613,7 @@ bool qemu_wakeup_suspend_enabled(void)
 
 void qemu_system_killed(int signal, pid_t pid)
 {
+    // cni_log_info("qemu_system_killed");
     shutdown_signal = signal;
     shutdown_pid = pid;
     shutdown_action = SHUTDOWN_ACTION_POWEROFF;
@@ -620,6 +627,7 @@ void qemu_system_killed(int signal, pid_t pid)
 
 void qemu_system_shutdown_request(ShutdownCause reason)
 {
+    // cni_log_info("qemu_system_shutdown_request");
     trace_qemu_system_shutdown_request(reason);
     replay_shutdown_request(reason);
     shutdown_requested = reason;
diff --git a/softmmu/vl.c b/softmmu/vl.c
index 620a1f1..8a143d5 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -129,6 +129,8 @@
 
 #include "config-host.h"
 
+#include "hw/vfio/cni_logger.h"
+
 #define MAX_VIRTIO_CONSOLES 1
 
 typedef struct BlockdevOptionsQueueEntry {
@@ -2732,6 +2734,15 @@ static void qemu_machine_creation_done(void)
 
 void qmp_x_exit_preconfig(Error **errp)
 {
+    // // cgroup contention debug point 1
+    // if (CNI_BARRIER_INDEX == 0) {
+    //     int ret_code = cni_obtain_barrier_sem("/barrierVM");
+    //     char debug_info[256];
+    //     sprintf(debug_info, "set-barrier:qemu-init:%d", ret_code);
+    //     cni_log_info(debug_info);
+    // }
+    cni_log_info("preconfig-start");
+
     if (phase_check(PHASE_MACHINE_INITIALIZED)) {
         error_setg(errp, "The command is permitted only before machine initialization");
         return;
@@ -2760,6 +2771,8 @@ void qmp_x_exit_preconfig(Error **errp)
     } else if (autostart) {
         qmp_cont(NULL);
     }
+
+    cni_log_info("preconfig-end");
 }
 
 void qemu_init(int argc, char **argv, char **envp)
@@ -2773,6 +2786,16 @@ void qemu_init(int argc, char **argv, char **envp)
     bool userconfig = true;
     FILE *vmstate_dump_file = NULL;
 
+    // cgroup contention debug point 4
+    // if (CNI_BARRIER_INDEX == 0) {
+    //     int ret_code = cni_obtain_barrier_sem("/barrierVM");
+    //     char debug_info[256];
+    //     sprintf(debug_info, "set-barrier:qemu-init:%d", ret_code);
+    //     cni_log_info(debug_info);
+    // }
+
+    cni_log_info("qemuInit-start");
+
     qemu_add_opts(&qemu_drive_opts);
     qemu_add_drive_opts(&qemu_legacy_drive_opts);
     qemu_add_drive_opts(&qemu_common_drive_opts);
@@ -2814,8 +2837,24 @@ void qemu_init(int argc, char **argv, char **envp)
     module_allow_arch(TARGET_NAME);
 #endif
 
+    // // cgroup contention debug point 3
+    // if (CNI_BARRIER_INDEX == 0) {
+    //     int ret_code = cni_obtain_barrier_sem("/barrierVM");
+    //     char debug_info[256];
+    //     sprintf(debug_info, "set-barrier:qemu-init:%d", ret_code);
+    //     cni_log_info(debug_info);
+    // }
+
     qemu_init_subsystems();
 
+    // // cgroup contention debug point 2
+    // if (CNI_BARRIER_INDEX == 0) {
+    //     int ret_code = cni_obtain_barrier_sem("/barrierVM");
+    //     char debug_info[256];
+    //     sprintf(debug_info, "set-barrier:qemu-init:%d", ret_code);
+    //     cni_log_info(debug_info);
+    // }
+
     /* first pass of option parsing */
     optind = 1;
     while (optind < argc) {
@@ -3778,4 +3817,6 @@ void qemu_init(int argc, char **argv, char **envp)
     accel_setup_post(current_machine);
     os_setup_post();
     resume_mux_open();
+
+    cni_log_info("qemuInit-end");
 }
diff --git a/subprojects/libvhost-user/include/atomic.h b/subprojects/libvhost-user/include/atomic.h
deleted file mode 120000
index 8c2be64..0000000
--- a/subprojects/libvhost-user/include/atomic.h
+++ /dev/null
@@ -1 +0,0 @@
-../../../include/qemu/atomic.h
\ No newline at end of file
diff --git a/subprojects/libvhost-user/include/atomic.h b/subprojects/libvhost-user/include/atomic.h
new file mode 100644
index 0000000..112a299
--- /dev/null
+++ b/subprojects/libvhost-user/include/atomic.h
@@ -0,0 +1,309 @@
+/*
+ * Simple interface for atomic operations.
+ *
+ * Copyright (C) 2013 Red Hat, Inc.
+ *
+ * Author: Paolo Bonzini <pbonzini@redhat.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ * See docs/devel/atomics.rst for discussion about the guarantees each
+ * atomic primitive is meant to provide.
+ */
+
+#ifndef QEMU_ATOMIC_H
+#define QEMU_ATOMIC_H
+
+/* Compiler barrier */
+#define barrier()   ({ asm volatile("" ::: "memory"); (void)0; })
+
+/* The variable that receives the old value of an atomically-accessed
+ * variable must be non-qualified, because atomic builtins return values
+ * through a pointer-type argument as in __atomic_load(&var, &old, MODEL).
+ *
+ * This macro has to handle types smaller than int manually, because of
+ * implicit promotion.  int and larger types, as well as pointers, can be
+ * converted to a non-qualified type just by applying a binary operator.
+ */
+#define typeof_strip_qual(expr)                                                    \
+  typeof(                                                                          \
+    __builtin_choose_expr(                                                         \
+      __builtin_types_compatible_p(typeof(expr), bool) ||                          \
+        __builtin_types_compatible_p(typeof(expr), const bool) ||                  \
+        __builtin_types_compatible_p(typeof(expr), volatile bool) ||               \
+        __builtin_types_compatible_p(typeof(expr), const volatile bool),           \
+        (bool)1,                                                                   \
+    __builtin_choose_expr(                                                         \
+      __builtin_types_compatible_p(typeof(expr), signed char) ||                   \
+        __builtin_types_compatible_p(typeof(expr), const signed char) ||           \
+        __builtin_types_compatible_p(typeof(expr), volatile signed char) ||        \
+        __builtin_types_compatible_p(typeof(expr), const volatile signed char),    \
+        (signed char)1,                                                            \
+    __builtin_choose_expr(                                                         \
+      __builtin_types_compatible_p(typeof(expr), unsigned char) ||                 \
+        __builtin_types_compatible_p(typeof(expr), const unsigned char) ||         \
+        __builtin_types_compatible_p(typeof(expr), volatile unsigned char) ||      \
+        __builtin_types_compatible_p(typeof(expr), const volatile unsigned char),  \
+        (unsigned char)1,                                                          \
+    __builtin_choose_expr(                                                         \
+      __builtin_types_compatible_p(typeof(expr), signed short) ||                  \
+        __builtin_types_compatible_p(typeof(expr), const signed short) ||          \
+        __builtin_types_compatible_p(typeof(expr), volatile signed short) ||       \
+        __builtin_types_compatible_p(typeof(expr), const volatile signed short),   \
+        (signed short)1,                                                           \
+    __builtin_choose_expr(                                                         \
+      __builtin_types_compatible_p(typeof(expr), unsigned short) ||                \
+        __builtin_types_compatible_p(typeof(expr), const unsigned short) ||        \
+        __builtin_types_compatible_p(typeof(expr), volatile unsigned short) ||     \
+        __builtin_types_compatible_p(typeof(expr), const volatile unsigned short), \
+        (unsigned short)1,                                                         \
+      (expr)+0))))))
+
+#ifndef __ATOMIC_RELAXED
+#error "Expecting C11 atomic ops"
+#endif
+
+/* Manual memory barriers
+ *
+ *__atomic_thread_fence does not include a compiler barrier; instead,
+ * the barrier is part of __atomic_load/__atomic_store's "volatile-like"
+ * semantics. If smp_wmb() is a no-op, absence of the barrier means that
+ * the compiler is free to reorder stores on each side of the barrier.
+ * Add one here, and similarly in smp_rmb() and smp_read_barrier_depends().
+ */
+
+#define smp_mb()                     ({ barrier(); __atomic_thread_fence(__ATOMIC_SEQ_CST); })
+#define smp_mb_release()             ({ barrier(); __atomic_thread_fence(__ATOMIC_RELEASE); })
+#define smp_mb_acquire()             ({ barrier(); __atomic_thread_fence(__ATOMIC_ACQUIRE); })
+
+/* Most compilers currently treat consume and acquire the same, but really
+ * no processors except Alpha need a barrier here.  Leave it in if
+ * using Thread Sanitizer to avoid warnings, otherwise optimize it away.
+ */
+#if defined(__SANITIZE_THREAD__)
+#define smp_read_barrier_depends()   ({ barrier(); __atomic_thread_fence(__ATOMIC_CONSUME); })
+#elif defined(__alpha__)
+#define smp_read_barrier_depends()   asm volatile("mb":::"memory")
+#else
+#define smp_read_barrier_depends()   barrier()
+#endif
+
+/*
+ * A signal barrier forces all pending local memory ops to be observed before
+ * a SIGSEGV is delivered to the *same* thread.  In practice this is exactly
+ * the same as barrier(), but since we have the correct builtin, use it.
+ */
+#define signal_barrier()    __atomic_signal_fence(__ATOMIC_SEQ_CST)
+
+/* Sanity check that the size of an atomic operation isn't "overly large".
+ * Despite the fact that e.g. i686 has 64-bit atomic operations, we do not
+ * want to use them because we ought not need them, and this lets us do a
+ * bit of sanity checking that other 32-bit hosts might build.
+ *
+ * That said, we have a problem on 64-bit ILP32 hosts in that in order to
+ * sync with TCG_OVERSIZED_GUEST, this must match TCG_TARGET_REG_BITS.
+ * We'd prefer not want to pull in everything else TCG related, so handle
+ * those few cases by hand.
+ *
+ * Note that x32 is fully detected with __x86_64__ + _ILP32, and that for
+ * Sparc we always force the use of sparcv9 in configure. MIPS n32 (ILP32) &
+ * n64 (LP64) ABIs are both detected using __mips64.
+ */
+#if defined(__x86_64__) || defined(__sparc__) || defined(__mips64)
+# define ATOMIC_REG_SIZE  8
+#else
+# define ATOMIC_REG_SIZE  sizeof(void *)
+#endif
+
+/* Weak atomic operations prevent the compiler moving other
+ * loads/stores past the atomic operation load/store. However there is
+ * no explicit memory barrier for the processor.
+ *
+ * The C11 memory model says that variables that are accessed from
+ * different threads should at least be done with __ATOMIC_RELAXED
+ * primitives or the result is undefined. Generally this has little to
+ * no effect on the generated code but not using the atomic primitives
+ * will get flagged by sanitizers as a violation.
+ */
+#define qatomic_read__nocheck(ptr) \
+    __atomic_load_n(ptr, __ATOMIC_RELAXED)
+
+#define qatomic_read(ptr)                              \
+    ({                                                 \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \
+    qatomic_read__nocheck(ptr);                        \
+    })
+
+#define qatomic_set__nocheck(ptr, i) \
+    __atomic_store_n(ptr, i, __ATOMIC_RELAXED)
+
+#define qatomic_set(ptr, i)  do {                      \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \
+    qatomic_set__nocheck(ptr, i);                      \
+} while(0)
+
+/* See above: most compilers currently treat consume and acquire the
+ * same, but this slows down qatomic_rcu_read unnecessarily.
+ */
+#ifdef __SANITIZE_THREAD__
+#define qatomic_rcu_read__nocheck(ptr, valptr)           \
+    __atomic_load(ptr, valptr, __ATOMIC_CONSUME);
+#else
+#define qatomic_rcu_read__nocheck(ptr, valptr)           \
+    __atomic_load(ptr, valptr, __ATOMIC_RELAXED);        \
+    smp_read_barrier_depends();
+#endif
+
+#define qatomic_rcu_read(ptr)                          \
+    ({                                                 \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \
+    typeof_strip_qual(*ptr) _val;                      \
+    qatomic_rcu_read__nocheck(ptr, &_val);             \
+    _val;                                              \
+    })
+
+#define qatomic_rcu_set(ptr, i) do {                   \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \
+    __atomic_store_n(ptr, i, __ATOMIC_RELEASE);        \
+} while(0)
+
+#define qatomic_load_acquire(ptr)                       \
+    ({                                                  \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE);  \
+    typeof_strip_qual(*ptr) _val;                       \
+    __atomic_load(ptr, &_val, __ATOMIC_ACQUIRE);        \
+    _val;                                               \
+    })
+
+#define qatomic_store_release(ptr, i)  do {             \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE);  \
+    __atomic_store_n(ptr, i, __ATOMIC_RELEASE);         \
+} while(0)
+
+
+/* All the remaining operations are fully sequentially consistent */
+
+#define qatomic_xchg__nocheck(ptr, i)    ({                 \
+    __atomic_exchange_n(ptr, (i), __ATOMIC_SEQ_CST);        \
+})
+
+#define qatomic_xchg(ptr, i)    ({                          \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE);      \
+    qatomic_xchg__nocheck(ptr, i);                          \
+})
+
+/* Returns the eventual value, failed or not */
+#define qatomic_cmpxchg__nocheck(ptr, old, new)    ({                   \
+    typeof_strip_qual(*ptr) _old = (old);                               \
+    (void)__atomic_compare_exchange_n(ptr, &_old, new, false,           \
+                              __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);      \
+    _old;                                                               \
+})
+
+#define qatomic_cmpxchg(ptr, old, new)    ({                            \
+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE);                  \
+    qatomic_cmpxchg__nocheck(ptr, old, new);                            \
+})
+
+/* Provide shorter names for GCC atomic builtins, return old value */
+#define qatomic_fetch_inc(ptr)  __atomic_fetch_add(ptr, 1, __ATOMIC_SEQ_CST)
+#define qatomic_fetch_dec(ptr)  __atomic_fetch_sub(ptr, 1, __ATOMIC_SEQ_CST)
+
+#define qatomic_fetch_add(ptr, n) __atomic_fetch_add(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_fetch_sub(ptr, n) __atomic_fetch_sub(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_fetch_and(ptr, n) __atomic_fetch_and(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_fetch_or(ptr, n)  __atomic_fetch_or(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_fetch_xor(ptr, n) __atomic_fetch_xor(ptr, n, __ATOMIC_SEQ_CST)
+
+#define qatomic_inc_fetch(ptr)    __atomic_add_fetch(ptr, 1, __ATOMIC_SEQ_CST)
+#define qatomic_dec_fetch(ptr)    __atomic_sub_fetch(ptr, 1, __ATOMIC_SEQ_CST)
+#define qatomic_add_fetch(ptr, n) __atomic_add_fetch(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_sub_fetch(ptr, n) __atomic_sub_fetch(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_and_fetch(ptr, n) __atomic_and_fetch(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_or_fetch(ptr, n)  __atomic_or_fetch(ptr, n, __ATOMIC_SEQ_CST)
+#define qatomic_xor_fetch(ptr, n) __atomic_xor_fetch(ptr, n, __ATOMIC_SEQ_CST)
+
+/* And even shorter names that return void.  */
+#define qatomic_inc(ptr) \
+    ((void) __atomic_fetch_add(ptr, 1, __ATOMIC_SEQ_CST))
+#define qatomic_dec(ptr) \
+    ((void) __atomic_fetch_sub(ptr, 1, __ATOMIC_SEQ_CST))
+#define qatomic_add(ptr, n) \
+    ((void) __atomic_fetch_add(ptr, n, __ATOMIC_SEQ_CST))
+#define qatomic_sub(ptr, n) \
+    ((void) __atomic_fetch_sub(ptr, n, __ATOMIC_SEQ_CST))
+#define qatomic_and(ptr, n) \
+    ((void) __atomic_fetch_and(ptr, n, __ATOMIC_SEQ_CST))
+#define qatomic_or(ptr, n) \
+    ((void) __atomic_fetch_or(ptr, n, __ATOMIC_SEQ_CST))
+#define qatomic_xor(ptr, n) \
+    ((void) __atomic_fetch_xor(ptr, n, __ATOMIC_SEQ_CST))
+
+#define smp_wmb()   smp_mb_release()
+#define smp_rmb()   smp_mb_acquire()
+
+/* qatomic_mb_read/set semantics map Java volatile variables. They are
+ * less expensive on some platforms (notably POWER) than fully
+ * sequentially consistent operations.
+ *
+ * As long as they are used as paired operations they are safe to
+ * use. See docs/devel/atomics.rst for more discussion.
+ */
+
+#define qatomic_mb_read(ptr)                             \
+    qatomic_load_acquire(ptr)
+
+#if !defined(__SANITIZE_THREAD__) && \
+    (defined(__i386__) || defined(__x86_64__) || defined(__s390x__))
+/* This is more efficient than a store plus a fence.  */
+# define qatomic_mb_set(ptr, i)  ((void)qatomic_xchg(ptr, i))
+#else
+# define qatomic_mb_set(ptr, i) \
+   ({ qatomic_store_release(ptr, i); smp_mb(); })
+#endif
+
+#define qatomic_fetch_inc_nonzero(ptr) ({                               \
+    typeof_strip_qual(*ptr) _oldn = qatomic_read(ptr);                  \
+    while (_oldn && qatomic_cmpxchg(ptr, _oldn, _oldn + 1) != _oldn) {  \
+        _oldn = qatomic_read(ptr);                                      \
+    }                                                                   \
+    _oldn;                                                              \
+})
+
+/*
+ * Abstractions to access atomically (i.e. "once") i64/u64 variables.
+ *
+ * The i386 abi is odd in that by default members are only aligned to
+ * 4 bytes, which means that 8-byte types can wind up mis-aligned.
+ * Clang will then warn about this, and emit a call into libatomic.
+ *
+ * Use of these types in structures when they will be used with atomic
+ * operations can avoid this.
+ */
+typedef int64_t aligned_int64_t __attribute__((aligned(8)));
+typedef uint64_t aligned_uint64_t __attribute__((aligned(8)));
+
+#ifdef CONFIG_ATOMIC64
+/* Use __nocheck because sizeof(void *) might be < sizeof(u64) */
+#define qatomic_read_i64(P) \
+    _Generic(*(P), int64_t: qatomic_read__nocheck(P))
+#define qatomic_read_u64(P) \
+    _Generic(*(P), uint64_t: qatomic_read__nocheck(P))
+#define qatomic_set_i64(P, V) \
+    _Generic(*(P), int64_t: qatomic_set__nocheck(P, V))
+#define qatomic_set_u64(P, V) \
+    _Generic(*(P), uint64_t: qatomic_set__nocheck(P, V))
+
+static inline void qatomic64_init(void)
+{
+}
+#else /* !CONFIG_ATOMIC64 */
+int64_t  qatomic_read_i64(const int64_t *ptr);
+uint64_t qatomic_read_u64(const uint64_t *ptr);
+void qatomic_set_i64(int64_t *ptr, int64_t val);
+void qatomic_set_u64(uint64_t *ptr, uint64_t val);
+void qatomic64_init(void);
+#endif /* !CONFIG_ATOMIC64 */
+
+#endif /* QEMU_ATOMIC_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux b/subprojects/libvhost-user/standard-headers/linux
deleted file mode 120000
index 15a2378..0000000
--- a/subprojects/libvhost-user/standard-headers/linux
+++ /dev/null
@@ -1 +0,0 @@
-../../../include/standard-headers/linux
\ No newline at end of file
diff --git a/subprojects/libvhost-user/standard-headers/linux/const.h b/subprojects/libvhost-user/standard-headers/linux/const.h
new file mode 100644
index 0000000..5e48987
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/const.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/* const.h: Macros for dealing with constants.  */
+
+#ifndef _LINUX_CONST_H
+#define _LINUX_CONST_H
+
+/* Some constant macros are used in both assembler and
+ * C code.  Therefore we cannot annotate them always with
+ * 'UL' and other type specifiers unilaterally.  We
+ * use the following macros to deal with this.
+ *
+ * Similarly, _AT() will cast an expression with a type in C, but
+ * leave it unchanged in asm.
+ */
+
+#ifdef __ASSEMBLY__
+#define _AC(X,Y)	X
+#define _AT(T,X)	X
+#else
+#define __AC(X,Y)	(X##Y)
+#define _AC(X,Y)	__AC(X,Y)
+#define _AT(T,X)	((T)(X))
+#endif
+
+#define _UL(x)		(_AC(x, UL))
+#define _ULL(x)		(_AC(x, ULL))
+
+#define _BITUL(x)	(_UL(1) << (x))
+#define _BITULL(x)	(_ULL(1) << (x))
+
+#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
+#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
+
+#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
+
+#endif /* _LINUX_CONST_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/ethtool.h b/subprojects/libvhost-user/standard-headers/linux/ethtool.h
new file mode 100644
index 0000000..053d3fa
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/ethtool.h
@@ -0,0 +1,2064 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * ethtool.h: Defines for Linux ethtool.
+ *
+ * Copyright (C) 1998 David S. Miller (davem@redhat.com)
+ * Copyright 2001 Jeff Garzik <jgarzik@pobox.com>
+ * Portions Copyright 2001 Sun Microsystems (thockin@sun.com)
+ * Portions Copyright 2002 Intel (eli.kupermann@intel.com,
+ *                                christopher.leech@intel.com,
+ *                                scott.feldman@intel.com)
+ * Portions Copyright (C) Sun Microsystems 2008
+ */
+
+#ifndef _LINUX_ETHTOOL_H
+#define _LINUX_ETHTOOL_H
+
+#include "net/eth.h"
+
+#include "standard-headers/linux/const.h"
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/if_ether.h"
+
+#include <limits.h> /* for INT_MAX */
+
+/* All structures exposed to userland should be defined such that they
+ * have the same layout for 32-bit and 64-bit userland.
+ */
+
+/* Note on reserved space.
+ * Reserved fields must not be accessed directly by user space because
+ * they may be replaced by a different field in the future. They must
+ * be initialized to zero before making the request, e.g. via memset
+ * of the entire structure or implicitly by not being set in a structure
+ * initializer.
+ */
+
+/**
+ * struct ethtool_cmd - DEPRECATED, link control and status
+ * This structure is DEPRECATED, please use struct ethtool_link_settings.
+ * @cmd: Command number = %ETHTOOL_GSET or %ETHTOOL_SSET
+ * @supported: Bitmask of %SUPPORTED_* flags for the link modes,
+ *	physical connectors and other link features for which the
+ *	interface supports autonegotiation or auto-detection.
+ *	Read-only.
+ * @advertising: Bitmask of %ADVERTISED_* flags for the link modes,
+ *	physical connectors and other link features that are
+ *	advertised through autonegotiation or enabled for
+ *	auto-detection.
+ * @speed: Low bits of the speed, 1Mb units, 0 to INT_MAX or SPEED_UNKNOWN
+ * @duplex: Duplex mode; one of %DUPLEX_*
+ * @port: Physical connector type; one of %PORT_*
+ * @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not
+ *	applicable.  For clause 45 PHYs this is the PRTAD.
+ * @transceiver: Historically used to distinguish different possible
+ *	PHY types, but not in a consistent way.  Deprecated.
+ * @autoneg: Enable/disable autonegotiation and auto-detection;
+ *	either %AUTONEG_DISABLE or %AUTONEG_ENABLE
+ * @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO
+ *	protocols supported by the interface; 0 if unknown.
+ *	Read-only.
+ * @maxtxpkt: Historically used to report TX IRQ coalescing; now
+ *	obsoleted by &struct ethtool_coalesce.  Read-only; deprecated.
+ * @maxrxpkt: Historically used to report RX IRQ coalescing; now
+ *	obsoleted by &struct ethtool_coalesce.  Read-only; deprecated.
+ * @speed_hi: High bits of the speed, 1Mb units, 0 to INT_MAX or SPEED_UNKNOWN
+ * @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of
+ *	%ETH_TP_MDI_*.  If the status is unknown or not applicable, the
+ *	value will be %ETH_TP_MDI_INVALID.  Read-only.
+ * @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of
+ *	%ETH_TP_MDI_*.  If MDI(-X) control is not implemented, reads
+ *	yield %ETH_TP_MDI_INVALID and writes may be ignored or rejected.
+ *	When written successfully, the link should be renegotiated if
+ *	necessary.
+ * @lp_advertising: Bitmask of %ADVERTISED_* flags for the link modes
+ *	and other link features that the link partner advertised
+ *	through autonegotiation; 0 if unknown or not applicable.
+ *	Read-only.
+ * @reserved: Reserved for future use; see the note on reserved space.
+ *
+ * The link speed in Mbps is split between @speed and @speed_hi.  Use
+ * the ethtool_cmd_speed() and ethtool_cmd_speed_set() functions to
+ * access it.
+ *
+ * If autonegotiation is disabled, the speed and @duplex represent the
+ * fixed link mode and are writable if the driver supports multiple
+ * link modes.  If it is enabled then they are read-only; if the link
+ * is up they represent the negotiated link mode; if the link is down,
+ * the speed is 0, %SPEED_UNKNOWN or the highest enabled speed and
+ * @duplex is %DUPLEX_UNKNOWN or the best enabled duplex mode.
+ *
+ * Some hardware interfaces may have multiple PHYs and/or physical
+ * connectors fitted or do not allow the driver to detect which are
+ * fitted.  For these interfaces @port and/or @phy_address may be
+ * writable, possibly dependent on @autoneg being %AUTONEG_DISABLE.
+ * Otherwise, attempts to write different values may be ignored or
+ * rejected.
+ *
+ * Users should assume that all fields not marked read-only are
+ * writable and subject to validation by the driver.  They should use
+ * %ETHTOOL_GSET to get the current values before making specific
+ * changes and then applying them with %ETHTOOL_SSET.
+ *
+ * Deprecated fields should be ignored by both users and drivers.
+ */
+struct ethtool_cmd {
+	uint32_t	cmd;
+	uint32_t	supported;
+	uint32_t	advertising;
+	uint16_t	speed;
+	uint8_t	duplex;
+	uint8_t	port;
+	uint8_t	phy_address;
+	uint8_t	transceiver;
+	uint8_t	autoneg;
+	uint8_t	mdio_support;
+	uint32_t	maxtxpkt;
+	uint32_t	maxrxpkt;
+	uint16_t	speed_hi;
+	uint8_t	eth_tp_mdix;
+	uint8_t	eth_tp_mdix_ctrl;
+	uint32_t	lp_advertising;
+	uint32_t	reserved[2];
+};
+
+static inline void ethtool_cmd_speed_set(struct ethtool_cmd *ep,
+					 uint32_t speed)
+{
+	ep->speed = (uint16_t)(speed & 0xFFFF);
+	ep->speed_hi = (uint16_t)(speed >> 16);
+}
+
+static inline uint32_t ethtool_cmd_speed(const struct ethtool_cmd *ep)
+{
+	return (ep->speed_hi << 16) | ep->speed;
+}
+
+/* Device supports clause 22 register access to PHY or peripherals
+ * using the interface defined in "standard-headers/linux/mii.h".  This should not be
+ * set if there are known to be no such peripherals present or if
+ * the driver only emulates clause 22 registers for compatibility.
+ */
+#define ETH_MDIO_SUPPORTS_C22	1
+
+/* Device supports clause 45 register access to PHY or peripherals
+ * using the interface defined in "standard-headers/linux/mii.h" and <linux/mdio.h>.
+ * This should not be set if there are known to be no such peripherals
+ * present.
+ */
+#define ETH_MDIO_SUPPORTS_C45	2
+
+#define ETHTOOL_FWVERS_LEN	32
+#define ETHTOOL_BUSINFO_LEN	32
+#define ETHTOOL_EROMVERS_LEN	32
+
+/**
+ * struct ethtool_drvinfo - general driver and device information
+ * @cmd: Command number = %ETHTOOL_GDRVINFO
+ * @driver: Driver short name.  This should normally match the name
+ *	in its bus driver structure (e.g. pci_driver::name).  Must
+ *	not be an empty string.
+ * @version: Driver version string; may be an empty string
+ * @fw_version: Firmware version string; may be an empty string
+ * @erom_version: Expansion ROM version string; may be an empty string
+ * @bus_info: Device bus address.  This should match the dev_name()
+ *	string for the underlying bus device, if there is one.  May be
+ *	an empty string.
+ * @reserved2: Reserved for future use; see the note on reserved space.
+ * @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and
+ *	%ETHTOOL_SPFLAGS commands; also the number of strings in the
+ *	%ETH_SS_PRIV_FLAGS set
+ * @n_stats: Number of uint64_t statistics returned by the %ETHTOOL_GSTATS
+ *	command; also the number of strings in the %ETH_SS_STATS set
+ * @testinfo_len: Number of results returned by the %ETHTOOL_TEST
+ *	command; also the number of strings in the %ETH_SS_TEST set
+ * @eedump_len: Size of EEPROM accessible through the %ETHTOOL_GEEPROM
+ *	and %ETHTOOL_SEEPROM commands, in bytes
+ * @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS
+ *	command, in bytes
+ *
+ * Users can use the %ETHTOOL_GSSET_INFO command to get the number of
+ * strings in any string set (from Linux 2.6.34).
+ *
+ * Drivers should set at most @driver, @version, @fw_version and
+ * @bus_info in their get_drvinfo() implementation.  The ethtool
+ * core fills in the other fields using other driver operations.
+ */
+struct ethtool_drvinfo {
+	uint32_t	cmd;
+	char	driver[32];
+	char	version[32];
+	char	fw_version[ETHTOOL_FWVERS_LEN];
+	char	bus_info[ETHTOOL_BUSINFO_LEN];
+	char	erom_version[ETHTOOL_EROMVERS_LEN];
+	char	reserved2[12];
+	uint32_t	n_priv_flags;
+	uint32_t	n_stats;
+	uint32_t	testinfo_len;
+	uint32_t	eedump_len;
+	uint32_t	regdump_len;
+};
+
+#define SOPASS_MAX	6
+
+/**
+ * struct ethtool_wolinfo - Wake-On-Lan configuration
+ * @cmd: Command number = %ETHTOOL_GWOL or %ETHTOOL_SWOL
+ * @supported: Bitmask of %WAKE_* flags for supported Wake-On-Lan modes.
+ *	Read-only.
+ * @wolopts: Bitmask of %WAKE_* flags for enabled Wake-On-Lan modes.
+ * @sopass: SecureOn(tm) password; meaningful only if %WAKE_MAGICSECURE
+ *	is set in @wolopts.
+ */
+struct ethtool_wolinfo {
+	uint32_t	cmd;
+	uint32_t	supported;
+	uint32_t	wolopts;
+	uint8_t	sopass[SOPASS_MAX];
+};
+
+/* for passing single values */
+struct ethtool_value {
+	uint32_t	cmd;
+	uint32_t	data;
+};
+
+#define PFC_STORM_PREVENTION_AUTO	0xffff
+#define PFC_STORM_PREVENTION_DISABLE	0
+
+enum tunable_id {
+	ETHTOOL_ID_UNSPEC,
+	ETHTOOL_RX_COPYBREAK,
+	ETHTOOL_TX_COPYBREAK,
+	ETHTOOL_PFC_PREVENTION_TOUT, /* timeout in msecs */
+	/*
+	 * Add your fresh new tunable attribute above and remember to update
+	 * tunable_strings[] in net/ethtool/common.c
+	 */
+	__ETHTOOL_TUNABLE_COUNT,
+};
+
+enum tunable_type_id {
+	ETHTOOL_TUNABLE_UNSPEC,
+	ETHTOOL_TUNABLE_U8,
+	ETHTOOL_TUNABLE_U16,
+	ETHTOOL_TUNABLE_U32,
+	ETHTOOL_TUNABLE_U64,
+	ETHTOOL_TUNABLE_STRING,
+	ETHTOOL_TUNABLE_S8,
+	ETHTOOL_TUNABLE_S16,
+	ETHTOOL_TUNABLE_S32,
+	ETHTOOL_TUNABLE_S64,
+};
+
+struct ethtool_tunable {
+	uint32_t	cmd;
+	uint32_t	id;
+	uint32_t	type_id;
+	uint32_t	len;
+	void	*data[0];
+};
+
+#define DOWNSHIFT_DEV_DEFAULT_COUNT	0xff
+#define DOWNSHIFT_DEV_DISABLE		0
+
+/* Time in msecs after which link is reported as down
+ * 0 = lowest time supported by the PHY
+ * 0xff = off, link down detection according to standard
+ */
+#define ETHTOOL_PHY_FAST_LINK_DOWN_ON	0
+#define ETHTOOL_PHY_FAST_LINK_DOWN_OFF	0xff
+
+/* Energy Detect Power Down (EDPD) is a feature supported by some PHYs, where
+ * the PHY's RX & TX blocks are put into a low-power mode when there is no
+ * link detected (typically cable is un-plugged). For RX, only a minimal
+ * link-detection is available, and for TX the PHY wakes up to send link pulses
+ * to avoid any lock-ups in case the peer PHY may also be running in EDPD mode.
+ *
+ * Some PHYs may support configuration of the wake-up interval for TX pulses,
+ * and some PHYs may support only disabling TX pulses entirely. For the latter
+ * a special value is required (ETHTOOL_PHY_EDPD_NO_TX) so that this can be
+ * configured from userspace (should the user want it).
+ *
+ * The interval units for TX wake-up are in milliseconds, since this should
+ * cover a reasonable range of intervals:
+ *  - from 1 millisecond, which does not sound like much of a power-saver
+ *  - to ~65 seconds which is quite a lot to wait for a link to come up when
+ *    plugging a cable
+ */
+#define ETHTOOL_PHY_EDPD_DFLT_TX_MSECS		0xffff
+#define ETHTOOL_PHY_EDPD_NO_TX			0xfffe
+#define ETHTOOL_PHY_EDPD_DISABLE		0
+
+enum phy_tunable_id {
+	ETHTOOL_PHY_ID_UNSPEC,
+	ETHTOOL_PHY_DOWNSHIFT,
+	ETHTOOL_PHY_FAST_LINK_DOWN,
+	ETHTOOL_PHY_EDPD,
+	/*
+	 * Add your fresh new phy tunable attribute above and remember to update
+	 * phy_tunable_strings[] in net/ethtool/common.c
+	 */
+	__ETHTOOL_PHY_TUNABLE_COUNT,
+};
+
+/**
+ * struct ethtool_regs - hardware register dump
+ * @cmd: Command number = %ETHTOOL_GREGS
+ * @version: Dump format version.  This is driver-specific and may
+ *	distinguish different chips/revisions.  Drivers must use new
+ *	version numbers whenever the dump format changes in an
+ *	incompatible way.
+ * @len: On entry, the real length of @data.  On return, the number of
+ *	bytes used.
+ * @data: Buffer for the register dump
+ *
+ * Users should use %ETHTOOL_GDRVINFO to find the maximum length of
+ * a register dump for the interface.  They must allocate the buffer
+ * immediately following this structure.
+ */
+struct ethtool_regs {
+	uint32_t	cmd;
+	uint32_t	version;
+	uint32_t	len;
+	uint8_t	data[0];
+};
+
+/**
+ * struct ethtool_eeprom - EEPROM dump
+ * @cmd: Command number = %ETHTOOL_GEEPROM, %ETHTOOL_GMODULEEEPROM or
+ *	%ETHTOOL_SEEPROM
+ * @magic: A 'magic cookie' value to guard against accidental changes.
+ *	The value passed in to %ETHTOOL_SEEPROM must match the value
+ *	returned by %ETHTOOL_GEEPROM for the same device.  This is
+ *	unused when @cmd is %ETHTOOL_GMODULEEEPROM.
+ * @offset: Offset within the EEPROM to begin reading/writing, in bytes
+ * @len: On entry, number of bytes to read/write.  On successful
+ *	return, number of bytes actually read/written.  In case of
+ *	error, this may indicate at what point the error occurred.
+ * @data: Buffer to read/write from
+ *
+ * Users may use %ETHTOOL_GDRVINFO or %ETHTOOL_GMODULEINFO to find
+ * the length of an on-board or module EEPROM, respectively.  They
+ * must allocate the buffer immediately following this structure.
+ */
+struct ethtool_eeprom {
+	uint32_t	cmd;
+	uint32_t	magic;
+	uint32_t	offset;
+	uint32_t	len;
+	uint8_t	data[0];
+};
+
+/**
+ * struct ethtool_eee - Energy Efficient Ethernet information
+ * @cmd: ETHTOOL_{G,S}EEE
+ * @supported: Mask of %SUPPORTED_* flags for the speed/duplex combinations
+ *	for which there is EEE support.
+ * @advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations
+ *	advertised as eee capable.
+ * @lp_advertised: Mask of %ADVERTISED_* flags for the speed/duplex
+ *	combinations advertised by the link partner as eee capable.
+ * @eee_active: Result of the eee auto negotiation.
+ * @eee_enabled: EEE configured mode (enabled/disabled).
+ * @tx_lpi_enabled: Whether the interface should assert its tx lpi, given
+ *	that eee was negotiated.
+ * @tx_lpi_timer: Time in microseconds the interface delays prior to asserting
+ *	its tx lpi (after reaching 'idle' state). Effective only when eee
+ *	was negotiated and tx_lpi_enabled was set.
+ * @reserved: Reserved for future use; see the note on reserved space.
+ */
+struct ethtool_eee {
+	uint32_t	cmd;
+	uint32_t	supported;
+	uint32_t	advertised;
+	uint32_t	lp_advertised;
+	uint32_t	eee_active;
+	uint32_t	eee_enabled;
+	uint32_t	tx_lpi_enabled;
+	uint32_t	tx_lpi_timer;
+	uint32_t	reserved[2];
+};
+
+/**
+ * struct ethtool_modinfo - plugin module eeprom information
+ * @cmd: %ETHTOOL_GMODULEINFO
+ * @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx
+ * @eeprom_len: Length of the eeprom
+ * @reserved: Reserved for future use; see the note on reserved space.
+ *
+ * This structure is used to return the information to
+ * properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.
+ * The type code indicates the eeprom data format
+ */
+struct ethtool_modinfo {
+	uint32_t   cmd;
+	uint32_t   type;
+	uint32_t   eeprom_len;
+	uint32_t   reserved[8];
+};
+
+/**
+ * struct ethtool_coalesce - coalescing parameters for IRQs and stats updates
+ * @cmd: ETHTOOL_{G,S}COALESCE
+ * @rx_coalesce_usecs: How many usecs to delay an RX interrupt after
+ *	a packet arrives.
+ * @rx_max_coalesced_frames: Maximum number of packets to receive
+ *	before an RX interrupt.
+ * @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that
+ *	this value applies while an IRQ is being serviced by the host.
+ * @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames,
+ *	except that this value applies while an IRQ is being serviced
+ *	by the host.
+ * @tx_coalesce_usecs: How many usecs to delay a TX interrupt after
+ *	a packet is sent.
+ * @tx_max_coalesced_frames: Maximum number of packets to be sent
+ *	before a TX interrupt.
+ * @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that
+ *	this value applies while an IRQ is being serviced by the host.
+ * @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames,
+ *	except that this value applies while an IRQ is being serviced
+ *	by the host.
+ * @stats_block_coalesce_usecs: How many usecs to delay in-memory
+ *	statistics block updates.  Some drivers do not have an
+ *	in-memory statistic block, and in such cases this value is
+ *	ignored.  This value must not be zero.
+ * @use_adaptive_rx_coalesce: Enable adaptive RX coalescing.
+ * @use_adaptive_tx_coalesce: Enable adaptive TX coalescing.
+ * @pkt_rate_low: Threshold for low packet rate (packets per second).
+ * @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after
+ *	a packet arrives, when the packet rate is below @pkt_rate_low.
+ * @rx_max_coalesced_frames_low: Maximum number of packets to be received
+ *	before an RX interrupt, when the packet rate is below @pkt_rate_low.
+ * @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after
+ *	a packet is sent, when the packet rate is below @pkt_rate_low.
+ * @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before
+ *	a TX interrupt, when the packet rate is below @pkt_rate_low.
+ * @pkt_rate_high: Threshold for high packet rate (packets per second).
+ * @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after
+ *	a packet arrives, when the packet rate is above @pkt_rate_high.
+ * @rx_max_coalesced_frames_high: Maximum number of packets to be received
+ *	before an RX interrupt, when the packet rate is above @pkt_rate_high.
+ * @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after
+ *	a packet is sent, when the packet rate is above @pkt_rate_high.
+ * @tx_max_coalesced_frames_high: Maximum number of packets to be sent before
+ *	a TX interrupt, when the packet rate is above @pkt_rate_high.
+ * @rate_sample_interval: How often to do adaptive coalescing packet rate
+ *	sampling, measured in seconds.  Must not be zero.
+ *
+ * Each pair of (usecs, max_frames) fields specifies that interrupts
+ * should be coalesced until
+ *	(usecs > 0 && time_since_first_completion >= usecs) ||
+ *	(max_frames > 0 && completed_frames >= max_frames)
+ *
+ * It is illegal to set both usecs and max_frames to zero as this
+ * would cause interrupts to never be generated.  To disable
+ * coalescing, set usecs = 0 and max_frames = 1.
+ *
+ * Some implementations ignore the value of max_frames and use the
+ * condition time_since_first_completion >= usecs
+ *
+ * This is deprecated.  Drivers for hardware that does not support
+ * counting completions should validate that max_frames == !rx_usecs.
+ *
+ * Adaptive RX/TX coalescing is an algorithm implemented by some
+ * drivers to improve latency under low packet rates and improve
+ * throughput under high packet rates.  Some drivers only implement
+ * one of RX or TX adaptive coalescing.  Anything not implemented by
+ * the driver causes these values to be silently ignored.
+ *
+ * When the packet rate is below @pkt_rate_high but above
+ * @pkt_rate_low (both measured in packets per second) the
+ * normal {rx,tx}_* coalescing parameters are used.
+ */
+struct ethtool_coalesce {
+	uint32_t	cmd;
+	uint32_t	rx_coalesce_usecs;
+	uint32_t	rx_max_coalesced_frames;
+	uint32_t	rx_coalesce_usecs_irq;
+	uint32_t	rx_max_coalesced_frames_irq;
+	uint32_t	tx_coalesce_usecs;
+	uint32_t	tx_max_coalesced_frames;
+	uint32_t	tx_coalesce_usecs_irq;
+	uint32_t	tx_max_coalesced_frames_irq;
+	uint32_t	stats_block_coalesce_usecs;
+	uint32_t	use_adaptive_rx_coalesce;
+	uint32_t	use_adaptive_tx_coalesce;
+	uint32_t	pkt_rate_low;
+	uint32_t	rx_coalesce_usecs_low;
+	uint32_t	rx_max_coalesced_frames_low;
+	uint32_t	tx_coalesce_usecs_low;
+	uint32_t	tx_max_coalesced_frames_low;
+	uint32_t	pkt_rate_high;
+	uint32_t	rx_coalesce_usecs_high;
+	uint32_t	rx_max_coalesced_frames_high;
+	uint32_t	tx_coalesce_usecs_high;
+	uint32_t	tx_max_coalesced_frames_high;
+	uint32_t	rate_sample_interval;
+};
+
+/**
+ * struct ethtool_ringparam - RX/TX ring parameters
+ * @cmd: Command number = %ETHTOOL_GRINGPARAM or %ETHTOOL_SRINGPARAM
+ * @rx_max_pending: Maximum supported number of pending entries per
+ *	RX ring.  Read-only.
+ * @rx_mini_max_pending: Maximum supported number of pending entries
+ *	per RX mini ring.  Read-only.
+ * @rx_jumbo_max_pending: Maximum supported number of pending entries
+ *	per RX jumbo ring.  Read-only.
+ * @tx_max_pending: Maximum supported number of pending entries per
+ *	TX ring.  Read-only.
+ * @rx_pending: Current maximum number of pending entries per RX ring
+ * @rx_mini_pending: Current maximum number of pending entries per RX
+ *	mini ring
+ * @rx_jumbo_pending: Current maximum number of pending entries per RX
+ *	jumbo ring
+ * @tx_pending: Current maximum supported number of pending entries
+ *	per TX ring
+ *
+ * If the interface does not have separate RX mini and/or jumbo rings,
+ * @rx_mini_max_pending and/or @rx_jumbo_max_pending will be 0.
+ *
+ * There may also be driver-dependent minimum values for the number
+ * of entries per ring.
+ */
+struct ethtool_ringparam {
+	uint32_t	cmd;
+	uint32_t	rx_max_pending;
+	uint32_t	rx_mini_max_pending;
+	uint32_t	rx_jumbo_max_pending;
+	uint32_t	tx_max_pending;
+	uint32_t	rx_pending;
+	uint32_t	rx_mini_pending;
+	uint32_t	rx_jumbo_pending;
+	uint32_t	tx_pending;
+};
+
+/**
+ * struct ethtool_channels - configuring number of network channel
+ * @cmd: ETHTOOL_{G,S}CHANNELS
+ * @max_rx: Read only. Maximum number of receive channel the driver support.
+ * @max_tx: Read only. Maximum number of transmit channel the driver support.
+ * @max_other: Read only. Maximum number of other channel the driver support.
+ * @max_combined: Read only. Maximum number of combined channel the driver
+ *	support. Set of queues RX, TX or other.
+ * @rx_count: Valid values are in the range 1 to the max_rx.
+ * @tx_count: Valid values are in the range 1 to the max_tx.
+ * @other_count: Valid values are in the range 1 to the max_other.
+ * @combined_count: Valid values are in the range 1 to the max_combined.
+ *
+ * This can be used to configure RX, TX and other channels.
+ */
+
+struct ethtool_channels {
+	uint32_t	cmd;
+	uint32_t	max_rx;
+	uint32_t	max_tx;
+	uint32_t	max_other;
+	uint32_t	max_combined;
+	uint32_t	rx_count;
+	uint32_t	tx_count;
+	uint32_t	other_count;
+	uint32_t	combined_count;
+};
+
+/**
+ * struct ethtool_pauseparam - Ethernet pause (flow control) parameters
+ * @cmd: Command number = %ETHTOOL_GPAUSEPARAM or %ETHTOOL_SPAUSEPARAM
+ * @autoneg: Flag to enable autonegotiation of pause frame use
+ * @rx_pause: Flag to enable reception of pause frames
+ * @tx_pause: Flag to enable transmission of pause frames
+ *
+ * Drivers should reject a non-zero setting of @autoneg when
+ * autoneogotiation is disabled (or not supported) for the link.
+ *
+ * If the link is autonegotiated, drivers should use
+ * mii_advertise_flowctrl() or similar code to set the advertised
+ * pause frame capabilities based on the @rx_pause and @tx_pause flags,
+ * even if @autoneg is zero.  They should also allow the advertised
+ * pause frame capabilities to be controlled directly through the
+ * advertising field of &struct ethtool_cmd.
+ *
+ * If @autoneg is non-zero, the MAC is configured to send and/or
+ * receive pause frames according to the result of autonegotiation.
+ * Otherwise, it is configured directly based on the @rx_pause and
+ * @tx_pause flags.
+ */
+struct ethtool_pauseparam {
+	uint32_t	cmd;
+	uint32_t	autoneg;
+	uint32_t	rx_pause;
+	uint32_t	tx_pause;
+};
+
+/* Link extended state */
+enum ethtool_link_ext_state {
+	ETHTOOL_LINK_EXT_STATE_AUTONEG,
+	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE,
+	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH,
+	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY,
+	ETHTOOL_LINK_EXT_STATE_NO_CABLE,
+	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE,
+	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE,
+	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE,
+	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED,
+	ETHTOOL_LINK_EXT_STATE_OVERHEAT,
+};
+
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_AUTONEG. */
+enum ethtool_link_ext_substate_autoneg {
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD,
+};
+
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE.
+ */
+enum ethtool_link_ext_substate_link_training {
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT,
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY,
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT,
+};
+
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH.
+ */
+enum ethtool_link_ext_substate_link_logical_mismatch {
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED,
+};
+
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY.
+ */
+enum ethtool_link_ext_substate_bad_signal_integrity {
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE,
+};
+
+/* More information in addition to ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE. */
+enum ethtool_link_ext_substate_cable_issue {
+	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE,
+};
+
+#define ETH_GSTRING_LEN		32
+
+/**
+ * enum ethtool_stringset - string set ID
+ * @ETH_SS_TEST: Self-test result names, for use with %ETHTOOL_TEST
+ * @ETH_SS_STATS: Statistic names, for use with %ETHTOOL_GSTATS
+ * @ETH_SS_PRIV_FLAGS: Driver private flag names, for use with
+ *	%ETHTOOL_GPFLAGS and %ETHTOOL_SPFLAGS
+ * @ETH_SS_NTUPLE_FILTERS: Previously used with %ETHTOOL_GRXNTUPLE;
+ *	now deprecated
+ * @ETH_SS_FEATURES: Device feature names
+ * @ETH_SS_RSS_HASH_FUNCS: RSS hush function names
+ * @ETH_SS_TUNABLES: tunable names
+ * @ETH_SS_PHY_STATS: Statistic names, for use with %ETHTOOL_GPHYSTATS
+ * @ETH_SS_PHY_TUNABLES: PHY tunable names
+ * @ETH_SS_LINK_MODES: link mode names
+ * @ETH_SS_MSG_CLASSES: debug message class names
+ * @ETH_SS_WOL_MODES: wake-on-lan modes
+ * @ETH_SS_SOF_TIMESTAMPING: SOF_TIMESTAMPING_* flags
+ * @ETH_SS_TS_TX_TYPES: timestamping Tx types
+ * @ETH_SS_TS_RX_FILTERS: timestamping Rx filters
+ * @ETH_SS_UDP_TUNNEL_TYPES: UDP tunnel types
+ * @ETH_SS_STATS_STD: standardized stats
+ * @ETH_SS_STATS_ETH_PHY: names of IEEE 802.3 PHY statistics
+ * @ETH_SS_STATS_ETH_MAC: names of IEEE 802.3 MAC statistics
+ * @ETH_SS_STATS_ETH_CTRL: names of IEEE 802.3 MAC Control statistics
+ * @ETH_SS_STATS_RMON: names of RMON statistics
+ *
+ * @ETH_SS_COUNT: number of defined string sets
+ */
+enum ethtool_stringset {
+	ETH_SS_TEST		= 0,
+	ETH_SS_STATS,
+	ETH_SS_PRIV_FLAGS,
+	ETH_SS_NTUPLE_FILTERS,
+	ETH_SS_FEATURES,
+	ETH_SS_RSS_HASH_FUNCS,
+	ETH_SS_TUNABLES,
+	ETH_SS_PHY_STATS,
+	ETH_SS_PHY_TUNABLES,
+	ETH_SS_LINK_MODES,
+	ETH_SS_MSG_CLASSES,
+	ETH_SS_WOL_MODES,
+	ETH_SS_SOF_TIMESTAMPING,
+	ETH_SS_TS_TX_TYPES,
+	ETH_SS_TS_RX_FILTERS,
+	ETH_SS_UDP_TUNNEL_TYPES,
+	ETH_SS_STATS_STD,
+	ETH_SS_STATS_ETH_PHY,
+	ETH_SS_STATS_ETH_MAC,
+	ETH_SS_STATS_ETH_CTRL,
+	ETH_SS_STATS_RMON,
+
+	/* add new constants above here */
+	ETH_SS_COUNT
+};
+
+/**
+ * struct ethtool_gstrings - string set for data tagging
+ * @cmd: Command number = %ETHTOOL_GSTRINGS
+ * @string_set: String set ID; one of &enum ethtool_stringset
+ * @len: On return, the number of strings in the string set
+ * @data: Buffer for strings.  Each string is null-padded to a size of
+ *	%ETH_GSTRING_LEN.
+ *
+ * Users must use %ETHTOOL_GSSET_INFO to find the number of strings in
+ * the string set.  They must allocate a buffer of the appropriate
+ * size immediately following this structure.
+ */
+struct ethtool_gstrings {
+	uint32_t	cmd;
+	uint32_t	string_set;
+	uint32_t	len;
+	uint8_t	data[0];
+};
+
+/**
+ * struct ethtool_sset_info - string set information
+ * @cmd: Command number = %ETHTOOL_GSSET_INFO
+ * @reserved: Reserved for future use; see the note on reserved space.
+ * @sset_mask: On entry, a bitmask of string sets to query, with bits
+ *	numbered according to &enum ethtool_stringset.  On return, a
+ *	bitmask of those string sets queried that are supported.
+ * @data: Buffer for string set sizes.  On return, this contains the
+ *	size of each string set that was queried and supported, in
+ *	order of ID.
+ *
+ * Example: The user passes in @sset_mask = 0x7 (sets 0, 1, 2) and on
+ * return @sset_mask == 0x6 (sets 1, 2).  Then @data[0] contains the
+ * size of set 1 and @data[1] contains the size of set 2.
+ *
+ * Users must allocate a buffer of the appropriate size (4 * number of
+ * sets queried) immediately following this structure.
+ */
+struct ethtool_sset_info {
+	uint32_t	cmd;
+	uint32_t	reserved;
+	uint64_t	sset_mask;
+	uint32_t	data[0];
+};
+
+/**
+ * enum ethtool_test_flags - flags definition of ethtool_test
+ * @ETH_TEST_FL_OFFLINE: if set perform online and offline tests, otherwise
+ *	only online tests.
+ * @ETH_TEST_FL_FAILED: Driver set this flag if test fails.
+ * @ETH_TEST_FL_EXTERNAL_LB: Application request to perform external loopback
+ *	test.
+ * @ETH_TEST_FL_EXTERNAL_LB_DONE: Driver performed the external loopback test
+ */
+
+enum ethtool_test_flags {
+	ETH_TEST_FL_OFFLINE	= (1 << 0),
+	ETH_TEST_FL_FAILED	= (1 << 1),
+	ETH_TEST_FL_EXTERNAL_LB	= (1 << 2),
+	ETH_TEST_FL_EXTERNAL_LB_DONE	= (1 << 3),
+};
+
+/**
+ * struct ethtool_test - device self-test invocation
+ * @cmd: Command number = %ETHTOOL_TEST
+ * @flags: A bitmask of flags from &enum ethtool_test_flags.  Some
+ *	flags may be set by the user on entry; others may be set by
+ *	the driver on return.
+ * @reserved: Reserved for future use; see the note on reserved space.
+ * @len: On return, the number of test results
+ * @data: Array of test results
+ *
+ * Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the
+ * number of test results that will be returned.  They must allocate a
+ * buffer of the appropriate size (8 * number of results) immediately
+ * following this structure.
+ */
+struct ethtool_test {
+	uint32_t	cmd;
+	uint32_t	flags;
+	uint32_t	reserved;
+	uint32_t	len;
+	uint64_t	data[0];
+};
+
+/**
+ * struct ethtool_stats - device-specific statistics
+ * @cmd: Command number = %ETHTOOL_GSTATS
+ * @n_stats: On return, the number of statistics
+ * @data: Array of statistics
+ *
+ * Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the
+ * number of statistics that will be returned.  They must allocate a
+ * buffer of the appropriate size (8 * number of statistics)
+ * immediately following this structure.
+ */
+struct ethtool_stats {
+	uint32_t	cmd;
+	uint32_t	n_stats;
+	uint64_t	data[0];
+};
+
+/**
+ * struct ethtool_perm_addr - permanent hardware address
+ * @cmd: Command number = %ETHTOOL_GPERMADDR
+ * @size: On entry, the size of the buffer.  On return, the size of the
+ *	address.  The command fails if the buffer is too small.
+ * @data: Buffer for the address
+ *
+ * Users must allocate the buffer immediately following this structure.
+ * A buffer size of %MAX_ADDR_LEN should be sufficient for any address
+ * type.
+ */
+struct ethtool_perm_addr {
+	uint32_t	cmd;
+	uint32_t	size;
+	uint8_t	data[0];
+};
+
+/* boolean flags controlling per-interface behavior characteristics.
+ * When reading, the flag indicates whether or not a certain behavior
+ * is enabled/present.  When writing, the flag indicates whether
+ * or not the driver should turn on (set) or off (clear) a behavior.
+ *
+ * Some behaviors may read-only (unconditionally absent or present).
+ * If such is the case, return EINVAL in the set-flags operation if the
+ * flag differs from the read-only value.
+ */
+enum ethtool_flags {
+	ETH_FLAG_TXVLAN		= (1 << 7),	/* TX VLAN offload enabled */
+	ETH_FLAG_RXVLAN		= (1 << 8),	/* RX VLAN offload enabled */
+	ETH_FLAG_LRO		= (1 << 15),	/* LRO is enabled */
+	ETH_FLAG_NTUPLE		= (1 << 27),	/* N-tuple filters enabled */
+	ETH_FLAG_RXHASH		= (1 << 28),
+};
+
+/* The following structures are for supporting RX network flow
+ * classification and RX n-tuple configuration. Note, all multibyte
+ * fields, e.g., ip4src, ip4dst, psrc, pdst, spi, etc. are expected to
+ * be in network byte order.
+ */
+
+/**
+ * struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc.
+ * @ip4src: Source host
+ * @ip4dst: Destination host
+ * @psrc: Source port
+ * @pdst: Destination port
+ * @tos: Type-of-service
+ *
+ * This can be used to specify a TCP/IPv4, UDP/IPv4 or SCTP/IPv4 flow.
+ */
+struct ethtool_tcpip4_spec {
+	uint32_t	ip4src;
+	uint32_t	ip4dst;
+	uint16_t	psrc;
+	uint16_t	pdst;
+	uint8_t    tos;
+};
+
+/**
+ * struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4
+ * @ip4src: Source host
+ * @ip4dst: Destination host
+ * @spi: Security parameters index
+ * @tos: Type-of-service
+ *
+ * This can be used to specify an IPsec transport or tunnel over IPv4.
+ */
+struct ethtool_ah_espip4_spec {
+	uint32_t	ip4src;
+	uint32_t	ip4dst;
+	uint32_t	spi;
+	uint8_t    tos;
+};
+
+#define	ETH_RX_NFC_IP4	1
+
+/**
+ * struct ethtool_usrip4_spec - general flow specification for IPv4
+ * @ip4src: Source host
+ * @ip4dst: Destination host
+ * @l4_4_bytes: First 4 bytes of transport (layer 4) header
+ * @tos: Type-of-service
+ * @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0
+ * @proto: Transport protocol number; mask must be 0
+ */
+struct ethtool_usrip4_spec {
+	uint32_t	ip4src;
+	uint32_t	ip4dst;
+	uint32_t	l4_4_bytes;
+	uint8_t    tos;
+	uint8_t    ip_ver;
+	uint8_t    proto;
+};
+
+/**
+ * struct ethtool_tcpip6_spec - flow specification for TCP/IPv6 etc.
+ * @ip6src: Source host
+ * @ip6dst: Destination host
+ * @psrc: Source port
+ * @pdst: Destination port
+ * @tclass: Traffic Class
+ *
+ * This can be used to specify a TCP/IPv6, UDP/IPv6 or SCTP/IPv6 flow.
+ */
+struct ethtool_tcpip6_spec {
+	uint32_t	ip6src[4];
+	uint32_t	ip6dst[4];
+	uint16_t	psrc;
+	uint16_t	pdst;
+	uint8_t    tclass;
+};
+
+/**
+ * struct ethtool_ah_espip6_spec - flow specification for IPsec/IPv6
+ * @ip6src: Source host
+ * @ip6dst: Destination host
+ * @spi: Security parameters index
+ * @tclass: Traffic Class
+ *
+ * This can be used to specify an IPsec transport or tunnel over IPv6.
+ */
+struct ethtool_ah_espip6_spec {
+	uint32_t	ip6src[4];
+	uint32_t	ip6dst[4];
+	uint32_t	spi;
+	uint8_t    tclass;
+};
+
+/**
+ * struct ethtool_usrip6_spec - general flow specification for IPv6
+ * @ip6src: Source host
+ * @ip6dst: Destination host
+ * @l4_4_bytes: First 4 bytes of transport (layer 4) header
+ * @tclass: Traffic Class
+ * @l4_proto: Transport protocol number (nexthdr after any Extension Headers)
+ */
+struct ethtool_usrip6_spec {
+	uint32_t	ip6src[4];
+	uint32_t	ip6dst[4];
+	uint32_t	l4_4_bytes;
+	uint8_t    tclass;
+	uint8_t    l4_proto;
+};
+
+union ethtool_flow_union {
+	struct ethtool_tcpip4_spec		tcp_ip4_spec;
+	struct ethtool_tcpip4_spec		udp_ip4_spec;
+	struct ethtool_tcpip4_spec		sctp_ip4_spec;
+	struct ethtool_ah_espip4_spec		ah_ip4_spec;
+	struct ethtool_ah_espip4_spec		esp_ip4_spec;
+	struct ethtool_usrip4_spec		usr_ip4_spec;
+	struct ethtool_tcpip6_spec		tcp_ip6_spec;
+	struct ethtool_tcpip6_spec		udp_ip6_spec;
+	struct ethtool_tcpip6_spec		sctp_ip6_spec;
+	struct ethtool_ah_espip6_spec		ah_ip6_spec;
+	struct ethtool_ah_espip6_spec		esp_ip6_spec;
+	struct ethtool_usrip6_spec		usr_ip6_spec;
+	struct eth_header				ether_spec;
+	uint8_t					hdata[52];
+};
+
+/**
+ * struct ethtool_flow_ext - additional RX flow fields
+ * @h_dest: destination MAC address
+ * @vlan_etype: VLAN EtherType
+ * @vlan_tci: VLAN tag control information
+ * @data: user defined data
+ * @padding: Reserved for future use; see the note on reserved space.
+ *
+ * Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT
+ * is set in &struct ethtool_rx_flow_spec @flow_type.
+ * @h_dest is valid if %FLOW_MAC_EXT is set.
+ */
+struct ethtool_flow_ext {
+	uint8_t		padding[2];
+	unsigned char	h_dest[ETH_ALEN];
+	uint16_t		vlan_etype;
+	uint16_t		vlan_tci;
+	uint32_t		data[2];
+};
+
+/**
+ * struct ethtool_rx_flow_spec - classification rule for RX flows
+ * @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW
+ * @h_u: Flow fields to match (dependent on @flow_type)
+ * @h_ext: Additional fields to match
+ * @m_u: Masks for flow field bits to be matched
+ * @m_ext: Masks for additional field bits to be matched
+ *	Note, all additional fields must be ignored unless @flow_type
+ *	includes the %FLOW_EXT or %FLOW_MAC_EXT flag
+ *	(see &struct ethtool_flow_ext description).
+ * @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC
+ *	if packets should be discarded, or %RX_CLS_FLOW_WAKE if the
+ *	packets should be used for Wake-on-LAN with %WAKE_FILTER
+ * @location: Location of rule in the table.  Locations must be
+ *	numbered such that a flow matching multiple rules will be
+ *	classified according to the first (lowest numbered) rule.
+ */
+struct ethtool_rx_flow_spec {
+	uint32_t		flow_type;
+	union ethtool_flow_union h_u;
+	struct ethtool_flow_ext h_ext;
+	union ethtool_flow_union m_u;
+	struct ethtool_flow_ext m_ext;
+	uint64_t		ring_cookie;
+	uint32_t		location;
+};
+
+/* How rings are laid out when accessing virtual functions or
+ * offloaded queues is device specific. To allow users to do flow
+ * steering and specify these queues the ring cookie is partitioned
+ * into a 32bit queue index with an 8 bit virtual function id.
+ * This also leaves the 3bytes for further specifiers. It is possible
+ * future devices may support more than 256 virtual functions if
+ * devices start supporting PCIe w/ARI. However at the moment I
+ * do not know of any devices that support this so I do not reserve
+ * space for this at this time. If a future patch consumes the next
+ * byte it should be aware of this possibility.
+ */
+#define ETHTOOL_RX_FLOW_SPEC_RING	0x00000000FFFFFFFFLL
+#define ETHTOOL_RX_FLOW_SPEC_RING_VF	0x000000FF00000000LL
+#define ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF 32
+static inline uint64_t ethtool_get_flow_spec_ring(uint64_t ring_cookie)
+{
+	return ETHTOOL_RX_FLOW_SPEC_RING & ring_cookie;
+}
+
+static inline uint64_t ethtool_get_flow_spec_ring_vf(uint64_t ring_cookie)
+{
+	return (ETHTOOL_RX_FLOW_SPEC_RING_VF & ring_cookie) >>
+				ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;
+}
+
+/**
+ * struct ethtool_rxnfc - command to get or set RX flow classification rules
+ * @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH,
+ *	%ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE,
+ *	%ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS
+ * @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW
+ * @data: Command-dependent value
+ * @fs: Flow classification rule
+ * @rss_context: RSS context to be affected
+ * @rule_cnt: Number of rules to be affected
+ * @rule_locs: Array of used rule locations
+ *
+ * For %ETHTOOL_GRXFH and %ETHTOOL_SRXFH, @data is a bitmask indicating
+ * the fields included in the flow hash, e.g. %RXH_IP_SRC.  The following
+ * structure fields must not be used, except that if @flow_type includes
+ * the %FLOW_RSS flag, then @rss_context determines which RSS context to
+ * act on.
+ *
+ * For %ETHTOOL_GRXRINGS, @data is set to the number of RX rings/queues
+ * on return.
+ *
+ * For %ETHTOOL_GRXCLSRLCNT, @rule_cnt is set to the number of defined
+ * rules on return.  If @data is non-zero on return then it is the
+ * size of the rule table, plus the flag %RX_CLS_LOC_SPECIAL if the
+ * driver supports any special location values.  If that flag is not
+ * set in @data then special location values should not be used.
+ *
+ * For %ETHTOOL_GRXCLSRULE, @fs.@location specifies the location of an
+ * existing rule on entry and @fs contains the rule on return; if
+ * @fs.@flow_type includes the %FLOW_RSS flag, then @rss_context is
+ * filled with the RSS context ID associated with the rule.
+ *
+ * For %ETHTOOL_GRXCLSRLALL, @rule_cnt specifies the array size of the
+ * user buffer for @rule_locs on entry.  On return, @data is the size
+ * of the rule table, @rule_cnt is the number of defined rules, and
+ * @rule_locs contains the locations of the defined rules.  Drivers
+ * must use the second parameter to get_rxnfc() instead of @rule_locs.
+ *
+ * For %ETHTOOL_SRXCLSRLINS, @fs specifies the rule to add or update.
+ * @fs.@location either specifies the location to use or is a special
+ * location value with %RX_CLS_LOC_SPECIAL flag set.  On return,
+ * @fs.@location is the actual rule location.  If @fs.@flow_type
+ * includes the %FLOW_RSS flag, @rss_context is the RSS context ID to
+ * use for flow spreading traffic which matches this rule.  The value
+ * from the rxfh indirection table will be added to @fs.@ring_cookie
+ * to choose which ring to deliver to.
+ *
+ * For %ETHTOOL_SRXCLSRLDEL, @fs.@location specifies the location of an
+ * existing rule on entry.
+ *
+ * A driver supporting the special location values for
+ * %ETHTOOL_SRXCLSRLINS may add the rule at any suitable unused
+ * location, and may remove a rule at a later location (lower
+ * priority) that matches exactly the same set of flows.  The special
+ * values are %RX_CLS_LOC_ANY, selecting any location;
+ * %RX_CLS_LOC_FIRST, selecting the first suitable location (maximum
+ * priority); and %RX_CLS_LOC_LAST, selecting the last suitable
+ * location (minimum priority).  Additional special values may be
+ * defined in future and drivers must return -%EINVAL for any
+ * unrecognised value.
+ */
+struct ethtool_rxnfc {
+	uint32_t				cmd;
+	uint32_t				flow_type;
+	uint64_t				data;
+	struct ethtool_rx_flow_spec	fs;
+	union {
+		uint32_t			rule_cnt;
+		uint32_t			rss_context;
+	};
+	uint32_t				rule_locs[0];
+};
+
+
+/**
+ * struct ethtool_rxfh_indir - command to get or set RX flow hash indirection
+ * @cmd: Specific command number - %ETHTOOL_GRXFHINDIR or %ETHTOOL_SRXFHINDIR
+ * @size: On entry, the array size of the user buffer, which may be zero.
+ *	On return from %ETHTOOL_GRXFHINDIR, the array size of the hardware
+ *	indirection table.
+ * @ring_index: RX ring/queue index for each hash value
+ *
+ * For %ETHTOOL_GRXFHINDIR, a @size of zero means that only the size
+ * should be returned.  For %ETHTOOL_SRXFHINDIR, a @size of zero means
+ * the table should be reset to default values.  This last feature
+ * is not supported by the original implementations.
+ */
+struct ethtool_rxfh_indir {
+	uint32_t	cmd;
+	uint32_t	size;
+	uint32_t	ring_index[0];
+};
+
+/**
+ * struct ethtool_rxfh - command to get/set RX flow hash indir or/and hash key.
+ * @cmd: Specific command number - %ETHTOOL_GRSSH or %ETHTOOL_SRSSH
+ * @rss_context: RSS context identifier.  Context 0 is the default for normal
+ *	traffic; other contexts can be referenced as the destination for RX flow
+ *	classification rules.  %ETH_RXFH_CONTEXT_ALLOC is used with command
+ *	%ETHTOOL_SRSSH to allocate a new RSS context; on return this field will
+ *	contain the ID of the newly allocated context.
+ * @indir_size: On entry, the array size of the user buffer for the
+ *	indirection table, which may be zero, or (for %ETHTOOL_SRSSH),
+ *	%ETH_RXFH_INDIR_NO_CHANGE.  On return from %ETHTOOL_GRSSH,
+ *	the array size of the hardware indirection table.
+ * @key_size: On entry, the array size of the user buffer for the hash key,
+ *	which may be zero.  On return from %ETHTOOL_GRSSH, the size of the
+ *	hardware hash key.
+ * @hfunc: Defines the current RSS hash function used by HW (or to be set to).
+ *	Valid values are one of the %ETH_RSS_HASH_*.
+ * @rsvd8: Reserved for future use; see the note on reserved space.
+ * @rsvd32: Reserved for future use; see the note on reserved space.
+ * @rss_config: RX ring/queue index for each hash value i.e., indirection table
+ *	of @indir_size uint32_t elements, followed by hash key of @key_size
+ *	bytes.
+ *
+ * For %ETHTOOL_GRSSH, a @indir_size and key_size of zero means that only the
+ * size should be returned.  For %ETHTOOL_SRSSH, an @indir_size of
+ * %ETH_RXFH_INDIR_NO_CHANGE means that indir table setting is not requested
+ * and a @indir_size of zero means the indir table should be reset to default
+ * values (if @rss_context == 0) or that the RSS context should be deleted.
+ * An hfunc of zero means that hash function setting is not requested.
+ */
+struct ethtool_rxfh {
+	uint32_t   cmd;
+	uint32_t	rss_context;
+	uint32_t   indir_size;
+	uint32_t   key_size;
+	uint8_t	hfunc;
+	uint8_t	rsvd8[3];
+	uint32_t	rsvd32;
+	uint32_t   rss_config[0];
+};
+#define ETH_RXFH_CONTEXT_ALLOC		0xffffffff
+#define ETH_RXFH_INDIR_NO_CHANGE	0xffffffff
+
+/**
+ * struct ethtool_rx_ntuple_flow_spec - specification for RX flow filter
+ * @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW
+ * @h_u: Flow field values to match (dependent on @flow_type)
+ * @m_u: Masks for flow field value bits to be ignored
+ * @vlan_tag: VLAN tag to match
+ * @vlan_tag_mask: Mask for VLAN tag bits to be ignored
+ * @data: Driver-dependent data to match
+ * @data_mask: Mask for driver-dependent data bits to be ignored
+ * @action: RX ring/queue index to deliver to (non-negative) or other action
+ *	(negative, e.g. %ETHTOOL_RXNTUPLE_ACTION_DROP)
+ *
+ * For flow types %TCP_V4_FLOW, %UDP_V4_FLOW and %SCTP_V4_FLOW, where
+ * a field value and mask are both zero this is treated as if all mask
+ * bits are set i.e. the field is ignored.
+ */
+struct ethtool_rx_ntuple_flow_spec {
+	uint32_t		 flow_type;
+	union {
+		struct ethtool_tcpip4_spec		tcp_ip4_spec;
+		struct ethtool_tcpip4_spec		udp_ip4_spec;
+		struct ethtool_tcpip4_spec		sctp_ip4_spec;
+		struct ethtool_ah_espip4_spec		ah_ip4_spec;
+		struct ethtool_ah_espip4_spec		esp_ip4_spec;
+		struct ethtool_usrip4_spec		usr_ip4_spec;
+		struct eth_header				ether_spec;
+		uint8_t					hdata[72];
+	} h_u, m_u;
+
+	uint16_t	        vlan_tag;
+	uint16_t	        vlan_tag_mask;
+	uint64_t		data;
+	uint64_t		data_mask;
+
+	int32_t		action;
+#define ETHTOOL_RXNTUPLE_ACTION_DROP	(-1)	/* drop packet */
+#define ETHTOOL_RXNTUPLE_ACTION_CLEAR	(-2)	/* clear filter */
+};
+
+/**
+ * struct ethtool_rx_ntuple - command to set or clear RX flow filter
+ * @cmd: Command number - %ETHTOOL_SRXNTUPLE
+ * @fs: Flow filter specification
+ */
+struct ethtool_rx_ntuple {
+	uint32_t					cmd;
+	struct ethtool_rx_ntuple_flow_spec	fs;
+};
+
+#define ETHTOOL_FLASH_MAX_FILENAME	128
+enum ethtool_flash_op_type {
+	ETHTOOL_FLASH_ALL_REGIONS	= 0,
+};
+
+/* for passing firmware flashing related parameters */
+struct ethtool_flash {
+	uint32_t	cmd;
+	uint32_t	region;
+	char	data[ETHTOOL_FLASH_MAX_FILENAME];
+};
+
+/**
+ * struct ethtool_dump - used for retrieving, setting device dump
+ * @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or
+ * 	%ETHTOOL_SET_DUMP
+ * @version: FW version of the dump, filled in by driver
+ * @flag: driver dependent flag for dump setting, filled in by driver during
+ *        get and filled in by ethtool for set operation.
+ *        flag must be initialized by macro ETH_FW_DUMP_DISABLE value when
+ *        firmware dump is disabled.
+ * @len: length of dump data, used as the length of the user buffer on entry to
+ * 	 %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver
+ * 	 for %ETHTOOL_GET_DUMP_FLAG command
+ * @data: data collected for get dump data operation
+ */
+struct ethtool_dump {
+	uint32_t	cmd;
+	uint32_t	version;
+	uint32_t	flag;
+	uint32_t	len;
+	uint8_t	data[0];
+};
+
+#define ETH_FW_DUMP_DISABLE 0
+
+/* for returning and changing feature sets */
+
+/**
+ * struct ethtool_get_features_block - block with state of 32 features
+ * @available: mask of changeable features
+ * @requested: mask of features requested to be enabled if possible
+ * @active: mask of currently enabled features
+ * @never_changed: mask of features not changeable for any device
+ */
+struct ethtool_get_features_block {
+	uint32_t	available;
+	uint32_t	requested;
+	uint32_t	active;
+	uint32_t	never_changed;
+};
+
+/**
+ * struct ethtool_gfeatures - command to get state of device's features
+ * @cmd: command number = %ETHTOOL_GFEATURES
+ * @size: On entry, the number of elements in the features[] array;
+ *	on return, the number of elements in features[] needed to hold
+ *	all features
+ * @features: state of features
+ */
+struct ethtool_gfeatures {
+	uint32_t	cmd;
+	uint32_t	size;
+	struct ethtool_get_features_block features[0];
+};
+
+/**
+ * struct ethtool_set_features_block - block with request for 32 features
+ * @valid: mask of features to be changed
+ * @requested: values of features to be changed
+ */
+struct ethtool_set_features_block {
+	uint32_t	valid;
+	uint32_t	requested;
+};
+
+/**
+ * struct ethtool_sfeatures - command to request change in device's features
+ * @cmd: command number = %ETHTOOL_SFEATURES
+ * @size: array size of the features[] array
+ * @features: feature change masks
+ */
+struct ethtool_sfeatures {
+	uint32_t	cmd;
+	uint32_t	size;
+	struct ethtool_set_features_block features[0];
+};
+
+/**
+ * struct ethtool_ts_info - holds a device's timestamping and PHC association
+ * @cmd: command number = %ETHTOOL_GET_TS_INFO
+ * @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags
+ * @phc_index: device index of the associated PHC, or -1 if there is none
+ * @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values
+ * @tx_reserved: Reserved for future use; see the note on reserved space.
+ * @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values
+ * @rx_reserved: Reserved for future use; see the note on reserved space.
+ *
+ * The bits in the 'tx_types' and 'rx_filters' fields correspond to
+ * the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,
+ * respectively.  For example, if the device supports HWTSTAMP_TX_ON,
+ * then (1 << HWTSTAMP_TX_ON) in 'tx_types' will be set.
+ *
+ * Drivers should only report the filters they actually support without
+ * upscaling in the SIOCSHWTSTAMP ioctl. If the SIOCSHWSTAMP request for
+ * HWTSTAMP_FILTER_V1_SYNC is supported by HWTSTAMP_FILTER_V1_EVENT, then the
+ * driver should only report HWTSTAMP_FILTER_V1_EVENT in this op.
+ */
+struct ethtool_ts_info {
+	uint32_t	cmd;
+	uint32_t	so_timestamping;
+	int32_t	phc_index;
+	uint32_t	tx_types;
+	uint32_t	tx_reserved[3];
+	uint32_t	rx_filters;
+	uint32_t	rx_reserved[3];
+};
+
+/*
+ * %ETHTOOL_SFEATURES changes features present in features[].valid to the
+ * values of corresponding bits in features[].requested. Bits in .requested
+ * not set in .valid or not changeable are ignored.
+ *
+ * Returns %EINVAL when .valid contains undefined or never-changeable bits
+ * or size is not equal to required number of features words (32-bit blocks).
+ * Returns >= 0 if request was completed; bits set in the value mean:
+ *   %ETHTOOL_F_UNSUPPORTED - there were bits set in .valid that are not
+ *	changeable (not present in %ETHTOOL_GFEATURES' features[].available)
+ *	those bits were ignored.
+ *   %ETHTOOL_F_WISH - some or all changes requested were recorded but the
+ *      resulting state of bits masked by .valid is not equal to .requested.
+ *      Probably there are other device-specific constraints on some features
+ *      in the set. When %ETHTOOL_F_UNSUPPORTED is set, .valid is considered
+ *      here as though ignored bits were cleared.
+ *   %ETHTOOL_F_COMPAT - some or all changes requested were made by calling
+ *      compatibility functions. Requested offload state cannot be properly
+ *      managed by kernel.
+ *
+ * Meaning of bits in the masks are obtained by %ETHTOOL_GSSET_INFO (number of
+ * bits in the arrays - always multiple of 32) and %ETHTOOL_GSTRINGS commands
+ * for ETH_SS_FEATURES string set. First entry in the table corresponds to least
+ * significant bit in features[0] fields. Empty strings mark undefined features.
+ */
+enum ethtool_sfeatures_retval_bits {
+	ETHTOOL_F_UNSUPPORTED__BIT,
+	ETHTOOL_F_WISH__BIT,
+	ETHTOOL_F_COMPAT__BIT,
+};
+
+#define ETHTOOL_F_UNSUPPORTED   (1 << ETHTOOL_F_UNSUPPORTED__BIT)
+#define ETHTOOL_F_WISH          (1 << ETHTOOL_F_WISH__BIT)
+#define ETHTOOL_F_COMPAT        (1 << ETHTOOL_F_COMPAT__BIT)
+
+#define MAX_NUM_QUEUE		4096
+
+/**
+ * struct ethtool_per_queue_op - apply sub command to the queues in mask.
+ * @cmd: ETHTOOL_PERQUEUE
+ * @sub_command: the sub command which apply to each queues
+ * @queue_mask: Bitmap of the queues which sub command apply to
+ * @data: A complete command structure following for each of the queues addressed
+ */
+struct ethtool_per_queue_op {
+	uint32_t	cmd;
+	uint32_t	sub_command;
+	uint32_t	queue_mask[__KERNEL_DIV_ROUND_UP(MAX_NUM_QUEUE, 32)];
+	char	data[];
+};
+
+/**
+ * struct ethtool_fecparam - Ethernet Forward Error Correction parameters
+ * @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM
+ * @active_fec: FEC mode which is active on the port, single bit set, GET only.
+ * @fec: Bitmask of configured FEC modes.
+ * @reserved: Reserved for future extensions, ignore on GET, write 0 for SET.
+ *
+ * Note that @reserved was never validated on input and ethtool user space
+ * left it uninitialized when calling SET. Hence going forward it can only be
+ * used to return a value to userspace with GET.
+ *
+ * FEC modes supported by the device can be read via %ETHTOOL_GLINKSETTINGS.
+ * FEC settings are configured by link autonegotiation whenever it's enabled.
+ * With autoneg on %ETHTOOL_GFECPARAM can be used to read the current mode.
+ *
+ * When autoneg is disabled %ETHTOOL_SFECPARAM controls the FEC settings.
+ * It is recommended that drivers only accept a single bit set in @fec.
+ * When multiple bits are set in @fec drivers may pick mode in an implementation
+ * dependent way. Drivers should reject mixing %ETHTOOL_FEC_AUTO_BIT with other
+ * FEC modes, because it's unclear whether in this case other modes constrain
+ * AUTO or are independent choices.
+ * Drivers must reject SET requests if they support none of the requested modes.
+ *
+ * If device does not support FEC drivers may use %ETHTOOL_FEC_NONE instead
+ * of returning %EOPNOTSUPP from %ETHTOOL_GFECPARAM.
+ *
+ * See enum ethtool_fec_config_bits for definition of valid bits for both
+ * @fec and @active_fec.
+ */
+struct ethtool_fecparam {
+	uint32_t   cmd;
+	/* bitmask of FEC modes */
+	uint32_t   active_fec;
+	uint32_t   fec;
+	uint32_t   reserved;
+};
+
+/**
+ * enum ethtool_fec_config_bits - flags definition of ethtool_fec_configuration
+ * @ETHTOOL_FEC_NONE_BIT: FEC mode configuration is not supported. Should not
+ *			be used together with other bits. GET only.
+ * @ETHTOOL_FEC_AUTO_BIT: Select default/best FEC mode automatically, usually
+ *			based link mode and SFP parameters read from module's
+ *			EEPROM. This bit does _not_ mean autonegotiation.
+ * @ETHTOOL_FEC_OFF_BIT: No FEC Mode
+ * @ETHTOOL_FEC_RS_BIT: Reed-Solomon FEC Mode
+ * @ETHTOOL_FEC_BASER_BIT: Base-R/Reed-Solomon FEC Mode
+ * @ETHTOOL_FEC_LLRS_BIT: Low Latency Reed Solomon FEC Mode (25G/50G Ethernet
+ *			Consortium)
+ */
+enum ethtool_fec_config_bits {
+	ETHTOOL_FEC_NONE_BIT,
+	ETHTOOL_FEC_AUTO_BIT,
+	ETHTOOL_FEC_OFF_BIT,
+	ETHTOOL_FEC_RS_BIT,
+	ETHTOOL_FEC_BASER_BIT,
+	ETHTOOL_FEC_LLRS_BIT,
+};
+
+#define ETHTOOL_FEC_NONE		(1 << ETHTOOL_FEC_NONE_BIT)
+#define ETHTOOL_FEC_AUTO		(1 << ETHTOOL_FEC_AUTO_BIT)
+#define ETHTOOL_FEC_OFF			(1 << ETHTOOL_FEC_OFF_BIT)
+#define ETHTOOL_FEC_RS			(1 << ETHTOOL_FEC_RS_BIT)
+#define ETHTOOL_FEC_BASER		(1 << ETHTOOL_FEC_BASER_BIT)
+#define ETHTOOL_FEC_LLRS		(1 << ETHTOOL_FEC_LLRS_BIT)
+
+/* CMDs currently supported */
+#define ETHTOOL_GSET		0x00000001 /* DEPRECATED, Get settings.
+					    * Please use ETHTOOL_GLINKSETTINGS
+					    */
+#define ETHTOOL_SSET		0x00000002 /* DEPRECATED, Set settings.
+					    * Please use ETHTOOL_SLINKSETTINGS
+					    */
+#define ETHTOOL_GDRVINFO	0x00000003 /* Get driver info. */
+#define ETHTOOL_GREGS		0x00000004 /* Get NIC registers. */
+#define ETHTOOL_GWOL		0x00000005 /* Get wake-on-lan options. */
+#define ETHTOOL_SWOL		0x00000006 /* Set wake-on-lan options. */
+#define ETHTOOL_GMSGLVL		0x00000007 /* Get driver message level */
+#define ETHTOOL_SMSGLVL		0x00000008 /* Set driver msg level. */
+#define ETHTOOL_NWAY_RST	0x00000009 /* Restart autonegotiation. */
+/* Get link status for host, i.e. whether the interface *and* the
+ * physical port (if there is one) are up (ethtool_value). */
+#define ETHTOOL_GLINK		0x0000000a
+#define ETHTOOL_GEEPROM		0x0000000b /* Get EEPROM data */
+#define ETHTOOL_SEEPROM		0x0000000c /* Set EEPROM data. */
+#define ETHTOOL_GCOALESCE	0x0000000e /* Get coalesce config */
+#define ETHTOOL_SCOALESCE	0x0000000f /* Set coalesce config. */
+#define ETHTOOL_GRINGPARAM	0x00000010 /* Get ring parameters */
+#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters. */
+#define ETHTOOL_GPAUSEPARAM	0x00000012 /* Get pause parameters */
+#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters. */
+#define ETHTOOL_GRXCSUM		0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#define ETHTOOL_SRXCSUM		0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#define ETHTOOL_GTXCSUM		0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#define ETHTOOL_STXCSUM		0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
+					    * (ethtool_value) */
+#define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
+					    * (ethtool_value). */
+#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test. */
+#define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
+#define ETHTOOL_PHYS_ID		0x0000001c /* identify the NIC */
+#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
+#define ETHTOOL_GTSO		0x0000001e /* Get TSO enable (ethtool_value) */
+#define ETHTOOL_STSO		0x0000001f /* Set TSO enable (ethtool_value) */
+#define ETHTOOL_GPERMADDR	0x00000020 /* Get permanent hardware address */
+#define ETHTOOL_GUFO		0x00000021 /* Get UFO enable (ethtool_value) */
+#define ETHTOOL_SUFO		0x00000022 /* Set UFO enable (ethtool_value) */
+#define ETHTOOL_GGSO		0x00000023 /* Get GSO enable (ethtool_value) */
+#define ETHTOOL_SGSO		0x00000024 /* Set GSO enable (ethtool_value) */
+#define ETHTOOL_GFLAGS		0x00000025 /* Get flags bitmap(ethtool_value) */
+#define ETHTOOL_SFLAGS		0x00000026 /* Set flags bitmap(ethtool_value) */
+#define ETHTOOL_GPFLAGS		0x00000027 /* Get driver-private flags bitmap */
+#define ETHTOOL_SPFLAGS		0x00000028 /* Set driver-private flags bitmap */
+
+#define ETHTOOL_GRXFH		0x00000029 /* Get RX flow hash configuration */
+#define ETHTOOL_SRXFH		0x0000002a /* Set RX flow hash configuration */
+#define ETHTOOL_GGRO		0x0000002b /* Get GRO enable (ethtool_value) */
+#define ETHTOOL_SGRO		0x0000002c /* Set GRO enable (ethtool_value) */
+#define ETHTOOL_GRXRINGS	0x0000002d /* Get RX rings available for LB */
+#define ETHTOOL_GRXCLSRLCNT	0x0000002e /* Get RX class rule count */
+#define ETHTOOL_GRXCLSRULE	0x0000002f /* Get RX classification rule */
+#define ETHTOOL_GRXCLSRLALL	0x00000030 /* Get all RX classification rule */
+#define ETHTOOL_SRXCLSRLDEL	0x00000031 /* Delete RX classification rule */
+#define ETHTOOL_SRXCLSRLINS	0x00000032 /* Insert RX classification rule */
+#define ETHTOOL_FLASHDEV	0x00000033 /* Flash firmware to device */
+#define ETHTOOL_RESET		0x00000034 /* Reset hardware */
+#define ETHTOOL_SRXNTUPLE	0x00000035 /* Add an n-tuple filter to device */
+#define ETHTOOL_GRXNTUPLE	0x00000036 /* deprecated */
+#define ETHTOOL_GSSET_INFO	0x00000037 /* Get string set info */
+#define ETHTOOL_GRXFHINDIR	0x00000038 /* Get RX flow hash indir'n table */
+#define ETHTOOL_SRXFHINDIR	0x00000039 /* Set RX flow hash indir'n table */
+
+#define ETHTOOL_GFEATURES	0x0000003a /* Get device offload settings */
+#define ETHTOOL_SFEATURES	0x0000003b /* Change device offload settings */
+#define ETHTOOL_GCHANNELS	0x0000003c /* Get no of channels */
+#define ETHTOOL_SCHANNELS	0x0000003d /* Set no of channels */
+#define ETHTOOL_SET_DUMP	0x0000003e /* Set dump settings */
+#define ETHTOOL_GET_DUMP_FLAG	0x0000003f /* Get dump settings */
+#define ETHTOOL_GET_DUMP_DATA	0x00000040 /* Get dump data */
+#define ETHTOOL_GET_TS_INFO	0x00000041 /* Get time stamping and PHC info */
+#define ETHTOOL_GMODULEINFO	0x00000042 /* Get plug-in module information */
+#define ETHTOOL_GMODULEEEPROM	0x00000043 /* Get plug-in module eeprom */
+#define ETHTOOL_GEEE		0x00000044 /* Get EEE settings */
+#define ETHTOOL_SEEE		0x00000045 /* Set EEE settings */
+
+#define ETHTOOL_GRSSH		0x00000046 /* Get RX flow hash configuration */
+#define ETHTOOL_SRSSH		0x00000047 /* Set RX flow hash configuration */
+#define ETHTOOL_GTUNABLE	0x00000048 /* Get tunable configuration */
+#define ETHTOOL_STUNABLE	0x00000049 /* Set tunable configuration */
+#define ETHTOOL_GPHYSTATS	0x0000004a /* get PHY-specific statistics */
+
+#define ETHTOOL_PERQUEUE	0x0000004b /* Set per queue options */
+
+#define ETHTOOL_GLINKSETTINGS	0x0000004c /* Get ethtool_link_settings */
+#define ETHTOOL_SLINKSETTINGS	0x0000004d /* Set ethtool_link_settings */
+#define ETHTOOL_PHY_GTUNABLE	0x0000004e /* Get PHY tunable configuration */
+#define ETHTOOL_PHY_STUNABLE	0x0000004f /* Set PHY tunable configuration */
+#define ETHTOOL_GFECPARAM	0x00000050 /* Get FEC settings */
+#define ETHTOOL_SFECPARAM	0x00000051 /* Set FEC settings */
+
+/* compatibility with older code */
+#define SPARC_ETH_GSET		ETHTOOL_GSET
+#define SPARC_ETH_SSET		ETHTOOL_SSET
+
+/* Link mode bit indices */
+enum ethtool_link_mode_bit_indices {
+	ETHTOOL_LINK_MODE_10baseT_Half_BIT	= 0,
+	ETHTOOL_LINK_MODE_10baseT_Full_BIT	= 1,
+	ETHTOOL_LINK_MODE_100baseT_Half_BIT	= 2,
+	ETHTOOL_LINK_MODE_100baseT_Full_BIT	= 3,
+	ETHTOOL_LINK_MODE_1000baseT_Half_BIT	= 4,
+	ETHTOOL_LINK_MODE_1000baseT_Full_BIT	= 5,
+	ETHTOOL_LINK_MODE_Autoneg_BIT		= 6,
+	ETHTOOL_LINK_MODE_TP_BIT		= 7,
+	ETHTOOL_LINK_MODE_AUI_BIT		= 8,
+	ETHTOOL_LINK_MODE_MII_BIT		= 9,
+	ETHTOOL_LINK_MODE_FIBRE_BIT		= 10,
+	ETHTOOL_LINK_MODE_BNC_BIT		= 11,
+	ETHTOOL_LINK_MODE_10000baseT_Full_BIT	= 12,
+	ETHTOOL_LINK_MODE_Pause_BIT		= 13,
+	ETHTOOL_LINK_MODE_Asym_Pause_BIT	= 14,
+	ETHTOOL_LINK_MODE_2500baseX_Full_BIT	= 15,
+	ETHTOOL_LINK_MODE_Backplane_BIT		= 16,
+	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT	= 17,
+	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT	= 18,
+	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT	= 19,
+	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT	= 20,
+	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
+	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT	= 22,
+	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT	= 23,
+	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT	= 24,
+	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT	= 25,
+	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT	= 26,
+	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT	= 27,
+	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT	= 28,
+	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT	= 29,
+	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT	= 30,
+	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT	= 31,
+
+	/* Last allowed bit for __ETHTOOL_LINK_MODE_LEGACY_MASK is bit
+	 * 31. Please do NOT define any SUPPORTED_* or ADVERTISED_*
+	 * macro for bits > 31. The only way to use indices > 31 is to
+	 * use the new ETHTOOL_GLINKSETTINGS/ETHTOOL_SLINKSETTINGS API.
+	 */
+
+	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT	= 32,
+	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT	= 33,
+	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT	= 34,
+	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT	= 35,
+	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT	= 36,
+	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT	= 37,
+	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT	= 38,
+	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT	= 39,
+	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT		= 40,
+	ETHTOOL_LINK_MODE_1000baseX_Full_BIT	= 41,
+	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT	= 42,
+	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT	= 43,
+	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT	= 44,
+	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT	= 45,
+	ETHTOOL_LINK_MODE_10000baseER_Full_BIT	= 46,
+	ETHTOOL_LINK_MODE_2500baseT_Full_BIT	= 47,
+	ETHTOOL_LINK_MODE_5000baseT_Full_BIT	= 48,
+
+	ETHTOOL_LINK_MODE_FEC_NONE_BIT	= 49,
+	ETHTOOL_LINK_MODE_FEC_RS_BIT	= 50,
+	ETHTOOL_LINK_MODE_FEC_BASER_BIT	= 51,
+	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT		 = 52,
+	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT		 = 53,
+	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT		 = 54,
+	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT	 = 55,
+	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT		 = 56,
+	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT	 = 57,
+	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT	 = 58,
+	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT	 = 59,
+	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
+	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT	 = 61,
+	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT	 = 62,
+	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT	 = 63,
+	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
+	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT	 = 65,
+	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT	 = 66,
+	ETHTOOL_LINK_MODE_100baseT1_Full_BIT		 = 67,
+	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT		 = 68,
+	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT	 = 69,
+	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT	 = 70,
+	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
+	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT	 = 72,
+	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT	 = 73,
+	ETHTOOL_LINK_MODE_FEC_LLRS_BIT			 = 74,
+	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT		 = 75,
+	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT		 = 76,
+	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT	 = 77,
+	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT		 = 78,
+	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT		 = 79,
+	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT	 = 80,
+	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT	 = 81,
+	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
+	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT	 = 83,
+	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT	 = 84,
+	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT	 = 85,
+	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT	 = 86,
+	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
+	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT	 = 88,
+	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT	 = 89,
+	ETHTOOL_LINK_MODE_100baseFX_Half_BIT		 = 90,
+	ETHTOOL_LINK_MODE_100baseFX_Full_BIT		 = 91,
+	/* must be last entry */
+	__ETHTOOL_LINK_MODE_MASK_NBITS
+};
+
+#define __ETHTOOL_LINK_MODE_LEGACY_MASK(base_name)	\
+	(1UL << (ETHTOOL_LINK_MODE_ ## base_name ## _BIT))
+
+/* DEPRECATED macros. Please migrate to
+ * ETHTOOL_GLINKSETTINGS/ETHTOOL_SLINKSETTINGS API. Please do NOT
+ * define any new SUPPORTED_* macro for bits > 31.
+ */
+#define SUPPORTED_10baseT_Half		__ETHTOOL_LINK_MODE_LEGACY_MASK(10baseT_Half)
+#define SUPPORTED_10baseT_Full		__ETHTOOL_LINK_MODE_LEGACY_MASK(10baseT_Full)
+#define SUPPORTED_100baseT_Half		__ETHTOOL_LINK_MODE_LEGACY_MASK(100baseT_Half)
+#define SUPPORTED_100baseT_Full		__ETHTOOL_LINK_MODE_LEGACY_MASK(100baseT_Full)
+#define SUPPORTED_1000baseT_Half	__ETHTOOL_LINK_MODE_LEGACY_MASK(1000baseT_Half)
+#define SUPPORTED_1000baseT_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(1000baseT_Full)
+#define SUPPORTED_Autoneg		__ETHTOOL_LINK_MODE_LEGACY_MASK(Autoneg)
+#define SUPPORTED_TP			__ETHTOOL_LINK_MODE_LEGACY_MASK(TP)
+#define SUPPORTED_AUI			__ETHTOOL_LINK_MODE_LEGACY_MASK(AUI)
+#define SUPPORTED_MII			__ETHTOOL_LINK_MODE_LEGACY_MASK(MII)
+#define SUPPORTED_FIBRE			__ETHTOOL_LINK_MODE_LEGACY_MASK(FIBRE)
+#define SUPPORTED_BNC			__ETHTOOL_LINK_MODE_LEGACY_MASK(BNC)
+#define SUPPORTED_10000baseT_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseT_Full)
+#define SUPPORTED_Pause			__ETHTOOL_LINK_MODE_LEGACY_MASK(Pause)
+#define SUPPORTED_Asym_Pause		__ETHTOOL_LINK_MODE_LEGACY_MASK(Asym_Pause)
+#define SUPPORTED_2500baseX_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(2500baseX_Full)
+#define SUPPORTED_Backplane		__ETHTOOL_LINK_MODE_LEGACY_MASK(Backplane)
+#define SUPPORTED_1000baseKX_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(1000baseKX_Full)
+#define SUPPORTED_10000baseKX4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseKX4_Full)
+#define SUPPORTED_10000baseKR_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseKR_Full)
+#define SUPPORTED_10000baseR_FEC	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseR_FEC)
+#define SUPPORTED_20000baseMLD2_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(20000baseMLD2_Full)
+#define SUPPORTED_20000baseKR2_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(20000baseKR2_Full)
+#define SUPPORTED_40000baseKR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseKR4_Full)
+#define SUPPORTED_40000baseCR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseCR4_Full)
+#define SUPPORTED_40000baseSR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseSR4_Full)
+#define SUPPORTED_40000baseLR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseLR4_Full)
+#define SUPPORTED_56000baseKR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseKR4_Full)
+#define SUPPORTED_56000baseCR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseCR4_Full)
+#define SUPPORTED_56000baseSR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseSR4_Full)
+#define SUPPORTED_56000baseLR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseLR4_Full)
+/* Please do not define any new SUPPORTED_* macro for bits > 31, see
+ * notice above.
+ */
+
+/*
+ * DEPRECATED macros. Please migrate to
+ * ETHTOOL_GLINKSETTINGS/ETHTOOL_SLINKSETTINGS API. Please do NOT
+ * define any new ADERTISE_* macro for bits > 31.
+ */
+#define ADVERTISED_10baseT_Half		__ETHTOOL_LINK_MODE_LEGACY_MASK(10baseT_Half)
+#define ADVERTISED_10baseT_Full		__ETHTOOL_LINK_MODE_LEGACY_MASK(10baseT_Full)
+#define ADVERTISED_100baseT_Half	__ETHTOOL_LINK_MODE_LEGACY_MASK(100baseT_Half)
+#define ADVERTISED_100baseT_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(100baseT_Full)
+#define ADVERTISED_1000baseT_Half	__ETHTOOL_LINK_MODE_LEGACY_MASK(1000baseT_Half)
+#define ADVERTISED_1000baseT_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(1000baseT_Full)
+#define ADVERTISED_Autoneg		__ETHTOOL_LINK_MODE_LEGACY_MASK(Autoneg)
+#define ADVERTISED_TP			__ETHTOOL_LINK_MODE_LEGACY_MASK(TP)
+#define ADVERTISED_AUI			__ETHTOOL_LINK_MODE_LEGACY_MASK(AUI)
+#define ADVERTISED_MII			__ETHTOOL_LINK_MODE_LEGACY_MASK(MII)
+#define ADVERTISED_FIBRE		__ETHTOOL_LINK_MODE_LEGACY_MASK(FIBRE)
+#define ADVERTISED_BNC			__ETHTOOL_LINK_MODE_LEGACY_MASK(BNC)
+#define ADVERTISED_10000baseT_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseT_Full)
+#define ADVERTISED_Pause		__ETHTOOL_LINK_MODE_LEGACY_MASK(Pause)
+#define ADVERTISED_Asym_Pause		__ETHTOOL_LINK_MODE_LEGACY_MASK(Asym_Pause)
+#define ADVERTISED_2500baseX_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(2500baseX_Full)
+#define ADVERTISED_Backplane		__ETHTOOL_LINK_MODE_LEGACY_MASK(Backplane)
+#define ADVERTISED_1000baseKX_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(1000baseKX_Full)
+#define ADVERTISED_10000baseKX4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseKX4_Full)
+#define ADVERTISED_10000baseKR_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseKR_Full)
+#define ADVERTISED_10000baseR_FEC	__ETHTOOL_LINK_MODE_LEGACY_MASK(10000baseR_FEC)
+#define ADVERTISED_20000baseMLD2_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(20000baseMLD2_Full)
+#define ADVERTISED_20000baseKR2_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(20000baseKR2_Full)
+#define ADVERTISED_40000baseKR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseKR4_Full)
+#define ADVERTISED_40000baseCR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseCR4_Full)
+#define ADVERTISED_40000baseSR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseSR4_Full)
+#define ADVERTISED_40000baseLR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(40000baseLR4_Full)
+#define ADVERTISED_56000baseKR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseKR4_Full)
+#define ADVERTISED_56000baseCR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseCR4_Full)
+#define ADVERTISED_56000baseSR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseSR4_Full)
+#define ADVERTISED_56000baseLR4_Full	__ETHTOOL_LINK_MODE_LEGACY_MASK(56000baseLR4_Full)
+/* Please do not define any new ADVERTISED_* macro for bits > 31, see
+ * notice above.
+ */
+
+/* The following are all involved in forcing a particular link
+ * mode for the device for setting things.  When getting the
+ * devices settings, these indicate the current mode and whether
+ * it was forced up into this mode or autonegotiated.
+ */
+
+/* The forced speed, in units of 1Mb. All values 0 to INT_MAX are legal.
+ * Update drivers/net/phy/phy.c:phy_speed_to_str() and
+ * drivers/net/bonding/bond_3ad.c:__get_link_speed() when adding new values.
+ */
+#define SPEED_10		10
+#define SPEED_100		100
+#define SPEED_1000		1000
+#define SPEED_2500		2500
+#define SPEED_5000		5000
+#define SPEED_10000		10000
+#define SPEED_14000		14000
+#define SPEED_20000		20000
+#define SPEED_25000		25000
+#define SPEED_40000		40000
+#define SPEED_50000		50000
+#define SPEED_56000		56000
+#define SPEED_100000		100000
+#define SPEED_200000		200000
+#define SPEED_400000		400000
+
+#define SPEED_UNKNOWN		-1
+
+static inline int ethtool_validate_speed(uint32_t speed)
+{
+	return speed <= INT_MAX || speed == (uint32_t)SPEED_UNKNOWN;
+}
+
+/* Duplex, half or full. */
+#define DUPLEX_HALF		0x00
+#define DUPLEX_FULL		0x01
+#define DUPLEX_UNKNOWN		0xff
+
+static inline int ethtool_validate_duplex(uint8_t duplex)
+{
+	switch (duplex) {
+	case DUPLEX_HALF:
+	case DUPLEX_FULL:
+	case DUPLEX_UNKNOWN:
+		return 1;
+	}
+
+	return 0;
+}
+
+#define MASTER_SLAVE_CFG_UNSUPPORTED		0
+#define MASTER_SLAVE_CFG_UNKNOWN		1
+#define MASTER_SLAVE_CFG_MASTER_PREFERRED	2
+#define MASTER_SLAVE_CFG_SLAVE_PREFERRED	3
+#define MASTER_SLAVE_CFG_MASTER_FORCE		4
+#define MASTER_SLAVE_CFG_SLAVE_FORCE		5
+#define MASTER_SLAVE_STATE_UNSUPPORTED		0
+#define MASTER_SLAVE_STATE_UNKNOWN		1
+#define MASTER_SLAVE_STATE_MASTER		2
+#define MASTER_SLAVE_STATE_SLAVE		3
+#define MASTER_SLAVE_STATE_ERR			4
+
+/* Which connector port. */
+#define PORT_TP			0x00
+#define PORT_AUI		0x01
+#define PORT_MII		0x02
+#define PORT_FIBRE		0x03
+#define PORT_BNC		0x04
+#define PORT_DA			0x05
+#define PORT_NONE		0xef
+#define PORT_OTHER		0xff
+
+/* Which transceiver to use. */
+#define XCVR_INTERNAL		0x00 /* PHY and MAC are in the same package */
+#define XCVR_EXTERNAL		0x01 /* PHY and MAC are in different packages */
+#define XCVR_DUMMY1		0x02
+#define XCVR_DUMMY2		0x03
+#define XCVR_DUMMY3		0x04
+
+/* Enable or disable autonegotiation. */
+#define AUTONEG_DISABLE		0x00
+#define AUTONEG_ENABLE		0x01
+
+/* MDI or MDI-X status/control - if MDI/MDI_X/AUTO is set then
+ * the driver is required to renegotiate link
+ */
+#define ETH_TP_MDI_INVALID	0x00 /* status: unknown; control: unsupported */
+#define ETH_TP_MDI		0x01 /* status: MDI;     control: force MDI */
+#define ETH_TP_MDI_X		0x02 /* status: MDI-X;   control: force MDI-X */
+#define ETH_TP_MDI_AUTO		0x03 /*                  control: auto-select */
+
+/* Wake-On-Lan options. */
+#define WAKE_PHY		(1 << 0)
+#define WAKE_UCAST		(1 << 1)
+#define WAKE_MCAST		(1 << 2)
+#define WAKE_BCAST		(1 << 3)
+#define WAKE_ARP		(1 << 4)
+#define WAKE_MAGIC		(1 << 5)
+#define WAKE_MAGICSECURE	(1 << 6) /* only meaningful if WAKE_MAGIC */
+#define WAKE_FILTER		(1 << 7)
+
+#define WOL_MODE_COUNT		8
+
+/* L2-L4 network traffic flow types */
+#define	TCP_V4_FLOW	0x01	/* hash or spec (tcp_ip4_spec) */
+#define	UDP_V4_FLOW	0x02	/* hash or spec (udp_ip4_spec) */
+#define	SCTP_V4_FLOW	0x03	/* hash or spec (sctp_ip4_spec) */
+#define	AH_ESP_V4_FLOW	0x04	/* hash only */
+#define	TCP_V6_FLOW	0x05	/* hash or spec (tcp_ip6_spec; nfc only) */
+#define	UDP_V6_FLOW	0x06	/* hash or spec (udp_ip6_spec; nfc only) */
+#define	SCTP_V6_FLOW	0x07	/* hash or spec (sctp_ip6_spec; nfc only) */
+#define	AH_ESP_V6_FLOW	0x08	/* hash only */
+#define	AH_V4_FLOW	0x09	/* hash or spec (ah_ip4_spec) */
+#define	ESP_V4_FLOW	0x0a	/* hash or spec (esp_ip4_spec) */
+#define	AH_V6_FLOW	0x0b	/* hash or spec (ah_ip6_spec; nfc only) */
+#define	ESP_V6_FLOW	0x0c	/* hash or spec (esp_ip6_spec; nfc only) */
+#define	IPV4_USER_FLOW	0x0d	/* spec only (usr_ip4_spec) */
+#define	IP_USER_FLOW	IPV4_USER_FLOW
+#define	IPV6_USER_FLOW	0x0e	/* spec only (usr_ip6_spec; nfc only) */
+#define	IPV4_FLOW	0x10	/* hash only */
+#define	IPV6_FLOW	0x11	/* hash only */
+#define	ETHER_FLOW	0x12	/* spec only (ether_spec) */
+/* Flag to enable additional fields in struct ethtool_rx_flow_spec */
+#define	FLOW_EXT	0x80000000
+#define	FLOW_MAC_EXT	0x40000000
+/* Flag to enable RSS spreading of traffic matching rule (nfc only) */
+#define	FLOW_RSS	0x20000000
+
+/* L3-L4 network traffic flow hash options */
+#define	RXH_L2DA	(1 << 1)
+#define	RXH_VLAN	(1 << 2)
+#define	RXH_L3_PROTO	(1 << 3)
+#define	RXH_IP_SRC	(1 << 4)
+#define	RXH_IP_DST	(1 << 5)
+#define	RXH_L4_B_0_1	(1 << 6) /* src port in case of TCP/UDP/SCTP */
+#define	RXH_L4_B_2_3	(1 << 7) /* dst port in case of TCP/UDP/SCTP */
+#define	RXH_DISCARD	(1 << 31)
+
+#define	RX_CLS_FLOW_DISC	0xffffffffffffffffULL
+#define RX_CLS_FLOW_WAKE	0xfffffffffffffffeULL
+
+/* Special RX classification rule insert location values */
+#define RX_CLS_LOC_SPECIAL	0x80000000	/* flag */
+#define RX_CLS_LOC_ANY		0xffffffff
+#define RX_CLS_LOC_FIRST	0xfffffffe
+#define RX_CLS_LOC_LAST		0xfffffffd
+
+/* EEPROM Standards for plug in modules */
+#define ETH_MODULE_SFF_8079		0x1
+#define ETH_MODULE_SFF_8079_LEN		256
+#define ETH_MODULE_SFF_8472		0x2
+#define ETH_MODULE_SFF_8472_LEN		512
+#define ETH_MODULE_SFF_8636		0x3
+#define ETH_MODULE_SFF_8636_LEN		256
+#define ETH_MODULE_SFF_8436		0x4
+#define ETH_MODULE_SFF_8436_LEN		256
+
+#define ETH_MODULE_SFF_8636_MAX_LEN     640
+#define ETH_MODULE_SFF_8436_MAX_LEN     640
+
+/* Reset flags */
+/* The reset() operation must clear the flags for the components which
+ * were actually reset.  On successful return, the flags indicate the
+ * components which were not reset, either because they do not exist
+ * in the hardware or because they cannot be reset independently.  The
+ * driver must never reset any components that were not requested.
+ */
+enum ethtool_reset_flags {
+	/* These flags represent components dedicated to the interface
+	 * the command is addressed to.  Shift any flag left by
+	 * ETH_RESET_SHARED_SHIFT to reset a shared component of the
+	 * same type.
+	 */
+	ETH_RESET_MGMT		= 1 << 0,	/* Management processor */
+	ETH_RESET_IRQ		= 1 << 1,	/* Interrupt requester */
+	ETH_RESET_DMA		= 1 << 2,	/* DMA engine */
+	ETH_RESET_FILTER	= 1 << 3,	/* Filtering/flow direction */
+	ETH_RESET_OFFLOAD	= 1 << 4,	/* Protocol offload */
+	ETH_RESET_MAC		= 1 << 5,	/* Media access controller */
+	ETH_RESET_PHY		= 1 << 6,	/* Transceiver/PHY */
+	ETH_RESET_RAM		= 1 << 7,	/* RAM shared between
+						 * multiple components */
+	ETH_RESET_AP		= 1 << 8,	/* Application processor */
+
+	ETH_RESET_DEDICATED	= 0x0000ffff,	/* All components dedicated to
+						 * this interface */
+	ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
+						 * interface, even if shared */
+};
+#define ETH_RESET_SHARED_SHIFT	16
+
+
+/**
+ * struct ethtool_link_settings - link control and status
+ *
+ * IMPORTANT, Backward compatibility notice: When implementing new
+ *	user-space tools, please first try %ETHTOOL_GLINKSETTINGS, and
+ *	if it succeeds use %ETHTOOL_SLINKSETTINGS to change link
+ *	settings; do not use %ETHTOOL_SSET if %ETHTOOL_GLINKSETTINGS
+ *	succeeded: stick to %ETHTOOL_GLINKSETTINGS/%SLINKSETTINGS in
+ *	that case.  Conversely, if %ETHTOOL_GLINKSETTINGS fails, use
+ *	%ETHTOOL_GSET to query and %ETHTOOL_SSET to change link
+ *	settings; do not use %ETHTOOL_SLINKSETTINGS if
+ *	%ETHTOOL_GLINKSETTINGS failed: stick to
+ *	%ETHTOOL_GSET/%ETHTOOL_SSET in that case.
+ *
+ * @cmd: Command number = %ETHTOOL_GLINKSETTINGS or %ETHTOOL_SLINKSETTINGS
+ * @speed: Link speed (Mbps)
+ * @duplex: Duplex mode; one of %DUPLEX_*
+ * @port: Physical connector type; one of %PORT_*
+ * @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not
+ *	applicable.  For clause 45 PHYs this is the PRTAD.
+ * @autoneg: Enable/disable autonegotiation and auto-detection;
+ *	either %AUTONEG_DISABLE or %AUTONEG_ENABLE
+ * @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO
+ *	protocols supported by the interface; 0 if unknown.
+ *	Read-only.
+ * @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of
+ *	%ETH_TP_MDI_*.  If the status is unknown or not applicable, the
+ *	value will be %ETH_TP_MDI_INVALID.  Read-only.
+ * @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of
+ *	%ETH_TP_MDI_*.  If MDI(-X) control is not implemented, reads
+ *	yield %ETH_TP_MDI_INVALID and writes may be ignored or rejected.
+ *	When written successfully, the link should be renegotiated if
+ *	necessary.
+ * @link_mode_masks_nwords: Number of 32-bit words for each of the
+ *	supported, advertising, lp_advertising link mode bitmaps. For
+ *	%ETHTOOL_GLINKSETTINGS: on entry, number of words passed by user
+ *	(>= 0); on return, if handshake in progress, negative if
+ *	request size unsupported by kernel: absolute value indicates
+ *	kernel expected size and all the other fields but cmd
+ *	are 0; otherwise (handshake completed), strictly positive
+ *	to indicate size used by kernel and cmd field stays
+ *	%ETHTOOL_GLINKSETTINGS, all other fields populated by driver. For
+ *	%ETHTOOL_SLINKSETTINGS: must be valid on entry, ie. a positive
+ *	value returned previously by %ETHTOOL_GLINKSETTINGS, otherwise
+ *	refused. For drivers: ignore this field (use kernel's
+ *	__ETHTOOL_LINK_MODE_MASK_NBITS instead), any change to it will
+ *	be overwritten by kernel.
+ * @supported: Bitmap with each bit meaning given by
+ *	%ethtool_link_mode_bit_indices for the link modes, physical
+ *	connectors and other link features for which the interface
+ *	supports autonegotiation or auto-detection.  Read-only.
+ * @advertising: Bitmap with each bit meaning given by
+ *	%ethtool_link_mode_bit_indices for the link modes, physical
+ *	connectors and other link features that are advertised through
+ *	autonegotiation or enabled for auto-detection.
+ * @lp_advertising: Bitmap with each bit meaning given by
+ *	%ethtool_link_mode_bit_indices for the link modes, and other
+ *	link features that the link partner advertised through
+ *	autonegotiation; 0 if unknown or not applicable.  Read-only.
+ * @transceiver: Used to distinguish different possible PHY types,
+ *	reported consistently by PHYLIB.  Read-only.
+ * @master_slave_cfg: Master/slave port mode.
+ * @master_slave_state: Master/slave port state.
+ * @reserved: Reserved for future use; see the note on reserved space.
+ * @reserved1: Reserved for future use; see the note on reserved space.
+ * @link_mode_masks: Variable length bitmaps.
+ *
+ * If autonegotiation is disabled, the speed and @duplex represent the
+ * fixed link mode and are writable if the driver supports multiple
+ * link modes.  If it is enabled then they are read-only; if the link
+ * is up they represent the negotiated link mode; if the link is down,
+ * the speed is 0, %SPEED_UNKNOWN or the highest enabled speed and
+ * @duplex is %DUPLEX_UNKNOWN or the best enabled duplex mode.
+ *
+ * Some hardware interfaces may have multiple PHYs and/or physical
+ * connectors fitted or do not allow the driver to detect which are
+ * fitted.  For these interfaces @port and/or @phy_address may be
+ * writable, possibly dependent on @autoneg being %AUTONEG_DISABLE.
+ * Otherwise, attempts to write different values may be ignored or
+ * rejected.
+ *
+ * Deprecated %ethtool_cmd fields transceiver, maxtxpkt and maxrxpkt
+ * are not available in %ethtool_link_settings. These fields will be
+ * always set to zero in %ETHTOOL_GSET reply and %ETHTOOL_SSET will
+ * fail if any of them is set to non-zero value.
+ *
+ * Users should assume that all fields not marked read-only are
+ * writable and subject to validation by the driver.  They should use
+ * %ETHTOOL_GLINKSETTINGS to get the current values before making specific
+ * changes and then applying them with %ETHTOOL_SLINKSETTINGS.
+ *
+ * Drivers that implement %get_link_ksettings and/or
+ * %set_link_ksettings should ignore the @cmd
+ * and @link_mode_masks_nwords fields (any change to them overwritten
+ * by kernel), and rely only on kernel's internal
+ * %__ETHTOOL_LINK_MODE_MASK_NBITS and
+ * %ethtool_link_mode_mask_t. Drivers that implement
+ * %set_link_ksettings() should validate all fields other than @cmd
+ * and @link_mode_masks_nwords that are not described as read-only or
+ * deprecated, and must ignore all fields described as read-only.
+ */
+struct ethtool_link_settings {
+	uint32_t	cmd;
+	uint32_t	speed;
+	uint8_t	duplex;
+	uint8_t	port;
+	uint8_t	phy_address;
+	uint8_t	autoneg;
+	uint8_t	mdio_support;
+	uint8_t	eth_tp_mdix;
+	uint8_t	eth_tp_mdix_ctrl;
+	int8_t	link_mode_masks_nwords;
+	uint8_t	transceiver;
+	uint8_t	master_slave_cfg;
+	uint8_t	master_slave_state;
+	uint8_t	reserved1[1];
+	uint32_t	reserved[7];
+	uint32_t	link_mode_masks[0];
+	/* layout of link_mode_masks fields:
+	 * uint32_t map_supported[link_mode_masks_nwords];
+	 * uint32_t map_advertising[link_mode_masks_nwords];
+	 * uint32_t map_lp_advertising[link_mode_masks_nwords];
+	 */
+};
+#endif /* _LINUX_ETHTOOL_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/fuse.h b/subprojects/libvhost-user/standard-headers/linux/fuse.h
new file mode 100644
index 0000000..cce105b
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/fuse.h
@@ -0,0 +1,970 @@
+/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause) */
+/*
+    This file defines the kernel interface of FUSE
+    Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+
+    This -- and only this -- header file may also be distributed under
+    the terms of the BSD Licence as follows:
+
+    Copyright (C) 2001-2007 Miklos Szeredi. All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions
+    are met:
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+    ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+    OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+    SUCH DAMAGE.
+*/
+
+/*
+ * This file defines the kernel interface of FUSE
+ *
+ * Protocol changelog:
+ *
+ * 7.1:
+ *  - add the following messages:
+ *      FUSE_SETATTR, FUSE_SYMLINK, FUSE_MKNOD, FUSE_MKDIR, FUSE_UNLINK,
+ *      FUSE_RMDIR, FUSE_RENAME, FUSE_LINK, FUSE_OPEN, FUSE_READ, FUSE_WRITE,
+ *      FUSE_RELEASE, FUSE_FSYNC, FUSE_FLUSH, FUSE_SETXATTR, FUSE_GETXATTR,
+ *      FUSE_LISTXATTR, FUSE_REMOVEXATTR, FUSE_OPENDIR, FUSE_READDIR,
+ *      FUSE_RELEASEDIR
+ *  - add padding to messages to accommodate 32-bit servers on 64-bit kernels
+ *
+ * 7.2:
+ *  - add FOPEN_DIRECT_IO and FOPEN_KEEP_CACHE flags
+ *  - add FUSE_FSYNCDIR message
+ *
+ * 7.3:
+ *  - add FUSE_ACCESS message
+ *  - add FUSE_CREATE message
+ *  - add filehandle to fuse_setattr_in
+ *
+ * 7.4:
+ *  - add frsize to fuse_kstatfs
+ *  - clean up request size limit checking
+ *
+ * 7.5:
+ *  - add flags and max_write to fuse_init_out
+ *
+ * 7.6:
+ *  - add max_readahead to fuse_init_in and fuse_init_out
+ *
+ * 7.7:
+ *  - add FUSE_INTERRUPT message
+ *  - add POSIX file lock support
+ *
+ * 7.8:
+ *  - add lock_owner and flags fields to fuse_release_in
+ *  - add FUSE_BMAP message
+ *  - add FUSE_DESTROY message
+ *
+ * 7.9:
+ *  - new fuse_getattr_in input argument of GETATTR
+ *  - add lk_flags in fuse_lk_in
+ *  - add lock_owner field to fuse_setattr_in, fuse_read_in and fuse_write_in
+ *  - add blksize field to fuse_attr
+ *  - add file flags field to fuse_read_in and fuse_write_in
+ *  - Add ATIME_NOW and MTIME_NOW flags to fuse_setattr_in
+ *
+ * 7.10
+ *  - add nonseekable open flag
+ *
+ * 7.11
+ *  - add IOCTL message
+ *  - add unsolicited notification support
+ *  - add POLL message and NOTIFY_POLL notification
+ *
+ * 7.12
+ *  - add umask flag to input argument of create, mknod and mkdir
+ *  - add notification messages for invalidation of inodes and
+ *    directory entries
+ *
+ * 7.13
+ *  - make max number of background requests and congestion threshold
+ *    tunables
+ *
+ * 7.14
+ *  - add splice support to fuse device
+ *
+ * 7.15
+ *  - add store notify
+ *  - add retrieve notify
+ *
+ * 7.16
+ *  - add BATCH_FORGET request
+ *  - FUSE_IOCTL_UNRESTRICTED shall now return with array of 'struct
+ *    fuse_ioctl_iovec' instead of ambiguous 'struct iovec'
+ *  - add FUSE_IOCTL_32BIT flag
+ *
+ * 7.17
+ *  - add FUSE_FLOCK_LOCKS and FUSE_RELEASE_FLOCK_UNLOCK
+ *
+ * 7.18
+ *  - add FUSE_IOCTL_DIR flag
+ *  - add FUSE_NOTIFY_DELETE
+ *
+ * 7.19
+ *  - add FUSE_FALLOCATE
+ *
+ * 7.20
+ *  - add FUSE_AUTO_INVAL_DATA
+ *
+ * 7.21
+ *  - add FUSE_READDIRPLUS
+ *  - send the requested events in POLL request
+ *
+ * 7.22
+ *  - add FUSE_ASYNC_DIO
+ *
+ * 7.23
+ *  - add FUSE_WRITEBACK_CACHE
+ *  - add time_gran to fuse_init_out
+ *  - add reserved space to fuse_init_out
+ *  - add FATTR_CTIME
+ *  - add ctime and ctimensec to fuse_setattr_in
+ *  - add FUSE_RENAME2 request
+ *  - add FUSE_NO_OPEN_SUPPORT flag
+ *
+ *  7.24
+ *  - add FUSE_LSEEK for SEEK_HOLE and SEEK_DATA support
+ *
+ *  7.25
+ *  - add FUSE_PARALLEL_DIROPS
+ *
+ *  7.26
+ *  - add FUSE_HANDLE_KILLPRIV
+ *  - add FUSE_POSIX_ACL
+ *
+ *  7.27
+ *  - add FUSE_ABORT_ERROR
+ *
+ *  7.28
+ *  - add FUSE_COPY_FILE_RANGE
+ *  - add FOPEN_CACHE_DIR
+ *  - add FUSE_MAX_PAGES, add max_pages to init_out
+ *  - add FUSE_CACHE_SYMLINKS
+ *
+ *  7.29
+ *  - add FUSE_NO_OPENDIR_SUPPORT flag
+ *
+ *  7.30
+ *  - add FUSE_EXPLICIT_INVAL_DATA
+ *  - add FUSE_IOCTL_COMPAT_X32
+ *
+ *  7.31
+ *  - add FUSE_WRITE_KILL_PRIV flag
+ *  - add FUSE_SETUPMAPPING and FUSE_REMOVEMAPPING
+ *  - add map_alignment to fuse_init_out, add FUSE_MAP_ALIGNMENT flag
+ *
+ *  7.32
+ *  - add flags to fuse_attr, add FUSE_ATTR_SUBMOUNT, add FUSE_SUBMOUNTS
+ *
+ *  7.33
+ *  - add FUSE_HANDLE_KILLPRIV_V2, FUSE_WRITE_KILL_SUIDGID, FATTR_KILL_SUIDGID
+ *  - add FUSE_OPEN_KILL_SUIDGID
+ *  - extend fuse_setxattr_in, add FUSE_SETXATTR_EXT
+ *  - add FUSE_SETXATTR_ACL_KILL_SGID
+ */
+
+#ifndef _LINUX_FUSE_H
+#define _LINUX_FUSE_H
+
+#include <stdint.h>
+
+/*
+ * Version negotiation:
+ *
+ * Both the kernel and userspace send the version they support in the
+ * INIT request and reply respectively.
+ *
+ * If the major versions match then both shall use the smallest
+ * of the two minor versions for communication.
+ *
+ * If the kernel supports a larger major version, then userspace shall
+ * reply with the major version it supports, ignore the rest of the
+ * INIT message and expect a new INIT message from the kernel with a
+ * matching major version.
+ *
+ * If the library supports a larger major version, then it shall fall
+ * back to the major protocol version sent by the kernel for
+ * communication and reply with that major version (and an arbitrary
+ * supported minor version).
+ */
+
+/** Version number of this interface */
+#define FUSE_KERNEL_VERSION 7
+
+/** Minor version number of this interface */
+#define FUSE_KERNEL_MINOR_VERSION 33
+
+/** The node ID of the root inode */
+#define FUSE_ROOT_ID 1
+
+/* Make sure all structures are padded to 64bit boundary, so 32bit
+   userspace works under 64bit kernels */
+
+struct fuse_attr {
+	uint64_t	ino;
+	uint64_t	size;
+	uint64_t	blocks;
+	uint64_t	atime;
+	uint64_t	mtime;
+	uint64_t	ctime;
+	uint32_t	atimensec;
+	uint32_t	mtimensec;
+	uint32_t	ctimensec;
+	uint32_t	mode;
+	uint32_t	nlink;
+	uint32_t	uid;
+	uint32_t	gid;
+	uint32_t	rdev;
+	uint32_t	blksize;
+	uint32_t	flags;
+};
+
+struct fuse_kstatfs {
+	uint64_t	blocks;
+	uint64_t	bfree;
+	uint64_t	bavail;
+	uint64_t	files;
+	uint64_t	ffree;
+	uint32_t	bsize;
+	uint32_t	namelen;
+	uint32_t	frsize;
+	uint32_t	padding;
+	uint32_t	spare[6];
+};
+
+struct fuse_file_lock {
+	uint64_t	start;
+	uint64_t	end;
+	uint32_t	type;
+	uint32_t	pid; /* tgid */
+};
+
+/**
+ * Bitmasks for fuse_setattr_in.valid
+ */
+#define FATTR_MODE	(1 << 0)
+#define FATTR_UID	(1 << 1)
+#define FATTR_GID	(1 << 2)
+#define FATTR_SIZE	(1 << 3)
+#define FATTR_ATIME	(1 << 4)
+#define FATTR_MTIME	(1 << 5)
+#define FATTR_FH	(1 << 6)
+#define FATTR_ATIME_NOW	(1 << 7)
+#define FATTR_MTIME_NOW	(1 << 8)
+#define FATTR_LOCKOWNER	(1 << 9)
+#define FATTR_CTIME	(1 << 10)
+#define FATTR_KILL_SUIDGID	(1 << 11)
+
+/**
+ * Flags returned by the OPEN request
+ *
+ * FOPEN_DIRECT_IO: bypass page cache for this open file
+ * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
+ * FOPEN_NONSEEKABLE: the file is not seekable
+ * FOPEN_CACHE_DIR: allow caching this directory
+ * FOPEN_STREAM: the file is stream-like (no file position at all)
+ */
+#define FOPEN_DIRECT_IO		(1 << 0)
+#define FOPEN_KEEP_CACHE	(1 << 1)
+#define FOPEN_NONSEEKABLE	(1 << 2)
+#define FOPEN_CACHE_DIR		(1 << 3)
+#define FOPEN_STREAM		(1 << 4)
+
+/**
+ * INIT request/reply flags
+ *
+ * FUSE_ASYNC_READ: asynchronous read requests
+ * FUSE_POSIX_LOCKS: remote locking for POSIX file locks
+ * FUSE_FILE_OPS: kernel sends file handle for fstat, etc... (not yet supported)
+ * FUSE_ATOMIC_O_TRUNC: handles the O_TRUNC open flag in the filesystem
+ * FUSE_EXPORT_SUPPORT: filesystem handles lookups of "." and ".."
+ * FUSE_BIG_WRITES: filesystem can handle write size larger than 4kB
+ * FUSE_DONT_MASK: don't apply umask to file mode on create operations
+ * FUSE_SPLICE_WRITE: kernel supports splice write on the device
+ * FUSE_SPLICE_MOVE: kernel supports splice move on the device
+ * FUSE_SPLICE_READ: kernel supports splice read on the device
+ * FUSE_FLOCK_LOCKS: remote locking for BSD style file locks
+ * FUSE_HAS_IOCTL_DIR: kernel supports ioctl on directories
+ * FUSE_AUTO_INVAL_DATA: automatically invalidate cached pages
+ * FUSE_DO_READDIRPLUS: do READDIRPLUS (READDIR+LOOKUP in one)
+ * FUSE_READDIRPLUS_AUTO: adaptive readdirplus
+ * FUSE_ASYNC_DIO: asynchronous direct I/O submission
+ * FUSE_WRITEBACK_CACHE: use writeback cache for buffered writes
+ * FUSE_NO_OPEN_SUPPORT: kernel supports zero-message opens
+ * FUSE_PARALLEL_DIROPS: allow parallel lookups and readdir
+ * FUSE_HANDLE_KILLPRIV: fs handles killing suid/sgid/cap on write/chown/trunc
+ * FUSE_POSIX_ACL: filesystem supports posix acls
+ * FUSE_ABORT_ERROR: reading the device after abort returns ECONNABORTED
+ * FUSE_MAX_PAGES: init_out.max_pages contains the max number of req pages
+ * FUSE_CACHE_SYMLINKS: cache READLINK responses
+ * FUSE_NO_OPENDIR_SUPPORT: kernel supports zero-message opendir
+ * FUSE_EXPLICIT_INVAL_DATA: only invalidate cached pages on explicit request
+ * FUSE_MAP_ALIGNMENT: init_out.map_alignment contains log2(byte alignment) for
+ *		       foffset and moffset fields in struct
+ *		       fuse_setupmapping_out and fuse_removemapping_one.
+ * FUSE_SUBMOUNTS: kernel supports auto-mounting directory submounts
+ * FUSE_HANDLE_KILLPRIV_V2: fs kills suid/sgid/cap on write/chown/trunc.
+ *			Upon write/truncate suid/sgid is only killed if caller
+ *			does not have CAP_FSETID. Additionally upon
+ *			write/truncate sgid is killed only if file has group
+ *			execute permission. (Same as Linux VFS behavior).
+ * FUSE_SETXATTR_EXT:	Server supports extended struct fuse_setxattr_in
+ */
+#define FUSE_ASYNC_READ		(1 << 0)
+#define FUSE_POSIX_LOCKS	(1 << 1)
+#define FUSE_FILE_OPS		(1 << 2)
+#define FUSE_ATOMIC_O_TRUNC	(1 << 3)
+#define FUSE_EXPORT_SUPPORT	(1 << 4)
+#define FUSE_BIG_WRITES		(1 << 5)
+#define FUSE_DONT_MASK		(1 << 6)
+#define FUSE_SPLICE_WRITE	(1 << 7)
+#define FUSE_SPLICE_MOVE	(1 << 8)
+#define FUSE_SPLICE_READ	(1 << 9)
+#define FUSE_FLOCK_LOCKS	(1 << 10)
+#define FUSE_HAS_IOCTL_DIR	(1 << 11)
+#define FUSE_AUTO_INVAL_DATA	(1 << 12)
+#define FUSE_DO_READDIRPLUS	(1 << 13)
+#define FUSE_READDIRPLUS_AUTO	(1 << 14)
+#define FUSE_ASYNC_DIO		(1 << 15)
+#define FUSE_WRITEBACK_CACHE	(1 << 16)
+#define FUSE_NO_OPEN_SUPPORT	(1 << 17)
+#define FUSE_PARALLEL_DIROPS    (1 << 18)
+#define FUSE_HANDLE_KILLPRIV	(1 << 19)
+#define FUSE_POSIX_ACL		(1 << 20)
+#define FUSE_ABORT_ERROR	(1 << 21)
+#define FUSE_MAX_PAGES		(1 << 22)
+#define FUSE_CACHE_SYMLINKS	(1 << 23)
+#define FUSE_NO_OPENDIR_SUPPORT (1 << 24)
+#define FUSE_EXPLICIT_INVAL_DATA (1 << 25)
+#define FUSE_MAP_ALIGNMENT	(1 << 26)
+#define FUSE_SUBMOUNTS		(1 << 27)
+#define FUSE_HANDLE_KILLPRIV_V2	(1 << 28)
+#define FUSE_SETXATTR_EXT	(1 << 29)
+
+/**
+ * CUSE INIT request/reply flags
+ *
+ * CUSE_UNRESTRICTED_IOCTL:  use unrestricted ioctl
+ */
+#define CUSE_UNRESTRICTED_IOCTL	(1 << 0)
+
+/**
+ * Release flags
+ */
+#define FUSE_RELEASE_FLUSH	(1 << 0)
+#define FUSE_RELEASE_FLOCK_UNLOCK	(1 << 1)
+
+/**
+ * Getattr flags
+ */
+#define FUSE_GETATTR_FH		(1 << 0)
+
+/**
+ * Lock flags
+ */
+#define FUSE_LK_FLOCK		(1 << 0)
+
+/**
+ * WRITE flags
+ *
+ * FUSE_WRITE_CACHE: delayed write from page cache, file handle is guessed
+ * FUSE_WRITE_LOCKOWNER: lock_owner field is valid
+ * FUSE_WRITE_KILL_SUIDGID: kill suid and sgid bits
+ */
+#define FUSE_WRITE_CACHE	(1 << 0)
+#define FUSE_WRITE_LOCKOWNER	(1 << 1)
+#define FUSE_WRITE_KILL_SUIDGID (1 << 2)
+
+/* Obsolete alias; this flag implies killing suid/sgid only. */
+#define FUSE_WRITE_KILL_PRIV	FUSE_WRITE_KILL_SUIDGID
+
+/**
+ * Read flags
+ */
+#define FUSE_READ_LOCKOWNER	(1 << 1)
+
+/**
+ * Ioctl flags
+ *
+ * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
+ * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
+ * FUSE_IOCTL_RETRY: retry with new iovecs
+ * FUSE_IOCTL_32BIT: 32bit ioctl
+ * FUSE_IOCTL_DIR: is a directory
+ * FUSE_IOCTL_COMPAT_X32: x32 compat ioctl on 64bit machine (64bit time_t)
+ *
+ * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
+ */
+#define FUSE_IOCTL_COMPAT	(1 << 0)
+#define FUSE_IOCTL_UNRESTRICTED	(1 << 1)
+#define FUSE_IOCTL_RETRY	(1 << 2)
+#define FUSE_IOCTL_32BIT	(1 << 3)
+#define FUSE_IOCTL_DIR		(1 << 4)
+#define FUSE_IOCTL_COMPAT_X32	(1 << 5)
+
+#define FUSE_IOCTL_MAX_IOV	256
+
+/**
+ * Poll flags
+ *
+ * FUSE_POLL_SCHEDULE_NOTIFY: request poll notify
+ */
+#define FUSE_POLL_SCHEDULE_NOTIFY (1 << 0)
+
+/**
+ * Fsync flags
+ *
+ * FUSE_FSYNC_FDATASYNC: Sync data only, not metadata
+ */
+#define FUSE_FSYNC_FDATASYNC	(1 << 0)
+
+/**
+ * fuse_attr flags
+ *
+ * FUSE_ATTR_SUBMOUNT: Object is a submount root
+ */
+#define FUSE_ATTR_SUBMOUNT      (1 << 0)
+
+/**
+ * Open flags
+ * FUSE_OPEN_KILL_SUIDGID: Kill suid and sgid if executable
+ */
+#define FUSE_OPEN_KILL_SUIDGID	(1 << 0)
+
+/**
+ * setxattr flags
+ * FUSE_SETXATTR_ACL_KILL_SGID: Clear SGID when system.posix_acl_access is set
+ */
+#define FUSE_SETXATTR_ACL_KILL_SGID	(1 << 0)
+
+enum fuse_opcode {
+	FUSE_LOOKUP		= 1,
+	FUSE_FORGET		= 2,  /* no reply */
+	FUSE_GETATTR		= 3,
+	FUSE_SETATTR		= 4,
+	FUSE_READLINK		= 5,
+	FUSE_SYMLINK		= 6,
+	FUSE_MKNOD		= 8,
+	FUSE_MKDIR		= 9,
+	FUSE_UNLINK		= 10,
+	FUSE_RMDIR		= 11,
+	FUSE_RENAME		= 12,
+	FUSE_LINK		= 13,
+	FUSE_OPEN		= 14,
+	FUSE_READ		= 15,
+	FUSE_WRITE		= 16,
+	FUSE_STATFS		= 17,
+	FUSE_RELEASE		= 18,
+	FUSE_FSYNC		= 20,
+	FUSE_SETXATTR		= 21,
+	FUSE_GETXATTR		= 22,
+	FUSE_LISTXATTR		= 23,
+	FUSE_REMOVEXATTR	= 24,
+	FUSE_FLUSH		= 25,
+	FUSE_INIT		= 26,
+	FUSE_OPENDIR		= 27,
+	FUSE_READDIR		= 28,
+	FUSE_RELEASEDIR		= 29,
+	FUSE_FSYNCDIR		= 30,
+	FUSE_GETLK		= 31,
+	FUSE_SETLK		= 32,
+	FUSE_SETLKW		= 33,
+	FUSE_ACCESS		= 34,
+	FUSE_CREATE		= 35,
+	FUSE_INTERRUPT		= 36,
+	FUSE_BMAP		= 37,
+	FUSE_DESTROY		= 38,
+	FUSE_IOCTL		= 39,
+	FUSE_POLL		= 40,
+	FUSE_NOTIFY_REPLY	= 41,
+	FUSE_BATCH_FORGET	= 42,
+	FUSE_FALLOCATE		= 43,
+	FUSE_READDIRPLUS	= 44,
+	FUSE_RENAME2		= 45,
+	FUSE_LSEEK		= 46,
+	FUSE_COPY_FILE_RANGE	= 47,
+	FUSE_SETUPMAPPING	= 48,
+	FUSE_REMOVEMAPPING	= 49,
+
+	/* CUSE specific operations */
+	CUSE_INIT		= 4096,
+
+	/* Reserved opcodes: helpful to detect structure endian-ness */
+	CUSE_INIT_BSWAP_RESERVED	= 1048576,	/* CUSE_INIT << 8 */
+	FUSE_INIT_BSWAP_RESERVED	= 436207616,	/* FUSE_INIT << 24 */
+};
+
+enum fuse_notify_code {
+	FUSE_NOTIFY_POLL   = 1,
+	FUSE_NOTIFY_INVAL_INODE = 2,
+	FUSE_NOTIFY_INVAL_ENTRY = 3,
+	FUSE_NOTIFY_STORE = 4,
+	FUSE_NOTIFY_RETRIEVE = 5,
+	FUSE_NOTIFY_DELETE = 6,
+	FUSE_NOTIFY_CODE_MAX,
+};
+
+/* The read buffer is required to be at least 8k, but may be much larger */
+#define FUSE_MIN_READ_BUFFER 8192
+
+#define FUSE_COMPAT_ENTRY_OUT_SIZE 120
+
+struct fuse_entry_out {
+	uint64_t	nodeid;		/* Inode ID */
+	uint64_t	generation;	/* Inode generation: nodeid:gen must
+					   be unique for the fs's lifetime */
+	uint64_t	entry_valid;	/* Cache timeout for the name */
+	uint64_t	attr_valid;	/* Cache timeout for the attributes */
+	uint32_t	entry_valid_nsec;
+	uint32_t	attr_valid_nsec;
+	struct fuse_attr attr;
+};
+
+struct fuse_forget_in {
+	uint64_t	nlookup;
+};
+
+struct fuse_forget_one {
+	uint64_t	nodeid;
+	uint64_t	nlookup;
+};
+
+struct fuse_batch_forget_in {
+	uint32_t	count;
+	uint32_t	dummy;
+};
+
+struct fuse_getattr_in {
+	uint32_t	getattr_flags;
+	uint32_t	dummy;
+	uint64_t	fh;
+};
+
+#define FUSE_COMPAT_ATTR_OUT_SIZE 96
+
+struct fuse_attr_out {
+	uint64_t	attr_valid;	/* Cache timeout for the attributes */
+	uint32_t	attr_valid_nsec;
+	uint32_t	dummy;
+	struct fuse_attr attr;
+};
+
+#define FUSE_COMPAT_MKNOD_IN_SIZE 8
+
+struct fuse_mknod_in {
+	uint32_t	mode;
+	uint32_t	rdev;
+	uint32_t	umask;
+	uint32_t	padding;
+};
+
+struct fuse_mkdir_in {
+	uint32_t	mode;
+	uint32_t	umask;
+};
+
+struct fuse_rename_in {
+	uint64_t	newdir;
+};
+
+struct fuse_rename2_in {
+	uint64_t	newdir;
+	uint32_t	flags;
+	uint32_t	padding;
+};
+
+struct fuse_link_in {
+	uint64_t	oldnodeid;
+};
+
+struct fuse_setattr_in {
+	uint32_t	valid;
+	uint32_t	padding;
+	uint64_t	fh;
+	uint64_t	size;
+	uint64_t	lock_owner;
+	uint64_t	atime;
+	uint64_t	mtime;
+	uint64_t	ctime;
+	uint32_t	atimensec;
+	uint32_t	mtimensec;
+	uint32_t	ctimensec;
+	uint32_t	mode;
+	uint32_t	unused4;
+	uint32_t	uid;
+	uint32_t	gid;
+	uint32_t	unused5;
+};
+
+struct fuse_open_in {
+	uint32_t	flags;
+	uint32_t	open_flags;	/* FUSE_OPEN_... */
+};
+
+struct fuse_create_in {
+	uint32_t	flags;
+	uint32_t	mode;
+	uint32_t	umask;
+	uint32_t	open_flags;	/* FUSE_OPEN_... */
+};
+
+struct fuse_open_out {
+	uint64_t	fh;
+	uint32_t	open_flags;
+	uint32_t	padding;
+};
+
+struct fuse_release_in {
+	uint64_t	fh;
+	uint32_t	flags;
+	uint32_t	release_flags;
+	uint64_t	lock_owner;
+};
+
+struct fuse_flush_in {
+	uint64_t	fh;
+	uint32_t	unused;
+	uint32_t	padding;
+	uint64_t	lock_owner;
+};
+
+struct fuse_read_in {
+	uint64_t	fh;
+	uint64_t	offset;
+	uint32_t	size;
+	uint32_t	read_flags;
+	uint64_t	lock_owner;
+	uint32_t	flags;
+	uint32_t	padding;
+};
+
+#define FUSE_COMPAT_WRITE_IN_SIZE 24
+
+struct fuse_write_in {
+	uint64_t	fh;
+	uint64_t	offset;
+	uint32_t	size;
+	uint32_t	write_flags;
+	uint64_t	lock_owner;
+	uint32_t	flags;
+	uint32_t	padding;
+};
+
+struct fuse_write_out {
+	uint32_t	size;
+	uint32_t	padding;
+};
+
+#define FUSE_COMPAT_STATFS_SIZE 48
+
+struct fuse_statfs_out {
+	struct fuse_kstatfs st;
+};
+
+struct fuse_fsync_in {
+	uint64_t	fh;
+	uint32_t	fsync_flags;
+	uint32_t	padding;
+};
+
+#define FUSE_COMPAT_SETXATTR_IN_SIZE 8
+
+struct fuse_setxattr_in {
+	uint32_t	size;
+	uint32_t	flags;
+	uint32_t	setxattr_flags;
+	uint32_t	padding;
+};
+
+struct fuse_getxattr_in {
+	uint32_t	size;
+	uint32_t	padding;
+};
+
+struct fuse_getxattr_out {
+	uint32_t	size;
+	uint32_t	padding;
+};
+
+struct fuse_lk_in {
+	uint64_t	fh;
+	uint64_t	owner;
+	struct fuse_file_lock lk;
+	uint32_t	lk_flags;
+	uint32_t	padding;
+};
+
+struct fuse_lk_out {
+	struct fuse_file_lock lk;
+};
+
+struct fuse_access_in {
+	uint32_t	mask;
+	uint32_t	padding;
+};
+
+struct fuse_init_in {
+	uint32_t	major;
+	uint32_t	minor;
+	uint32_t	max_readahead;
+	uint32_t	flags;
+};
+
+#define FUSE_COMPAT_INIT_OUT_SIZE 8
+#define FUSE_COMPAT_22_INIT_OUT_SIZE 24
+
+struct fuse_init_out {
+	uint32_t	major;
+	uint32_t	minor;
+	uint32_t	max_readahead;
+	uint32_t	flags;
+	uint16_t	max_background;
+	uint16_t	congestion_threshold;
+	uint32_t	max_write;
+	uint32_t	time_gran;
+	uint16_t	max_pages;
+	uint16_t	map_alignment;
+	uint32_t	unused[8];
+};
+
+#define CUSE_INIT_INFO_MAX 4096
+
+struct cuse_init_in {
+	uint32_t	major;
+	uint32_t	minor;
+	uint32_t	unused;
+	uint32_t	flags;
+};
+
+struct cuse_init_out {
+	uint32_t	major;
+	uint32_t	minor;
+	uint32_t	unused;
+	uint32_t	flags;
+	uint32_t	max_read;
+	uint32_t	max_write;
+	uint32_t	dev_major;		/* chardev major */
+	uint32_t	dev_minor;		/* chardev minor */
+	uint32_t	spare[10];
+};
+
+struct fuse_interrupt_in {
+	uint64_t	unique;
+};
+
+struct fuse_bmap_in {
+	uint64_t	block;
+	uint32_t	blocksize;
+	uint32_t	padding;
+};
+
+struct fuse_bmap_out {
+	uint64_t	block;
+};
+
+struct fuse_ioctl_in {
+	uint64_t	fh;
+	uint32_t	flags;
+	uint32_t	cmd;
+	uint64_t	arg;
+	uint32_t	in_size;
+	uint32_t	out_size;
+};
+
+struct fuse_ioctl_iovec {
+	uint64_t	base;
+	uint64_t	len;
+};
+
+struct fuse_ioctl_out {
+	int32_t		result;
+	uint32_t	flags;
+	uint32_t	in_iovs;
+	uint32_t	out_iovs;
+};
+
+struct fuse_poll_in {
+	uint64_t	fh;
+	uint64_t	kh;
+	uint32_t	flags;
+	uint32_t	events;
+};
+
+struct fuse_poll_out {
+	uint32_t	revents;
+	uint32_t	padding;
+};
+
+struct fuse_notify_poll_wakeup_out {
+	uint64_t	kh;
+};
+
+struct fuse_fallocate_in {
+	uint64_t	fh;
+	uint64_t	offset;
+	uint64_t	length;
+	uint32_t	mode;
+	uint32_t	padding;
+};
+
+struct fuse_in_header {
+	uint32_t	len;
+	uint32_t	opcode;
+	uint64_t	unique;
+	uint64_t	nodeid;
+	uint32_t	uid;
+	uint32_t	gid;
+	uint32_t	pid;
+	uint32_t	padding;
+};
+
+struct fuse_out_header {
+	uint32_t	len;
+	int32_t		error;
+	uint64_t	unique;
+};
+
+struct fuse_dirent {
+	uint64_t	ino;
+	uint64_t	off;
+	uint32_t	namelen;
+	uint32_t	type;
+	char name[];
+};
+
+#define FUSE_NAME_OFFSET offsetof(struct fuse_dirent, name)
+#define FUSE_DIRENT_ALIGN(x) \
+	(((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))
+#define FUSE_DIRENT_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)
+
+struct fuse_direntplus {
+	struct fuse_entry_out entry_out;
+	struct fuse_dirent dirent;
+};
+
+#define FUSE_NAME_OFFSET_DIRENTPLUS \
+	offsetof(struct fuse_direntplus, dirent.name)
+#define FUSE_DIRENTPLUS_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET_DIRENTPLUS + (d)->dirent.namelen)
+
+struct fuse_notify_inval_inode_out {
+	uint64_t	ino;
+	int64_t		off;
+	int64_t		len;
+};
+
+struct fuse_notify_inval_entry_out {
+	uint64_t	parent;
+	uint32_t	namelen;
+	uint32_t	padding;
+};
+
+struct fuse_notify_delete_out {
+	uint64_t	parent;
+	uint64_t	child;
+	uint32_t	namelen;
+	uint32_t	padding;
+};
+
+struct fuse_notify_store_out {
+	uint64_t	nodeid;
+	uint64_t	offset;
+	uint32_t	size;
+	uint32_t	padding;
+};
+
+struct fuse_notify_retrieve_out {
+	uint64_t	notify_unique;
+	uint64_t	nodeid;
+	uint64_t	offset;
+	uint32_t	size;
+	uint32_t	padding;
+};
+
+/* Matches the size of fuse_write_in */
+struct fuse_notify_retrieve_in {
+	uint64_t	dummy1;
+	uint64_t	offset;
+	uint32_t	size;
+	uint32_t	dummy2;
+	uint64_t	dummy3;
+	uint64_t	dummy4;
+};
+
+/* Device ioctls: */
+#define FUSE_DEV_IOC_MAGIC		229
+#define FUSE_DEV_IOC_CLONE		_IOR(FUSE_DEV_IOC_MAGIC, 0, uint32_t)
+
+struct fuse_lseek_in {
+	uint64_t	fh;
+	uint64_t	offset;
+	uint32_t	whence;
+	uint32_t	padding;
+};
+
+struct fuse_lseek_out {
+	uint64_t	offset;
+};
+
+struct fuse_copy_file_range_in {
+	uint64_t	fh_in;
+	uint64_t	off_in;
+	uint64_t	nodeid_out;
+	uint64_t	fh_out;
+	uint64_t	off_out;
+	uint64_t	len;
+	uint64_t	flags;
+};
+
+#define FUSE_SETUPMAPPING_FLAG_WRITE (1ull << 0)
+#define FUSE_SETUPMAPPING_FLAG_READ (1ull << 1)
+struct fuse_setupmapping_in {
+	/* An already open handle */
+	uint64_t	fh;
+	/* Offset into the file to start the mapping */
+	uint64_t	foffset;
+	/* Length of mapping required */
+	uint64_t	len;
+	/* Flags, FUSE_SETUPMAPPING_FLAG_* */
+	uint64_t	flags;
+	/* Offset in Memory Window */
+	uint64_t	moffset;
+};
+
+struct fuse_removemapping_in {
+	/* number of fuse_removemapping_one follows */
+	uint32_t        count;
+};
+
+struct fuse_removemapping_one {
+	/* Offset into the dax window start the unmapping */
+	uint64_t        moffset;
+	/* Length of mapping required */
+	uint64_t	len;
+};
+
+#define FUSE_REMOVEMAPPING_MAX_ENTRY   \
+		(PAGE_SIZE / sizeof(struct fuse_removemapping_one))
+
+#endif /* _LINUX_FUSE_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/if_ether.h b/subprojects/libvhost-user/standard-headers/linux/if_ether.h
new file mode 100644
index 0000000..91cf735
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/if_ether.h
@@ -0,0 +1 @@
+#define ETH_ALEN    6
diff --git a/subprojects/libvhost-user/standard-headers/linux/input-event-codes.h b/subprojects/libvhost-user/standard-headers/linux/input-event-codes.h
new file mode 100644
index 0000000..b5e86b4
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/input-event-codes.h
@@ -0,0 +1,950 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * Input event codes
+ *
+ *    *** IMPORTANT ***
+ * This file is not only included from C-code but also from devicetree source
+ * files. As such this file MUST only contain comments and defines.
+ *
+ * Copyright (c) 1999-2002 Vojtech Pavlik
+ * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef _INPUT_EVENT_CODES_H
+#define _INPUT_EVENT_CODES_H
+
+/*
+ * Device properties and quirks
+ */
+
+#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
+#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
+#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
+#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
+#define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
+#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
+#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
+
+#define INPUT_PROP_MAX			0x1f
+#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
+
+/*
+ * Event types
+ */
+
+#define EV_SYN			0x00
+#define EV_KEY			0x01
+#define EV_REL			0x02
+#define EV_ABS			0x03
+#define EV_MSC			0x04
+#define EV_SW			0x05
+#define EV_LED			0x11
+#define EV_SND			0x12
+#define EV_REP			0x14
+#define EV_FF			0x15
+#define EV_PWR			0x16
+#define EV_FF_STATUS		0x17
+#define EV_MAX			0x1f
+#define EV_CNT			(EV_MAX+1)
+
+/*
+ * Synchronization events.
+ */
+
+#define SYN_REPORT		0
+#define SYN_CONFIG		1
+#define SYN_MT_REPORT		2
+#define SYN_DROPPED		3
+#define SYN_MAX			0xf
+#define SYN_CNT			(SYN_MAX+1)
+
+/*
+ * Keys and buttons
+ *
+ * Most of the keys/buttons are modeled after USB HUT 1.12
+ * (see http://www.usb.org/developers/hidpage).
+ * Abbreviations in the comments:
+ * AC - Application Control
+ * AL - Application Launch Button
+ * SC - System Control
+ */
+
+#define KEY_RESERVED		0
+#define KEY_ESC			1
+#define KEY_1			2
+#define KEY_2			3
+#define KEY_3			4
+#define KEY_4			5
+#define KEY_5			6
+#define KEY_6			7
+#define KEY_7			8
+#define KEY_8			9
+#define KEY_9			10
+#define KEY_0			11
+#define KEY_MINUS		12
+#define KEY_EQUAL		13
+#define KEY_BACKSPACE		14
+#define KEY_TAB			15
+#define KEY_Q			16
+#define KEY_W			17
+#define KEY_E			18
+#define KEY_R			19
+#define KEY_T			20
+#define KEY_Y			21
+#define KEY_U			22
+#define KEY_I			23
+#define KEY_O			24
+#define KEY_P			25
+#define KEY_LEFTBRACE		26
+#define KEY_RIGHTBRACE		27
+#define KEY_ENTER		28
+#define KEY_LEFTCTRL		29
+#define KEY_A			30
+#define KEY_S			31
+#define KEY_D			32
+#define KEY_F			33
+#define KEY_G			34
+#define KEY_H			35
+#define KEY_J			36
+#define KEY_K			37
+#define KEY_L			38
+#define KEY_SEMICOLON		39
+#define KEY_APOSTROPHE		40
+#define KEY_GRAVE		41
+#define KEY_LEFTSHIFT		42
+#define KEY_BACKSLASH		43
+#define KEY_Z			44
+#define KEY_X			45
+#define KEY_C			46
+#define KEY_V			47
+#define KEY_B			48
+#define KEY_N			49
+#define KEY_M			50
+#define KEY_COMMA		51
+#define KEY_DOT			52
+#define KEY_SLASH		53
+#define KEY_RIGHTSHIFT		54
+#define KEY_KPASTERISK		55
+#define KEY_LEFTALT		56
+#define KEY_SPACE		57
+#define KEY_CAPSLOCK		58
+#define KEY_F1			59
+#define KEY_F2			60
+#define KEY_F3			61
+#define KEY_F4			62
+#define KEY_F5			63
+#define KEY_F6			64
+#define KEY_F7			65
+#define KEY_F8			66
+#define KEY_F9			67
+#define KEY_F10			68
+#define KEY_NUMLOCK		69
+#define KEY_SCROLLLOCK		70
+#define KEY_KP7			71
+#define KEY_KP8			72
+#define KEY_KP9			73
+#define KEY_KPMINUS		74
+#define KEY_KP4			75
+#define KEY_KP5			76
+#define KEY_KP6			77
+#define KEY_KPPLUS		78
+#define KEY_KP1			79
+#define KEY_KP2			80
+#define KEY_KP3			81
+#define KEY_KP0			82
+#define KEY_KPDOT		83
+
+#define KEY_ZENKAKUHANKAKU	85
+#define KEY_102ND		86
+#define KEY_F11			87
+#define KEY_F12			88
+#define KEY_RO			89
+#define KEY_KATAKANA		90
+#define KEY_HIRAGANA		91
+#define KEY_HENKAN		92
+#define KEY_KATAKANAHIRAGANA	93
+#define KEY_MUHENKAN		94
+#define KEY_KPJPCOMMA		95
+#define KEY_KPENTER		96
+#define KEY_RIGHTCTRL		97
+#define KEY_KPSLASH		98
+#define KEY_SYSRQ		99
+#define KEY_RIGHTALT		100
+#define KEY_LINEFEED		101
+#define KEY_HOME		102
+#define KEY_UP			103
+#define KEY_PAGEUP		104
+#define KEY_LEFT		105
+#define KEY_RIGHT		106
+#define KEY_END			107
+#define KEY_DOWN		108
+#define KEY_PAGEDOWN		109
+#define KEY_INSERT		110
+#define KEY_DELETE		111
+#define KEY_MACRO		112
+#define KEY_MUTE		113
+#define KEY_VOLUMEDOWN		114
+#define KEY_VOLUMEUP		115
+#define KEY_POWER		116	/* SC System Power Down */
+#define KEY_KPEQUAL		117
+#define KEY_KPPLUSMINUS		118
+#define KEY_PAUSE		119
+#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
+
+#define KEY_KPCOMMA		121
+#define KEY_HANGEUL		122
+#define KEY_HANGUEL		KEY_HANGEUL
+#define KEY_HANJA		123
+#define KEY_YEN			124
+#define KEY_LEFTMETA		125
+#define KEY_RIGHTMETA		126
+#define KEY_COMPOSE		127
+
+#define KEY_STOP		128	/* AC Stop */
+#define KEY_AGAIN		129
+#define KEY_PROPS		130	/* AC Properties */
+#define KEY_UNDO		131	/* AC Undo */
+#define KEY_FRONT		132
+#define KEY_COPY		133	/* AC Copy */
+#define KEY_OPEN		134	/* AC Open */
+#define KEY_PASTE		135	/* AC Paste */
+#define KEY_FIND		136	/* AC Search */
+#define KEY_CUT			137	/* AC Cut */
+#define KEY_HELP		138	/* AL Integrated Help Center */
+#define KEY_MENU		139	/* Menu (show menu) */
+#define KEY_CALC		140	/* AL Calculator */
+#define KEY_SETUP		141
+#define KEY_SLEEP		142	/* SC System Sleep */
+#define KEY_WAKEUP		143	/* System Wake Up */
+#define KEY_FILE		144	/* AL Local Machine Browser */
+#define KEY_SENDFILE		145
+#define KEY_DELETEFILE		146
+#define KEY_XFER		147
+#define KEY_PROG1		148
+#define KEY_PROG2		149
+#define KEY_WWW			150	/* AL Internet Browser */
+#define KEY_MSDOS		151
+#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
+#define KEY_SCREENLOCK		KEY_COFFEE
+#define KEY_ROTATE_DISPLAY	153	/* Display orientation for e.g. tablets */
+#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
+#define KEY_CYCLEWINDOWS	154
+#define KEY_MAIL		155
+#define KEY_BOOKMARKS		156	/* AC Bookmarks */
+#define KEY_COMPUTER		157
+#define KEY_BACK		158	/* AC Back */
+#define KEY_FORWARD		159	/* AC Forward */
+#define KEY_CLOSECD		160
+#define KEY_EJECTCD		161
+#define KEY_EJECTCLOSECD	162
+#define KEY_NEXTSONG		163
+#define KEY_PLAYPAUSE		164
+#define KEY_PREVIOUSSONG	165
+#define KEY_STOPCD		166
+#define KEY_RECORD		167
+#define KEY_REWIND		168
+#define KEY_PHONE		169	/* Media Select Telephone */
+#define KEY_ISO			170
+#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
+#define KEY_HOMEPAGE		172	/* AC Home */
+#define KEY_REFRESH		173	/* AC Refresh */
+#define KEY_EXIT		174	/* AC Exit */
+#define KEY_MOVE		175
+#define KEY_EDIT		176
+#define KEY_SCROLLUP		177
+#define KEY_SCROLLDOWN		178
+#define KEY_KPLEFTPAREN		179
+#define KEY_KPRIGHTPAREN	180
+#define KEY_NEW			181	/* AC New */
+#define KEY_REDO		182	/* AC Redo/Repeat */
+
+#define KEY_F13			183
+#define KEY_F14			184
+#define KEY_F15			185
+#define KEY_F16			186
+#define KEY_F17			187
+#define KEY_F18			188
+#define KEY_F19			189
+#define KEY_F20			190
+#define KEY_F21			191
+#define KEY_F22			192
+#define KEY_F23			193
+#define KEY_F24			194
+
+#define KEY_PLAYCD		200
+#define KEY_PAUSECD		201
+#define KEY_PROG3		202
+#define KEY_PROG4		203
+#define KEY_DASHBOARD		204	/* AL Dashboard */
+#define KEY_SUSPEND		205
+#define KEY_CLOSE		206	/* AC Close */
+#define KEY_PLAY		207
+#define KEY_FASTFORWARD		208
+#define KEY_BASSBOOST		209
+#define KEY_PRINT		210	/* AC Print */
+#define KEY_HP			211
+#define KEY_CAMERA		212
+#define KEY_SOUND		213
+#define KEY_QUESTION		214
+#define KEY_EMAIL		215
+#define KEY_CHAT		216
+#define KEY_SEARCH		217
+#define KEY_CONNECT		218
+#define KEY_FINANCE		219	/* AL Checkbook/Finance */
+#define KEY_SPORT		220
+#define KEY_SHOP		221
+#define KEY_ALTERASE		222
+#define KEY_CANCEL		223	/* AC Cancel */
+#define KEY_BRIGHTNESSDOWN	224
+#define KEY_BRIGHTNESSUP	225
+#define KEY_MEDIA		226
+
+#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
+					   outputs (Monitor/LCD/TV-out/etc) */
+#define KEY_KBDILLUMTOGGLE	228
+#define KEY_KBDILLUMDOWN	229
+#define KEY_KBDILLUMUP		230
+
+#define KEY_SEND		231	/* AC Send */
+#define KEY_REPLY		232	/* AC Reply */
+#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
+#define KEY_SAVE		234	/* AC Save */
+#define KEY_DOCUMENTS		235
+
+#define KEY_BATTERY		236
+
+#define KEY_BLUETOOTH		237
+#define KEY_WLAN		238
+#define KEY_UWB			239
+
+#define KEY_UNKNOWN		240
+
+#define KEY_VIDEO_NEXT		241	/* drive next video source */
+#define KEY_VIDEO_PREV		242	/* drive previous video source */
+#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
+#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
+					  brightness control is off,
+					  rely on ambient */
+#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
+#define KEY_DISPLAY_OFF		245	/* display device to off state */
+
+#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
+#define KEY_WIMAX		KEY_WWAN
+#define KEY_RFKILL		247	/* Key that controls all radios */
+
+#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+
+/* Code 255 is reserved for special needs of AT keyboard driver */
+
+#define BTN_MISC		0x100
+#define BTN_0			0x100
+#define BTN_1			0x101
+#define BTN_2			0x102
+#define BTN_3			0x103
+#define BTN_4			0x104
+#define BTN_5			0x105
+#define BTN_6			0x106
+#define BTN_7			0x107
+#define BTN_8			0x108
+#define BTN_9			0x109
+
+#define BTN_MOUSE		0x110
+#define BTN_LEFT		0x110
+#define BTN_RIGHT		0x111
+#define BTN_MIDDLE		0x112
+#define BTN_SIDE		0x113
+#define BTN_EXTRA		0x114
+#define BTN_FORWARD		0x115
+#define BTN_BACK		0x116
+#define BTN_TASK		0x117
+
+#define BTN_JOYSTICK		0x120
+#define BTN_TRIGGER		0x120
+#define BTN_THUMB		0x121
+#define BTN_THUMB2		0x122
+#define BTN_TOP			0x123
+#define BTN_TOP2		0x124
+#define BTN_PINKIE		0x125
+#define BTN_BASE		0x126
+#define BTN_BASE2		0x127
+#define BTN_BASE3		0x128
+#define BTN_BASE4		0x129
+#define BTN_BASE5		0x12a
+#define BTN_BASE6		0x12b
+#define BTN_DEAD		0x12f
+
+#define BTN_GAMEPAD		0x130
+#define BTN_SOUTH		0x130
+#define BTN_A			BTN_SOUTH
+#define BTN_EAST		0x131
+#define BTN_B			BTN_EAST
+#define BTN_C			0x132
+#define BTN_NORTH		0x133
+#define BTN_X			BTN_NORTH
+#define BTN_WEST		0x134
+#define BTN_Y			BTN_WEST
+#define BTN_Z			0x135
+#define BTN_TL			0x136
+#define BTN_TR			0x137
+#define BTN_TL2			0x138
+#define BTN_TR2			0x139
+#define BTN_SELECT		0x13a
+#define BTN_START		0x13b
+#define BTN_MODE		0x13c
+#define BTN_THUMBL		0x13d
+#define BTN_THUMBR		0x13e
+
+#define BTN_DIGI		0x140
+#define BTN_TOOL_PEN		0x140
+#define BTN_TOOL_RUBBER		0x141
+#define BTN_TOOL_BRUSH		0x142
+#define BTN_TOOL_PENCIL		0x143
+#define BTN_TOOL_AIRBRUSH	0x144
+#define BTN_TOOL_FINGER		0x145
+#define BTN_TOOL_MOUSE		0x146
+#define BTN_TOOL_LENS		0x147
+#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
+#define BTN_STYLUS3		0x149
+#define BTN_TOUCH		0x14a
+#define BTN_STYLUS		0x14b
+#define BTN_STYLUS2		0x14c
+#define BTN_TOOL_DOUBLETAP	0x14d
+#define BTN_TOOL_TRIPLETAP	0x14e
+#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
+
+#define BTN_WHEEL		0x150
+#define BTN_GEAR_DOWN		0x150
+#define BTN_GEAR_UP		0x151
+
+#define KEY_OK			0x160
+#define KEY_SELECT		0x161
+#define KEY_GOTO		0x162
+#define KEY_CLEAR		0x163
+#define KEY_POWER2		0x164
+#define KEY_OPTION		0x165
+#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
+#define KEY_TIME		0x167
+#define KEY_VENDOR		0x168
+#define KEY_ARCHIVE		0x169
+#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
+#define KEY_CHANNEL		0x16b
+#define KEY_FAVORITES		0x16c
+#define KEY_EPG			0x16d
+#define KEY_PVR			0x16e	/* Media Select Home */
+#define KEY_MHP			0x16f
+#define KEY_LANGUAGE		0x170
+#define KEY_TITLE		0x171
+#define KEY_SUBTITLE		0x172
+#define KEY_ANGLE		0x173
+#define KEY_FULL_SCREEN		0x174	/* AC View Toggle */
+#define KEY_ZOOM		KEY_FULL_SCREEN
+#define KEY_MODE		0x175
+#define KEY_KEYBOARD		0x176
+#define KEY_ASPECT_RATIO	0x177	/* HUTRR37: Aspect */
+#define KEY_SCREEN		KEY_ASPECT_RATIO
+#define KEY_PC			0x178	/* Media Select Computer */
+#define KEY_TV			0x179	/* Media Select TV */
+#define KEY_TV2			0x17a	/* Media Select Cable */
+#define KEY_VCR			0x17b	/* Media Select VCR */
+#define KEY_VCR2		0x17c	/* VCR Plus */
+#define KEY_SAT			0x17d	/* Media Select Satellite */
+#define KEY_SAT2		0x17e
+#define KEY_CD			0x17f	/* Media Select CD */
+#define KEY_TAPE		0x180	/* Media Select Tape */
+#define KEY_RADIO		0x181
+#define KEY_TUNER		0x182	/* Media Select Tuner */
+#define KEY_PLAYER		0x183
+#define KEY_TEXT		0x184
+#define KEY_DVD			0x185	/* Media Select DVD */
+#define KEY_AUX			0x186
+#define KEY_MP3			0x187
+#define KEY_AUDIO		0x188	/* AL Audio Browser */
+#define KEY_VIDEO		0x189	/* AL Movie Browser */
+#define KEY_DIRECTORY		0x18a
+#define KEY_LIST		0x18b
+#define KEY_MEMO		0x18c	/* Media Select Messages */
+#define KEY_CALENDAR		0x18d
+#define KEY_RED			0x18e
+#define KEY_GREEN		0x18f
+#define KEY_YELLOW		0x190
+#define KEY_BLUE		0x191
+#define KEY_CHANNELUP		0x192	/* Channel Increment */
+#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
+#define KEY_FIRST		0x194
+#define KEY_LAST		0x195	/* Recall Last */
+#define KEY_AB			0x196
+#define KEY_NEXT		0x197
+#define KEY_RESTART		0x198
+#define KEY_SLOW		0x199
+#define KEY_SHUFFLE		0x19a
+#define KEY_BREAK		0x19b
+#define KEY_PREVIOUS		0x19c
+#define KEY_DIGITS		0x19d
+#define KEY_TEEN		0x19e
+#define KEY_TWEN		0x19f
+#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
+#define KEY_GAMES		0x1a1	/* Media Select Games */
+#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
+#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
+#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
+#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
+#define KEY_EDITOR		0x1a6	/* AL Text Editor */
+#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
+#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
+#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
+#define KEY_DATABASE		0x1aa	/* AL Database App */
+#define KEY_NEWS		0x1ab	/* AL Newsreader */
+#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
+#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
+#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
+#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
+#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
+#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
+#define KEY_LOGOFF		0x1b1   /* AL Logoff */
+
+#define KEY_DOLLAR		0x1b2
+#define KEY_EURO		0x1b3
+
+#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
+#define KEY_FRAMEFORWARD	0x1b5
+#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
+#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
+#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
+#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
+#define KEY_IMAGES		0x1ba	/* AL Image Browser */
+#define KEY_NOTIFICATION_CENTER	0x1bc	/* Show/hide the notification center */
+#define KEY_PICKUP_PHONE	0x1bd	/* Answer incoming call */
+#define KEY_HANGUP_PHONE	0x1be	/* Decline incoming call */
+
+#define KEY_DEL_EOL		0x1c0
+#define KEY_DEL_EOS		0x1c1
+#define KEY_INS_LINE		0x1c2
+#define KEY_DEL_LINE		0x1c3
+
+#define KEY_FN			0x1d0
+#define KEY_FN_ESC		0x1d1
+#define KEY_FN_F1		0x1d2
+#define KEY_FN_F2		0x1d3
+#define KEY_FN_F3		0x1d4
+#define KEY_FN_F4		0x1d5
+#define KEY_FN_F5		0x1d6
+#define KEY_FN_F6		0x1d7
+#define KEY_FN_F7		0x1d8
+#define KEY_FN_F8		0x1d9
+#define KEY_FN_F9		0x1da
+#define KEY_FN_F10		0x1db
+#define KEY_FN_F11		0x1dc
+#define KEY_FN_F12		0x1dd
+#define KEY_FN_1		0x1de
+#define KEY_FN_2		0x1df
+#define KEY_FN_D		0x1e0
+#define KEY_FN_E		0x1e1
+#define KEY_FN_F		0x1e2
+#define KEY_FN_S		0x1e3
+#define KEY_FN_B		0x1e4
+#define KEY_FN_RIGHT_SHIFT	0x1e5
+
+#define KEY_BRL_DOT1		0x1f1
+#define KEY_BRL_DOT2		0x1f2
+#define KEY_BRL_DOT3		0x1f3
+#define KEY_BRL_DOT4		0x1f4
+#define KEY_BRL_DOT5		0x1f5
+#define KEY_BRL_DOT6		0x1f6
+#define KEY_BRL_DOT7		0x1f7
+#define KEY_BRL_DOT8		0x1f8
+#define KEY_BRL_DOT9		0x1f9
+#define KEY_BRL_DOT10		0x1fa
+
+#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
+#define KEY_NUMERIC_1		0x201	/* and other keypads */
+#define KEY_NUMERIC_2		0x202
+#define KEY_NUMERIC_3		0x203
+#define KEY_NUMERIC_4		0x204
+#define KEY_NUMERIC_5		0x205
+#define KEY_NUMERIC_6		0x206
+#define KEY_NUMERIC_7		0x207
+#define KEY_NUMERIC_8		0x208
+#define KEY_NUMERIC_9		0x209
+#define KEY_NUMERIC_STAR	0x20a
+#define KEY_NUMERIC_POUND	0x20b
+#define KEY_NUMERIC_A		0x20c	/* Phone key A - HUT Telephony 0xb9 */
+#define KEY_NUMERIC_B		0x20d
+#define KEY_NUMERIC_C		0x20e
+#define KEY_NUMERIC_D		0x20f
+
+#define KEY_CAMERA_FOCUS	0x210
+#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
+
+#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
+#define KEY_TOUCHPAD_ON		0x213
+#define KEY_TOUCHPAD_OFF	0x214
+
+#define KEY_CAMERA_ZOOMIN	0x215
+#define KEY_CAMERA_ZOOMOUT	0x216
+#define KEY_CAMERA_UP		0x217
+#define KEY_CAMERA_DOWN		0x218
+#define KEY_CAMERA_LEFT		0x219
+#define KEY_CAMERA_RIGHT	0x21a
+
+#define KEY_ATTENDANT_ON	0x21b
+#define KEY_ATTENDANT_OFF	0x21c
+#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
+#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
+
+#define BTN_DPAD_UP		0x220
+#define BTN_DPAD_DOWN		0x221
+#define BTN_DPAD_LEFT		0x222
+#define BTN_DPAD_RIGHT		0x223
+
+#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
+#define KEY_ROTATE_LOCK_TOGGLE	0x231	/* Display rotation lock */
+
+#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
+#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
+#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
+#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
+#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
+#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
+#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
+#define KEY_ASSISTANT		0x247	/* AL Context-aware desktop assistant */
+#define KEY_KBD_LAYOUT_NEXT	0x248	/* AC Next Keyboard Layout Select */
+#define KEY_EMOJI_PICKER	0x249	/* Show/hide emoji picker (HUTRR101) */
+
+#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
+#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
+
+#define KEY_KBDINPUTASSIST_PREV		0x260
+#define KEY_KBDINPUTASSIST_NEXT		0x261
+#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
+#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
+#define KEY_KBDINPUTASSIST_ACCEPT		0x264
+#define KEY_KBDINPUTASSIST_CANCEL		0x265
+
+/* Diagonal movement keys */
+#define KEY_RIGHT_UP			0x266
+#define KEY_RIGHT_DOWN			0x267
+#define KEY_LEFT_UP			0x268
+#define KEY_LEFT_DOWN			0x269
+
+#define KEY_ROOT_MENU			0x26a /* Show Device's Root Menu */
+/* Show Top Menu of the Media (e.g. DVD) */
+#define KEY_MEDIA_TOP_MENU		0x26b
+#define KEY_NUMERIC_11			0x26c
+#define KEY_NUMERIC_12			0x26d
+/*
+ * Toggle Audio Description: refers to an audio service that helps blind and
+ * visually impaired consumers understand the action in a program. Note: in
+ * some countries this is referred to as "Video Description".
+ */
+#define KEY_AUDIO_DESC			0x26e
+#define KEY_3D_MODE			0x26f
+#define KEY_NEXT_FAVORITE		0x270
+#define KEY_STOP_RECORD			0x271
+#define KEY_PAUSE_RECORD		0x272
+#define KEY_VOD				0x273 /* Video on Demand */
+#define KEY_UNMUTE			0x274
+#define KEY_FASTREVERSE			0x275
+#define KEY_SLOWREVERSE			0x276
+/*
+ * Control a data application associated with the currently viewed channel,
+ * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
+ */
+#define KEY_DATA			0x277
+#define KEY_ONSCREEN_KEYBOARD		0x278
+/* Electronic privacy screen control */
+#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
+
+/* Select an area of screen to be copied */
+#define KEY_SELECTIVE_SCREENSHOT	0x27a
+
+/*
+ * Some keyboards have keys which do not have a defined meaning, these keys
+ * are intended to be programmed / bound to macros by the user. For most
+ * keyboards with these macro-keys the key-sequence to inject, or action to
+ * take, is all handled by software on the host side. So from the kernel's
+ * point of view these are just normal keys.
+ *
+ * The KEY_MACRO# codes below are intended for such keys, which may be labeled
+ * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
+ * where the marking on the key does indicate a defined meaning / purpose.
+ *
+ * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
+ * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
+ * define MUST be added.
+ */
+#define KEY_MACRO1			0x290
+#define KEY_MACRO2			0x291
+#define KEY_MACRO3			0x292
+#define KEY_MACRO4			0x293
+#define KEY_MACRO5			0x294
+#define KEY_MACRO6			0x295
+#define KEY_MACRO7			0x296
+#define KEY_MACRO8			0x297
+#define KEY_MACRO9			0x298
+#define KEY_MACRO10			0x299
+#define KEY_MACRO11			0x29a
+#define KEY_MACRO12			0x29b
+#define KEY_MACRO13			0x29c
+#define KEY_MACRO14			0x29d
+#define KEY_MACRO15			0x29e
+#define KEY_MACRO16			0x29f
+#define KEY_MACRO17			0x2a0
+#define KEY_MACRO18			0x2a1
+#define KEY_MACRO19			0x2a2
+#define KEY_MACRO20			0x2a3
+#define KEY_MACRO21			0x2a4
+#define KEY_MACRO22			0x2a5
+#define KEY_MACRO23			0x2a6
+#define KEY_MACRO24			0x2a7
+#define KEY_MACRO25			0x2a8
+#define KEY_MACRO26			0x2a9
+#define KEY_MACRO27			0x2aa
+#define KEY_MACRO28			0x2ab
+#define KEY_MACRO29			0x2ac
+#define KEY_MACRO30			0x2ad
+
+/*
+ * Some keyboards with the macro-keys described above have some extra keys
+ * for controlling the host-side software responsible for the macro handling:
+ * -A macro recording start/stop key. Note that not all keyboards which emit
+ *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
+ *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
+ *  should be interpreted as a recording start/stop toggle;
+ * -Keys for switching between different macro (pre)sets, either a key for
+ *  cycling through the configured presets or keys to directly select a preset.
+ */
+#define KEY_MACRO_RECORD_START		0x2b0
+#define KEY_MACRO_RECORD_STOP		0x2b1
+#define KEY_MACRO_PRESET_CYCLE		0x2b2
+#define KEY_MACRO_PRESET1		0x2b3
+#define KEY_MACRO_PRESET2		0x2b4
+#define KEY_MACRO_PRESET3		0x2b5
+
+/*
+ * Some keyboards have a buildin LCD panel where the contents are controlled
+ * by the host. Often these have a number of keys directly below the LCD
+ * intended for controlling a menu shown on the LCD. These keys often don't
+ * have any labeling so we just name them KEY_KBD_LCD_MENU#
+ */
+#define KEY_KBD_LCD_MENU1		0x2b8
+#define KEY_KBD_LCD_MENU2		0x2b9
+#define KEY_KBD_LCD_MENU3		0x2ba
+#define KEY_KBD_LCD_MENU4		0x2bb
+#define KEY_KBD_LCD_MENU5		0x2bc
+
+#define BTN_TRIGGER_HAPPY		0x2c0
+#define BTN_TRIGGER_HAPPY1		0x2c0
+#define BTN_TRIGGER_HAPPY2		0x2c1
+#define BTN_TRIGGER_HAPPY3		0x2c2
+#define BTN_TRIGGER_HAPPY4		0x2c3
+#define BTN_TRIGGER_HAPPY5		0x2c4
+#define BTN_TRIGGER_HAPPY6		0x2c5
+#define BTN_TRIGGER_HAPPY7		0x2c6
+#define BTN_TRIGGER_HAPPY8		0x2c7
+#define BTN_TRIGGER_HAPPY9		0x2c8
+#define BTN_TRIGGER_HAPPY10		0x2c9
+#define BTN_TRIGGER_HAPPY11		0x2ca
+#define BTN_TRIGGER_HAPPY12		0x2cb
+#define BTN_TRIGGER_HAPPY13		0x2cc
+#define BTN_TRIGGER_HAPPY14		0x2cd
+#define BTN_TRIGGER_HAPPY15		0x2ce
+#define BTN_TRIGGER_HAPPY16		0x2cf
+#define BTN_TRIGGER_HAPPY17		0x2d0
+#define BTN_TRIGGER_HAPPY18		0x2d1
+#define BTN_TRIGGER_HAPPY19		0x2d2
+#define BTN_TRIGGER_HAPPY20		0x2d3
+#define BTN_TRIGGER_HAPPY21		0x2d4
+#define BTN_TRIGGER_HAPPY22		0x2d5
+#define BTN_TRIGGER_HAPPY23		0x2d6
+#define BTN_TRIGGER_HAPPY24		0x2d7
+#define BTN_TRIGGER_HAPPY25		0x2d8
+#define BTN_TRIGGER_HAPPY26		0x2d9
+#define BTN_TRIGGER_HAPPY27		0x2da
+#define BTN_TRIGGER_HAPPY28		0x2db
+#define BTN_TRIGGER_HAPPY29		0x2dc
+#define BTN_TRIGGER_HAPPY30		0x2dd
+#define BTN_TRIGGER_HAPPY31		0x2de
+#define BTN_TRIGGER_HAPPY32		0x2df
+#define BTN_TRIGGER_HAPPY33		0x2e0
+#define BTN_TRIGGER_HAPPY34		0x2e1
+#define BTN_TRIGGER_HAPPY35		0x2e2
+#define BTN_TRIGGER_HAPPY36		0x2e3
+#define BTN_TRIGGER_HAPPY37		0x2e4
+#define BTN_TRIGGER_HAPPY38		0x2e5
+#define BTN_TRIGGER_HAPPY39		0x2e6
+#define BTN_TRIGGER_HAPPY40		0x2e7
+
+/* We avoid low common keys in module aliases so they don't get huge. */
+#define KEY_MIN_INTERESTING	KEY_MUTE
+#define KEY_MAX			0x2ff
+#define KEY_CNT			(KEY_MAX+1)
+
+/*
+ * Relative axes
+ */
+
+#define REL_X			0x00
+#define REL_Y			0x01
+#define REL_Z			0x02
+#define REL_RX			0x03
+#define REL_RY			0x04
+#define REL_RZ			0x05
+#define REL_HWHEEL		0x06
+#define REL_DIAL		0x07
+#define REL_WHEEL		0x08
+#define REL_MISC		0x09
+/*
+ * 0x0a is reserved and should not be used in input drivers.
+ * It was used by HID as REL_MISC+1 and userspace needs to detect if
+ * the next REL_* event is correct or is just REL_MISC + n.
+ * We define here REL_RESERVED so userspace can rely on it and detect
+ * the situation described above.
+ */
+#define REL_RESERVED		0x0a
+#define REL_WHEEL_HI_RES	0x0b
+#define REL_HWHEEL_HI_RES	0x0c
+#define REL_MAX			0x0f
+#define REL_CNT			(REL_MAX+1)
+
+/*
+ * Absolute axes
+ */
+
+#define ABS_X			0x00
+#define ABS_Y			0x01
+#define ABS_Z			0x02
+#define ABS_RX			0x03
+#define ABS_RY			0x04
+#define ABS_RZ			0x05
+#define ABS_THROTTLE		0x06
+#define ABS_RUDDER		0x07
+#define ABS_WHEEL		0x08
+#define ABS_GAS			0x09
+#define ABS_BRAKE		0x0a
+#define ABS_HAT0X		0x10
+#define ABS_HAT0Y		0x11
+#define ABS_HAT1X		0x12
+#define ABS_HAT1Y		0x13
+#define ABS_HAT2X		0x14
+#define ABS_HAT2Y		0x15
+#define ABS_HAT3X		0x16
+#define ABS_HAT3Y		0x17
+#define ABS_PRESSURE		0x18
+#define ABS_DISTANCE		0x19
+#define ABS_TILT_X		0x1a
+#define ABS_TILT_Y		0x1b
+#define ABS_TOOL_WIDTH		0x1c
+
+#define ABS_VOLUME		0x20
+
+#define ABS_MISC		0x28
+
+/*
+ * 0x2e is reserved and should not be used in input drivers.
+ * It was used by HID as ABS_MISC+6 and userspace needs to detect if
+ * the next ABS_* event is correct or is just ABS_MISC + n.
+ * We define here ABS_RESERVED so userspace can rely on it and detect
+ * the situation described above.
+ */
+#define ABS_RESERVED		0x2e
+
+#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
+#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
+#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
+#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
+#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
+#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
+#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
+#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
+#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
+
+
+#define ABS_MAX			0x3f
+#define ABS_CNT			(ABS_MAX+1)
+
+/*
+ * Switch events
+ */
+
+#define SW_LID			0x00  /* set = lid shut */
+#define SW_TABLET_MODE		0x01  /* set = tablet mode */
+#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
+#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
+					 set = radio enabled */
+#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
+#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
+#define SW_DOCK			0x05  /* set = plugged into dock */
+#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
+#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
+#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
+#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
+#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
+#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
+#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
+#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
+#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
+#define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
+#define SW_MACHINE_COVER	0x10  /* set = cover closed */
+#define SW_MAX_			0x10
+#define SW_CNT			(SW_MAX_+1)
+
+/*
+ * Misc events
+ */
+
+#define MSC_SERIAL		0x00
+#define MSC_PULSELED		0x01
+#define MSC_GESTURE		0x02
+#define MSC_RAW			0x03
+#define MSC_SCAN		0x04
+#define MSC_TIMESTAMP		0x05
+#define MSC_MAX			0x07
+#define MSC_CNT			(MSC_MAX+1)
+
+/*
+ * LEDs
+ */
+
+#define LED_NUML		0x00
+#define LED_CAPSL		0x01
+#define LED_SCROLLL		0x02
+#define LED_COMPOSE		0x03
+#define LED_KANA		0x04
+#define LED_SLEEP		0x05
+#define LED_SUSPEND		0x06
+#define LED_MUTE		0x07
+#define LED_MISC		0x08
+#define LED_MAIL		0x09
+#define LED_CHARGING		0x0a
+#define LED_MAX			0x0f
+#define LED_CNT			(LED_MAX+1)
+
+/*
+ * Autorepeat values
+ */
+
+#define REP_DELAY		0x00
+#define REP_PERIOD		0x01
+#define REP_MAX			0x01
+#define REP_CNT			(REP_MAX+1)
+
+/*
+ * Sounds
+ */
+
+#define SND_CLICK		0x00
+#define SND_BELL		0x01
+#define SND_TONE		0x02
+#define SND_MAX			0x07
+#define SND_CNT			(SND_MAX+1)
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/input.h b/subprojects/libvhost-user/standard-headers/linux/input.h
new file mode 100644
index 0000000..7822c24
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/input.h
@@ -0,0 +1,511 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Copyright (c) 1999-2002 Vojtech Pavlik
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef _INPUT_H
+#define _INPUT_H
+
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include "standard-headers/linux/types.h"
+
+#include "standard-headers/linux/input-event-codes.h"
+
+/*
+ * The event structure itself
+ * Note that __USE_TIME_BITS64 is defined by libc based on
+ * application's request to use 64 bit time_t.
+ */
+
+struct input_event {
+#if (HOST_LONG_BITS != 32 || !defined(__USE_TIME_BITS64)) && !defined(__KERNEL__)
+	struct timeval time;
+#define input_event_sec time.tv_sec
+#define input_event_usec time.tv_usec
+#else
+	unsigned long __sec;
+#if defined(__sparc__) && defined(__arch64__)
+	unsigned int __usec;
+	unsigned int __pad;
+#else
+	unsigned long __usec;
+#endif
+#define input_event_sec  __sec
+#define input_event_usec __usec
+#endif
+	uint16_t type;
+	uint16_t code;
+	int32_t value;
+};
+
+/*
+ * Protocol version.
+ */
+
+#define EV_VERSION		0x010001
+
+/*
+ * IOCTLs (0x00 - 0x7f)
+ */
+
+struct input_id {
+	uint16_t bustype;
+	uint16_t vendor;
+	uint16_t product;
+	uint16_t version;
+};
+
+/**
+ * struct input_absinfo - used by EVIOCGABS/EVIOCSABS ioctls
+ * @value: latest reported value for the axis.
+ * @minimum: specifies minimum value for the axis.
+ * @maximum: specifies maximum value for the axis.
+ * @fuzz: specifies fuzz value that is used to filter noise from
+ *	the event stream.
+ * @flat: values that are within this value will be discarded by
+ *	joydev interface and reported as 0 instead.
+ * @resolution: specifies resolution for the values reported for
+ *	the axis.
+ *
+ * Note that input core does not clamp reported values to the
+ * [minimum, maximum] limits, such task is left to userspace.
+ *
+ * The default resolution for main axes (ABS_X, ABS_Y, ABS_Z)
+ * is reported in units per millimeter (units/mm), resolution
+ * for rotational axes (ABS_RX, ABS_RY, ABS_RZ) is reported
+ * in units per radian.
+ * When INPUT_PROP_ACCELEROMETER is set the resolution changes.
+ * The main axes (ABS_X, ABS_Y, ABS_Z) are then reported in
+ * units per g (units/g) and in units per degree per second
+ * (units/deg/s) for rotational axes (ABS_RX, ABS_RY, ABS_RZ).
+ */
+struct input_absinfo {
+	int32_t value;
+	int32_t minimum;
+	int32_t maximum;
+	int32_t fuzz;
+	int32_t flat;
+	int32_t resolution;
+};
+
+/**
+ * struct input_keymap_entry - used by EVIOCGKEYCODE/EVIOCSKEYCODE ioctls
+ * @scancode: scancode represented in machine-endian form.
+ * @len: length of the scancode that resides in @scancode buffer.
+ * @index: index in the keymap, may be used instead of scancode
+ * @flags: allows to specify how kernel should handle the request. For
+ *	example, setting INPUT_KEYMAP_BY_INDEX flag indicates that kernel
+ *	should perform lookup in keymap by @index instead of @scancode
+ * @keycode: key code assigned to this scancode
+ *
+ * The structure is used to retrieve and modify keymap data. Users have
+ * option of performing lookup either by @scancode itself or by @index
+ * in keymap entry. EVIOCGKEYCODE will also return scancode or index
+ * (depending on which element was used to perform lookup).
+ */
+struct input_keymap_entry {
+#define INPUT_KEYMAP_BY_INDEX	(1 << 0)
+	uint8_t  flags;
+	uint8_t  len;
+	uint16_t index;
+	uint32_t keycode;
+	uint8_t  scancode[32];
+};
+
+struct input_mask {
+	uint32_t type;
+	uint32_t codes_size;
+	uint64_t codes_ptr;
+};
+
+#define EVIOCGVERSION		_IOR('E', 0x01, int)			/* get driver version */
+#define EVIOCGID		_IOR('E', 0x02, struct input_id)	/* get device ID */
+#define EVIOCGREP		_IOR('E', 0x03, unsigned int[2])	/* get repeat settings */
+#define EVIOCSREP		_IOW('E', 0x03, unsigned int[2])	/* set repeat settings */
+
+#define EVIOCGKEYCODE		_IOR('E', 0x04, unsigned int[2])        /* get keycode */
+#define EVIOCGKEYCODE_V2	_IOR('E', 0x04, struct input_keymap_entry)
+#define EVIOCSKEYCODE		_IOW('E', 0x04, unsigned int[2])        /* set keycode */
+#define EVIOCSKEYCODE_V2	_IOW('E', 0x04, struct input_keymap_entry)
+
+#define EVIOCGNAME(len)		_IOC(_IOC_READ, 'E', 0x06, len)		/* get device name */
+#define EVIOCGPHYS(len)		_IOC(_IOC_READ, 'E', 0x07, len)		/* get physical location */
+#define EVIOCGUNIQ(len)		_IOC(_IOC_READ, 'E', 0x08, len)		/* get unique identifier */
+#define EVIOCGPROP(len)		_IOC(_IOC_READ, 'E', 0x09, len)		/* get device properties */
+
+/**
+ * EVIOCGMTSLOTS(len) - get MT slot values
+ * @len: size of the data buffer in bytes
+ *
+ * The ioctl buffer argument should be binary equivalent to
+ *
+ * struct input_mt_request_layout {
+ *	uint32_t code;
+ *	int32_t values[num_slots];
+ * };
+ *
+ * where num_slots is the (arbitrary) number of MT slots to extract.
+ *
+ * The ioctl size argument (len) is the size of the buffer, which
+ * should satisfy len = (num_slots + 1) * sizeof(int32_t).  If len is
+ * too small to fit all available slots, the first num_slots are
+ * returned.
+ *
+ * Before the call, code is set to the wanted ABS_MT event type. On
+ * return, values[] is filled with the slot values for the specified
+ * ABS_MT code.
+ *
+ * If the request code is not an ABS_MT value, -EINVAL is returned.
+ */
+#define EVIOCGMTSLOTS(len)	_IOC(_IOC_READ, 'E', 0x0a, len)
+
+#define EVIOCGKEY(len)		_IOC(_IOC_READ, 'E', 0x18, len)		/* get global key state */
+#define EVIOCGLED(len)		_IOC(_IOC_READ, 'E', 0x19, len)		/* get all LEDs */
+#define EVIOCGSND(len)		_IOC(_IOC_READ, 'E', 0x1a, len)		/* get all sounds status */
+#define EVIOCGSW(len)		_IOC(_IOC_READ, 'E', 0x1b, len)		/* get all switch states */
+
+#define EVIOCGBIT(ev,len)	_IOC(_IOC_READ, 'E', 0x20 + (ev), len)	/* get event bits */
+#define EVIOCGABS(abs)		_IOR('E', 0x40 + (abs), struct input_absinfo)	/* get abs value/limits */
+#define EVIOCSABS(abs)		_IOW('E', 0xc0 + (abs), struct input_absinfo)	/* set abs value/limits */
+
+#define EVIOCSFF		_IOW('E', 0x80, struct ff_effect)	/* send a force effect to a force feedback device */
+#define EVIOCRMFF		_IOW('E', 0x81, int)			/* Erase a force effect */
+#define EVIOCGEFFECTS		_IOR('E', 0x84, int)			/* Report number of effects playable at the same time */
+
+#define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
+#define EVIOCREVOKE		_IOW('E', 0x91, int)			/* Revoke device access */
+
+/**
+ * EVIOCGMASK - Retrieve current event mask
+ *
+ * This ioctl allows user to retrieve the current event mask for specific
+ * event type. The argument must be of type "struct input_mask" and
+ * specifies the event type to query, the address of the receive buffer and
+ * the size of the receive buffer.
+ *
+ * The event mask is a per-client mask that specifies which events are
+ * forwarded to the client. Each event code is represented by a single bit
+ * in the event mask. If the bit is set, the event is passed to the client
+ * normally. Otherwise, the event is filtered and will never be queued on
+ * the client's receive buffer.
+ *
+ * Event masks do not affect global state of the input device. They only
+ * affect the file descriptor they are applied to.
+ *
+ * The default event mask for a client has all bits set, i.e. all events
+ * are forwarded to the client. If the kernel is queried for an unknown
+ * event type or if the receive buffer is larger than the number of
+ * event codes known to the kernel, the kernel returns all zeroes for those
+ * codes.
+ *
+ * At maximum, codes_size bytes are copied.
+ *
+ * This ioctl may fail with ENODEV in case the file is revoked, EFAULT
+ * if the receive-buffer points to invalid memory, or EINVAL if the kernel
+ * does not implement the ioctl.
+ */
+#define EVIOCGMASK		_IOR('E', 0x92, struct input_mask)	/* Get event-masks */
+
+/**
+ * EVIOCSMASK - Set event mask
+ *
+ * This ioctl is the counterpart to EVIOCGMASK. Instead of receiving the
+ * current event mask, this changes the client's event mask for a specific
+ * type.  See EVIOCGMASK for a description of event-masks and the
+ * argument-type.
+ *
+ * This ioctl provides full forward compatibility. If the passed event type
+ * is unknown to the kernel, or if the number of event codes specified in
+ * the mask is bigger than what is known to the kernel, the ioctl is still
+ * accepted and applied. However, any unknown codes are left untouched and
+ * stay cleared. That means, the kernel always filters unknown codes
+ * regardless of what the client requests.  If the new mask doesn't cover
+ * all known event-codes, all remaining codes are automatically cleared and
+ * thus filtered.
+ *
+ * This ioctl may fail with ENODEV in case the file is revoked. EFAULT is
+ * returned if the receive-buffer points to invalid memory. EINVAL is returned
+ * if the kernel does not implement the ioctl.
+ */
+#define EVIOCSMASK		_IOW('E', 0x93, struct input_mask)	/* Set event-masks */
+
+#define EVIOCSCLOCKID		_IOW('E', 0xa0, int)			/* Set clockid to be used for timestamps */
+
+/*
+ * IDs.
+ */
+
+#define ID_BUS			0
+#define ID_VENDOR		1
+#define ID_PRODUCT		2
+#define ID_VERSION		3
+
+#define BUS_PCI			0x01
+#define BUS_ISAPNP		0x02
+#define BUS_USB			0x03
+#define BUS_HIL			0x04
+#define BUS_BLUETOOTH		0x05
+#define BUS_VIRTUAL		0x06
+
+#define BUS_ISA			0x10
+#define BUS_I8042		0x11
+#define BUS_XTKBD		0x12
+#define BUS_RS232		0x13
+#define BUS_GAMEPORT		0x14
+#define BUS_PARPORT		0x15
+#define BUS_AMIGA		0x16
+#define BUS_ADB			0x17
+#define BUS_I2C			0x18
+#define BUS_HOST		0x19
+#define BUS_GSC			0x1A
+#define BUS_ATARI		0x1B
+#define BUS_SPI			0x1C
+#define BUS_RMI			0x1D
+#define BUS_CEC			0x1E
+#define BUS_INTEL_ISHTP		0x1F
+
+/*
+ * MT_TOOL types
+ */
+#define MT_TOOL_FINGER		0x00
+#define MT_TOOL_PEN		0x01
+#define MT_TOOL_PALM		0x02
+#define MT_TOOL_DIAL		0x0a
+#define MT_TOOL_MAX		0x0f
+
+/*
+ * Values describing the status of a force-feedback effect
+ */
+#define FF_STATUS_STOPPED	0x00
+#define FF_STATUS_PLAYING	0x01
+#define FF_STATUS_MAX		0x01
+
+/*
+ * Structures used in ioctls to upload effects to a device
+ * They are pieces of a bigger structure (called ff_effect)
+ */
+
+/*
+ * All duration values are expressed in ms. Values above 32767 ms (0x7fff)
+ * should not be used and have unspecified results.
+ */
+
+/**
+ * struct ff_replay - defines scheduling of the force-feedback effect
+ * @length: duration of the effect
+ * @delay: delay before effect should start playing
+ */
+struct ff_replay {
+	uint16_t length;
+	uint16_t delay;
+};
+
+/**
+ * struct ff_trigger - defines what triggers the force-feedback effect
+ * @button: number of the button triggering the effect
+ * @interval: controls how soon the effect can be re-triggered
+ */
+struct ff_trigger {
+	uint16_t button;
+	uint16_t interval;
+};
+
+/**
+ * struct ff_envelope - generic force-feedback effect envelope
+ * @attack_length: duration of the attack (ms)
+ * @attack_level: level at the beginning of the attack
+ * @fade_length: duration of fade (ms)
+ * @fade_level: level at the end of fade
+ *
+ * The @attack_level and @fade_level are absolute values; when applying
+ * envelope force-feedback core will convert to positive/negative
+ * value based on polarity of the default level of the effect.
+ * Valid range for the attack and fade levels is 0x0000 - 0x7fff
+ */
+struct ff_envelope {
+	uint16_t attack_length;
+	uint16_t attack_level;
+	uint16_t fade_length;
+	uint16_t fade_level;
+};
+
+/**
+ * struct ff_constant_effect - defines parameters of a constant force-feedback effect
+ * @level: strength of the effect; may be negative
+ * @envelope: envelope data
+ */
+struct ff_constant_effect {
+	int16_t level;
+	struct ff_envelope envelope;
+};
+
+/**
+ * struct ff_ramp_effect - defines parameters of a ramp force-feedback effect
+ * @start_level: beginning strength of the effect; may be negative
+ * @end_level: final strength of the effect; may be negative
+ * @envelope: envelope data
+ */
+struct ff_ramp_effect {
+	int16_t start_level;
+	int16_t end_level;
+	struct ff_envelope envelope;
+};
+
+/**
+ * struct ff_condition_effect - defines a spring or friction force-feedback effect
+ * @right_saturation: maximum level when joystick moved all way to the right
+ * @left_saturation: same for the left side
+ * @right_coeff: controls how fast the force grows when the joystick moves
+ *	to the right
+ * @left_coeff: same for the left side
+ * @deadband: size of the dead zone, where no force is produced
+ * @center: position of the dead zone
+ */
+struct ff_condition_effect {
+	uint16_t right_saturation;
+	uint16_t left_saturation;
+
+	int16_t right_coeff;
+	int16_t left_coeff;
+
+	uint16_t deadband;
+	int16_t center;
+};
+
+/**
+ * struct ff_periodic_effect - defines parameters of a periodic force-feedback effect
+ * @waveform: kind of the effect (wave)
+ * @period: period of the wave (ms)
+ * @magnitude: peak value
+ * @offset: mean value of the wave (roughly)
+ * @phase: 'horizontal' shift
+ * @envelope: envelope data
+ * @custom_len: number of samples (FF_CUSTOM only)
+ * @custom_data: buffer of samples (FF_CUSTOM only)
+ *
+ * Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,
+ * FF_SAW_DOWN, FF_CUSTOM. The exact syntax FF_CUSTOM is undefined
+ * for the time being as no driver supports it yet.
+ *
+ * Note: the data pointed by custom_data is copied by the driver.
+ * You can therefore dispose of the memory after the upload/update.
+ */
+struct ff_periodic_effect {
+	uint16_t waveform;
+	uint16_t period;
+	int16_t magnitude;
+	int16_t offset;
+	uint16_t phase;
+
+	struct ff_envelope envelope;
+
+	uint32_t custom_len;
+	int16_t *custom_data;
+};
+
+/**
+ * struct ff_rumble_effect - defines parameters of a periodic force-feedback effect
+ * @strong_magnitude: magnitude of the heavy motor
+ * @weak_magnitude: magnitude of the light one
+ *
+ * Some rumble pads have two motors of different weight. Strong_magnitude
+ * represents the magnitude of the vibration generated by the heavy one.
+ */
+struct ff_rumble_effect {
+	uint16_t strong_magnitude;
+	uint16_t weak_magnitude;
+};
+
+/**
+ * struct ff_effect - defines force feedback effect
+ * @type: type of the effect (FF_CONSTANT, FF_PERIODIC, FF_RAMP, FF_SPRING,
+ *	FF_FRICTION, FF_DAMPER, FF_RUMBLE, FF_INERTIA, or FF_CUSTOM)
+ * @id: an unique id assigned to an effect
+ * @direction: direction of the effect
+ * @trigger: trigger conditions (struct ff_trigger)
+ * @replay: scheduling of the effect (struct ff_replay)
+ * @u: effect-specific structure (one of ff_constant_effect, ff_ramp_effect,
+ *	ff_periodic_effect, ff_condition_effect, ff_rumble_effect) further
+ *	defining effect parameters
+ *
+ * This structure is sent through ioctl from the application to the driver.
+ * To create a new effect application should set its @id to -1; the kernel
+ * will return assigned @id which can later be used to update or delete
+ * this effect.
+ *
+ * Direction of the effect is encoded as follows:
+ *	0 deg -> 0x0000 (down)
+ *	90 deg -> 0x4000 (left)
+ *	180 deg -> 0x8000 (up)
+ *	270 deg -> 0xC000 (right)
+ */
+struct ff_effect {
+	uint16_t type;
+	int16_t id;
+	uint16_t direction;
+	struct ff_trigger trigger;
+	struct ff_replay replay;
+
+	union {
+		struct ff_constant_effect constant;
+		struct ff_ramp_effect ramp;
+		struct ff_periodic_effect periodic;
+		struct ff_condition_effect condition[2]; /* One for each axis */
+		struct ff_rumble_effect rumble;
+	} u;
+};
+
+/*
+ * Force feedback effect types
+ */
+
+#define FF_RUMBLE	0x50
+#define FF_PERIODIC	0x51
+#define FF_CONSTANT	0x52
+#define FF_SPRING	0x53
+#define FF_FRICTION	0x54
+#define FF_DAMPER	0x55
+#define FF_INERTIA	0x56
+#define FF_RAMP		0x57
+
+#define FF_EFFECT_MIN	FF_RUMBLE
+#define FF_EFFECT_MAX	FF_RAMP
+
+/*
+ * Force feedback periodic effect types
+ */
+
+#define FF_SQUARE	0x58
+#define FF_TRIANGLE	0x59
+#define FF_SINE		0x5a
+#define FF_SAW_UP	0x5b
+#define FF_SAW_DOWN	0x5c
+#define FF_CUSTOM	0x5d
+
+#define FF_WAVEFORM_MIN	FF_SQUARE
+#define FF_WAVEFORM_MAX	FF_CUSTOM
+
+/*
+ * Set ff device properties
+ */
+
+#define FF_GAIN		0x60
+#define FF_AUTOCENTER	0x61
+
+/*
+ * ff->playback(effect_id = FF_GAIN) is the first effect_id to
+ * cause a collision with another ff method, in this case ff->set_gain().
+ * Therefore the greatest safe value for effect_id is FF_GAIN - 1,
+ * and thus the total number of effects should never exceed FF_GAIN.
+ */
+#define FF_MAX_EFFECTS	FF_GAIN
+
+#define FF_MAX		0x7f
+#define FF_CNT		(FF_MAX+1)
+
+#endif /* _INPUT_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/kernel.h b/subprojects/libvhost-user/standard-headers/linux/kernel.h
new file mode 100644
index 0000000..7848c5a
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/kernel.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_KERNEL_H
+#define _LINUX_KERNEL_H
+
+#include "standard-headers/linux/sysinfo.h"
+#include "standard-headers/linux/const.h"
+
+#endif /* _LINUX_KERNEL_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/pci_regs.h b/subprojects/libvhost-user/standard-headers/linux/pci_regs.h
new file mode 100644
index 0000000..e709ae8
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/pci_regs.h
@@ -0,0 +1,1095 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ *	PCI standard defines
+ *	Copyright 1994, Drew Eckhardt
+ *	Copyright 1997--1999 Martin Mares <mj@ucw.cz>
+ *
+ *	For more information, please consult the following manuals (look at
+ *	http://www.pcisig.com/ for how to get them):
+ *
+ *	PCI BIOS Specification
+ *	PCI Local Bus Specification
+ *	PCI to PCI Bridge Specification
+ *	PCI System Design Guide
+ *
+ *	For HyperTransport information, please consult the following manuals
+ *	from http://www.hypertransport.org :
+ *
+ *	The HyperTransport I/O Link Specification
+ */
+
+#ifndef LINUX_PCI_REGS_H
+#define LINUX_PCI_REGS_H
+
+/*
+ * Conventional PCI and PCI-X Mode 1 devices have 256 bytes of
+ * configuration space.  PCI-X Mode 2 and PCIe devices have 4096 bytes of
+ * configuration space.
+ */
+#define PCI_CFG_SPACE_SIZE	256
+#define PCI_CFG_SPACE_EXP_SIZE	4096
+
+/*
+ * Under PCI, each device has 256 bytes of configuration address space,
+ * of which the first 64 bytes are standardized as follows:
+ */
+#define PCI_STD_HEADER_SIZEOF	64
+#define PCI_STD_NUM_BARS	6	/* Number of standard BARs */
+#define PCI_VENDOR_ID		0x00	/* 16 bits */
+#define PCI_DEVICE_ID		0x02	/* 16 bits */
+#define PCI_COMMAND		0x04	/* 16 bits */
+#define  PCI_COMMAND_IO		0x1	/* Enable response in I/O space */
+#define  PCI_COMMAND_MEMORY	0x2	/* Enable response in Memory space */
+#define  PCI_COMMAND_MASTER	0x4	/* Enable bus mastering */
+#define  PCI_COMMAND_SPECIAL	0x8	/* Enable response to special cycles */
+#define  PCI_COMMAND_INVALIDATE	0x10	/* Use memory write and invalidate */
+#define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
+#define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+#define  PCI_COMMAND_WAIT	0x80	/* Enable address/data stepping */
+#define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+#define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
+#define  PCI_COMMAND_INTX_DISABLE 0x400 /* INTx Emulation Disable */
+
+#define PCI_STATUS		0x06	/* 16 bits */
+#define  PCI_STATUS_IMM_READY	0x01	/* Immediate Readiness */
+#define  PCI_STATUS_INTERRUPT	0x08	/* Interrupt status */
+#define  PCI_STATUS_CAP_LIST	0x10	/* Support Capability List */
+#define  PCI_STATUS_66MHZ	0x20	/* Support 66 MHz PCI 2.1 bus */
+#define  PCI_STATUS_UDF		0x40	/* Support User Definable Features [obsolete] */
+#define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
+#define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+#define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
+#define  PCI_STATUS_DEVSEL_FAST		0x000
+#define  PCI_STATUS_DEVSEL_MEDIUM	0x200
+#define  PCI_STATUS_DEVSEL_SLOW		0x400
+#define  PCI_STATUS_SIG_TARGET_ABORT	0x800 /* Set on target abort */
+#define  PCI_STATUS_REC_TARGET_ABORT	0x1000 /* Master ack of " */
+#define  PCI_STATUS_REC_MASTER_ABORT	0x2000 /* Set on master abort */
+#define  PCI_STATUS_SIG_SYSTEM_ERROR	0x4000 /* Set when we drive SERR */
+#define  PCI_STATUS_DETECTED_PARITY	0x8000 /* Set on parity error */
+
+#define PCI_CLASS_REVISION	0x08	/* High 24 bits are class, low 8 revision */
+#define PCI_REVISION_ID		0x08	/* Revision ID */
+#define PCI_CLASS_PROG		0x09	/* Reg. Level Programming Interface */
+#define PCI_CLASS_DEVICE	0x0a	/* Device class */
+
+#define PCI_CACHE_LINE_SIZE	0x0c	/* 8 bits */
+#define PCI_LATENCY_TIMER	0x0d	/* 8 bits */
+#define PCI_HEADER_TYPE		0x0e	/* 8 bits */
+#define  PCI_HEADER_TYPE_MASK		0x7f
+#define  PCI_HEADER_TYPE_NORMAL		0
+#define  PCI_HEADER_TYPE_BRIDGE		1
+#define  PCI_HEADER_TYPE_CARDBUS	2
+
+#define PCI_BIST		0x0f	/* 8 bits */
+#define  PCI_BIST_CODE_MASK	0x0f	/* Return result */
+#define  PCI_BIST_START		0x40	/* 1 to start BIST, 2 secs or less */
+#define  PCI_BIST_CAPABLE	0x80	/* 1 if BIST capable */
+
+/*
+ * Base addresses specify locations in memory or I/O space.
+ * Decoded size can be determined by writing a value of
+ * 0xffffffff to the register, and reading it back.  Only
+ * 1 bits are decoded.
+ */
+#define PCI_BASE_ADDRESS_0	0x10	/* 32 bits */
+#define PCI_BASE_ADDRESS_1	0x14	/* 32 bits [htype 0,1 only] */
+#define PCI_BASE_ADDRESS_2	0x18	/* 32 bits [htype 0 only] */
+#define PCI_BASE_ADDRESS_3	0x1c	/* 32 bits */
+#define PCI_BASE_ADDRESS_4	0x20	/* 32 bits */
+#define PCI_BASE_ADDRESS_5	0x24	/* 32 bits */
+#define  PCI_BASE_ADDRESS_SPACE		0x01	/* 0 = memory, 1 = I/O */
+#define  PCI_BASE_ADDRESS_SPACE_IO	0x01
+#define  PCI_BASE_ADDRESS_SPACE_MEMORY	0x00
+#define  PCI_BASE_ADDRESS_MEM_TYPE_MASK	0x06
+#define  PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
+#define  PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
+#define  PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
+#define  PCI_BASE_ADDRESS_MEM_PREFETCH	0x08	/* prefetchable? */
+#define  PCI_BASE_ADDRESS_MEM_MASK	(~0x0fUL)
+#define  PCI_BASE_ADDRESS_IO_MASK	(~0x03UL)
+/* bit 1 is reserved if address_space = 1 */
+
+/* Header type 0 (normal devices) */
+#define PCI_CARDBUS_CIS		0x28
+#define PCI_SUBSYSTEM_VENDOR_ID	0x2c
+#define PCI_SUBSYSTEM_ID	0x2e
+#define PCI_ROM_ADDRESS		0x30	/* Bits 31..11 are address, 10..1 reserved */
+#define  PCI_ROM_ADDRESS_ENABLE	0x01
+#define PCI_ROM_ADDRESS_MASK	(~0x7ffU)
+
+#define PCI_CAPABILITY_LIST	0x34	/* Offset of first capability list entry */
+
+/* 0x35-0x3b are reserved */
+#define PCI_INTERRUPT_LINE	0x3c	/* 8 bits */
+#define PCI_INTERRUPT_PIN	0x3d	/* 8 bits */
+#define PCI_MIN_GNT		0x3e	/* 8 bits */
+#define PCI_MAX_LAT		0x3f	/* 8 bits */
+
+/* Header type 1 (PCI-to-PCI bridges) */
+#define PCI_PRIMARY_BUS		0x18	/* Primary bus number */
+#define PCI_SECONDARY_BUS	0x19	/* Secondary bus number */
+#define PCI_SUBORDINATE_BUS	0x1a	/* Highest bus number behind the bridge */
+#define PCI_SEC_LATENCY_TIMER	0x1b	/* Latency timer for secondary interface */
+#define PCI_IO_BASE		0x1c	/* I/O range behind the bridge */
+#define PCI_IO_LIMIT		0x1d
+#define  PCI_IO_RANGE_TYPE_MASK	0x0fUL	/* I/O bridging type */
+#define  PCI_IO_RANGE_TYPE_16	0x00
+#define  PCI_IO_RANGE_TYPE_32	0x01
+#define  PCI_IO_RANGE_MASK	(~0x0fUL) /* Standard 4K I/O windows */
+#define  PCI_IO_1K_RANGE_MASK	(~0x03UL) /* Intel 1K I/O windows */
+#define PCI_SEC_STATUS		0x1e	/* Secondary status register, only bit 14 used */
+#define PCI_MEMORY_BASE		0x20	/* Memory range behind */
+#define PCI_MEMORY_LIMIT	0x22
+#define  PCI_MEMORY_RANGE_TYPE_MASK 0x0fUL
+#define  PCI_MEMORY_RANGE_MASK	(~0x0fUL)
+#define PCI_PREF_MEMORY_BASE	0x24	/* Prefetchable memory range behind */
+#define PCI_PREF_MEMORY_LIMIT	0x26
+#define  PCI_PREF_RANGE_TYPE_MASK 0x0fUL
+#define  PCI_PREF_RANGE_TYPE_32	0x00
+#define  PCI_PREF_RANGE_TYPE_64	0x01
+#define  PCI_PREF_RANGE_MASK	(~0x0fUL)
+#define PCI_PREF_BASE_UPPER32	0x28	/* Upper half of prefetchable memory range */
+#define PCI_PREF_LIMIT_UPPER32	0x2c
+#define PCI_IO_BASE_UPPER16	0x30	/* Upper half of I/O addresses */
+#define PCI_IO_LIMIT_UPPER16	0x32
+/* 0x34 same as for htype 0 */
+/* 0x35-0x3b is reserved */
+#define PCI_ROM_ADDRESS1	0x38	/* Same as PCI_ROM_ADDRESS, but for htype 1 */
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_BRIDGE_CONTROL	0x3e
+#define  PCI_BRIDGE_CTL_PARITY	0x01	/* Enable parity detection on secondary interface */
+#define  PCI_BRIDGE_CTL_SERR	0x02	/* The same for SERR forwarding */
+#define  PCI_BRIDGE_CTL_ISA	0x04	/* Enable ISA mode */
+#define  PCI_BRIDGE_CTL_VGA	0x08	/* Forward VGA addresses */
+#define  PCI_BRIDGE_CTL_MASTER_ABORT	0x20  /* Report master aborts */
+#define  PCI_BRIDGE_CTL_BUS_RESET	0x40	/* Secondary bus reset */
+#define  PCI_BRIDGE_CTL_FAST_BACK	0x80	/* Fast Back2Back enabled on secondary interface */
+
+/* Header type 2 (CardBus bridges) */
+#define PCI_CB_CAPABILITY_LIST	0x14
+/* 0x15 reserved */
+#define PCI_CB_SEC_STATUS	0x16	/* Secondary status */
+#define PCI_CB_PRIMARY_BUS	0x18	/* PCI bus number */
+#define PCI_CB_CARD_BUS		0x19	/* CardBus bus number */
+#define PCI_CB_SUBORDINATE_BUS	0x1a	/* Subordinate bus number */
+#define PCI_CB_LATENCY_TIMER	0x1b	/* CardBus latency timer */
+#define PCI_CB_MEMORY_BASE_0	0x1c
+#define PCI_CB_MEMORY_LIMIT_0	0x20
+#define PCI_CB_MEMORY_BASE_1	0x24
+#define PCI_CB_MEMORY_LIMIT_1	0x28
+#define PCI_CB_IO_BASE_0	0x2c
+#define PCI_CB_IO_BASE_0_HI	0x2e
+#define PCI_CB_IO_LIMIT_0	0x30
+#define PCI_CB_IO_LIMIT_0_HI	0x32
+#define PCI_CB_IO_BASE_1	0x34
+#define PCI_CB_IO_BASE_1_HI	0x36
+#define PCI_CB_IO_LIMIT_1	0x38
+#define PCI_CB_IO_LIMIT_1_HI	0x3a
+#define  PCI_CB_IO_RANGE_MASK	(~0x03UL)
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_CB_BRIDGE_CONTROL	0x3e
+#define  PCI_CB_BRIDGE_CTL_PARITY	0x01	/* Similar to standard bridge control register */
+#define  PCI_CB_BRIDGE_CTL_SERR		0x02
+#define  PCI_CB_BRIDGE_CTL_ISA		0x04
+#define  PCI_CB_BRIDGE_CTL_VGA		0x08
+#define  PCI_CB_BRIDGE_CTL_MASTER_ABORT	0x20
+#define  PCI_CB_BRIDGE_CTL_CB_RESET	0x40	/* CardBus reset */
+#define  PCI_CB_BRIDGE_CTL_16BIT_INT	0x80	/* Enable interrupt for 16-bit cards */
+#define  PCI_CB_BRIDGE_CTL_PREFETCH_MEM0 0x100	/* Prefetch enable for both memory regions */
+#define  PCI_CB_BRIDGE_CTL_PREFETCH_MEM1 0x200
+#define  PCI_CB_BRIDGE_CTL_POST_WRITES	0x400
+#define PCI_CB_SUBSYSTEM_VENDOR_ID	0x40
+#define PCI_CB_SUBSYSTEM_ID		0x42
+#define PCI_CB_LEGACY_MODE_BASE		0x44	/* 16-bit PC Card legacy mode base address (ExCa) */
+/* 0x48-0x7f reserved */
+
+/* Capability lists */
+
+#define PCI_CAP_LIST_ID		0	/* Capability ID */
+#define  PCI_CAP_ID_PM		0x01	/* Power Management */
+#define  PCI_CAP_ID_AGP		0x02	/* Accelerated Graphics Port */
+#define  PCI_CAP_ID_VPD		0x03	/* Vital Product Data */
+#define  PCI_CAP_ID_SLOTID	0x04	/* Slot Identification */
+#define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
+#define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
+#define  PCI_CAP_ID_PCIX	0x07	/* PCI-X */
+#define  PCI_CAP_ID_HT		0x08	/* HyperTransport */
+#define  PCI_CAP_ID_VNDR	0x09	/* Vendor-Specific */
+#define  PCI_CAP_ID_DBG		0x0A	/* Debug port */
+#define  PCI_CAP_ID_CCRC	0x0B	/* CompactPCI Central Resource Control */
+#define  PCI_CAP_ID_SHPC	0x0C	/* PCI Standard Hot-Plug Controller */
+#define  PCI_CAP_ID_SSVID	0x0D	/* Bridge subsystem vendor/device ID */
+#define  PCI_CAP_ID_AGP3	0x0E	/* AGP Target PCI-PCI bridge */
+#define  PCI_CAP_ID_SECDEV	0x0F	/* Secure Device */
+#define  PCI_CAP_ID_EXP		0x10	/* PCI Express */
+#define  PCI_CAP_ID_MSIX	0x11	/* MSI-X */
+#define  PCI_CAP_ID_SATA	0x12	/* SATA Data/Index Conf. */
+#define  PCI_CAP_ID_AF		0x13	/* PCI Advanced Features */
+#define  PCI_CAP_ID_EA		0x14	/* PCI Enhanced Allocation */
+#define  PCI_CAP_ID_MAX		PCI_CAP_ID_EA
+#define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
+#define PCI_CAP_FLAGS		2	/* Capability defined flags (16 bits) */
+#define PCI_CAP_SIZEOF		4
+
+/* Power Management Registers */
+
+#define PCI_PM_PMC		2	/* PM Capabilities Register */
+#define  PCI_PM_CAP_VER_MASK	0x0007	/* Version */
+#define  PCI_PM_CAP_PME_CLOCK	0x0008	/* PME clock required */
+#define  PCI_PM_CAP_RESERVED    0x0010  /* Reserved field */
+#define  PCI_PM_CAP_DSI		0x0020	/* Device specific initialization */
+#define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxiliary power support mask */
+#define  PCI_PM_CAP_D1		0x0200	/* D1 power state support */
+#define  PCI_PM_CAP_D2		0x0400	/* D2 power state support */
+#define  PCI_PM_CAP_PME		0x0800	/* PME pin supported */
+#define  PCI_PM_CAP_PME_MASK	0xF800	/* PME Mask of all supported states */
+#define  PCI_PM_CAP_PME_D0	0x0800	/* PME# from D0 */
+#define  PCI_PM_CAP_PME_D1	0x1000	/* PME# from D1 */
+#define  PCI_PM_CAP_PME_D2	0x2000	/* PME# from D2 */
+#define  PCI_PM_CAP_PME_D3hot	0x4000	/* PME# from D3 (hot) */
+#define  PCI_PM_CAP_PME_D3cold	0x8000	/* PME# from D3 (cold) */
+#define  PCI_PM_CAP_PME_SHIFT	11	/* Start of the PME Mask in PMC */
+#define PCI_PM_CTRL		4	/* PM control and status register */
+#define  PCI_PM_CTRL_STATE_MASK	0x0003	/* Current power state (D0 to D3) */
+#define  PCI_PM_CTRL_NO_SOFT_RESET	0x0008	/* No reset for D3hot->D0 */
+#define  PCI_PM_CTRL_PME_ENABLE	0x0100	/* PME pin enable */
+#define  PCI_PM_CTRL_DATA_SEL_MASK	0x1e00	/* Data select (??) */
+#define  PCI_PM_CTRL_DATA_SCALE_MASK	0x6000	/* Data scale (??) */
+#define  PCI_PM_CTRL_PME_STATUS	0x8000	/* PME pin status */
+#define PCI_PM_PPB_EXTENSIONS	6	/* PPB support extensions (??) */
+#define  PCI_PM_PPB_B2_B3	0x40	/* Stop clock when in D3hot (??) */
+#define  PCI_PM_BPCC_ENABLE	0x80	/* Bus power/clock control enable (??) */
+#define PCI_PM_DATA_REGISTER	7	/* (??) */
+#define PCI_PM_SIZEOF		8
+
+/* AGP registers */
+
+#define PCI_AGP_VERSION		2	/* BCD version number */
+#define PCI_AGP_RFU		3	/* Rest of capability flags */
+#define PCI_AGP_STATUS		4	/* Status register */
+#define  PCI_AGP_STATUS_RQ_MASK	0xff000000	/* Maximum number of requests - 1 */
+#define  PCI_AGP_STATUS_SBA	0x0200	/* Sideband addressing supported */
+#define  PCI_AGP_STATUS_64BIT	0x0020	/* 64-bit addressing supported */
+#define  PCI_AGP_STATUS_FW	0x0010	/* FW transfers supported */
+#define  PCI_AGP_STATUS_RATE4	0x0004	/* 4x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE2	0x0002	/* 2x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE1	0x0001	/* 1x transfer rate supported */
+#define PCI_AGP_COMMAND		8	/* Control register */
+#define  PCI_AGP_COMMAND_RQ_MASK 0xff000000  /* Master: Maximum number of requests */
+#define  PCI_AGP_COMMAND_SBA	0x0200	/* Sideband addressing enabled */
+#define  PCI_AGP_COMMAND_AGP	0x0100	/* Allow processing of AGP transactions */
+#define  PCI_AGP_COMMAND_64BIT	0x0020	/* Allow processing of 64-bit addresses */
+#define  PCI_AGP_COMMAND_FW	0x0010	/* Force FW transfers */
+#define  PCI_AGP_COMMAND_RATE4	0x0004	/* Use 4x rate */
+#define  PCI_AGP_COMMAND_RATE2	0x0002	/* Use 2x rate */
+#define  PCI_AGP_COMMAND_RATE1	0x0001	/* Use 1x rate */
+#define PCI_AGP_SIZEOF		12
+
+/* Vital Product Data */
+
+#define PCI_VPD_ADDR		2	/* Address to access (15 bits!) */
+#define  PCI_VPD_ADDR_MASK	0x7fff	/* Address mask */
+#define  PCI_VPD_ADDR_F		0x8000	/* Write 0, 1 indicates completion */
+#define PCI_VPD_DATA		4	/* 32-bits of data returned here */
+#define PCI_CAP_VPD_SIZEOF	8
+
+/* Slot Identification */
+
+#define PCI_SID_ESR		2	/* Expansion Slot Register */
+#define  PCI_SID_ESR_NSLOTS	0x1f	/* Number of expansion slots available */
+#define  PCI_SID_ESR_FIC	0x20	/* First In Chassis Flag */
+#define PCI_SID_CHASSIS_NR	3	/* Chassis Number */
+
+/* Message Signalled Interrupt registers */
+
+#define PCI_MSI_FLAGS		2	/* Message Control */
+#define  PCI_MSI_FLAGS_ENABLE	0x0001	/* MSI feature enabled */
+#define  PCI_MSI_FLAGS_QMASK	0x000e	/* Maximum queue size available */
+#define  PCI_MSI_FLAGS_QSIZE	0x0070	/* Message queue size configured */
+#define  PCI_MSI_FLAGS_64BIT	0x0080	/* 64-bit addresses allowed */
+#define  PCI_MSI_FLAGS_MASKBIT	0x0100	/* Per-vector masking capable */
+#define PCI_MSI_RFU		3	/* Rest of capability flags */
+#define PCI_MSI_ADDRESS_LO	4	/* Lower 32 bits */
+#define PCI_MSI_ADDRESS_HI	8	/* Upper 32 bits (if PCI_MSI_FLAGS_64BIT set) */
+#define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
+#define PCI_MSI_MASK_32		12	/* Mask bits register for 32-bit devices */
+#define PCI_MSI_PENDING_32	16	/* Pending intrs for 32-bit devices */
+#define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
+#define PCI_MSI_MASK_64		16	/* Mask bits register for 64-bit devices */
+#define PCI_MSI_PENDING_64	20	/* Pending intrs for 64-bit devices */
+
+/* MSI-X registers (in MSI-X capability) */
+#define PCI_MSIX_FLAGS		2	/* Message Control */
+#define  PCI_MSIX_FLAGS_QSIZE	0x07FF	/* Table size */
+#define  PCI_MSIX_FLAGS_MASKALL	0x4000	/* Mask all vectors for this function */
+#define  PCI_MSIX_FLAGS_ENABLE	0x8000	/* MSI-X enable */
+#define PCI_MSIX_TABLE		4	/* Table offset */
+#define  PCI_MSIX_TABLE_BIR	0x00000007 /* BAR index */
+#define  PCI_MSIX_TABLE_OFFSET	0xfffffff8 /* Offset into specified BAR */
+#define PCI_MSIX_PBA		8	/* Pending Bit Array offset */
+#define  PCI_MSIX_PBA_BIR	0x00000007 /* BAR index */
+#define  PCI_MSIX_PBA_OFFSET	0xfffffff8 /* Offset into specified BAR */
+#define PCI_MSIX_FLAGS_BIRMASK	PCI_MSIX_PBA_BIR /* deprecated */
+#define PCI_CAP_MSIX_SIZEOF	12	/* size of MSIX registers */
+
+/* MSI-X Table entry format (in memory mapped by a BAR) */
+#define PCI_MSIX_ENTRY_SIZE		16
+#define PCI_MSIX_ENTRY_LOWER_ADDR	0  /* Message Address */
+#define PCI_MSIX_ENTRY_UPPER_ADDR	4  /* Message Upper Address */
+#define PCI_MSIX_ENTRY_DATA		8  /* Message Data */
+#define PCI_MSIX_ENTRY_VECTOR_CTRL	12 /* Vector Control */
+#define  PCI_MSIX_ENTRY_CTRL_MASKBIT	0x00000001
+
+/* CompactPCI Hotswap Register */
+
+#define PCI_CHSWP_CSR		2	/* Control and Status Register */
+#define  PCI_CHSWP_DHA		0x01	/* Device Hiding Arm */
+#define  PCI_CHSWP_EIM		0x02	/* ENUM# Signal Mask */
+#define  PCI_CHSWP_PIE		0x04	/* Pending Insert or Extract */
+#define  PCI_CHSWP_LOO		0x08	/* LED On / Off */
+#define  PCI_CHSWP_PI		0x30	/* Programming Interface */
+#define  PCI_CHSWP_EXT		0x40	/* ENUM# status - extraction */
+#define  PCI_CHSWP_INS		0x80	/* ENUM# status - insertion */
+
+/* PCI Advanced Feature registers */
+
+#define PCI_AF_LENGTH		2
+#define PCI_AF_CAP		3
+#define  PCI_AF_CAP_TP		0x01
+#define  PCI_AF_CAP_FLR		0x02
+#define PCI_AF_CTRL		4
+#define  PCI_AF_CTRL_FLR	0x01
+#define PCI_AF_STATUS		5
+#define  PCI_AF_STATUS_TP	0x01
+#define PCI_CAP_AF_SIZEOF	6	/* size of AF registers */
+
+/* PCI Enhanced Allocation registers */
+
+#define PCI_EA_NUM_ENT		2	/* Number of Capability Entries */
+#define  PCI_EA_NUM_ENT_MASK	0x3f	/* Num Entries Mask */
+#define PCI_EA_FIRST_ENT	4	/* First EA Entry in List */
+#define PCI_EA_FIRST_ENT_BRIDGE	8	/* First EA Entry for Bridges */
+#define  PCI_EA_ES		0x00000007 /* Entry Size */
+#define  PCI_EA_BEI		0x000000f0 /* BAR Equivalent Indicator */
+
+/* EA fixed Secondary and Subordinate bus numbers for Bridge */
+#define PCI_EA_SEC_BUS_MASK	0xff
+#define PCI_EA_SUB_BUS_MASK	0xff00
+#define PCI_EA_SUB_BUS_SHIFT	8
+
+/* 0-5 map to BARs 0-5 respectively */
+#define   PCI_EA_BEI_BAR0		0
+#define   PCI_EA_BEI_BAR5		5
+#define   PCI_EA_BEI_BRIDGE		6	/* Resource behind bridge */
+#define   PCI_EA_BEI_ENI		7	/* Equivalent Not Indicated */
+#define   PCI_EA_BEI_ROM		8	/* Expansion ROM */
+/* 9-14 map to VF BARs 0-5 respectively */
+#define   PCI_EA_BEI_VF_BAR0		9
+#define   PCI_EA_BEI_VF_BAR5		14
+#define   PCI_EA_BEI_RESERVED		15	/* Reserved - Treat like ENI */
+#define  PCI_EA_PP		0x0000ff00	/* Primary Properties */
+#define  PCI_EA_SP		0x00ff0000	/* Secondary Properties */
+#define   PCI_EA_P_MEM			0x00	/* Non-Prefetch Memory */
+#define   PCI_EA_P_MEM_PREFETCH		0x01	/* Prefetchable Memory */
+#define   PCI_EA_P_IO			0x02	/* I/O Space */
+#define   PCI_EA_P_VF_MEM_PREFETCH	0x03	/* VF Prefetchable Memory */
+#define   PCI_EA_P_VF_MEM		0x04	/* VF Non-Prefetch Memory */
+#define   PCI_EA_P_BRIDGE_MEM		0x05	/* Bridge Non-Prefetch Memory */
+#define   PCI_EA_P_BRIDGE_MEM_PREFETCH	0x06	/* Bridge Prefetchable Memory */
+#define   PCI_EA_P_BRIDGE_IO		0x07	/* Bridge I/O Space */
+/* 0x08-0xfc reserved */
+#define   PCI_EA_P_MEM_RESERVED		0xfd	/* Reserved Memory */
+#define   PCI_EA_P_IO_RESERVED		0xfe	/* Reserved I/O Space */
+#define   PCI_EA_P_UNAVAILABLE		0xff	/* Entry Unavailable */
+#define  PCI_EA_WRITABLE	0x40000000	/* Writable: 1 = RW, 0 = HwInit */
+#define  PCI_EA_ENABLE		0x80000000	/* Enable for this entry */
+#define PCI_EA_BASE		4		/* Base Address Offset */
+#define PCI_EA_MAX_OFFSET	8		/* MaxOffset (resource length) */
+/* bit 0 is reserved */
+#define  PCI_EA_IS_64		0x00000002	/* 64-bit field flag */
+#define  PCI_EA_FIELD_MASK	0xfffffffc	/* For Base & Max Offset */
+
+/* PCI-X registers (Type 0 (non-bridge) devices) */
+
+#define PCI_X_CMD		2	/* Modes & Features */
+#define  PCI_X_CMD_DPERR_E	0x0001	/* Data Parity Error Recovery Enable */
+#define  PCI_X_CMD_ERO		0x0002	/* Enable Relaxed Ordering */
+#define  PCI_X_CMD_READ_512	0x0000	/* 512 byte maximum read byte count */
+#define  PCI_X_CMD_READ_1K	0x0004	/* 1Kbyte maximum read byte count */
+#define  PCI_X_CMD_READ_2K	0x0008	/* 2Kbyte maximum read byte count */
+#define  PCI_X_CMD_READ_4K	0x000c	/* 4Kbyte maximum read byte count */
+#define  PCI_X_CMD_MAX_READ	0x000c	/* Max Memory Read Byte Count */
+				/* Max # of outstanding split transactions */
+#define  PCI_X_CMD_SPLIT_1	0x0000	/* Max 1 */
+#define  PCI_X_CMD_SPLIT_2	0x0010	/* Max 2 */
+#define  PCI_X_CMD_SPLIT_3	0x0020	/* Max 3 */
+#define  PCI_X_CMD_SPLIT_4	0x0030	/* Max 4 */
+#define  PCI_X_CMD_SPLIT_8	0x0040	/* Max 8 */
+#define  PCI_X_CMD_SPLIT_12	0x0050	/* Max 12 */
+#define  PCI_X_CMD_SPLIT_16	0x0060	/* Max 16 */
+#define  PCI_X_CMD_SPLIT_32	0x0070	/* Max 32 */
+#define  PCI_X_CMD_MAX_SPLIT	0x0070	/* Max Outstanding Split Transactions */
+#define  PCI_X_CMD_VERSION(x)	(((x) >> 12) & 3) /* Version */
+#define PCI_X_STATUS		4	/* PCI-X capabilities */
+#define  PCI_X_STATUS_DEVFN	0x000000ff	/* A copy of devfn */
+#define  PCI_X_STATUS_BUS	0x0000ff00	/* A copy of bus nr */
+#define  PCI_X_STATUS_64BIT	0x00010000	/* 64-bit device */
+#define  PCI_X_STATUS_133MHZ	0x00020000	/* 133 MHz capable */
+#define  PCI_X_STATUS_SPL_DISC	0x00040000	/* Split Completion Discarded */
+#define  PCI_X_STATUS_UNX_SPL	0x00080000	/* Unexpected Split Completion */
+#define  PCI_X_STATUS_COMPLEX	0x00100000	/* Device Complexity */
+#define  PCI_X_STATUS_MAX_READ	0x00600000	/* Designed Max Memory Read Count */
+#define  PCI_X_STATUS_MAX_SPLIT	0x03800000	/* Designed Max Outstanding Split Transactions */
+#define  PCI_X_STATUS_MAX_CUM	0x1c000000	/* Designed Max Cumulative Read Size */
+#define  PCI_X_STATUS_SPL_ERR	0x20000000	/* Rcvd Split Completion Error Msg */
+#define  PCI_X_STATUS_266MHZ	0x40000000	/* 266 MHz capable */
+#define  PCI_X_STATUS_533MHZ	0x80000000	/* 533 MHz capable */
+#define PCI_X_ECC_CSR		8	/* ECC control and status */
+#define PCI_CAP_PCIX_SIZEOF_V0	8	/* size of registers for Version 0 */
+#define PCI_CAP_PCIX_SIZEOF_V1	24	/* size for Version 1 */
+#define PCI_CAP_PCIX_SIZEOF_V2	PCI_CAP_PCIX_SIZEOF_V1	/* Same for v2 */
+
+/* PCI-X registers (Type 1 (bridge) devices) */
+
+#define PCI_X_BRIDGE_SSTATUS	2	/* Secondary Status */
+#define  PCI_X_SSTATUS_64BIT	0x0001	/* Secondary AD interface is 64 bits */
+#define  PCI_X_SSTATUS_133MHZ	0x0002	/* 133 MHz capable */
+#define  PCI_X_SSTATUS_FREQ	0x03c0	/* Secondary Bus Mode and Frequency */
+#define  PCI_X_SSTATUS_VERS	0x3000	/* PCI-X Capability Version */
+#define  PCI_X_SSTATUS_V1	0x1000	/* Mode 2, not Mode 1 */
+#define  PCI_X_SSTATUS_V2	0x2000	/* Mode 1 or Modes 1 and 2 */
+#define  PCI_X_SSTATUS_266MHZ	0x4000	/* 266 MHz capable */
+#define  PCI_X_SSTATUS_533MHZ	0x8000	/* 533 MHz capable */
+#define PCI_X_BRIDGE_STATUS	4	/* Bridge Status */
+
+/* PCI Bridge Subsystem ID registers */
+
+#define PCI_SSVID_VENDOR_ID     4	/* PCI Bridge subsystem vendor ID */
+#define PCI_SSVID_DEVICE_ID     6	/* PCI Bridge subsystem device ID */
+
+/* PCI Express capability registers */
+
+#define PCI_EXP_FLAGS		2	/* Capabilities register */
+#define  PCI_EXP_FLAGS_VERS	0x000f	/* Capability version */
+#define  PCI_EXP_FLAGS_TYPE	0x00f0	/* Device/Port type */
+#define   PCI_EXP_TYPE_ENDPOINT	   0x0	/* Express Endpoint */
+#define   PCI_EXP_TYPE_LEG_END	   0x1	/* Legacy Endpoint */
+#define   PCI_EXP_TYPE_ROOT_PORT   0x4	/* Root Port */
+#define   PCI_EXP_TYPE_UPSTREAM	   0x5	/* Upstream Port */
+#define   PCI_EXP_TYPE_DOWNSTREAM  0x6	/* Downstream Port */
+#define   PCI_EXP_TYPE_PCI_BRIDGE  0x7	/* PCIe to PCI/PCI-X Bridge */
+#define   PCI_EXP_TYPE_PCIE_BRIDGE 0x8	/* PCI/PCI-X to PCIe Bridge */
+#define   PCI_EXP_TYPE_RC_END	   0x9	/* Root Complex Integrated Endpoint */
+#define   PCI_EXP_TYPE_RC_EC	   0xa	/* Root Complex Event Collector */
+#define  PCI_EXP_FLAGS_SLOT	0x0100	/* Slot implemented */
+#define  PCI_EXP_FLAGS_IRQ	0x3e00	/* Interrupt message number */
+#define PCI_EXP_DEVCAP		4	/* Device capabilities */
+#define  PCI_EXP_DEVCAP_PAYLOAD	0x00000007 /* Max_Payload_Size */
+#define  PCI_EXP_DEVCAP_PHANTOM	0x00000018 /* Phantom functions */
+#define  PCI_EXP_DEVCAP_EXT_TAG	0x00000020 /* Extended tags */
+#define  PCI_EXP_DEVCAP_L0S	0x000001c0 /* L0s Acceptable Latency */
+#define  PCI_EXP_DEVCAP_L1	0x00000e00 /* L1 Acceptable Latency */
+#define  PCI_EXP_DEVCAP_ATN_BUT	0x00001000 /* Attention Button Present */
+#define  PCI_EXP_DEVCAP_ATN_IND	0x00002000 /* Attention Indicator Present */
+#define  PCI_EXP_DEVCAP_PWR_IND	0x00004000 /* Power Indicator Present */
+#define  PCI_EXP_DEVCAP_RBER	0x00008000 /* Role-Based Error Reporting */
+#define  PCI_EXP_DEVCAP_PWR_VAL	0x03fc0000 /* Slot Power Limit Value */
+#define  PCI_EXP_DEVCAP_PWR_SCL	0x0c000000 /* Slot Power Limit Scale */
+#define  PCI_EXP_DEVCAP_FLR     0x10000000 /* Function Level Reset */
+#define PCI_EXP_DEVCTL		8	/* Device Control */
+#define  PCI_EXP_DEVCTL_CERE	0x0001	/* Correctable Error Reporting En. */
+#define  PCI_EXP_DEVCTL_NFERE	0x0002	/* Non-Fatal Error Reporting Enable */
+#define  PCI_EXP_DEVCTL_FERE	0x0004	/* Fatal Error Reporting Enable */
+#define  PCI_EXP_DEVCTL_URRE	0x0008	/* Unsupported Request Reporting En. */
+#define  PCI_EXP_DEVCTL_RELAX_EN 0x0010 /* Enable relaxed ordering */
+#define  PCI_EXP_DEVCTL_PAYLOAD	0x00e0	/* Max_Payload_Size */
+#define  PCI_EXP_DEVCTL_EXT_TAG	0x0100	/* Extended Tag Field Enable */
+#define  PCI_EXP_DEVCTL_PHANTOM	0x0200	/* Phantom Functions Enable */
+#define  PCI_EXP_DEVCTL_AUX_PME	0x0400	/* Auxiliary Power PM Enable */
+#define  PCI_EXP_DEVCTL_NOSNOOP_EN 0x0800  /* Enable No Snoop */
+#define  PCI_EXP_DEVCTL_READRQ	0x7000	/* Max_Read_Request_Size */
+#define  PCI_EXP_DEVCTL_READRQ_128B  0x0000 /* 128 Bytes */
+#define  PCI_EXP_DEVCTL_READRQ_256B  0x1000 /* 256 Bytes */
+#define  PCI_EXP_DEVCTL_READRQ_512B  0x2000 /* 512 Bytes */
+#define  PCI_EXP_DEVCTL_READRQ_1024B 0x3000 /* 1024 Bytes */
+#define  PCI_EXP_DEVCTL_READRQ_2048B 0x4000 /* 2048 Bytes */
+#define  PCI_EXP_DEVCTL_READRQ_4096B 0x5000 /* 4096 Bytes */
+#define  PCI_EXP_DEVCTL_BCR_FLR 0x8000  /* Bridge Configuration Retry / FLR */
+#define PCI_EXP_DEVSTA		10	/* Device Status */
+#define  PCI_EXP_DEVSTA_CED	0x0001	/* Correctable Error Detected */
+#define  PCI_EXP_DEVSTA_NFED	0x0002	/* Non-Fatal Error Detected */
+#define  PCI_EXP_DEVSTA_FED	0x0004	/* Fatal Error Detected */
+#define  PCI_EXP_DEVSTA_URD	0x0008	/* Unsupported Request Detected */
+#define  PCI_EXP_DEVSTA_AUXPD	0x0010	/* AUX Power Detected */
+#define  PCI_EXP_DEVSTA_TRPND	0x0020	/* Transactions Pending */
+#define PCI_CAP_EXP_RC_ENDPOINT_SIZEOF_V1	12	/* v1 endpoints without link end here */
+#define PCI_EXP_LNKCAP		12	/* Link Capabilities */
+#define  PCI_EXP_LNKCAP_SLS	0x0000000f /* Supported Link Speeds */
+#define  PCI_EXP_LNKCAP_SLS_2_5GB 0x00000001 /* LNKCAP2 SLS Vector bit 0 */
+#define  PCI_EXP_LNKCAP_SLS_5_0GB 0x00000002 /* LNKCAP2 SLS Vector bit 1 */
+#define  PCI_EXP_LNKCAP_SLS_8_0GB 0x00000003 /* LNKCAP2 SLS Vector bit 2 */
+#define  PCI_EXP_LNKCAP_SLS_16_0GB 0x00000004 /* LNKCAP2 SLS Vector bit 3 */
+#define  PCI_EXP_LNKCAP_SLS_32_0GB 0x00000005 /* LNKCAP2 SLS Vector bit 4 */
+#define  PCI_EXP_LNKCAP_SLS_64_0GB 0x00000006 /* LNKCAP2 SLS Vector bit 5 */
+#define  PCI_EXP_LNKCAP_MLW	0x000003f0 /* Maximum Link Width */
+#define  PCI_EXP_LNKCAP_ASPMS	0x00000c00 /* ASPM Support */
+#define  PCI_EXP_LNKCAP_ASPM_L0S 0x00000400 /* ASPM L0s Support */
+#define  PCI_EXP_LNKCAP_ASPM_L1  0x00000800 /* ASPM L1 Support */
+#define  PCI_EXP_LNKCAP_L0SEL	0x00007000 /* L0s Exit Latency */
+#define  PCI_EXP_LNKCAP_L1EL	0x00038000 /* L1 Exit Latency */
+#define  PCI_EXP_LNKCAP_CLKPM	0x00040000 /* Clock Power Management */
+#define  PCI_EXP_LNKCAP_SDERC	0x00080000 /* Surprise Down Error Reporting Capable */
+#define  PCI_EXP_LNKCAP_DLLLARC	0x00100000 /* Data Link Layer Link Active Reporting Capable */
+#define  PCI_EXP_LNKCAP_LBNC	0x00200000 /* Link Bandwidth Notification Capability */
+#define  PCI_EXP_LNKCAP_PN	0xff000000 /* Port Number */
+#define PCI_EXP_LNKCTL		16	/* Link Control */
+#define  PCI_EXP_LNKCTL_ASPMC	0x0003	/* ASPM Control */
+#define  PCI_EXP_LNKCTL_ASPM_L0S 0x0001	/* L0s Enable */
+#define  PCI_EXP_LNKCTL_ASPM_L1  0x0002	/* L1 Enable */
+#define  PCI_EXP_LNKCTL_RCB	0x0008	/* Read Completion Boundary */
+#define  PCI_EXP_LNKCTL_LD	0x0010	/* Link Disable */
+#define  PCI_EXP_LNKCTL_RL	0x0020	/* Retrain Link */
+#define  PCI_EXP_LNKCTL_CCC	0x0040	/* Common Clock Configuration */
+#define  PCI_EXP_LNKCTL_ES	0x0080	/* Extended Synch */
+#define  PCI_EXP_LNKCTL_CLKREQ_EN 0x0100 /* Enable clkreq */
+#define  PCI_EXP_LNKCTL_HAWD	0x0200	/* Hardware Autonomous Width Disable */
+#define  PCI_EXP_LNKCTL_LBMIE	0x0400	/* Link Bandwidth Management Interrupt Enable */
+#define  PCI_EXP_LNKCTL_LABIE	0x0800	/* Link Autonomous Bandwidth Interrupt Enable */
+#define PCI_EXP_LNKSTA		18	/* Link Status */
+#define  PCI_EXP_LNKSTA_CLS	0x000f	/* Current Link Speed */
+#define  PCI_EXP_LNKSTA_CLS_2_5GB 0x0001 /* Current Link Speed 2.5GT/s */
+#define  PCI_EXP_LNKSTA_CLS_5_0GB 0x0002 /* Current Link Speed 5.0GT/s */
+#define  PCI_EXP_LNKSTA_CLS_8_0GB 0x0003 /* Current Link Speed 8.0GT/s */
+#define  PCI_EXP_LNKSTA_CLS_16_0GB 0x0004 /* Current Link Speed 16.0GT/s */
+#define  PCI_EXP_LNKSTA_CLS_32_0GB 0x0005 /* Current Link Speed 32.0GT/s */
+#define  PCI_EXP_LNKSTA_CLS_64_0GB 0x0006 /* Current Link Speed 64.0GT/s */
+#define  PCI_EXP_LNKSTA_NLW	0x03f0	/* Negotiated Link Width */
+#define  PCI_EXP_LNKSTA_NLW_X1	0x0010	/* Current Link Width x1 */
+#define  PCI_EXP_LNKSTA_NLW_X2	0x0020	/* Current Link Width x2 */
+#define  PCI_EXP_LNKSTA_NLW_X4	0x0040	/* Current Link Width x4 */
+#define  PCI_EXP_LNKSTA_NLW_X8	0x0080	/* Current Link Width x8 */
+#define  PCI_EXP_LNKSTA_NLW_SHIFT 4	/* start of NLW mask in link status */
+#define  PCI_EXP_LNKSTA_LT	0x0800	/* Link Training */
+#define  PCI_EXP_LNKSTA_SLC	0x1000	/* Slot Clock Configuration */
+#define  PCI_EXP_LNKSTA_DLLLA	0x2000	/* Data Link Layer Link Active */
+#define  PCI_EXP_LNKSTA_LBMS	0x4000	/* Link Bandwidth Management Status */
+#define  PCI_EXP_LNKSTA_LABS	0x8000	/* Link Autonomous Bandwidth Status */
+#define PCI_CAP_EXP_ENDPOINT_SIZEOF_V1	20	/* v1 endpoints with link end here */
+#define PCI_EXP_SLTCAP		20	/* Slot Capabilities */
+#define  PCI_EXP_SLTCAP_ABP	0x00000001 /* Attention Button Present */
+#define  PCI_EXP_SLTCAP_PCP	0x00000002 /* Power Controller Present */
+#define  PCI_EXP_SLTCAP_MRLSP	0x00000004 /* MRL Sensor Present */
+#define  PCI_EXP_SLTCAP_AIP	0x00000008 /* Attention Indicator Present */
+#define  PCI_EXP_SLTCAP_PIP	0x00000010 /* Power Indicator Present */
+#define  PCI_EXP_SLTCAP_HPS	0x00000020 /* Hot-Plug Surprise */
+#define  PCI_EXP_SLTCAP_HPC	0x00000040 /* Hot-Plug Capable */
+#define  PCI_EXP_SLTCAP_SPLV	0x00007f80 /* Slot Power Limit Value */
+#define  PCI_EXP_SLTCAP_SPLS	0x00018000 /* Slot Power Limit Scale */
+#define  PCI_EXP_SLTCAP_EIP	0x00020000 /* Electromechanical Interlock Present */
+#define  PCI_EXP_SLTCAP_NCCS	0x00040000 /* No Command Completed Support */
+#define  PCI_EXP_SLTCAP_PSN	0xfff80000 /* Physical Slot Number */
+#define PCI_EXP_SLTCTL		24	/* Slot Control */
+#define  PCI_EXP_SLTCTL_ABPE	0x0001	/* Attention Button Pressed Enable */
+#define  PCI_EXP_SLTCTL_PFDE	0x0002	/* Power Fault Detected Enable */
+#define  PCI_EXP_SLTCTL_MRLSCE	0x0004	/* MRL Sensor Changed Enable */
+#define  PCI_EXP_SLTCTL_PDCE	0x0008	/* Presence Detect Changed Enable */
+#define  PCI_EXP_SLTCTL_CCIE	0x0010	/* Command Completed Interrupt Enable */
+#define  PCI_EXP_SLTCTL_HPIE	0x0020	/* Hot-Plug Interrupt Enable */
+#define  PCI_EXP_SLTCTL_AIC	0x00c0	/* Attention Indicator Control */
+#define  PCI_EXP_SLTCTL_ATTN_IND_SHIFT 6      /* Attention Indicator shift */
+#define  PCI_EXP_SLTCTL_ATTN_IND_ON    0x0040 /* Attention Indicator on */
+#define  PCI_EXP_SLTCTL_ATTN_IND_BLINK 0x0080 /* Attention Indicator blinking */
+#define  PCI_EXP_SLTCTL_ATTN_IND_OFF   0x00c0 /* Attention Indicator off */
+#define  PCI_EXP_SLTCTL_PIC	0x0300	/* Power Indicator Control */
+#define  PCI_EXP_SLTCTL_PWR_IND_ON     0x0100 /* Power Indicator on */
+#define  PCI_EXP_SLTCTL_PWR_IND_BLINK  0x0200 /* Power Indicator blinking */
+#define  PCI_EXP_SLTCTL_PWR_IND_OFF    0x0300 /* Power Indicator off */
+#define  PCI_EXP_SLTCTL_PCC	0x0400	/* Power Controller Control */
+#define  PCI_EXP_SLTCTL_PWR_ON         0x0000 /* Power On */
+#define  PCI_EXP_SLTCTL_PWR_OFF        0x0400 /* Power Off */
+#define  PCI_EXP_SLTCTL_EIC	0x0800	/* Electromechanical Interlock Control */
+#define  PCI_EXP_SLTCTL_DLLSCE	0x1000	/* Data Link Layer State Changed Enable */
+#define  PCI_EXP_SLTCTL_IBPD_DISABLE	0x4000 /* In-band PD disable */
+#define PCI_EXP_SLTSTA		26	/* Slot Status */
+#define  PCI_EXP_SLTSTA_ABP	0x0001	/* Attention Button Pressed */
+#define  PCI_EXP_SLTSTA_PFD	0x0002	/* Power Fault Detected */
+#define  PCI_EXP_SLTSTA_MRLSC	0x0004	/* MRL Sensor Changed */
+#define  PCI_EXP_SLTSTA_PDC	0x0008	/* Presence Detect Changed */
+#define  PCI_EXP_SLTSTA_CC	0x0010	/* Command Completed */
+#define  PCI_EXP_SLTSTA_MRLSS	0x0020	/* MRL Sensor State */
+#define  PCI_EXP_SLTSTA_PDS	0x0040	/* Presence Detect State */
+#define  PCI_EXP_SLTSTA_EIS	0x0080	/* Electromechanical Interlock Status */
+#define  PCI_EXP_SLTSTA_DLLSC	0x0100	/* Data Link Layer State Changed */
+#define PCI_EXP_RTCTL		28	/* Root Control */
+#define  PCI_EXP_RTCTL_SECEE	0x0001	/* System Error on Correctable Error */
+#define  PCI_EXP_RTCTL_SENFEE	0x0002	/* System Error on Non-Fatal Error */
+#define  PCI_EXP_RTCTL_SEFEE	0x0004	/* System Error on Fatal Error */
+#define  PCI_EXP_RTCTL_PMEIE	0x0008	/* PME Interrupt Enable */
+#define  PCI_EXP_RTCTL_CRSSVE	0x0010	/* CRS Software Visibility Enable */
+#define PCI_EXP_RTCAP		30	/* Root Capabilities */
+#define  PCI_EXP_RTCAP_CRSVIS	0x0001	/* CRS Software Visibility capability */
+#define PCI_EXP_RTSTA		32	/* Root Status */
+#define  PCI_EXP_RTSTA_PME	0x00010000 /* PME status */
+#define  PCI_EXP_RTSTA_PENDING	0x00020000 /* PME pending */
+/*
+ * The Device Capabilities 2, Device Status 2, Device Control 2,
+ * Link Capabilities 2, Link Status 2, Link Control 2,
+ * Slot Capabilities 2, Slot Status 2, and Slot Control 2 registers
+ * are only present on devices with PCIe Capability version 2.
+ * Use pcie_capability_read_word() and similar interfaces to use them
+ * safely.
+ */
+#define PCI_EXP_DEVCAP2		36	/* Device Capabilities 2 */
+#define  PCI_EXP_DEVCAP2_COMP_TMOUT_DIS	0x00000010 /* Completion Timeout Disable supported */
+#define  PCI_EXP_DEVCAP2_ARI		0x00000020 /* Alternative Routing-ID */
+#define  PCI_EXP_DEVCAP2_ATOMIC_ROUTE	0x00000040 /* Atomic Op routing */
+#define  PCI_EXP_DEVCAP2_ATOMIC_COMP32	0x00000080 /* 32b AtomicOp completion */
+#define  PCI_EXP_DEVCAP2_ATOMIC_COMP64	0x00000100 /* 64b AtomicOp completion */
+#define  PCI_EXP_DEVCAP2_ATOMIC_COMP128	0x00000200 /* 128b AtomicOp completion */
+#define  PCI_EXP_DEVCAP2_LTR		0x00000800 /* Latency tolerance reporting */
+#define  PCI_EXP_DEVCAP2_OBFF_MASK	0x000c0000 /* OBFF support mechanism */
+#define  PCI_EXP_DEVCAP2_OBFF_MSG	0x00040000 /* New message signaling */
+#define  PCI_EXP_DEVCAP2_OBFF_WAKE	0x00080000 /* Re-use WAKE# for OBFF */
+#define  PCI_EXP_DEVCAP2_EE_PREFIX	0x00200000 /* End-End TLP Prefix */
+#define PCI_EXP_DEVCTL2		40	/* Device Control 2 */
+#define  PCI_EXP_DEVCTL2_COMP_TIMEOUT	0x000f	/* Completion Timeout Value */
+#define  PCI_EXP_DEVCTL2_COMP_TMOUT_DIS	0x0010	/* Completion Timeout Disable */
+#define  PCI_EXP_DEVCTL2_ARI		0x0020	/* Alternative Routing-ID */
+#define  PCI_EXP_DEVCTL2_ATOMIC_REQ	0x0040	/* Set Atomic requests */
+#define  PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK 0x0080 /* Block atomic egress */
+#define  PCI_EXP_DEVCTL2_IDO_REQ_EN	0x0100	/* Allow IDO for requests */
+#define  PCI_EXP_DEVCTL2_IDO_CMP_EN	0x0200	/* Allow IDO for completions */
+#define  PCI_EXP_DEVCTL2_LTR_EN		0x0400	/* Enable LTR mechanism */
+#define  PCI_EXP_DEVCTL2_OBFF_MSGA_EN	0x2000	/* Enable OBFF Message type A */
+#define  PCI_EXP_DEVCTL2_OBFF_MSGB_EN	0x4000	/* Enable OBFF Message type B */
+#define  PCI_EXP_DEVCTL2_OBFF_WAKE_EN	0x6000	/* OBFF using WAKE# signaling */
+#define PCI_EXP_DEVSTA2		42	/* Device Status 2 */
+#define PCI_CAP_EXP_RC_ENDPOINT_SIZEOF_V2	44	/* v2 endpoints without link end here */
+#define PCI_EXP_LNKCAP2		44	/* Link Capabilities 2 */
+#define  PCI_EXP_LNKCAP2_SLS_2_5GB	0x00000002 /* Supported Speed 2.5GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_5_0GB	0x00000004 /* Supported Speed 5GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_8_0GB	0x00000008 /* Supported Speed 8GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_16_0GB	0x00000010 /* Supported Speed 16GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_32_0GB	0x00000020 /* Supported Speed 32GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_64_0GB	0x00000040 /* Supported Speed 64GT/s */
+#define  PCI_EXP_LNKCAP2_CROSSLINK	0x00000100 /* Crosslink supported */
+#define PCI_EXP_LNKCTL2		48	/* Link Control 2 */
+#define  PCI_EXP_LNKCTL2_TLS		0x000f
+#define  PCI_EXP_LNKCTL2_TLS_2_5GT	0x0001 /* Supported Speed 2.5GT/s */
+#define  PCI_EXP_LNKCTL2_TLS_5_0GT	0x0002 /* Supported Speed 5GT/s */
+#define  PCI_EXP_LNKCTL2_TLS_8_0GT	0x0003 /* Supported Speed 8GT/s */
+#define  PCI_EXP_LNKCTL2_TLS_16_0GT	0x0004 /* Supported Speed 16GT/s */
+#define  PCI_EXP_LNKCTL2_TLS_32_0GT	0x0005 /* Supported Speed 32GT/s */
+#define  PCI_EXP_LNKCTL2_TLS_64_0GT	0x0006 /* Supported Speed 64GT/s */
+#define  PCI_EXP_LNKCTL2_ENTER_COMP	0x0010 /* Enter Compliance */
+#define  PCI_EXP_LNKCTL2_TX_MARGIN	0x0380 /* Transmit Margin */
+#define  PCI_EXP_LNKCTL2_HASD		0x0020 /* HW Autonomous Speed Disable */
+#define PCI_EXP_LNKSTA2		50	/* Link Status 2 */
+#define PCI_CAP_EXP_ENDPOINT_SIZEOF_V2	52	/* v2 endpoints with link end here */
+#define PCI_EXP_SLTCAP2		52	/* Slot Capabilities 2 */
+#define  PCI_EXP_SLTCAP2_IBPD	0x00000001 /* In-band PD Disable Supported */
+#define PCI_EXP_SLTCTL2		56	/* Slot Control 2 */
+#define PCI_EXP_SLTSTA2		58	/* Slot Status 2 */
+
+/* Extended Capabilities (PCI-X 2.0 and Express) */
+#define PCI_EXT_CAP_ID(header)		(header & 0x0000ffff)
+#define PCI_EXT_CAP_VER(header)		((header >> 16) & 0xf)
+#define PCI_EXT_CAP_NEXT(header)	((header >> 20) & 0xffc)
+
+#define PCI_EXT_CAP_ID_ERR	0x01	/* Advanced Error Reporting */
+#define PCI_EXT_CAP_ID_VC	0x02	/* Virtual Channel Capability */
+#define PCI_EXT_CAP_ID_DSN	0x03	/* Device Serial Number */
+#define PCI_EXT_CAP_ID_PWR	0x04	/* Power Budgeting */
+#define PCI_EXT_CAP_ID_RCLD	0x05	/* Root Complex Link Declaration */
+#define PCI_EXT_CAP_ID_RCILC	0x06	/* Root Complex Internal Link Control */
+#define PCI_EXT_CAP_ID_RCEC	0x07	/* Root Complex Event Collector */
+#define PCI_EXT_CAP_ID_MFVC	0x08	/* Multi-Function VC Capability */
+#define PCI_EXT_CAP_ID_VC9	0x09	/* same as _VC */
+#define PCI_EXT_CAP_ID_RCRB	0x0A	/* Root Complex RB? */
+#define PCI_EXT_CAP_ID_VNDR	0x0B	/* Vendor-Specific */
+#define PCI_EXT_CAP_ID_CAC	0x0C	/* Config Access - obsolete */
+#define PCI_EXT_CAP_ID_ACS	0x0D	/* Access Control Services */
+#define PCI_EXT_CAP_ID_ARI	0x0E	/* Alternate Routing ID */
+#define PCI_EXT_CAP_ID_ATS	0x0F	/* Address Translation Services */
+#define PCI_EXT_CAP_ID_SRIOV	0x10	/* Single Root I/O Virtualization */
+#define PCI_EXT_CAP_ID_MRIOV	0x11	/* Multi Root I/O Virtualization */
+#define PCI_EXT_CAP_ID_MCAST	0x12	/* Multicast */
+#define PCI_EXT_CAP_ID_PRI	0x13	/* Page Request Interface */
+#define PCI_EXT_CAP_ID_AMD_XXX	0x14	/* Reserved for AMD */
+#define PCI_EXT_CAP_ID_REBAR	0x15	/* Resizable BAR */
+#define PCI_EXT_CAP_ID_DPA	0x16	/* Dynamic Power Allocation */
+#define PCI_EXT_CAP_ID_TPH	0x17	/* TPH Requester */
+#define PCI_EXT_CAP_ID_LTR	0x18	/* Latency Tolerance Reporting */
+#define PCI_EXT_CAP_ID_SECPCI	0x19	/* Secondary PCIe Capability */
+#define PCI_EXT_CAP_ID_PMUX	0x1A	/* Protocol Multiplexing */
+#define PCI_EXT_CAP_ID_PASID	0x1B	/* Process Address Space ID */
+#define PCI_EXT_CAP_ID_DPC	0x1D	/* Downstream Port Containment */
+#define PCI_EXT_CAP_ID_L1SS	0x1E	/* L1 PM Substates */
+#define PCI_EXT_CAP_ID_PTM	0x1F	/* Precision Time Measurement */
+#define PCI_EXT_CAP_ID_DVSEC	0x23	/* Designated Vendor-Specific */
+#define PCI_EXT_CAP_ID_DLF	0x25	/* Data Link Feature */
+#define PCI_EXT_CAP_ID_PL_16GT	0x26	/* Physical Layer 16.0 GT/s */
+#define PCI_EXT_CAP_ID_MAX	PCI_EXT_CAP_ID_PL_16GT
+
+#define PCI_EXT_CAP_DSN_SIZEOF	12
+#define PCI_EXT_CAP_MCAST_ENDPOINT_SIZEOF 40
+
+/* Advanced Error Reporting */
+#define PCI_ERR_UNCOR_STATUS	4	/* Uncorrectable Error Status */
+#define  PCI_ERR_UNC_UND	0x00000001	/* Undefined */
+#define  PCI_ERR_UNC_DLP	0x00000010	/* Data Link Protocol */
+#define  PCI_ERR_UNC_SURPDN	0x00000020	/* Surprise Down */
+#define  PCI_ERR_UNC_POISON_TLP	0x00001000	/* Poisoned TLP */
+#define  PCI_ERR_UNC_FCP	0x00002000	/* Flow Control Protocol */
+#define  PCI_ERR_UNC_COMP_TIME	0x00004000	/* Completion Timeout */
+#define  PCI_ERR_UNC_COMP_ABORT	0x00008000	/* Completer Abort */
+#define  PCI_ERR_UNC_UNX_COMP	0x00010000	/* Unexpected Completion */
+#define  PCI_ERR_UNC_RX_OVER	0x00020000	/* Receiver Overflow */
+#define  PCI_ERR_UNC_MALF_TLP	0x00040000	/* Malformed TLP */
+#define  PCI_ERR_UNC_ECRC	0x00080000	/* ECRC Error Status */
+#define  PCI_ERR_UNC_UNSUP	0x00100000	/* Unsupported Request */
+#define  PCI_ERR_UNC_ACSV	0x00200000	/* ACS Violation */
+#define  PCI_ERR_UNC_INTN	0x00400000	/* internal error */
+#define  PCI_ERR_UNC_MCBTLP	0x00800000	/* MC blocked TLP */
+#define  PCI_ERR_UNC_ATOMEG	0x01000000	/* Atomic egress blocked */
+#define  PCI_ERR_UNC_TLPPRE	0x02000000	/* TLP prefix blocked */
+#define PCI_ERR_UNCOR_MASK	8	/* Uncorrectable Error Mask */
+	/* Same bits as above */
+#define PCI_ERR_UNCOR_SEVER	12	/* Uncorrectable Error Severity */
+	/* Same bits as above */
+#define PCI_ERR_COR_STATUS	16	/* Correctable Error Status */
+#define  PCI_ERR_COR_RCVR	0x00000001	/* Receiver Error Status */
+#define  PCI_ERR_COR_BAD_TLP	0x00000040	/* Bad TLP Status */
+#define  PCI_ERR_COR_BAD_DLLP	0x00000080	/* Bad DLLP Status */
+#define  PCI_ERR_COR_REP_ROLL	0x00000100	/* REPLAY_NUM Rollover */
+#define  PCI_ERR_COR_REP_TIMER	0x00001000	/* Replay Timer Timeout */
+#define  PCI_ERR_COR_ADV_NFAT	0x00002000	/* Advisory Non-Fatal */
+#define  PCI_ERR_COR_INTERNAL	0x00004000	/* Corrected Internal */
+#define  PCI_ERR_COR_LOG_OVER	0x00008000	/* Header Log Overflow */
+#define PCI_ERR_COR_MASK	20	/* Correctable Error Mask */
+	/* Same bits as above */
+#define PCI_ERR_CAP		24	/* Advanced Error Capabilities */
+#define  PCI_ERR_CAP_FEP(x)	((x) & 31)	/* First Error Pointer */
+#define  PCI_ERR_CAP_ECRC_GENC	0x00000020	/* ECRC Generation Capable */
+#define  PCI_ERR_CAP_ECRC_GENE	0x00000040	/* ECRC Generation Enable */
+#define  PCI_ERR_CAP_ECRC_CHKC	0x00000080	/* ECRC Check Capable */
+#define  PCI_ERR_CAP_ECRC_CHKE	0x00000100	/* ECRC Check Enable */
+#define PCI_ERR_HEADER_LOG	28	/* Header Log Register (16 bytes) */
+#define PCI_ERR_ROOT_COMMAND	44	/* Root Error Command */
+#define  PCI_ERR_ROOT_CMD_COR_EN	0x00000001 /* Correctable Err Reporting Enable */
+#define  PCI_ERR_ROOT_CMD_NONFATAL_EN	0x00000002 /* Non-Fatal Err Reporting Enable */
+#define  PCI_ERR_ROOT_CMD_FATAL_EN	0x00000004 /* Fatal Err Reporting Enable */
+#define PCI_ERR_ROOT_STATUS	48
+#define  PCI_ERR_ROOT_COR_RCV		0x00000001 /* ERR_COR Received */
+#define  PCI_ERR_ROOT_MULTI_COR_RCV	0x00000002 /* Multiple ERR_COR */
+#define  PCI_ERR_ROOT_UNCOR_RCV		0x00000004 /* ERR_FATAL/NONFATAL */
+#define  PCI_ERR_ROOT_MULTI_UNCOR_RCV	0x00000008 /* Multiple FATAL/NONFATAL */
+#define  PCI_ERR_ROOT_FIRST_FATAL	0x00000010 /* First UNC is Fatal */
+#define  PCI_ERR_ROOT_NONFATAL_RCV	0x00000020 /* Non-Fatal Received */
+#define  PCI_ERR_ROOT_FATAL_RCV		0x00000040 /* Fatal Received */
+#define  PCI_ERR_ROOT_AER_IRQ		0xf8000000 /* Advanced Error Interrupt Message Number */
+#define PCI_ERR_ROOT_ERR_SRC	52	/* Error Source Identification */
+
+/* Virtual Channel */
+#define PCI_VC_PORT_CAP1	4
+#define  PCI_VC_CAP1_EVCC	0x00000007	/* extended VC count */
+#define  PCI_VC_CAP1_LPEVCC	0x00000070	/* low prio extended VC count */
+#define  PCI_VC_CAP1_ARB_SIZE	0x00000c00
+#define PCI_VC_PORT_CAP2	8
+#define  PCI_VC_CAP2_32_PHASE		0x00000002
+#define  PCI_VC_CAP2_64_PHASE		0x00000004
+#define  PCI_VC_CAP2_128_PHASE		0x00000008
+#define  PCI_VC_CAP2_ARB_OFF		0xff000000
+#define PCI_VC_PORT_CTRL	12
+#define  PCI_VC_PORT_CTRL_LOAD_TABLE	0x00000001
+#define PCI_VC_PORT_STATUS	14
+#define  PCI_VC_PORT_STATUS_TABLE	0x00000001
+#define PCI_VC_RES_CAP		16
+#define  PCI_VC_RES_CAP_32_PHASE	0x00000002
+#define  PCI_VC_RES_CAP_64_PHASE	0x00000004
+#define  PCI_VC_RES_CAP_128_PHASE	0x00000008
+#define  PCI_VC_RES_CAP_128_PHASE_TB	0x00000010
+#define  PCI_VC_RES_CAP_256_PHASE	0x00000020
+#define  PCI_VC_RES_CAP_ARB_OFF		0xff000000
+#define PCI_VC_RES_CTRL		20
+#define  PCI_VC_RES_CTRL_LOAD_TABLE	0x00010000
+#define  PCI_VC_RES_CTRL_ARB_SELECT	0x000e0000
+#define  PCI_VC_RES_CTRL_ID		0x07000000
+#define  PCI_VC_RES_CTRL_ENABLE		0x80000000
+#define PCI_VC_RES_STATUS	26
+#define  PCI_VC_RES_STATUS_TABLE	0x00000001
+#define  PCI_VC_RES_STATUS_NEGO		0x00000002
+#define PCI_CAP_VC_BASE_SIZEOF		0x10
+#define PCI_CAP_VC_PER_VC_SIZEOF	0x0C
+
+/* Power Budgeting */
+#define PCI_PWR_DSR		4	/* Data Select Register */
+#define PCI_PWR_DATA		8	/* Data Register */
+#define  PCI_PWR_DATA_BASE(x)	((x) & 0xff)	    /* Base Power */
+#define  PCI_PWR_DATA_SCALE(x)	(((x) >> 8) & 3)    /* Data Scale */
+#define  PCI_PWR_DATA_PM_SUB(x)	(((x) >> 10) & 7)   /* PM Sub State */
+#define  PCI_PWR_DATA_PM_STATE(x) (((x) >> 13) & 3) /* PM State */
+#define  PCI_PWR_DATA_TYPE(x)	(((x) >> 15) & 7)   /* Type */
+#define  PCI_PWR_DATA_RAIL(x)	(((x) >> 18) & 7)   /* Power Rail */
+#define PCI_PWR_CAP		12	/* Capability */
+#define  PCI_PWR_CAP_BUDGET(x)	((x) & 1)	/* Included in system budget */
+#define PCI_EXT_CAP_PWR_SIZEOF	16
+
+/* Root Complex Event Collector Endpoint Association  */
+#define PCI_RCEC_RCIEP_BITMAP	4	/* Associated Bitmap for RCiEPs */
+#define PCI_RCEC_BUSN		8	/* RCEC Associated Bus Numbers */
+#define  PCI_RCEC_BUSN_REG_VER	0x02	/* Least version with BUSN present */
+#define  PCI_RCEC_BUSN_NEXT(x)	(((x) >> 8) & 0xff)
+#define  PCI_RCEC_BUSN_LAST(x)	(((x) >> 16) & 0xff)
+
+/* Vendor-Specific (VSEC, PCI_EXT_CAP_ID_VNDR) */
+#define PCI_VNDR_HEADER		4	/* Vendor-Specific Header */
+#define  PCI_VNDR_HEADER_ID(x)	((x) & 0xffff)
+#define  PCI_VNDR_HEADER_REV(x)	(((x) >> 16) & 0xf)
+#define  PCI_VNDR_HEADER_LEN(x)	(((x) >> 20) & 0xfff)
+
+/*
+ * HyperTransport sub capability types
+ *
+ * Unfortunately there are both 3 bit and 5 bit capability types defined
+ * in the HT spec, catering for that is a little messy. You probably don't
+ * want to use these directly, just use pci_find_ht_capability() and it
+ * will do the right thing for you.
+ */
+#define HT_3BIT_CAP_MASK	0xE0
+#define HT_CAPTYPE_SLAVE	0x00	/* Slave/Primary link configuration */
+#define HT_CAPTYPE_HOST		0x20	/* Host/Secondary link configuration */
+
+#define HT_5BIT_CAP_MASK	0xF8
+#define HT_CAPTYPE_IRQ		0x80	/* IRQ Configuration */
+#define HT_CAPTYPE_REMAPPING_40	0xA0	/* 40 bit address remapping */
+#define HT_CAPTYPE_REMAPPING_64 0xA2	/* 64 bit address remapping */
+#define HT_CAPTYPE_UNITID_CLUMP	0x90	/* Unit ID clumping */
+#define HT_CAPTYPE_EXTCONF	0x98	/* Extended Configuration Space Access */
+#define HT_CAPTYPE_MSI_MAPPING	0xA8	/* MSI Mapping Capability */
+#define  HT_MSI_FLAGS		0x02		/* Offset to flags */
+#define  HT_MSI_FLAGS_ENABLE	0x1		/* Mapping enable */
+#define  HT_MSI_FLAGS_FIXED	0x2		/* Fixed mapping only */
+#define  HT_MSI_FIXED_ADDR	0x00000000FEE00000ULL	/* Fixed addr */
+#define  HT_MSI_ADDR_LO		0x04		/* Offset to low addr bits */
+#define  HT_MSI_ADDR_LO_MASK	0xFFF00000	/* Low address bit mask */
+#define  HT_MSI_ADDR_HI		0x08		/* Offset to high addr bits */
+#define HT_CAPTYPE_DIRECT_ROUTE	0xB0	/* Direct routing configuration */
+#define HT_CAPTYPE_VCSET	0xB8	/* Virtual Channel configuration */
+#define HT_CAPTYPE_ERROR_RETRY	0xC0	/* Retry on error configuration */
+#define HT_CAPTYPE_GEN3		0xD0	/* Generation 3 HyperTransport configuration */
+#define HT_CAPTYPE_PM		0xE0	/* HyperTransport power management configuration */
+#define HT_CAP_SIZEOF_LONG	28	/* slave & primary */
+#define HT_CAP_SIZEOF_SHORT	24	/* host & secondary */
+
+/* Alternative Routing-ID Interpretation */
+#define PCI_ARI_CAP		0x04	/* ARI Capability Register */
+#define  PCI_ARI_CAP_MFVC	0x0001	/* MFVC Function Groups Capability */
+#define  PCI_ARI_CAP_ACS	0x0002	/* ACS Function Groups Capability */
+#define  PCI_ARI_CAP_NFN(x)	(((x) >> 8) & 0xff) /* Next Function Number */
+#define PCI_ARI_CTRL		0x06	/* ARI Control Register */
+#define  PCI_ARI_CTRL_MFVC	0x0001	/* MFVC Function Groups Enable */
+#define  PCI_ARI_CTRL_ACS	0x0002	/* ACS Function Groups Enable */
+#define  PCI_ARI_CTRL_FG(x)	(((x) >> 4) & 7) /* Function Group */
+#define PCI_EXT_CAP_ARI_SIZEOF	8
+
+/* Address Translation Service */
+#define PCI_ATS_CAP		0x04	/* ATS Capability Register */
+#define  PCI_ATS_CAP_QDEP(x)	((x) & 0x1f)	/* Invalidate Queue Depth */
+#define  PCI_ATS_MAX_QDEP	32	/* Max Invalidate Queue Depth */
+#define  PCI_ATS_CAP_PAGE_ALIGNED	0x0020 /* Page Aligned Request */
+#define PCI_ATS_CTRL		0x06	/* ATS Control Register */
+#define  PCI_ATS_CTRL_ENABLE	0x8000	/* ATS Enable */
+#define  PCI_ATS_CTRL_STU(x)	((x) & 0x1f)	/* Smallest Translation Unit */
+#define  PCI_ATS_MIN_STU	12	/* shift of minimum STU block */
+#define PCI_EXT_CAP_ATS_SIZEOF	8
+
+/* Page Request Interface */
+#define PCI_PRI_CTRL		0x04	/* PRI control register */
+#define  PCI_PRI_CTRL_ENABLE	0x0001	/* Enable */
+#define  PCI_PRI_CTRL_RESET	0x0002	/* Reset */
+#define PCI_PRI_STATUS		0x06	/* PRI status register */
+#define  PCI_PRI_STATUS_RF	0x0001	/* Response Failure */
+#define  PCI_PRI_STATUS_UPRGI	0x0002	/* Unexpected PRG index */
+#define  PCI_PRI_STATUS_STOPPED	0x0100	/* PRI Stopped */
+#define  PCI_PRI_STATUS_PASID	0x8000	/* PRG Response PASID Required */
+#define PCI_PRI_MAX_REQ		0x08	/* PRI max reqs supported */
+#define PCI_PRI_ALLOC_REQ	0x0c	/* PRI max reqs allowed */
+#define PCI_EXT_CAP_PRI_SIZEOF	16
+
+/* Process Address Space ID */
+#define PCI_PASID_CAP		0x04    /* PASID feature register */
+#define  PCI_PASID_CAP_EXEC	0x02	/* Exec permissions Supported */
+#define  PCI_PASID_CAP_PRIV	0x04	/* Privilege Mode Supported */
+#define PCI_PASID_CTRL		0x06    /* PASID control register */
+#define  PCI_PASID_CTRL_ENABLE	0x01	/* Enable bit */
+#define  PCI_PASID_CTRL_EXEC	0x02	/* Exec permissions Enable */
+#define  PCI_PASID_CTRL_PRIV	0x04	/* Privilege Mode Enable */
+#define PCI_EXT_CAP_PASID_SIZEOF	8
+
+/* Single Root I/O Virtualization */
+#define PCI_SRIOV_CAP		0x04	/* SR-IOV Capabilities */
+#define  PCI_SRIOV_CAP_VFM	0x00000001  /* VF Migration Capable */
+#define  PCI_SRIOV_CAP_INTR(x)	((x) >> 21) /* Interrupt Message Number */
+#define PCI_SRIOV_CTRL		0x08	/* SR-IOV Control */
+#define  PCI_SRIOV_CTRL_VFE	0x0001	/* VF Enable */
+#define  PCI_SRIOV_CTRL_VFM	0x0002	/* VF Migration Enable */
+#define  PCI_SRIOV_CTRL_INTR	0x0004	/* VF Migration Interrupt Enable */
+#define  PCI_SRIOV_CTRL_MSE	0x0008	/* VF Memory Space Enable */
+#define  PCI_SRIOV_CTRL_ARI	0x0010	/* ARI Capable Hierarchy */
+#define PCI_SRIOV_STATUS	0x0a	/* SR-IOV Status */
+#define  PCI_SRIOV_STATUS_VFM	0x0001	/* VF Migration Status */
+#define PCI_SRIOV_INITIAL_VF	0x0c	/* Initial VFs */
+#define PCI_SRIOV_TOTAL_VF	0x0e	/* Total VFs */
+#define PCI_SRIOV_NUM_VF	0x10	/* Number of VFs */
+#define PCI_SRIOV_FUNC_LINK	0x12	/* Function Dependency Link */
+#define PCI_SRIOV_VF_OFFSET	0x14	/* First VF Offset */
+#define PCI_SRIOV_VF_STRIDE	0x16	/* Following VF Stride */
+#define PCI_SRIOV_VF_DID	0x1a	/* VF Device ID */
+#define PCI_SRIOV_SUP_PGSIZE	0x1c	/* Supported Page Sizes */
+#define PCI_SRIOV_SYS_PGSIZE	0x20	/* System Page Size */
+#define PCI_SRIOV_BAR		0x24	/* VF BAR0 */
+#define  PCI_SRIOV_NUM_BARS	6	/* Number of VF BARs */
+#define PCI_SRIOV_VFM		0x3c	/* VF Migration State Array Offset*/
+#define  PCI_SRIOV_VFM_BIR(x)	((x) & 7)	/* State BIR */
+#define  PCI_SRIOV_VFM_OFFSET(x) ((x) & ~7)	/* State Offset */
+#define  PCI_SRIOV_VFM_UA	0x0	/* Inactive.Unavailable */
+#define  PCI_SRIOV_VFM_MI	0x1	/* Dormant.MigrateIn */
+#define  PCI_SRIOV_VFM_MO	0x2	/* Active.MigrateOut */
+#define  PCI_SRIOV_VFM_AV	0x3	/* Active.Available */
+#define PCI_EXT_CAP_SRIOV_SIZEOF 64
+
+#define PCI_LTR_MAX_SNOOP_LAT	0x4
+#define PCI_LTR_MAX_NOSNOOP_LAT	0x6
+#define  PCI_LTR_VALUE_MASK	0x000003ff
+#define  PCI_LTR_SCALE_MASK	0x00001c00
+#define  PCI_LTR_SCALE_SHIFT	10
+#define PCI_EXT_CAP_LTR_SIZEOF	8
+
+/* Access Control Service */
+#define PCI_ACS_CAP		0x04	/* ACS Capability Register */
+#define  PCI_ACS_SV		0x0001	/* Source Validation */
+#define  PCI_ACS_TB		0x0002	/* Translation Blocking */
+#define  PCI_ACS_RR		0x0004	/* P2P Request Redirect */
+#define  PCI_ACS_CR		0x0008	/* P2P Completion Redirect */
+#define  PCI_ACS_UF		0x0010	/* Upstream Forwarding */
+#define  PCI_ACS_EC		0x0020	/* P2P Egress Control */
+#define  PCI_ACS_DT		0x0040	/* Direct Translated P2P */
+#define PCI_ACS_EGRESS_BITS	0x05	/* ACS Egress Control Vector Size */
+#define PCI_ACS_CTRL		0x06	/* ACS Control Register */
+#define PCI_ACS_EGRESS_CTL_V	0x08	/* ACS Egress Control Vector */
+
+#define PCI_VSEC_HDR		4	/* extended cap - vendor-specific */
+#define  PCI_VSEC_HDR_LEN_SHIFT	20	/* shift for length field */
+
+/* SATA capability */
+#define PCI_SATA_REGS		4	/* SATA REGs specifier */
+#define  PCI_SATA_REGS_MASK	0xF	/* location - BAR#/inline */
+#define  PCI_SATA_REGS_INLINE	0xF	/* REGS in config space */
+#define PCI_SATA_SIZEOF_SHORT	8
+#define PCI_SATA_SIZEOF_LONG	16
+
+/* Resizable BARs */
+#define PCI_REBAR_CAP		4	/* capability register */
+#define  PCI_REBAR_CAP_SIZES		0x00FFFFF0  /* supported BAR sizes */
+#define PCI_REBAR_CTRL		8	/* control register */
+#define  PCI_REBAR_CTRL_BAR_IDX		0x00000007  /* BAR index */
+#define  PCI_REBAR_CTRL_NBAR_MASK	0x000000E0  /* # of resizable BARs */
+#define  PCI_REBAR_CTRL_NBAR_SHIFT	5	    /* shift for # of BARs */
+#define  PCI_REBAR_CTRL_BAR_SIZE	0x00001F00  /* BAR size */
+#define  PCI_REBAR_CTRL_BAR_SHIFT	8	    /* shift for BAR size */
+
+/* Dynamic Power Allocation */
+#define PCI_DPA_CAP		4	/* capability register */
+#define  PCI_DPA_CAP_SUBSTATE_MASK	0x1F	/* # substates - 1 */
+#define PCI_DPA_BASE_SIZEOF	16	/* size with 0 substates */
+
+/* TPH Requester */
+#define PCI_TPH_CAP		4	/* capability register */
+#define  PCI_TPH_CAP_LOC_MASK	0x600	/* location mask */
+#define   PCI_TPH_LOC_NONE	0x000	/* no location */
+#define   PCI_TPH_LOC_CAP	0x200	/* in capability */
+#define   PCI_TPH_LOC_MSIX	0x400	/* in MSI-X */
+#define PCI_TPH_CAP_ST_MASK	0x07FF0000	/* st table mask */
+#define PCI_TPH_CAP_ST_SHIFT	16	/* st table shift */
+#define PCI_TPH_BASE_SIZEOF	12	/* size with no st table */
+
+/* Downstream Port Containment */
+#define PCI_EXP_DPC_CAP			4	/* DPC Capability */
+#define PCI_EXP_DPC_IRQ			0x001F	/* Interrupt Message Number */
+#define  PCI_EXP_DPC_CAP_RP_EXT		0x0020	/* Root Port Extensions */
+#define  PCI_EXP_DPC_CAP_POISONED_TLP	0x0040	/* Poisoned TLP Egress Blocking Supported */
+#define  PCI_EXP_DPC_CAP_SW_TRIGGER	0x0080	/* Software Triggering Supported */
+#define  PCI_EXP_DPC_RP_PIO_LOG_SIZE	0x0F00	/* RP PIO Log Size */
+#define  PCI_EXP_DPC_CAP_DL_ACTIVE	0x1000	/* ERR_COR signal on DL_Active supported */
+
+#define PCI_EXP_DPC_CTL			6	/* DPC control */
+#define  PCI_EXP_DPC_CTL_EN_FATAL	0x0001	/* Enable trigger on ERR_FATAL message */
+#define  PCI_EXP_DPC_CTL_EN_NONFATAL	0x0002	/* Enable trigger on ERR_NONFATAL message */
+#define  PCI_EXP_DPC_CTL_INT_EN		0x0008	/* DPC Interrupt Enable */
+
+#define PCI_EXP_DPC_STATUS		8	/* DPC Status */
+#define  PCI_EXP_DPC_STATUS_TRIGGER	    0x0001 /* Trigger Status */
+#define  PCI_EXP_DPC_STATUS_TRIGGER_RSN	    0x0006 /* Trigger Reason */
+#define  PCI_EXP_DPC_STATUS_INTERRUPT	    0x0008 /* Interrupt Status */
+#define  PCI_EXP_DPC_RP_BUSY		    0x0010 /* Root Port Busy */
+#define  PCI_EXP_DPC_STATUS_TRIGGER_RSN_EXT 0x0060 /* Trig Reason Extension */
+
+#define PCI_EXP_DPC_SOURCE_ID		10	/* DPC Source Identifier */
+
+#define PCI_EXP_DPC_RP_PIO_STATUS	 0x0C	/* RP PIO Status */
+#define PCI_EXP_DPC_RP_PIO_MASK		 0x10	/* RP PIO Mask */
+#define PCI_EXP_DPC_RP_PIO_SEVERITY	 0x14	/* RP PIO Severity */
+#define PCI_EXP_DPC_RP_PIO_SYSERROR	 0x18	/* RP PIO SysError */
+#define PCI_EXP_DPC_RP_PIO_EXCEPTION	 0x1C	/* RP PIO Exception */
+#define PCI_EXP_DPC_RP_PIO_HEADER_LOG	 0x20	/* RP PIO Header Log */
+#define PCI_EXP_DPC_RP_PIO_IMPSPEC_LOG	 0x30	/* RP PIO ImpSpec Log */
+#define PCI_EXP_DPC_RP_PIO_TLPPREFIX_LOG 0x34	/* RP PIO TLP Prefix Log */
+
+/* Precision Time Measurement */
+#define PCI_PTM_CAP			0x04	    /* PTM Capability */
+#define  PCI_PTM_CAP_REQ		0x00000001  /* Requester capable */
+#define  PCI_PTM_CAP_ROOT		0x00000004  /* Root capable */
+#define  PCI_PTM_GRANULARITY_MASK	0x0000FF00  /* Clock granularity */
+#define PCI_PTM_CTRL			0x08	    /* PTM Control */
+#define  PCI_PTM_CTRL_ENABLE		0x00000001  /* PTM enable */
+#define  PCI_PTM_CTRL_ROOT		0x00000002  /* Root select */
+
+/* ASPM L1 PM Substates */
+#define PCI_L1SS_CAP		0x04	/* Capabilities Register */
+#define  PCI_L1SS_CAP_PCIPM_L1_2	0x00000001  /* PCI-PM L1.2 Supported */
+#define  PCI_L1SS_CAP_PCIPM_L1_1	0x00000002  /* PCI-PM L1.1 Supported */
+#define  PCI_L1SS_CAP_ASPM_L1_2		0x00000004  /* ASPM L1.2 Supported */
+#define  PCI_L1SS_CAP_ASPM_L1_1		0x00000008  /* ASPM L1.1 Supported */
+#define  PCI_L1SS_CAP_L1_PM_SS		0x00000010  /* L1 PM Substates Supported */
+#define  PCI_L1SS_CAP_CM_RESTORE_TIME	0x0000ff00  /* Port Common_Mode_Restore_Time */
+#define  PCI_L1SS_CAP_P_PWR_ON_SCALE	0x00030000  /* Port T_POWER_ON scale */
+#define  PCI_L1SS_CAP_P_PWR_ON_VALUE	0x00f80000  /* Port T_POWER_ON value */
+#define PCI_L1SS_CTL1		0x08	/* Control 1 Register */
+#define  PCI_L1SS_CTL1_PCIPM_L1_2	0x00000001  /* PCI-PM L1.2 Enable */
+#define  PCI_L1SS_CTL1_PCIPM_L1_1	0x00000002  /* PCI-PM L1.1 Enable */
+#define  PCI_L1SS_CTL1_ASPM_L1_2	0x00000004  /* ASPM L1.2 Enable */
+#define  PCI_L1SS_CTL1_ASPM_L1_1	0x00000008  /* ASPM L1.1 Enable */
+#define  PCI_L1SS_CTL1_L1_2_MASK	0x00000005
+#define  PCI_L1SS_CTL1_L1SS_MASK	0x0000000f
+#define  PCI_L1SS_CTL1_CM_RESTORE_TIME	0x0000ff00  /* Common_Mode_Restore_Time */
+#define  PCI_L1SS_CTL1_LTR_L12_TH_VALUE	0x03ff0000  /* LTR_L1.2_THRESHOLD_Value */
+#define  PCI_L1SS_CTL1_LTR_L12_TH_SCALE	0xe0000000  /* LTR_L1.2_THRESHOLD_Scale */
+#define PCI_L1SS_CTL2		0x0c	/* Control 2 Register */
+
+/* Designated Vendor-Specific (DVSEC, PCI_EXT_CAP_ID_DVSEC) */
+#define PCI_DVSEC_HEADER1		0x4 /* Designated Vendor-Specific Header1 */
+#define PCI_DVSEC_HEADER2		0x8 /* Designated Vendor-Specific Header2 */
+
+/* Data Link Feature */
+#define PCI_DLF_CAP		0x04	/* Capabilities Register */
+#define  PCI_DLF_EXCHANGE_ENABLE	0x80000000  /* Data Link Feature Exchange Enable */
+
+/* Physical Layer 16.0 GT/s */
+#define PCI_PL_16GT_LE_CTRL	0x20	/* Lane Equalization Control Register */
+#define  PCI_PL_16GT_LE_CTRL_DSP_TX_PRESET_MASK		0x0000000F
+#define  PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_MASK		0x000000F0
+#define  PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_SHIFT	4
+
+#endif /* LINUX_PCI_REGS_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/qemu_fw_cfg.h b/subprojects/libvhost-user/standard-headers/linux/qemu_fw_cfg.h
new file mode 100644
index 0000000..cb93f66
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/qemu_fw_cfg.h
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+#ifndef _LINUX_FW_CFG_H
+#define _LINUX_FW_CFG_H
+
+#include "standard-headers/linux/types.h"
+
+#define FW_CFG_ACPI_DEVICE_ID	"QEMU0002"
+
+/* selector key values for "well-known" fw_cfg entries */
+#define FW_CFG_SIGNATURE	0x00
+#define FW_CFG_ID		0x01
+#define FW_CFG_UUID		0x02
+#define FW_CFG_RAM_SIZE		0x03
+#define FW_CFG_NOGRAPHIC	0x04
+#define FW_CFG_NB_CPUS		0x05
+#define FW_CFG_MACHINE_ID	0x06
+#define FW_CFG_KERNEL_ADDR	0x07
+#define FW_CFG_KERNEL_SIZE	0x08
+#define FW_CFG_KERNEL_CMDLINE	0x09
+#define FW_CFG_INITRD_ADDR	0x0a
+#define FW_CFG_INITRD_SIZE	0x0b
+#define FW_CFG_BOOT_DEVICE	0x0c
+#define FW_CFG_NUMA		0x0d
+#define FW_CFG_BOOT_MENU	0x0e
+#define FW_CFG_MAX_CPUS		0x0f
+#define FW_CFG_KERNEL_ENTRY	0x10
+#define FW_CFG_KERNEL_DATA	0x11
+#define FW_CFG_INITRD_DATA	0x12
+#define FW_CFG_CMDLINE_ADDR	0x13
+#define FW_CFG_CMDLINE_SIZE	0x14
+#define FW_CFG_CMDLINE_DATA	0x15
+#define FW_CFG_SETUP_ADDR	0x16
+#define FW_CFG_SETUP_SIZE	0x17
+#define FW_CFG_SETUP_DATA	0x18
+#define FW_CFG_FILE_DIR		0x19
+
+#define FW_CFG_FILE_FIRST	0x20
+#define FW_CFG_FILE_SLOTS_MIN	0x10
+
+#define FW_CFG_WRITE_CHANNEL	0x4000
+#define FW_CFG_ARCH_LOCAL	0x8000
+#define FW_CFG_ENTRY_MASK	(~(FW_CFG_WRITE_CHANNEL | FW_CFG_ARCH_LOCAL))
+
+#define FW_CFG_INVALID		0xffff
+
+/* width in bytes of fw_cfg control register */
+#define FW_CFG_CTL_SIZE		0x02
+
+/* fw_cfg "file name" is up to 56 characters (including terminating nul) */
+#define FW_CFG_MAX_FILE_PATH	56
+
+/* size in bytes of fw_cfg signature */
+#define FW_CFG_SIG_SIZE 4
+
+/* FW_CFG_ID bits */
+#define FW_CFG_VERSION		0x01
+#define FW_CFG_VERSION_DMA	0x02
+
+/* fw_cfg file directory entry type */
+struct fw_cfg_file {
+	uint32_t size;
+	uint16_t select;
+	uint16_t reserved;
+	char name[FW_CFG_MAX_FILE_PATH];
+};
+
+/* FW_CFG_DMA_CONTROL bits */
+#define FW_CFG_DMA_CTL_ERROR	0x01
+#define FW_CFG_DMA_CTL_READ	0x02
+#define FW_CFG_DMA_CTL_SKIP	0x04
+#define FW_CFG_DMA_CTL_SELECT	0x08
+#define FW_CFG_DMA_CTL_WRITE	0x10
+
+#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */
+
+/* Control as first field allows for different structures selected by this
+ * field, which might be useful in the future
+ */
+struct fw_cfg_dma_access {
+	uint32_t control;
+	uint32_t length;
+	uint64_t address;
+};
+
+#define FW_CFG_VMCOREINFO_FILENAME "etc/vmcoreinfo"
+
+#define FW_CFG_VMCOREINFO_FORMAT_NONE 0x0
+#define FW_CFG_VMCOREINFO_FORMAT_ELF 0x1
+
+struct fw_cfg_vmcoreinfo {
+	uint16_t host_format;
+	uint16_t guest_format;
+	uint32_t size;
+	uint64_t paddr;
+};
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/sysinfo.h b/subprojects/libvhost-user/standard-headers/linux/sysinfo.h
new file mode 100644
index 0000000..e3c06ac
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/sysinfo.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_SYSINFO_H
+#define _LINUX_SYSINFO_H
+
+#include "standard-headers/linux/types.h"
+
+#define SI_LOAD_SHIFT	16
+struct sysinfo {
+	long uptime;		/* Seconds since boot */
+	unsigned long loads[3];	/* 1, 5, and 15 minute load averages */
+	unsigned long totalram;	/* Total usable main memory size */
+	unsigned long freeram;	/* Available memory size */
+	unsigned long sharedram;	/* Amount of shared memory */
+	unsigned long bufferram;	/* Memory used by buffers */
+	unsigned long totalswap;	/* Total swap space size */
+	unsigned long freeswap;	/* swap space still available */
+	uint16_t procs;		   	/* Number of current processes */
+	uint16_t pad;		   	/* Explicit padding for m68k */
+	unsigned long totalhigh;	/* Total high memory size */
+	unsigned long freehigh;	/* Available high memory size */
+	uint32_t mem_unit;			/* Memory unit size in bytes */
+	char _f[20-2*sizeof(unsigned long)-sizeof(uint32_t)];	/* Padding: libc5 uses this.. */
+};
+
+#endif /* _LINUX_SYSINFO_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/types.h b/subprojects/libvhost-user/standard-headers/linux/types.h
new file mode 100644
index 0000000..9dbbc73
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/types.h
@@ -0,0 +1,3 @@
+/* For QEMU all types are already defined via osdep.h, so this
+ * header does not need to do anything.
+ */
diff --git a/subprojects/libvhost-user/standard-headers/linux/udmabuf.h b/subprojects/libvhost-user/standard-headers/linux/udmabuf.h
new file mode 100644
index 0000000..e19eb5b
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/udmabuf.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_UDMABUF_H
+#define _LINUX_UDMABUF_H
+
+#include "standard-headers/linux/types.h"
+
+#define UDMABUF_FLAGS_CLOEXEC	0x01
+
+struct udmabuf_create {
+	uint32_t memfd;
+	uint32_t flags;
+	uint64_t offset;
+	uint64_t size;
+};
+
+struct udmabuf_create_item {
+	uint32_t memfd;
+	uint32_t __pad;
+	uint64_t offset;
+	uint64_t size;
+};
+
+struct udmabuf_create_list {
+	uint32_t flags;
+	uint32_t count;
+	struct udmabuf_create_item list[];
+};
+
+#define UDMABUF_CREATE       _IOW('u', 0x42, struct udmabuf_create)
+#define UDMABUF_CREATE_LIST  _IOW('u', 0x43, struct udmabuf_create_list)
+
+#endif /* _LINUX_UDMABUF_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/vhost_types.h b/subprojects/libvhost-user/standard-headers/linux/vhost_types.h
new file mode 100644
index 0000000..0bd2684
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/vhost_types.h
@@ -0,0 +1,156 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_VHOST_TYPES_H
+#define _LINUX_VHOST_TYPES_H
+/* Userspace interface for in-kernel virtio accelerators. */
+
+/* vhost is used to reduce the number of system calls involved in virtio.
+ *
+ * Existing virtio net code is used in the guest without modification.
+ *
+ * This header includes interface used by userspace hypervisor for
+ * device configuration.
+ */
+
+#include "standard-headers/linux/types.h"
+
+#include "standard-headers/linux/virtio_config.h"
+#include "standard-headers/linux/virtio_ring.h"
+
+struct vhost_vring_state {
+	unsigned int index;
+	unsigned int num;
+};
+
+struct vhost_vring_file {
+	unsigned int index;
+	int fd; /* Pass -1 to unbind from file. */
+
+};
+
+struct vhost_vring_addr {
+	unsigned int index;
+	/* Option flags. */
+	unsigned int flags;
+	/* Flag values: */
+	/* Whether log address is valid. If set enables logging. */
+#define VHOST_VRING_F_LOG 0
+
+	/* Start of array of descriptors (virtually contiguous) */
+	uint64_t desc_user_addr;
+	/* Used structure address. Must be 32 bit aligned */
+	uint64_t used_user_addr;
+	/* Available structure address. Must be 16 bit aligned */
+	uint64_t avail_user_addr;
+	/* Logging support. */
+	/* Log writes to used structure, at offset calculated from specified
+	 * address. Address must be 32 bit aligned. */
+	uint64_t log_guest_addr;
+};
+
+/* no alignment requirement */
+struct vhost_iotlb_msg {
+	uint64_t iova;
+	uint64_t size;
+	uint64_t uaddr;
+#define VHOST_ACCESS_RO      0x1
+#define VHOST_ACCESS_WO      0x2
+#define VHOST_ACCESS_RW      0x3
+	uint8_t perm;
+#define VHOST_IOTLB_MISS           1
+#define VHOST_IOTLB_UPDATE         2
+#define VHOST_IOTLB_INVALIDATE     3
+#define VHOST_IOTLB_ACCESS_FAIL    4
+/*
+ * VHOST_IOTLB_BATCH_BEGIN and VHOST_IOTLB_BATCH_END allow modifying
+ * multiple mappings in one go: beginning with
+ * VHOST_IOTLB_BATCH_BEGIN, followed by any number of
+ * VHOST_IOTLB_UPDATE messages, and ending with VHOST_IOTLB_BATCH_END.
+ * When one of these two values is used as the message type, the rest
+ * of the fields in the message are ignored. There's no guarantee that
+ * these changes take place automatically in the device.
+ */
+#define VHOST_IOTLB_BATCH_BEGIN    5
+#define VHOST_IOTLB_BATCH_END      6
+	uint8_t type;
+};
+
+#define VHOST_IOTLB_MSG 0x1
+#define VHOST_IOTLB_MSG_V2 0x2
+
+struct vhost_msg {
+	int type;
+	union {
+		struct vhost_iotlb_msg iotlb;
+		uint8_t padding[64];
+	};
+};
+
+struct vhost_msg_v2 {
+	uint32_t type;
+	uint32_t reserved;
+	union {
+		struct vhost_iotlb_msg iotlb;
+		uint8_t padding[64];
+	};
+};
+
+struct vhost_memory_region {
+	uint64_t guest_phys_addr;
+	uint64_t memory_size; /* bytes */
+	uint64_t userspace_addr;
+	uint64_t flags_padding; /* No flags are currently specified. */
+};
+
+/* All region addresses and sizes must be 4K aligned. */
+#define VHOST_PAGE_SIZE 0x1000
+
+struct vhost_memory {
+	uint32_t nregions;
+	uint32_t padding;
+	struct vhost_memory_region regions[0];
+};
+
+/* VHOST_SCSI specific definitions */
+
+/*
+ * Used by QEMU userspace to ensure a consistent vhost-scsi ABI.
+ *
+ * ABI Rev 0: July 2012 version starting point for v3.6-rc merge candidate +
+ *            RFC-v2 vhost-scsi userspace.  Add GET_ABI_VERSION ioctl usage
+ * ABI Rev 1: January 2013. Ignore vhost_tpgt field in struct vhost_scsi_target.
+ *            All the targets under vhost_wwpn can be seen and used by guset.
+ */
+
+#define VHOST_SCSI_ABI_VERSION	1
+
+struct vhost_scsi_target {
+	int abi_version;
+	char vhost_wwpn[224]; /* TRANSPORT_IQN_LEN */
+	unsigned short vhost_tpgt;
+	unsigned short reserved;
+};
+
+/* VHOST_VDPA specific definitions */
+
+struct vhost_vdpa_config {
+	uint32_t off;
+	uint32_t len;
+	uint8_t buf[0];
+};
+
+/* vhost vdpa IOVA range
+ * @first: First address that can be mapped by vhost-vDPA
+ * @last: Last address that can be mapped by vhost-vDPA
+ */
+struct vhost_vdpa_iova_range {
+	uint64_t first;
+	uint64_t last;
+};
+
+/* Feature bits */
+/* Log all write descriptors. Can be changed while device is active. */
+#define VHOST_F_LOG_ALL 26
+/* vhost-net should add virtio_net_hdr for RX, and strip for TX packets. */
+#define VHOST_NET_F_VIRTIO_NET_HDR 27
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_9p.h b/subprojects/libvhost-user/standard-headers/linux/virtio_9p.h
new file mode 100644
index 0000000..f5604fc
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_9p.h
@@ -0,0 +1,44 @@
+#ifndef _LINUX_VIRTIO_9P_H
+#define _LINUX_VIRTIO_9P_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+#include "standard-headers/linux/virtio_types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+/* The feature bitmap for virtio 9P */
+
+/* The mount point is specified in a config variable */
+#define VIRTIO_9P_MOUNT_TAG 0
+
+struct virtio_9p_config {
+	/* length of the tag name */
+	__virtio16 tag_len;
+	/* non-NULL terminated tag name */
+	uint8_t tag[0];
+} QEMU_PACKED;
+
+#endif /* _LINUX_VIRTIO_9P_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_balloon.h b/subprojects/libvhost-user/standard-headers/linux/virtio_balloon.h
new file mode 100644
index 0000000..f343bfe
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_balloon.h
@@ -0,0 +1,119 @@
+#ifndef _LINUX_VIRTIO_BALLOON_H
+#define _LINUX_VIRTIO_BALLOON_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+/* The feature bitmap for virtio balloon */
+#define VIRTIO_BALLOON_F_MUST_TELL_HOST	0 /* Tell before reclaiming pages */
+#define VIRTIO_BALLOON_F_STATS_VQ	1 /* Memory Stats virtqueue */
+#define VIRTIO_BALLOON_F_DEFLATE_ON_OOM	2 /* Deflate balloon on OOM */
+#define VIRTIO_BALLOON_F_FREE_PAGE_HINT	3 /* VQ to report free pages */
+#define VIRTIO_BALLOON_F_PAGE_POISON	4 /* Guest is using page poisoning */
+#define VIRTIO_BALLOON_F_REPORTING	5 /* Page reporting virtqueue */
+
+/* Size of a PFN in the balloon interface. */
+#define VIRTIO_BALLOON_PFN_SHIFT 12
+
+#define VIRTIO_BALLOON_CMD_ID_STOP	0
+#define VIRTIO_BALLOON_CMD_ID_DONE	1
+struct virtio_balloon_config {
+	/* Number of pages host wants Guest to give up. */
+	uint32_t num_pages;
+	/* Number of pages we've actually got in balloon. */
+	uint32_t actual;
+	/*
+	 * Free page hint command id, readonly by guest.
+	 * Was previously named free_page_report_cmd_id so we
+	 * need to carry that name for legacy support.
+	 */
+	union {
+		uint32_t free_page_hint_cmd_id;
+		uint32_t free_page_report_cmd_id;	/* deprecated */
+	};
+	/* Stores PAGE_POISON if page poisoning is in use */
+	uint32_t poison_val;
+};
+
+#define VIRTIO_BALLOON_S_SWAP_IN  0   /* Amount of memory swapped in */
+#define VIRTIO_BALLOON_S_SWAP_OUT 1   /* Amount of memory swapped out */
+#define VIRTIO_BALLOON_S_MAJFLT   2   /* Number of major faults */
+#define VIRTIO_BALLOON_S_MINFLT   3   /* Number of minor faults */
+#define VIRTIO_BALLOON_S_MEMFREE  4   /* Total amount of free memory */
+#define VIRTIO_BALLOON_S_MEMTOT   5   /* Total amount of memory */
+#define VIRTIO_BALLOON_S_AVAIL    6   /* Available memory as in /proc */
+#define VIRTIO_BALLOON_S_CACHES   7   /* Disk caches */
+#define VIRTIO_BALLOON_S_HTLB_PGALLOC  8  /* Hugetlb page allocations */
+#define VIRTIO_BALLOON_S_HTLB_PGFAIL   9  /* Hugetlb page allocation failures */
+#define VIRTIO_BALLOON_S_NR       10
+
+#define VIRTIO_BALLOON_S_NAMES_WITH_PREFIX(VIRTIO_BALLOON_S_NAMES_prefix) { \
+	VIRTIO_BALLOON_S_NAMES_prefix "swap-in", \
+	VIRTIO_BALLOON_S_NAMES_prefix "swap-out", \
+	VIRTIO_BALLOON_S_NAMES_prefix "major-faults", \
+	VIRTIO_BALLOON_S_NAMES_prefix "minor-faults", \
+	VIRTIO_BALLOON_S_NAMES_prefix "free-memory", \
+	VIRTIO_BALLOON_S_NAMES_prefix "total-memory", \
+	VIRTIO_BALLOON_S_NAMES_prefix "available-memory", \
+	VIRTIO_BALLOON_S_NAMES_prefix "disk-caches", \
+	VIRTIO_BALLOON_S_NAMES_prefix "hugetlb-allocations", \
+	VIRTIO_BALLOON_S_NAMES_prefix "hugetlb-failures" \
+}
+
+#define VIRTIO_BALLOON_S_NAMES VIRTIO_BALLOON_S_NAMES_WITH_PREFIX("")
+
+/*
+ * Memory statistics structure.
+ * Driver fills an array of these structures and passes to device.
+ *
+ * NOTE: fields are laid out in a way that would make compiler add padding
+ * between and after fields, so we have to use compiler-specific attributes to
+ * pack it, to disable this padding. This also often causes compiler to
+ * generate suboptimal code.
+ *
+ * We maintain this statistics structure format for backwards compatibility,
+ * but don't follow this example.
+ *
+ * If implementing a similar structure, do something like the below instead:
+ *     struct virtio_balloon_stat {
+ *         __virtio16 tag;
+ *         uint8_t reserved[6];
+ *         __virtio64 val;
+ *     };
+ *
+ * In other words, add explicit reserved fields to align field and
+ * structure boundaries at field size, avoiding compiler padding
+ * without the packed attribute.
+ */
+struct virtio_balloon_stat {
+	__virtio16 tag;
+	__virtio64 val;
+} QEMU_PACKED;
+
+#endif /* _LINUX_VIRTIO_BALLOON_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_blk.h b/subprojects/libvhost-user/standard-headers/linux/virtio_blk.h
new file mode 100644
index 0000000..2dcc908
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_blk.h
@@ -0,0 +1,201 @@
+#ifndef _LINUX_VIRTIO_BLK_H
+#define _LINUX_VIRTIO_BLK_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+#include "standard-headers/linux/virtio_types.h"
+
+/* Feature bits */
+#define VIRTIO_BLK_F_SIZE_MAX	1	/* Indicates maximum segment size */
+#define VIRTIO_BLK_F_SEG_MAX	2	/* Indicates maximum # of segments */
+#define VIRTIO_BLK_F_GEOMETRY	4	/* Legacy geometry available  */
+#define VIRTIO_BLK_F_RO		5	/* Disk is read-only */
+#define VIRTIO_BLK_F_BLK_SIZE	6	/* Block size of disk is available*/
+#define VIRTIO_BLK_F_TOPOLOGY	10	/* Topology information is available */
+#define VIRTIO_BLK_F_MQ		12	/* support more than one vq */
+#define VIRTIO_BLK_F_DISCARD	13	/* DISCARD is supported */
+#define VIRTIO_BLK_F_WRITE_ZEROES	14	/* WRITE ZEROES is supported */
+
+/* Legacy feature bits */
+#ifndef VIRTIO_BLK_NO_LEGACY
+#define VIRTIO_BLK_F_BARRIER	0	/* Does host support barriers? */
+#define VIRTIO_BLK_F_SCSI	7	/* Supports scsi command passthru */
+#define VIRTIO_BLK_F_FLUSH	9	/* Flush command supported */
+#define VIRTIO_BLK_F_CONFIG_WCE	11	/* Writeback mode available in config */
+/* Old (deprecated) name for VIRTIO_BLK_F_FLUSH. */
+#define VIRTIO_BLK_F_WCE VIRTIO_BLK_F_FLUSH
+#endif /* !VIRTIO_BLK_NO_LEGACY */
+
+#define VIRTIO_BLK_ID_BYTES	20	/* ID string length */
+
+struct virtio_blk_config {
+	/* The capacity (in 512-byte sectors). */
+	__virtio64 capacity;
+	/* The maximum segment size (if VIRTIO_BLK_F_SIZE_MAX) */
+	__virtio32 size_max;
+	/* The maximum number of segments (if VIRTIO_BLK_F_SEG_MAX) */
+	__virtio32 seg_max;
+	/* geometry of the device (if VIRTIO_BLK_F_GEOMETRY) */
+	struct virtio_blk_geometry {
+		__virtio16 cylinders;
+		uint8_t heads;
+		uint8_t sectors;
+	} geometry;
+
+	/* block size of device (if VIRTIO_BLK_F_BLK_SIZE) */
+	__virtio32 blk_size;
+
+	/* the next 4 entries are guarded by VIRTIO_BLK_F_TOPOLOGY  */
+	/* exponent for physical block per logical block. */
+	uint8_t physical_block_exp;
+	/* alignment offset in logical blocks. */
+	uint8_t alignment_offset;
+	/* minimum I/O size without performance penalty in logical blocks. */
+	__virtio16 min_io_size;
+	/* optimal sustained I/O size in logical blocks. */
+	__virtio32 opt_io_size;
+
+	/* writeback mode (if VIRTIO_BLK_F_CONFIG_WCE) */
+	uint8_t wce;
+	uint8_t unused;
+
+	/* number of vqs, only available when VIRTIO_BLK_F_MQ is set */
+	__virtio16 num_queues;
+
+	/* the next 3 entries are guarded by VIRTIO_BLK_F_DISCARD */
+	/*
+	 * The maximum discard sectors (in 512-byte sectors) for
+	 * one segment.
+	 */
+	__virtio32 max_discard_sectors;
+	/*
+	 * The maximum number of discard segments in a
+	 * discard command.
+	 */
+	__virtio32 max_discard_seg;
+	/* Discard commands must be aligned to this number of sectors. */
+	__virtio32 discard_sector_alignment;
+
+	/* the next 3 entries are guarded by VIRTIO_BLK_F_WRITE_ZEROES */
+	/*
+	 * The maximum number of write zeroes sectors (in 512-byte sectors) in
+	 * one segment.
+	 */
+	__virtio32 max_write_zeroes_sectors;
+	/*
+	 * The maximum number of segments in a write zeroes
+	 * command.
+	 */
+	__virtio32 max_write_zeroes_seg;
+	/*
+	 * Set if a VIRTIO_BLK_T_WRITE_ZEROES request may result in the
+	 * deallocation of one or more of the sectors.
+	 */
+	uint8_t write_zeroes_may_unmap;
+
+	uint8_t unused1[3];
+} QEMU_PACKED;
+
+/*
+ * Command types
+ *
+ * Usage is a bit tricky as some bits are used as flags and some are not.
+ *
+ * Rules:
+ *   VIRTIO_BLK_T_OUT may be combined with VIRTIO_BLK_T_SCSI_CMD or
+ *   VIRTIO_BLK_T_BARRIER.  VIRTIO_BLK_T_FLUSH is a command of its own
+ *   and may not be combined with any of the other flags.
+ */
+
+/* These two define direction. */
+#define VIRTIO_BLK_T_IN		0
+#define VIRTIO_BLK_T_OUT	1
+
+#ifndef VIRTIO_BLK_NO_LEGACY
+/* This bit says it's a scsi command, not an actual read or write. */
+#define VIRTIO_BLK_T_SCSI_CMD	2
+#endif /* VIRTIO_BLK_NO_LEGACY */
+
+/* Cache flush command */
+#define VIRTIO_BLK_T_FLUSH	4
+
+/* Get device ID command */
+#define VIRTIO_BLK_T_GET_ID    8
+
+/* Discard command */
+#define VIRTIO_BLK_T_DISCARD	11
+
+/* Write zeroes command */
+#define VIRTIO_BLK_T_WRITE_ZEROES	13
+
+#ifndef VIRTIO_BLK_NO_LEGACY
+/* Barrier before this op. */
+#define VIRTIO_BLK_T_BARRIER	0x80000000
+#endif /* !VIRTIO_BLK_NO_LEGACY */
+
+/*
+ * This comes first in the read scatter-gather list.
+ * For legacy virtio, if VIRTIO_F_ANY_LAYOUT is not negotiated,
+ * this is the first element of the read scatter-gather list.
+ */
+struct virtio_blk_outhdr {
+	/* VIRTIO_BLK_T* */
+	__virtio32 type;
+	/* io priority. */
+	__virtio32 ioprio;
+	/* Sector (ie. 512 byte offset) */
+	__virtio64 sector;
+};
+
+/* Unmap this range (only valid for write zeroes command) */
+#define VIRTIO_BLK_WRITE_ZEROES_FLAG_UNMAP	0x00000001
+
+/* Discard/write zeroes range for each request. */
+struct virtio_blk_discard_write_zeroes {
+	/* discard/write zeroes start sector */
+	uint64_t sector;
+	/* number of discard/write zeroes sectors */
+	uint32_t num_sectors;
+	/* flags for this range */
+	uint32_t flags;
+};
+
+#ifndef VIRTIO_BLK_NO_LEGACY
+struct virtio_scsi_inhdr {
+	__virtio32 errors;
+	__virtio32 data_len;
+	__virtio32 sense_len;
+	__virtio32 residual;
+};
+#endif /* !VIRTIO_BLK_NO_LEGACY */
+
+/* And this is the final byte of the write scatter-gather list. */
+#define VIRTIO_BLK_S_OK		0
+#define VIRTIO_BLK_S_IOERR	1
+#define VIRTIO_BLK_S_UNSUPP	2
+#endif /* _LINUX_VIRTIO_BLK_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_bt.h b/subprojects/libvhost-user/standard-headers/linux/virtio_bt.h
new file mode 100644
index 0000000..245e1ef
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_bt.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+
+#ifndef _LINUX_VIRTIO_BT_H
+#define _LINUX_VIRTIO_BT_H
+
+#include "standard-headers/linux/virtio_types.h"
+
+/* Feature bits */
+#define VIRTIO_BT_F_VND_HCI	0	/* Indicates vendor command support */
+#define VIRTIO_BT_F_MSFT_EXT	1	/* Indicates MSFT vendor support */
+#define VIRTIO_BT_F_AOSP_EXT	2	/* Indicates AOSP vendor support */
+
+enum virtio_bt_config_type {
+	VIRTIO_BT_CONFIG_TYPE_PRIMARY	= 0,
+	VIRTIO_BT_CONFIG_TYPE_AMP	= 1,
+};
+
+enum virtio_bt_config_vendor {
+	VIRTIO_BT_CONFIG_VENDOR_NONE	= 0,
+	VIRTIO_BT_CONFIG_VENDOR_ZEPHYR	= 1,
+	VIRTIO_BT_CONFIG_VENDOR_INTEL	= 2,
+	VIRTIO_BT_CONFIG_VENDOR_REALTEK	= 3,
+};
+
+struct virtio_bt_config {
+	uint8_t  type;
+	uint16_t vendor;
+	uint16_t msft_opcode;
+} QEMU_PACKED;
+
+#endif /* _LINUX_VIRTIO_BT_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_config.h b/subprojects/libvhost-user/standard-headers/linux/virtio_config.h
new file mode 100644
index 0000000..22e3a85
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_config.h
@@ -0,0 +1,93 @@
+#ifndef _LINUX_VIRTIO_CONFIG_H
+#define _LINUX_VIRTIO_CONFIG_H
+/* This header, excluding the #ifdef __KERNEL__ part, is BSD licensed so
+ * anyone can use the definitions to implement compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+
+/* Virtio devices use a standardized configuration space to define their
+ * features and pass configuration information, but each implementation can
+ * store and access that space differently. */
+#include "standard-headers/linux/types.h"
+
+/* Status byte for guest to report progress, and synchronize features. */
+/* We have seen device and processed generic fields (VIRTIO_CONFIG_F_VIRTIO) */
+#define VIRTIO_CONFIG_S_ACKNOWLEDGE	1
+/* We have found a driver for the device. */
+#define VIRTIO_CONFIG_S_DRIVER		2
+/* Driver has used its parts of the config, and is happy */
+#define VIRTIO_CONFIG_S_DRIVER_OK	4
+/* Driver has finished configuring features */
+#define VIRTIO_CONFIG_S_FEATURES_OK	8
+/* Device entered invalid state, driver must reset it */
+#define VIRTIO_CONFIG_S_NEEDS_RESET	0x40
+/* We've given up on this device. */
+#define VIRTIO_CONFIG_S_FAILED		0x80
+
+/*
+ * Virtio feature bits VIRTIO_TRANSPORT_F_START through
+ * VIRTIO_TRANSPORT_F_END are reserved for the transport
+ * being used (e.g. virtio_ring, virtio_pci etc.), the
+ * rest are per-device feature bits.
+ */
+#define VIRTIO_TRANSPORT_F_START	28
+#define VIRTIO_TRANSPORT_F_END		38
+
+#ifndef VIRTIO_CONFIG_NO_LEGACY
+/* Do we get callbacks when the ring is completely used, even if we've
+ * suppressed them? */
+#define VIRTIO_F_NOTIFY_ON_EMPTY	24
+
+/* Can the device handle any descriptor layout? */
+#define VIRTIO_F_ANY_LAYOUT		27
+#endif /* VIRTIO_CONFIG_NO_LEGACY */
+
+/* v1.0 compliant. */
+#define VIRTIO_F_VERSION_1		32
+
+/*
+ * If clear - device has the platform DMA (e.g. IOMMU) bypass quirk feature.
+ * If set - use platform DMA tools to access the memory.
+ *
+ * Note the reverse polarity (compared to most other features),
+ * this is for compatibility with legacy systems.
+ */
+#define VIRTIO_F_ACCESS_PLATFORM	33
+/* Legacy name for VIRTIO_F_ACCESS_PLATFORM (for compatibility with old userspace) */
+#define VIRTIO_F_IOMMU_PLATFORM		VIRTIO_F_ACCESS_PLATFORM
+
+/* This feature indicates support for the packed virtqueue layout. */
+#define VIRTIO_F_RING_PACKED		34
+
+/*
+ * This feature indicates that memory accesses by the driver and the
+ * device are ordered in a way described by the platform.
+ */
+#define VIRTIO_F_ORDER_PLATFORM		36
+
+/*
+ * Does the device support Single Root I/O Virtualization?
+ */
+#define VIRTIO_F_SR_IOV			37
+#endif /* _LINUX_VIRTIO_CONFIG_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_console.h b/subprojects/libvhost-user/standard-headers/linux/virtio_console.h
new file mode 100644
index 0000000..71f5f64
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_console.h
@@ -0,0 +1,78 @@
+/*
+ * This header, excluding the #ifdef __KERNEL__ part, is BSD licensed so
+ * anyone can use the definitions to implement compatible drivers/servers:
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Copyright (C) Red Hat, Inc., 2009, 2010, 2011
+ * Copyright (C) Amit Shah <amit.shah@redhat.com>, 2009, 2010, 2011
+ */
+#ifndef _LINUX_VIRTIO_CONSOLE_H
+#define _LINUX_VIRTIO_CONSOLE_H
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+/* Feature bits */
+#define VIRTIO_CONSOLE_F_SIZE	0	/* Does host provide console size? */
+#define VIRTIO_CONSOLE_F_MULTIPORT 1	/* Does host provide multiple ports? */
+#define VIRTIO_CONSOLE_F_EMERG_WRITE 2 /* Does host support emergency write? */
+
+#define VIRTIO_CONSOLE_BAD_ID		(~(uint32_t)0)
+
+struct virtio_console_config {
+	/* colums of the screens */
+	__virtio16 cols;
+	/* rows of the screens */
+	__virtio16 rows;
+	/* max. number of ports this device can hold */
+	__virtio32 max_nr_ports;
+	/* emergency write register */
+	__virtio32 emerg_wr;
+} QEMU_PACKED;
+
+/*
+ * A message that's passed between the Host and the Guest for a
+ * particular port.
+ */
+struct virtio_console_control {
+	__virtio32 id;		/* Port number */
+	__virtio16 event;	/* The kind of control event (see below) */
+	__virtio16 value;	/* Extra information for the key */
+};
+
+/* Some events for control messages */
+#define VIRTIO_CONSOLE_DEVICE_READY	0
+#define VIRTIO_CONSOLE_PORT_ADD		1
+#define VIRTIO_CONSOLE_PORT_REMOVE	2
+#define VIRTIO_CONSOLE_PORT_READY	3
+#define VIRTIO_CONSOLE_CONSOLE_PORT	4
+#define VIRTIO_CONSOLE_RESIZE		5
+#define VIRTIO_CONSOLE_PORT_OPEN	6
+#define VIRTIO_CONSOLE_PORT_NAME	7
+
+
+#endif /* _LINUX_VIRTIO_CONSOLE_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_crypto.h b/subprojects/libvhost-user/standard-headers/linux/virtio_crypto.h
new file mode 100644
index 0000000..5ff0b4e
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_crypto.h
@@ -0,0 +1,450 @@
+#ifndef _VIRTIO_CRYPTO_H
+#define _VIRTIO_CRYPTO_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+
+#define VIRTIO_CRYPTO_SERVICE_CIPHER 0
+#define VIRTIO_CRYPTO_SERVICE_HASH   1
+#define VIRTIO_CRYPTO_SERVICE_MAC    2
+#define VIRTIO_CRYPTO_SERVICE_AEAD   3
+
+#define VIRTIO_CRYPTO_OPCODE(service, op)   (((service) << 8) | (op))
+
+struct virtio_crypto_ctrl_header {
+#define VIRTIO_CRYPTO_CIPHER_CREATE_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_CIPHER, 0x02)
+#define VIRTIO_CRYPTO_CIPHER_DESTROY_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_CIPHER, 0x03)
+#define VIRTIO_CRYPTO_HASH_CREATE_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_HASH, 0x02)
+#define VIRTIO_CRYPTO_HASH_DESTROY_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_HASH, 0x03)
+#define VIRTIO_CRYPTO_MAC_CREATE_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_MAC, 0x02)
+#define VIRTIO_CRYPTO_MAC_DESTROY_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_MAC, 0x03)
+#define VIRTIO_CRYPTO_AEAD_CREATE_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_AEAD, 0x02)
+#define VIRTIO_CRYPTO_AEAD_DESTROY_SESSION \
+	   VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_AEAD, 0x03)
+	uint32_t opcode;
+	uint32_t algo;
+	uint32_t flag;
+	/* data virtqueue id */
+	uint32_t queue_id;
+};
+
+struct virtio_crypto_cipher_session_para {
+#define VIRTIO_CRYPTO_NO_CIPHER                 0
+#define VIRTIO_CRYPTO_CIPHER_ARC4               1
+#define VIRTIO_CRYPTO_CIPHER_AES_ECB            2
+#define VIRTIO_CRYPTO_CIPHER_AES_CBC            3
+#define VIRTIO_CRYPTO_CIPHER_AES_CTR            4
+#define VIRTIO_CRYPTO_CIPHER_DES_ECB            5
+#define VIRTIO_CRYPTO_CIPHER_DES_CBC            6
+#define VIRTIO_CRYPTO_CIPHER_3DES_ECB           7
+#define VIRTIO_CRYPTO_CIPHER_3DES_CBC           8
+#define VIRTIO_CRYPTO_CIPHER_3DES_CTR           9
+#define VIRTIO_CRYPTO_CIPHER_KASUMI_F8          10
+#define VIRTIO_CRYPTO_CIPHER_SNOW3G_UEA2        11
+#define VIRTIO_CRYPTO_CIPHER_AES_F8             12
+#define VIRTIO_CRYPTO_CIPHER_AES_XTS            13
+#define VIRTIO_CRYPTO_CIPHER_ZUC_EEA3           14
+	uint32_t algo;
+	/* length of key */
+	uint32_t keylen;
+
+#define VIRTIO_CRYPTO_OP_ENCRYPT  1
+#define VIRTIO_CRYPTO_OP_DECRYPT  2
+	/* encrypt or decrypt */
+	uint32_t op;
+	uint32_t padding;
+};
+
+struct virtio_crypto_session_input {
+	/* Device-writable part */
+	uint64_t session_id;
+	uint32_t status;
+	uint32_t padding;
+};
+
+struct virtio_crypto_cipher_session_req {
+	struct virtio_crypto_cipher_session_para para;
+	uint8_t padding[32];
+};
+
+struct virtio_crypto_hash_session_para {
+#define VIRTIO_CRYPTO_NO_HASH            0
+#define VIRTIO_CRYPTO_HASH_MD5           1
+#define VIRTIO_CRYPTO_HASH_SHA1          2
+#define VIRTIO_CRYPTO_HASH_SHA_224       3
+#define VIRTIO_CRYPTO_HASH_SHA_256       4
+#define VIRTIO_CRYPTO_HASH_SHA_384       5
+#define VIRTIO_CRYPTO_HASH_SHA_512       6
+#define VIRTIO_CRYPTO_HASH_SHA3_224      7
+#define VIRTIO_CRYPTO_HASH_SHA3_256      8
+#define VIRTIO_CRYPTO_HASH_SHA3_384      9
+#define VIRTIO_CRYPTO_HASH_SHA3_512      10
+#define VIRTIO_CRYPTO_HASH_SHA3_SHAKE128      11
+#define VIRTIO_CRYPTO_HASH_SHA3_SHAKE256      12
+	uint32_t algo;
+	/* hash result length */
+	uint32_t hash_result_len;
+	uint8_t padding[8];
+};
+
+struct virtio_crypto_hash_create_session_req {
+	struct virtio_crypto_hash_session_para para;
+	uint8_t padding[40];
+};
+
+struct virtio_crypto_mac_session_para {
+#define VIRTIO_CRYPTO_NO_MAC                       0
+#define VIRTIO_CRYPTO_MAC_HMAC_MD5                 1
+#define VIRTIO_CRYPTO_MAC_HMAC_SHA1                2
+#define VIRTIO_CRYPTO_MAC_HMAC_SHA_224             3
+#define VIRTIO_CRYPTO_MAC_HMAC_SHA_256             4
+#define VIRTIO_CRYPTO_MAC_HMAC_SHA_384             5
+#define VIRTIO_CRYPTO_MAC_HMAC_SHA_512             6
+#define VIRTIO_CRYPTO_MAC_CMAC_3DES                25
+#define VIRTIO_CRYPTO_MAC_CMAC_AES                 26
+#define VIRTIO_CRYPTO_MAC_KASUMI_F9                27
+#define VIRTIO_CRYPTO_MAC_SNOW3G_UIA2              28
+#define VIRTIO_CRYPTO_MAC_GMAC_AES                 41
+#define VIRTIO_CRYPTO_MAC_GMAC_TWOFISH             42
+#define VIRTIO_CRYPTO_MAC_CBCMAC_AES               49
+#define VIRTIO_CRYPTO_MAC_CBCMAC_KASUMI_F9         50
+#define VIRTIO_CRYPTO_MAC_XCBC_AES                 53
+	uint32_t algo;
+	/* hash result length */
+	uint32_t hash_result_len;
+	/* length of authenticated key */
+	uint32_t auth_key_len;
+	uint32_t padding;
+};
+
+struct virtio_crypto_mac_create_session_req {
+	struct virtio_crypto_mac_session_para para;
+	uint8_t padding[40];
+};
+
+struct virtio_crypto_aead_session_para {
+#define VIRTIO_CRYPTO_NO_AEAD     0
+#define VIRTIO_CRYPTO_AEAD_GCM    1
+#define VIRTIO_CRYPTO_AEAD_CCM    2
+#define VIRTIO_CRYPTO_AEAD_CHACHA20_POLY1305  3
+	uint32_t algo;
+	/* length of key */
+	uint32_t key_len;
+	/* hash result length */
+	uint32_t hash_result_len;
+	/* length of the additional authenticated data (AAD) in bytes */
+	uint32_t aad_len;
+	/* encrypt or decrypt, See above VIRTIO_CRYPTO_OP_* */
+	uint32_t op;
+	uint32_t padding;
+};
+
+struct virtio_crypto_aead_create_session_req {
+	struct virtio_crypto_aead_session_para para;
+	uint8_t padding[32];
+};
+
+struct virtio_crypto_alg_chain_session_para {
+#define VIRTIO_CRYPTO_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER  1
+#define VIRTIO_CRYPTO_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH  2
+	uint32_t alg_chain_order;
+/* Plain hash */
+#define VIRTIO_CRYPTO_SYM_HASH_MODE_PLAIN    1
+/* Authenticated hash (mac) */
+#define VIRTIO_CRYPTO_SYM_HASH_MODE_AUTH     2
+/* Nested hash */
+#define VIRTIO_CRYPTO_SYM_HASH_MODE_NESTED   3
+	uint32_t hash_mode;
+	struct virtio_crypto_cipher_session_para cipher_param;
+	union {
+		struct virtio_crypto_hash_session_para hash_param;
+		struct virtio_crypto_mac_session_para mac_param;
+		uint8_t padding[16];
+	} u;
+	/* length of the additional authenticated data (AAD) in bytes */
+	uint32_t aad_len;
+	uint32_t padding;
+};
+
+struct virtio_crypto_alg_chain_session_req {
+	struct virtio_crypto_alg_chain_session_para para;
+};
+
+struct virtio_crypto_sym_create_session_req {
+	union {
+		struct virtio_crypto_cipher_session_req cipher;
+		struct virtio_crypto_alg_chain_session_req chain;
+		uint8_t padding[48];
+	} u;
+
+	/* Device-readable part */
+
+/* No operation */
+#define VIRTIO_CRYPTO_SYM_OP_NONE  0
+/* Cipher only operation on the data */
+#define VIRTIO_CRYPTO_SYM_OP_CIPHER  1
+/*
+ * Chain any cipher with any hash or mac operation. The order
+ * depends on the value of alg_chain_order param
+ */
+#define VIRTIO_CRYPTO_SYM_OP_ALGORITHM_CHAINING  2
+	uint32_t op_type;
+	uint32_t padding;
+};
+
+struct virtio_crypto_destroy_session_req {
+	/* Device-readable part */
+	uint64_t  session_id;
+	uint8_t padding[48];
+};
+
+/* The request of the control virtqueue's packet */
+struct virtio_crypto_op_ctrl_req {
+	struct virtio_crypto_ctrl_header header;
+
+	union {
+		struct virtio_crypto_sym_create_session_req
+			sym_create_session;
+		struct virtio_crypto_hash_create_session_req
+			hash_create_session;
+		struct virtio_crypto_mac_create_session_req
+			mac_create_session;
+		struct virtio_crypto_aead_create_session_req
+			aead_create_session;
+		struct virtio_crypto_destroy_session_req
+			destroy_session;
+		uint8_t padding[56];
+	} u;
+};
+
+struct virtio_crypto_op_header {
+#define VIRTIO_CRYPTO_CIPHER_ENCRYPT \
+	VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_CIPHER, 0x00)
+#define VIRTIO_CRYPTO_CIPHER_DECRYPT \
+	VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_CIPHER, 0x01)
+#define VIRTIO_CRYPTO_HASH \
+	VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_HASH, 0x00)
+#define VIRTIO_CRYPTO_MAC \
+	VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_MAC, 0x00)
+#define VIRTIO_CRYPTO_AEAD_ENCRYPT \
+	VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_AEAD, 0x00)
+#define VIRTIO_CRYPTO_AEAD_DECRYPT \
+	VIRTIO_CRYPTO_OPCODE(VIRTIO_CRYPTO_SERVICE_AEAD, 0x01)
+	uint32_t opcode;
+	/* algo should be service-specific algorithms */
+	uint32_t algo;
+	/* session_id should be service-specific algorithms */
+	uint64_t session_id;
+	/* control flag to control the request */
+	uint32_t flag;
+	uint32_t padding;
+};
+
+struct virtio_crypto_cipher_para {
+	/*
+	 * Byte Length of valid IV/Counter
+	 *
+	 * For block ciphers in CBC or F8 mode, or for Kasumi in F8 mode, or for
+	 *   SNOW3G in UEA2 mode, this is the length of the IV (which
+	 *   must be the same as the block length of the cipher).
+	 * For block ciphers in CTR mode, this is the length of the counter
+	 *   (which must be the same as the block length of the cipher).
+	 * For AES-XTS, this is the 128bit tweak, i, from IEEE Std 1619-2007.
+	 *
+	 * The IV/Counter will be updated after every partial cryptographic
+	 * operation.
+	 */
+	uint32_t iv_len;
+	/* length of source data */
+	uint32_t src_data_len;
+	/* length of dst data */
+	uint32_t dst_data_len;
+	uint32_t padding;
+};
+
+struct virtio_crypto_hash_para {
+	/* length of source data */
+	uint32_t src_data_len;
+	/* hash result length */
+	uint32_t hash_result_len;
+};
+
+struct virtio_crypto_mac_para {
+	struct virtio_crypto_hash_para hash;
+};
+
+struct virtio_crypto_aead_para {
+	/*
+	 * Byte Length of valid IV data pointed to by the below iv_addr
+	 * parameter.
+	 *
+	 * For GCM mode, this is either 12 (for 96-bit IVs) or 16, in which
+	 *   case iv_addr points to J0.
+	 * For CCM mode, this is the length of the nonce, which can be in the
+	 *   range 7 to 13 inclusive.
+	 */
+	uint32_t iv_len;
+	/* length of additional auth data */
+	uint32_t aad_len;
+	/* length of source data */
+	uint32_t src_data_len;
+	/* length of dst data */
+	uint32_t dst_data_len;
+};
+
+struct virtio_crypto_cipher_data_req {
+	/* Device-readable part */
+	struct virtio_crypto_cipher_para para;
+	uint8_t padding[24];
+};
+
+struct virtio_crypto_hash_data_req {
+	/* Device-readable part */
+	struct virtio_crypto_hash_para para;
+	uint8_t padding[40];
+};
+
+struct virtio_crypto_mac_data_req {
+	/* Device-readable part */
+	struct virtio_crypto_mac_para para;
+	uint8_t padding[40];
+};
+
+struct virtio_crypto_alg_chain_data_para {
+	uint32_t iv_len;
+	/* Length of source data */
+	uint32_t src_data_len;
+	/* Length of destination data */
+	uint32_t dst_data_len;
+	/* Starting point for cipher processing in source data */
+	uint32_t cipher_start_src_offset;
+	/* Length of the source data that the cipher will be computed on */
+	uint32_t len_to_cipher;
+	/* Starting point for hash processing in source data */
+	uint32_t hash_start_src_offset;
+	/* Length of the source data that the hash will be computed on */
+	uint32_t len_to_hash;
+	/* Length of the additional auth data */
+	uint32_t aad_len;
+	/* Length of the hash result */
+	uint32_t hash_result_len;
+	uint32_t reserved;
+};
+
+struct virtio_crypto_alg_chain_data_req {
+	/* Device-readable part */
+	struct virtio_crypto_alg_chain_data_para para;
+};
+
+struct virtio_crypto_sym_data_req {
+	union {
+		struct virtio_crypto_cipher_data_req cipher;
+		struct virtio_crypto_alg_chain_data_req chain;
+		uint8_t padding[40];
+	} u;
+
+	/* See above VIRTIO_CRYPTO_SYM_OP_* */
+	uint32_t op_type;
+	uint32_t padding;
+};
+
+struct virtio_crypto_aead_data_req {
+	/* Device-readable part */
+	struct virtio_crypto_aead_para para;
+	uint8_t padding[32];
+};
+
+/* The request of the data virtqueue's packet */
+struct virtio_crypto_op_data_req {
+	struct virtio_crypto_op_header header;
+
+	union {
+		struct virtio_crypto_sym_data_req  sym_req;
+		struct virtio_crypto_hash_data_req hash_req;
+		struct virtio_crypto_mac_data_req mac_req;
+		struct virtio_crypto_aead_data_req aead_req;
+		uint8_t padding[48];
+	} u;
+};
+
+#define VIRTIO_CRYPTO_OK        0
+#define VIRTIO_CRYPTO_ERR       1
+#define VIRTIO_CRYPTO_BADMSG    2
+#define VIRTIO_CRYPTO_NOTSUPP   3
+#define VIRTIO_CRYPTO_INVSESS   4 /* Invalid session id */
+
+/* The accelerator hardware is ready */
+#define VIRTIO_CRYPTO_S_HW_READY  (1 << 0)
+
+struct virtio_crypto_config {
+	/* See VIRTIO_CRYPTO_OP_* above */
+	uint32_t  status;
+
+	/*
+	 * Maximum number of data queue
+	 */
+	uint32_t  max_dataqueues;
+
+	/*
+	 * Specifies the services mask which the device support,
+	 * see VIRTIO_CRYPTO_SERVICE_* above
+	 */
+	uint32_t crypto_services;
+
+	/* Detailed algorithms mask */
+	uint32_t cipher_algo_l;
+	uint32_t cipher_algo_h;
+	uint32_t hash_algo;
+	uint32_t mac_algo_l;
+	uint32_t mac_algo_h;
+	uint32_t aead_algo;
+	/* Maximum length of cipher key */
+	uint32_t max_cipher_key_len;
+	/* Maximum length of authenticated key */
+	uint32_t max_auth_key_len;
+	uint32_t reserve;
+	/* Maximum size of each crypto request's content */
+	uint64_t max_size;
+};
+
+struct virtio_crypto_inhdr {
+	/* See VIRTIO_CRYPTO_* above */
+	uint8_t status;
+};
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_fs.h b/subprojects/libvhost-user/standard-headers/linux/virtio_fs.h
new file mode 100644
index 0000000..a32fe8a
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_fs.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause) */
+
+#ifndef _LINUX_VIRTIO_FS_H
+#define _LINUX_VIRTIO_FS_H
+
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+#include "standard-headers/linux/virtio_types.h"
+
+struct virtio_fs_config {
+	/* Filesystem name (UTF-8, not NUL-terminated, padded with NULs) */
+	uint8_t tag[36];
+
+	/* Number of request queues */
+	uint32_t num_request_queues;
+} QEMU_PACKED;
+
+/* For the id field in virtio_pci_shm_cap */
+#define VIRTIO_FS_SHMCAP_ID_CACHE 0
+
+#endif /* _LINUX_VIRTIO_FS_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_gpu.h b/subprojects/libvhost-user/standard-headers/linux/virtio_gpu.h
new file mode 100644
index 0000000..1357e47
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_gpu.h
@@ -0,0 +1,444 @@
+/*
+ * Virtio GPU Device
+ *
+ * Copyright Red Hat, Inc. 2013-2014
+ *
+ * Authors:
+ *     Dave Airlie <airlied@redhat.com>
+ *     Gerd Hoffmann <kraxel@redhat.com>
+ *
+ * This header is BSD licensed so anyone can use the definitions
+ * to implement compatible drivers/servers:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef VIRTIO_GPU_HW_H
+#define VIRTIO_GPU_HW_H
+
+#include "standard-headers/linux/types.h"
+
+/*
+ * VIRTIO_GPU_CMD_CTX_*
+ * VIRTIO_GPU_CMD_*_3D
+ */
+#define VIRTIO_GPU_F_VIRGL               0
+
+/*
+ * VIRTIO_GPU_CMD_GET_EDID
+ */
+#define VIRTIO_GPU_F_EDID                1
+/*
+ * VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID
+ */
+#define VIRTIO_GPU_F_RESOURCE_UUID       2
+
+/*
+ * VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB
+ */
+#define VIRTIO_GPU_F_RESOURCE_BLOB       3
+
+enum virtio_gpu_ctrl_type {
+	VIRTIO_GPU_UNDEFINED = 0,
+
+	/* 2d commands */
+	VIRTIO_GPU_CMD_GET_DISPLAY_INFO = 0x0100,
+	VIRTIO_GPU_CMD_RESOURCE_CREATE_2D,
+	VIRTIO_GPU_CMD_RESOURCE_UNREF,
+	VIRTIO_GPU_CMD_SET_SCANOUT,
+	VIRTIO_GPU_CMD_RESOURCE_FLUSH,
+	VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D,
+	VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING,
+	VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING,
+	VIRTIO_GPU_CMD_GET_CAPSET_INFO,
+	VIRTIO_GPU_CMD_GET_CAPSET,
+	VIRTIO_GPU_CMD_GET_EDID,
+	VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID,
+	VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB,
+	VIRTIO_GPU_CMD_SET_SCANOUT_BLOB,
+
+	/* 3d commands */
+	VIRTIO_GPU_CMD_CTX_CREATE = 0x0200,
+	VIRTIO_GPU_CMD_CTX_DESTROY,
+	VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE,
+	VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE,
+	VIRTIO_GPU_CMD_RESOURCE_CREATE_3D,
+	VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D,
+	VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D,
+	VIRTIO_GPU_CMD_SUBMIT_3D,
+	VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB,
+	VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB,
+
+	/* cursor commands */
+	VIRTIO_GPU_CMD_UPDATE_CURSOR = 0x0300,
+	VIRTIO_GPU_CMD_MOVE_CURSOR,
+
+	/* success responses */
+	VIRTIO_GPU_RESP_OK_NODATA = 0x1100,
+	VIRTIO_GPU_RESP_OK_DISPLAY_INFO,
+	VIRTIO_GPU_RESP_OK_CAPSET_INFO,
+	VIRTIO_GPU_RESP_OK_CAPSET,
+	VIRTIO_GPU_RESP_OK_EDID,
+	VIRTIO_GPU_RESP_OK_RESOURCE_UUID,
+	VIRTIO_GPU_RESP_OK_MAP_INFO,
+
+	/* error responses */
+	VIRTIO_GPU_RESP_ERR_UNSPEC = 0x1200,
+	VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY,
+	VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID,
+	VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID,
+	VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID,
+	VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER,
+};
+
+enum virtio_gpu_shm_id {
+	VIRTIO_GPU_SHM_ID_UNDEFINED = 0,
+	/*
+	 * VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB
+	 * VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB
+	 */
+	VIRTIO_GPU_SHM_ID_HOST_VISIBLE = 1
+};
+
+#define VIRTIO_GPU_FLAG_FENCE (1 << 0)
+
+struct virtio_gpu_ctrl_hdr {
+	uint32_t type;
+	uint32_t flags;
+	uint64_t fence_id;
+	uint32_t ctx_id;
+	uint32_t padding;
+};
+
+/* data passed in the cursor vq */
+
+struct virtio_gpu_cursor_pos {
+	uint32_t scanout_id;
+	uint32_t x;
+	uint32_t y;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_UPDATE_CURSOR, VIRTIO_GPU_CMD_MOVE_CURSOR */
+struct virtio_gpu_update_cursor {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_cursor_pos pos;  /* update & move */
+	uint32_t resource_id;           /* update only */
+	uint32_t hot_x;                 /* update only */
+	uint32_t hot_y;                 /* update only */
+	uint32_t padding;
+};
+
+/* data passed in the control vq, 2d related */
+
+struct virtio_gpu_rect {
+	uint32_t x;
+	uint32_t y;
+	uint32_t width;
+	uint32_t height;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_UNREF */
+struct virtio_gpu_resource_unref {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_CREATE_2D: create a 2d resource with a format */
+struct virtio_gpu_resource_create_2d {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t format;
+	uint32_t width;
+	uint32_t height;
+};
+
+/* VIRTIO_GPU_CMD_SET_SCANOUT */
+struct virtio_gpu_set_scanout {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_rect r;
+	uint32_t scanout_id;
+	uint32_t resource_id;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_FLUSH */
+struct virtio_gpu_resource_flush {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_rect r;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D: simple transfer to_host */
+struct virtio_gpu_transfer_to_host_2d {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_rect r;
+	uint64_t offset;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+struct virtio_gpu_mem_entry {
+	uint64_t addr;
+	uint32_t length;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING */
+struct virtio_gpu_resource_attach_backing {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t nr_entries;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING */
+struct virtio_gpu_resource_detach_backing {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_RESP_OK_DISPLAY_INFO */
+#define VIRTIO_GPU_MAX_SCANOUTS 16
+struct virtio_gpu_resp_display_info {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_display_one {
+		struct virtio_gpu_rect r;
+		uint32_t enabled;
+		uint32_t flags;
+	} pmodes[VIRTIO_GPU_MAX_SCANOUTS];
+};
+
+/* data passed in the control vq, 3d related */
+
+struct virtio_gpu_box {
+	uint32_t x, y, z;
+	uint32_t w, h, d;
+};
+
+/* VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D, VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D */
+struct virtio_gpu_transfer_host_3d {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_box box;
+	uint64_t offset;
+	uint32_t resource_id;
+	uint32_t level;
+	uint32_t stride;
+	uint32_t layer_stride;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_CREATE_3D */
+#define VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP (1 << 0)
+struct virtio_gpu_resource_create_3d {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t target;
+	uint32_t format;
+	uint32_t bind;
+	uint32_t width;
+	uint32_t height;
+	uint32_t depth;
+	uint32_t array_size;
+	uint32_t last_level;
+	uint32_t nr_samples;
+	uint32_t flags;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_CTX_CREATE */
+struct virtio_gpu_ctx_create {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t nlen;
+	uint32_t padding;
+	char debug_name[64];
+};
+
+/* VIRTIO_GPU_CMD_CTX_DESTROY */
+struct virtio_gpu_ctx_destroy {
+	struct virtio_gpu_ctrl_hdr hdr;
+};
+
+/* VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE, VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE */
+struct virtio_gpu_ctx_resource {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_SUBMIT_3D */
+struct virtio_gpu_cmd_submit {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t size;
+	uint32_t padding;
+};
+
+#define VIRTIO_GPU_CAPSET_VIRGL 1
+#define VIRTIO_GPU_CAPSET_VIRGL2 2
+
+/* VIRTIO_GPU_CMD_GET_CAPSET_INFO */
+struct virtio_gpu_get_capset_info {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t capset_index;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_RESP_OK_CAPSET_INFO */
+struct virtio_gpu_resp_capset_info {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t capset_id;
+	uint32_t capset_max_version;
+	uint32_t capset_max_size;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_GET_CAPSET */
+struct virtio_gpu_get_capset {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t capset_id;
+	uint32_t capset_version;
+};
+
+/* VIRTIO_GPU_RESP_OK_CAPSET */
+struct virtio_gpu_resp_capset {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint8_t capset_data[];
+};
+
+/* VIRTIO_GPU_CMD_GET_EDID */
+struct virtio_gpu_cmd_get_edid {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t scanout;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_RESP_OK_EDID */
+struct virtio_gpu_resp_edid {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t size;
+	uint32_t padding;
+	uint8_t edid[1024];
+};
+
+#define VIRTIO_GPU_EVENT_DISPLAY (1 << 0)
+
+struct virtio_gpu_config {
+	uint32_t events_read;
+	uint32_t events_clear;
+	uint32_t num_scanouts;
+	uint32_t num_capsets;
+};
+
+/* simple formats for fbcon/X use */
+enum virtio_gpu_formats {
+	VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM  = 1,
+	VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM  = 2,
+	VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM  = 3,
+	VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM  = 4,
+
+	VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM  = 67,
+	VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM  = 68,
+
+	VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM  = 121,
+	VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM  = 134,
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID */
+struct virtio_gpu_resource_assign_uuid {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_RESP_OK_RESOURCE_UUID */
+struct virtio_gpu_resp_resource_uuid {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint8_t uuid[16];
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB */
+struct virtio_gpu_resource_create_blob {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+#define VIRTIO_GPU_BLOB_MEM_GUEST             0x0001
+#define VIRTIO_GPU_BLOB_MEM_HOST3D            0x0002
+#define VIRTIO_GPU_BLOB_MEM_HOST3D_GUEST      0x0003
+
+#define VIRTIO_GPU_BLOB_FLAG_USE_MAPPABLE     0x0001
+#define VIRTIO_GPU_BLOB_FLAG_USE_SHAREABLE    0x0002
+#define VIRTIO_GPU_BLOB_FLAG_USE_CROSS_DEVICE 0x0004
+	/* zero is invalid blob mem */
+	uint32_t blob_mem;
+	uint32_t blob_flags;
+	uint32_t nr_entries;
+	uint64_t blob_id;
+	uint64_t size;
+	/*
+	 * sizeof(nr_entries * virtio_gpu_mem_entry) bytes follow
+	 */
+};
+
+/* VIRTIO_GPU_CMD_SET_SCANOUT_BLOB */
+struct virtio_gpu_set_scanout_blob {
+	struct virtio_gpu_ctrl_hdr hdr;
+	struct virtio_gpu_rect r;
+	uint32_t scanout_id;
+	uint32_t resource_id;
+	uint32_t width;
+	uint32_t height;
+	uint32_t format;
+	uint32_t padding;
+	uint32_t strides[4];
+	uint32_t offsets[4];
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB */
+struct virtio_gpu_resource_map_blob {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t padding;
+	uint64_t offset;
+};
+
+/* VIRTIO_GPU_RESP_OK_MAP_INFO */
+#define VIRTIO_GPU_MAP_CACHE_MASK     0x0f
+#define VIRTIO_GPU_MAP_CACHE_NONE     0x00
+#define VIRTIO_GPU_MAP_CACHE_CACHED   0x01
+#define VIRTIO_GPU_MAP_CACHE_UNCACHED 0x02
+#define VIRTIO_GPU_MAP_CACHE_WC       0x03
+struct virtio_gpu_resp_map_info {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t map_info;
+	uint32_t padding;
+};
+
+/* VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB */
+struct virtio_gpu_resource_unmap_blob {
+	struct virtio_gpu_ctrl_hdr hdr;
+	uint32_t resource_id;
+	uint32_t padding;
+};
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_ids.h b/subprojects/libvhost-user/standard-headers/linux/virtio_ids.h
new file mode 100644
index 0000000..4fe842c
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_ids.h
@@ -0,0 +1,60 @@
+#ifndef _LINUX_VIRTIO_IDS_H
+#define _LINUX_VIRTIO_IDS_H
+/*
+ * Virtio IDs
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+
+#define VIRTIO_ID_NET			1 /* virtio net */
+#define VIRTIO_ID_BLOCK			2 /* virtio block */
+#define VIRTIO_ID_CONSOLE		3 /* virtio console */
+#define VIRTIO_ID_RNG			4 /* virtio rng */
+#define VIRTIO_ID_BALLOON		5 /* virtio balloon */
+#define VIRTIO_ID_IOMEM			6 /* virtio ioMemory */
+#define VIRTIO_ID_RPMSG			7 /* virtio remote processor messaging */
+#define VIRTIO_ID_SCSI			8 /* virtio scsi */
+#define VIRTIO_ID_9P			9 /* 9p virtio console */
+#define VIRTIO_ID_MAC80211_WLAN		10 /* virtio WLAN MAC */
+#define VIRTIO_ID_RPROC_SERIAL		11 /* virtio remoteproc serial link */
+#define VIRTIO_ID_CAIF			12 /* Virtio caif */
+#define VIRTIO_ID_MEMORY_BALLOON	13 /* virtio memory balloon */
+#define VIRTIO_ID_GPU			16 /* virtio GPU */
+#define VIRTIO_ID_CLOCK			17 /* virtio clock/timer */
+#define VIRTIO_ID_INPUT			18 /* virtio input */
+#define VIRTIO_ID_VSOCK			19 /* virtio vsock transport */
+#define VIRTIO_ID_CRYPTO		20 /* virtio crypto */
+#define VIRTIO_ID_SIGNAL_DIST		21 /* virtio signal distribution device */
+#define VIRTIO_ID_PSTORE		22 /* virtio pstore device */
+#define VIRTIO_ID_IOMMU			23 /* virtio IOMMU */
+#define VIRTIO_ID_MEM			24 /* virtio mem */
+#define VIRTIO_ID_SOUND			25 /* virtio sound */
+#define VIRTIO_ID_FS			26 /* virtio filesystem */
+#define VIRTIO_ID_PMEM			27 /* virtio pmem */
+#define VIRTIO_ID_MAC80211_HWSIM	29 /* virtio mac80211-hwsim */
+#define VIRTIO_ID_BT			40 /* virtio bluetooth */
+
+#endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_input.h b/subprojects/libvhost-user/standard-headers/linux/virtio_input.h
new file mode 100644
index 0000000..a98a797
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_input.h
@@ -0,0 +1,76 @@
+#ifndef _LINUX_VIRTIO_INPUT_H
+#define _LINUX_VIRTIO_INPUT_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+
+#include "standard-headers/linux/types.h"
+
+enum virtio_input_config_select {
+	VIRTIO_INPUT_CFG_UNSET      = 0x00,
+	VIRTIO_INPUT_CFG_ID_NAME    = 0x01,
+	VIRTIO_INPUT_CFG_ID_SERIAL  = 0x02,
+	VIRTIO_INPUT_CFG_ID_DEVIDS  = 0x03,
+	VIRTIO_INPUT_CFG_PROP_BITS  = 0x10,
+	VIRTIO_INPUT_CFG_EV_BITS    = 0x11,
+	VIRTIO_INPUT_CFG_ABS_INFO   = 0x12,
+};
+
+struct virtio_input_absinfo {
+	uint32_t min;
+	uint32_t max;
+	uint32_t fuzz;
+	uint32_t flat;
+	uint32_t res;
+};
+
+struct virtio_input_devids {
+	uint16_t bustype;
+	uint16_t vendor;
+	uint16_t product;
+	uint16_t version;
+};
+
+struct virtio_input_config {
+	uint8_t    select;
+	uint8_t    subsel;
+	uint8_t    size;
+	uint8_t    reserved[5];
+	union {
+		char string[128];
+		uint8_t bitmap[128];
+		struct virtio_input_absinfo abs;
+		struct virtio_input_devids ids;
+	} u;
+};
+
+struct virtio_input_event {
+	uint16_t type;
+	uint16_t code;
+	uint32_t value;
+};
+
+#endif /* _LINUX_VIRTIO_INPUT_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_iommu.h b/subprojects/libvhost-user/standard-headers/linux/virtio_iommu.h
new file mode 100644
index 0000000..b9443b8
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_iommu.h
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Virtio-iommu definition v0.12
+ *
+ * Copyright (C) 2019 Arm Ltd.
+ */
+#ifndef _LINUX_VIRTIO_IOMMU_H
+#define _LINUX_VIRTIO_IOMMU_H
+
+#include "standard-headers/linux/types.h"
+
+/* Feature bits */
+#define VIRTIO_IOMMU_F_INPUT_RANGE		0
+#define VIRTIO_IOMMU_F_DOMAIN_RANGE		1
+#define VIRTIO_IOMMU_F_MAP_UNMAP		2
+#define VIRTIO_IOMMU_F_BYPASS			3
+#define VIRTIO_IOMMU_F_PROBE			4
+#define VIRTIO_IOMMU_F_MMIO			5
+
+struct virtio_iommu_range_64 {
+	uint64_t					start;
+	uint64_t					end;
+};
+
+struct virtio_iommu_range_32 {
+	uint32_t					start;
+	uint32_t					end;
+};
+
+struct virtio_iommu_config {
+	/* Supported page sizes */
+	uint64_t					page_size_mask;
+	/* Supported IOVA range */
+	struct virtio_iommu_range_64		input_range;
+	/* Max domain ID size */
+	struct virtio_iommu_range_32		domain_range;
+	/* Probe buffer size */
+	uint32_t					probe_size;
+};
+
+/* Request types */
+#define VIRTIO_IOMMU_T_ATTACH			0x01
+#define VIRTIO_IOMMU_T_DETACH			0x02
+#define VIRTIO_IOMMU_T_MAP			0x03
+#define VIRTIO_IOMMU_T_UNMAP			0x04
+#define VIRTIO_IOMMU_T_PROBE			0x05
+
+/* Status types */
+#define VIRTIO_IOMMU_S_OK			0x00
+#define VIRTIO_IOMMU_S_IOERR			0x01
+#define VIRTIO_IOMMU_S_UNSUPP			0x02
+#define VIRTIO_IOMMU_S_DEVERR			0x03
+#define VIRTIO_IOMMU_S_INVAL			0x04
+#define VIRTIO_IOMMU_S_RANGE			0x05
+#define VIRTIO_IOMMU_S_NOENT			0x06
+#define VIRTIO_IOMMU_S_FAULT			0x07
+#define VIRTIO_IOMMU_S_NOMEM			0x08
+
+struct virtio_iommu_req_head {
+	uint8_t					type;
+	uint8_t					reserved[3];
+};
+
+struct virtio_iommu_req_tail {
+	uint8_t					status;
+	uint8_t					reserved[3];
+};
+
+struct virtio_iommu_req_attach {
+	struct virtio_iommu_req_head		head;
+	uint32_t					domain;
+	uint32_t					endpoint;
+	uint8_t					reserved[8];
+	struct virtio_iommu_req_tail		tail;
+};
+
+struct virtio_iommu_req_detach {
+	struct virtio_iommu_req_head		head;
+	uint32_t					domain;
+	uint32_t					endpoint;
+	uint8_t					reserved[8];
+	struct virtio_iommu_req_tail		tail;
+};
+
+#define VIRTIO_IOMMU_MAP_F_READ			(1 << 0)
+#define VIRTIO_IOMMU_MAP_F_WRITE		(1 << 1)
+#define VIRTIO_IOMMU_MAP_F_MMIO			(1 << 2)
+
+#define VIRTIO_IOMMU_MAP_F_MASK			(VIRTIO_IOMMU_MAP_F_READ |	\
+						 VIRTIO_IOMMU_MAP_F_WRITE |	\
+						 VIRTIO_IOMMU_MAP_F_MMIO)
+
+struct virtio_iommu_req_map {
+	struct virtio_iommu_req_head		head;
+	uint32_t					domain;
+	uint64_t					virt_start;
+	uint64_t					virt_end;
+	uint64_t					phys_start;
+	uint32_t					flags;
+	struct virtio_iommu_req_tail		tail;
+};
+
+struct virtio_iommu_req_unmap {
+	struct virtio_iommu_req_head		head;
+	uint32_t					domain;
+	uint64_t					virt_start;
+	uint64_t					virt_end;
+	uint8_t					reserved[4];
+	struct virtio_iommu_req_tail		tail;
+};
+
+#define VIRTIO_IOMMU_PROBE_T_NONE		0
+#define VIRTIO_IOMMU_PROBE_T_RESV_MEM		1
+
+#define VIRTIO_IOMMU_PROBE_T_MASK		0xfff
+
+struct virtio_iommu_probe_property {
+	uint16_t					type;
+	uint16_t					length;
+};
+
+#define VIRTIO_IOMMU_RESV_MEM_T_RESERVED	0
+#define VIRTIO_IOMMU_RESV_MEM_T_MSI		1
+
+struct virtio_iommu_probe_resv_mem {
+	struct virtio_iommu_probe_property	head;
+	uint8_t					subtype;
+	uint8_t					reserved[3];
+	uint64_t					start;
+	uint64_t					end;
+};
+
+struct virtio_iommu_req_probe {
+	struct virtio_iommu_req_head		head;
+	uint32_t					endpoint;
+	uint8_t					reserved[64];
+
+	uint8_t					properties[];
+
+	/*
+	 * Tail follows the variable-length properties array. No padding,
+	 * property lengths are all aligned on 8 bytes.
+	 */
+};
+
+/* Fault types */
+#define VIRTIO_IOMMU_FAULT_R_UNKNOWN		0
+#define VIRTIO_IOMMU_FAULT_R_DOMAIN		1
+#define VIRTIO_IOMMU_FAULT_R_MAPPING		2
+
+#define VIRTIO_IOMMU_FAULT_F_READ		(1 << 0)
+#define VIRTIO_IOMMU_FAULT_F_WRITE		(1 << 1)
+#define VIRTIO_IOMMU_FAULT_F_EXEC		(1 << 2)
+#define VIRTIO_IOMMU_FAULT_F_ADDRESS		(1 << 8)
+
+struct virtio_iommu_fault {
+	uint8_t					reason;
+	uint8_t					reserved[3];
+	uint32_t					flags;
+	uint32_t					endpoint;
+	uint8_t					reserved2[4];
+	uint64_t					address;
+};
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_mem.h b/subprojects/libvhost-user/standard-headers/linux/virtio_mem.h
new file mode 100644
index 0000000..05e5ade
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_mem.h
@@ -0,0 +1,211 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Virtio Mem Device
+ *
+ * Copyright Red Hat, Inc. 2020
+ *
+ * Authors:
+ *     David Hildenbrand <david@redhat.com>
+ *
+ * This header is BSD licensed so anyone can use the definitions
+ * to implement compatible drivers/servers:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_VIRTIO_MEM_H
+#define _LINUX_VIRTIO_MEM_H
+
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+/*
+ * Each virtio-mem device manages a dedicated region in physical address
+ * space. Each device can belong to a single NUMA node, multiple devices
+ * for a single NUMA node are possible. A virtio-mem device is like a
+ * "resizable DIMM" consisting of small memory blocks that can be plugged
+ * or unplugged. The device driver is responsible for (un)plugging memory
+ * blocks on demand.
+ *
+ * Virtio-mem devices can only operate on their assigned memory region in
+ * order to (un)plug memory. A device cannot (un)plug memory belonging to
+ * other devices.
+ *
+ * The "region_size" corresponds to the maximum amount of memory that can
+ * be provided by a device. The "size" corresponds to the amount of memory
+ * that is currently plugged. "requested_size" corresponds to a request
+ * from the device to the device driver to (un)plug blocks. The
+ * device driver should try to (un)plug blocks in order to reach the
+ * "requested_size". It is impossible to plug more memory than requested.
+ *
+ * The "usable_region_size" represents the memory region that can actually
+ * be used to (un)plug memory. It is always at least as big as the
+ * "requested_size" and will grow dynamically. It will only shrink when
+ * explicitly triggered (VIRTIO_MEM_REQ_UNPLUG).
+ *
+ * There are no guarantees what will happen if unplugged memory is
+ * read/written. Such memory should, in general, not be touched. E.g.,
+ * even writing might succeed, but the values will simply be discarded at
+ * random points in time.
+ *
+ * It can happen that the device cannot process a request, because it is
+ * busy. The device driver has to retry later.
+ *
+ * Usually, during system resets all memory will get unplugged, so the
+ * device driver can start with a clean state. However, in specific
+ * scenarios (if the device is busy) it can happen that the device still
+ * has memory plugged. The device driver can request to unplug all memory
+ * (VIRTIO_MEM_REQ_UNPLUG) - which might take a while to succeed if the
+ * device is busy.
+ */
+
+/* --- virtio-mem: feature bits --- */
+
+/* node_id is an ACPI PXM and is valid */
+#define VIRTIO_MEM_F_ACPI_PXM		0
+
+
+/* --- virtio-mem: guest -> host requests --- */
+
+/* request to plug memory blocks */
+#define VIRTIO_MEM_REQ_PLUG			0
+/* request to unplug memory blocks */
+#define VIRTIO_MEM_REQ_UNPLUG			1
+/* request to unplug all blocks and shrink the usable size */
+#define VIRTIO_MEM_REQ_UNPLUG_ALL		2
+/* request information about the plugged state of memory blocks */
+#define VIRTIO_MEM_REQ_STATE			3
+
+struct virtio_mem_req_plug {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+	__virtio16 padding[3];
+};
+
+struct virtio_mem_req_unplug {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+	__virtio16 padding[3];
+};
+
+struct virtio_mem_req_state {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+	__virtio16 padding[3];
+};
+
+struct virtio_mem_req {
+	__virtio16 type;
+	__virtio16 padding[3];
+
+	union {
+		struct virtio_mem_req_plug plug;
+		struct virtio_mem_req_unplug unplug;
+		struct virtio_mem_req_state state;
+	} u;
+};
+
+
+/* --- virtio-mem: host -> guest response --- */
+
+/*
+ * Request processed successfully, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_UNPLUG_ALL
+ * - VIRTIO_MEM_REQ_STATE
+ */
+#define VIRTIO_MEM_RESP_ACK			0
+/*
+ * Request denied - e.g. trying to plug more than requested, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ */
+#define VIRTIO_MEM_RESP_NACK			1
+/*
+ * Request cannot be processed right now, try again later, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_UNPLUG_ALL
+ */
+#define VIRTIO_MEM_RESP_BUSY			2
+/*
+ * Error in request (e.g. addresses/alignment), applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_STATE
+ */
+#define VIRTIO_MEM_RESP_ERROR			3
+
+
+/* State of memory blocks is "plugged" */
+#define VIRTIO_MEM_STATE_PLUGGED		0
+/* State of memory blocks is "unplugged" */
+#define VIRTIO_MEM_STATE_UNPLUGGED		1
+/* State of memory blocks is "mixed" */
+#define VIRTIO_MEM_STATE_MIXED			2
+
+struct virtio_mem_resp_state {
+	__virtio16 state;
+};
+
+struct virtio_mem_resp {
+	__virtio16 type;
+	__virtio16 padding[3];
+
+	union {
+		struct virtio_mem_resp_state state;
+	} u;
+};
+
+/* --- virtio-mem: configuration --- */
+
+struct virtio_mem_config {
+	/* Block size and alignment. Cannot change. */
+	uint64_t block_size;
+	/* Valid with VIRTIO_MEM_F_ACPI_PXM. Cannot change. */
+	uint16_t node_id;
+	uint8_t padding[6];
+	/* Start address of the memory region. Cannot change. */
+	uint64_t addr;
+	/* Region size (maximum). Cannot change. */
+	uint64_t region_size;
+	/*
+	 * Currently usable region size. Can grow up to region_size. Can
+	 * shrink due to VIRTIO_MEM_REQ_UNPLUG_ALL (in which case no config
+	 * update will be sent).
+	 */
+	uint64_t usable_region_size;
+	/*
+	 * Currently used size. Changes due to plug/unplug requests, but no
+	 * config updates will be sent.
+	 */
+	uint64_t plugged_size;
+	/* Requested size. New plug requests cannot exceed it. Can change. */
+	uint64_t requested_size;
+};
+
+#endif /* _LINUX_VIRTIO_MEM_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_mmio.h b/subprojects/libvhost-user/standard-headers/linux/virtio_mmio.h
new file mode 100644
index 0000000..0650f91
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_mmio.h
@@ -0,0 +1,152 @@
+/*
+ * Virtio platform device driver
+ *
+ * Copyright 2011, ARM Ltd.
+ *
+ * Based on Virtio PCI driver by Anthony Liguori, copyright IBM Corp. 2007
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_VIRTIO_MMIO_H
+#define _LINUX_VIRTIO_MMIO_H
+
+/*
+ * Control registers
+ */
+
+/* Magic value ("virt" string) - Read Only */
+#define VIRTIO_MMIO_MAGIC_VALUE		0x000
+
+/* Virtio device version - Read Only */
+#define VIRTIO_MMIO_VERSION		0x004
+
+/* Virtio device ID - Read Only */
+#define VIRTIO_MMIO_DEVICE_ID		0x008
+
+/* Virtio vendor ID - Read Only */
+#define VIRTIO_MMIO_VENDOR_ID		0x00c
+
+/* Bitmask of the features supported by the device (host)
+ * (32 bits per set) - Read Only */
+#define VIRTIO_MMIO_DEVICE_FEATURES	0x010
+
+/* Device (host) features set selector - Write Only */
+#define VIRTIO_MMIO_DEVICE_FEATURES_SEL	0x014
+
+/* Bitmask of features activated by the driver (guest)
+ * (32 bits per set) - Write Only */
+#define VIRTIO_MMIO_DRIVER_FEATURES	0x020
+
+/* Activated features set selector - Write Only */
+#define VIRTIO_MMIO_DRIVER_FEATURES_SEL	0x024
+
+
+#ifndef VIRTIO_MMIO_NO_LEGACY /* LEGACY DEVICES ONLY! */
+
+/* Guest's memory page size in bytes - Write Only */
+#define VIRTIO_MMIO_GUEST_PAGE_SIZE	0x028
+
+#endif
+
+
+/* Queue selector - Write Only */
+#define VIRTIO_MMIO_QUEUE_SEL		0x030
+
+/* Maximum size of the currently selected queue - Read Only */
+#define VIRTIO_MMIO_QUEUE_NUM_MAX	0x034
+
+/* Queue size for the currently selected queue - Write Only */
+#define VIRTIO_MMIO_QUEUE_NUM		0x038
+
+
+#ifndef VIRTIO_MMIO_NO_LEGACY /* LEGACY DEVICES ONLY! */
+
+/* Used Ring alignment for the currently selected queue - Write Only */
+#define VIRTIO_MMIO_QUEUE_ALIGN		0x03c
+
+/* Guest's PFN for the currently selected queue - Read Write */
+#define VIRTIO_MMIO_QUEUE_PFN		0x040
+
+#endif
+
+
+/* Ready bit for the currently selected queue - Read Write */
+#define VIRTIO_MMIO_QUEUE_READY		0x044
+
+/* Queue notifier - Write Only */
+#define VIRTIO_MMIO_QUEUE_NOTIFY	0x050
+
+/* Interrupt status - Read Only */
+#define VIRTIO_MMIO_INTERRUPT_STATUS	0x060
+
+/* Interrupt acknowledge - Write Only */
+#define VIRTIO_MMIO_INTERRUPT_ACK	0x064
+
+/* Device status register - Read Write */
+#define VIRTIO_MMIO_STATUS		0x070
+
+/* Selected queue's Descriptor Table address, 64 bits in two halves */
+#define VIRTIO_MMIO_QUEUE_DESC_LOW	0x080
+#define VIRTIO_MMIO_QUEUE_DESC_HIGH	0x084
+
+/* Selected queue's Available Ring address, 64 bits in two halves */
+#define VIRTIO_MMIO_QUEUE_AVAIL_LOW	0x090
+#define VIRTIO_MMIO_QUEUE_AVAIL_HIGH	0x094
+
+/* Selected queue's Used Ring address, 64 bits in two halves */
+#define VIRTIO_MMIO_QUEUE_USED_LOW	0x0a0
+#define VIRTIO_MMIO_QUEUE_USED_HIGH	0x0a4
+
+/* Shared memory region id */
+#define VIRTIO_MMIO_SHM_SEL             0x0ac
+
+/* Shared memory region length, 64 bits in two halves */
+#define VIRTIO_MMIO_SHM_LEN_LOW         0x0b0
+#define VIRTIO_MMIO_SHM_LEN_HIGH        0x0b4
+
+/* Shared memory region base address, 64 bits in two halves */
+#define VIRTIO_MMIO_SHM_BASE_LOW        0x0b8
+#define VIRTIO_MMIO_SHM_BASE_HIGH       0x0bc
+
+/* Configuration atomicity value */
+#define VIRTIO_MMIO_CONFIG_GENERATION	0x0fc
+
+/* The config space is defined by each driver as
+ * the per-driver configuration space - Read Write */
+#define VIRTIO_MMIO_CONFIG		0x100
+
+
+
+/*
+ * Interrupt flags (re: interrupt status & acknowledge registers)
+ */
+
+#define VIRTIO_MMIO_INT_VRING		(1 << 0)
+#define VIRTIO_MMIO_INT_CONFIG		(1 << 1)
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_net.h b/subprojects/libvhost-user/standard-headers/linux/virtio_net.h
new file mode 100644
index 0000000..e0a0705
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_net.h
@@ -0,0 +1,358 @@
+#ifndef _LINUX_VIRTIO_NET_H
+#define _LINUX_VIRTIO_NET_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE. */
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+#include "standard-headers/linux/virtio_types.h"
+#include "standard-headers/linux/if_ether.h"
+
+/* The feature bitmap for virtio net */
+#define VIRTIO_NET_F_CSUM	0	/* Host handles pkts w/ partial csum */
+#define VIRTIO_NET_F_GUEST_CSUM	1	/* Guest handles pkts w/ partial csum */
+#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS 2 /* Dynamic offload configuration. */
+#define VIRTIO_NET_F_MTU	3	/* Initial MTU advice */
+#define VIRTIO_NET_F_MAC	5	/* Host has given MAC address. */
+#define VIRTIO_NET_F_GUEST_TSO4	7	/* Guest can handle TSOv4 in. */
+#define VIRTIO_NET_F_GUEST_TSO6	8	/* Guest can handle TSOv6 in. */
+#define VIRTIO_NET_F_GUEST_ECN	9	/* Guest can handle TSO[6] w/ ECN in. */
+#define VIRTIO_NET_F_GUEST_UFO	10	/* Guest can handle UFO in. */
+#define VIRTIO_NET_F_HOST_TSO4	11	/* Host can handle TSOv4 in. */
+#define VIRTIO_NET_F_HOST_TSO6	12	/* Host can handle TSOv6 in. */
+#define VIRTIO_NET_F_HOST_ECN	13	/* Host can handle TSO[6] w/ ECN in. */
+#define VIRTIO_NET_F_HOST_UFO	14	/* Host can handle UFO in. */
+#define VIRTIO_NET_F_MRG_RXBUF	15	/* Host can merge receive buffers. */
+#define VIRTIO_NET_F_STATUS	16	/* virtio_net_config.status available */
+#define VIRTIO_NET_F_CTRL_VQ	17	/* Control channel available */
+#define VIRTIO_NET_F_CTRL_RX	18	/* Control channel RX mode support */
+#define VIRTIO_NET_F_CTRL_VLAN	19	/* Control channel VLAN filtering */
+#define VIRTIO_NET_F_CTRL_RX_EXTRA 20	/* Extra RX mode control support */
+#define VIRTIO_NET_F_GUEST_ANNOUNCE 21	/* Guest can announce device on the
+					 * network */
+#define VIRTIO_NET_F_MQ	22	/* Device supports Receive Flow
+					 * Steering */
+#define VIRTIO_NET_F_CTRL_MAC_ADDR 23	/* Set MAC address */
+
+#define VIRTIO_NET_F_HASH_REPORT  57	/* Supports hash report */
+#define VIRTIO_NET_F_RSS	  60	/* Supports RSS RX steering */
+#define VIRTIO_NET_F_RSC_EXT	  61	/* extended coalescing info */
+#define VIRTIO_NET_F_STANDBY	  62	/* Act as standby for another device
+					 * with the same MAC.
+					 */
+#define VIRTIO_NET_F_SPEED_DUPLEX 63	/* Device set linkspeed and duplex */
+
+#ifndef VIRTIO_NET_NO_LEGACY
+#define VIRTIO_NET_F_GSO	6	/* Host handles pkts w/ any GSO type */
+#endif /* VIRTIO_NET_NO_LEGACY */
+
+#define VIRTIO_NET_S_LINK_UP	1	/* Link is up */
+#define VIRTIO_NET_S_ANNOUNCE	2	/* Announcement is needed */
+
+/* supported/enabled hash types */
+#define VIRTIO_NET_RSS_HASH_TYPE_IPv4          (1 << 0)
+#define VIRTIO_NET_RSS_HASH_TYPE_TCPv4         (1 << 1)
+#define VIRTIO_NET_RSS_HASH_TYPE_UDPv4         (1 << 2)
+#define VIRTIO_NET_RSS_HASH_TYPE_IPv6          (1 << 3)
+#define VIRTIO_NET_RSS_HASH_TYPE_TCPv6         (1 << 4)
+#define VIRTIO_NET_RSS_HASH_TYPE_UDPv6         (1 << 5)
+#define VIRTIO_NET_RSS_HASH_TYPE_IP_EX         (1 << 6)
+#define VIRTIO_NET_RSS_HASH_TYPE_TCP_EX        (1 << 7)
+#define VIRTIO_NET_RSS_HASH_TYPE_UDP_EX        (1 << 8)
+
+struct virtio_net_config {
+	/* The config defining mac address (if VIRTIO_NET_F_MAC) */
+	uint8_t mac[ETH_ALEN];
+	/* See VIRTIO_NET_F_STATUS and VIRTIO_NET_S_* above */
+	__virtio16 status;
+	/* Maximum number of each of transmit and receive queues;
+	 * see VIRTIO_NET_F_MQ and VIRTIO_NET_CTRL_MQ.
+	 * Legal values are between 1 and 0x8000
+	 */
+	__virtio16 max_virtqueue_pairs;
+	/* Default maximum transmit unit advice */
+	__virtio16 mtu;
+	/*
+	 * speed, in units of 1Mb. All values 0 to INT_MAX are legal.
+	 * Any other value stands for unknown.
+	 */
+	uint32_t speed;
+	/*
+	 * 0x00 - half duplex
+	 * 0x01 - full duplex
+	 * Any other value stands for unknown.
+	 */
+	uint8_t duplex;
+	/* maximum size of RSS key */
+	uint8_t rss_max_key_size;
+	/* maximum number of indirection table entries */
+	uint16_t rss_max_indirection_table_length;
+	/* bitmask of supported VIRTIO_NET_RSS_HASH_ types */
+	uint32_t supported_hash_types;
+} QEMU_PACKED;
+
+/*
+ * This header comes first in the scatter-gather list.  If you don't
+ * specify GSO or CSUM features, you can simply ignore the header.
+ *
+ * This is bitwise-equivalent to the legacy struct virtio_net_hdr_mrg_rxbuf,
+ * only flattened.
+ */
+struct virtio_net_hdr_v1 {
+#define VIRTIO_NET_HDR_F_NEEDS_CSUM	1	/* Use csum_start, csum_offset */
+#define VIRTIO_NET_HDR_F_DATA_VALID	2	/* Csum is valid */
+#define VIRTIO_NET_HDR_F_RSC_INFO	4	/* rsc info in csum_ fields */
+	uint8_t flags;
+#define VIRTIO_NET_HDR_GSO_NONE		0	/* Not a GSO frame */
+#define VIRTIO_NET_HDR_GSO_TCPV4	1	/* GSO frame, IPv4 TCP (TSO) */
+#define VIRTIO_NET_HDR_GSO_UDP		3	/* GSO frame, IPv4 UDP (UFO) */
+#define VIRTIO_NET_HDR_GSO_TCPV6	4	/* GSO frame, IPv6 TCP */
+#define VIRTIO_NET_HDR_GSO_ECN		0x80	/* TCP has ECN set */
+	uint8_t gso_type;
+	__virtio16 hdr_len;	/* Ethernet + IP + tcp/udp hdrs */
+	__virtio16 gso_size;	/* Bytes to append to hdr_len per frame */
+	union {
+		struct {
+			__virtio16 csum_start;
+			__virtio16 csum_offset;
+		};
+		/* Checksum calculation */
+		struct {
+			/* Position to start checksumming from */
+			__virtio16 start;
+			/* Offset after that to place checksum */
+			__virtio16 offset;
+		} csum;
+		/* Receive Segment Coalescing */
+		struct {
+			/* Number of coalesced segments */
+			uint16_t segments;
+			/* Number of duplicated acks */
+			uint16_t dup_acks;
+		} rsc;
+	};
+	__virtio16 num_buffers;	/* Number of merged rx buffers */
+};
+
+struct virtio_net_hdr_v1_hash {
+	struct virtio_net_hdr_v1 hdr;
+	uint32_t hash_value;
+#define VIRTIO_NET_HASH_REPORT_NONE            0
+#define VIRTIO_NET_HASH_REPORT_IPv4            1
+#define VIRTIO_NET_HASH_REPORT_TCPv4           2
+#define VIRTIO_NET_HASH_REPORT_UDPv4           3
+#define VIRTIO_NET_HASH_REPORT_IPv6            4
+#define VIRTIO_NET_HASH_REPORT_TCPv6           5
+#define VIRTIO_NET_HASH_REPORT_UDPv6           6
+#define VIRTIO_NET_HASH_REPORT_IPv6_EX         7
+#define VIRTIO_NET_HASH_REPORT_TCPv6_EX        8
+#define VIRTIO_NET_HASH_REPORT_UDPv6_EX        9
+	uint16_t hash_report;
+	uint16_t padding;
+};
+
+#ifndef VIRTIO_NET_NO_LEGACY
+/* This header comes first in the scatter-gather list.
+ * For legacy virtio, if VIRTIO_F_ANY_LAYOUT is not negotiated, it must
+ * be the first element of the scatter-gather list.  If you don't
+ * specify GSO or CSUM features, you can simply ignore the header. */
+struct virtio_net_hdr {
+	/* See VIRTIO_NET_HDR_F_* */
+	uint8_t flags;
+	/* See VIRTIO_NET_HDR_GSO_* */
+	uint8_t gso_type;
+	__virtio16 hdr_len;		/* Ethernet + IP + tcp/udp hdrs */
+	__virtio16 gso_size;		/* Bytes to append to hdr_len per frame */
+	__virtio16 csum_start;	/* Position to start checksumming from */
+	__virtio16 csum_offset;	/* Offset after that to place checksum */
+};
+
+/* This is the version of the header to use when the MRG_RXBUF
+ * feature has been negotiated. */
+struct virtio_net_hdr_mrg_rxbuf {
+	struct virtio_net_hdr hdr;
+	__virtio16 num_buffers;	/* Number of merged rx buffers */
+};
+#endif /* ...VIRTIO_NET_NO_LEGACY */
+
+/*
+ * Control virtqueue data structures
+ *
+ * The control virtqueue expects a header in the first sg entry
+ * and an ack/status response in the last entry.  Data for the
+ * command goes in between.
+ */
+struct virtio_net_ctrl_hdr {
+	uint8_t class;
+	uint8_t cmd;
+} QEMU_PACKED;
+
+typedef uint8_t virtio_net_ctrl_ack;
+
+#define VIRTIO_NET_OK     0
+#define VIRTIO_NET_ERR    1
+
+/*
+ * Control the RX mode, ie. promisucous, allmulti, etc...
+ * All commands require an "out" sg entry containing a 1 byte
+ * state value, zero = disable, non-zero = enable.  Commands
+ * 0 and 1 are supported with the VIRTIO_NET_F_CTRL_RX feature.
+ * Commands 2-5 are added with VIRTIO_NET_F_CTRL_RX_EXTRA.
+ */
+#define VIRTIO_NET_CTRL_RX    0
+ #define VIRTIO_NET_CTRL_RX_PROMISC      0
+ #define VIRTIO_NET_CTRL_RX_ALLMULTI     1
+ #define VIRTIO_NET_CTRL_RX_ALLUNI       2
+ #define VIRTIO_NET_CTRL_RX_NOMULTI      3
+ #define VIRTIO_NET_CTRL_RX_NOUNI        4
+ #define VIRTIO_NET_CTRL_RX_NOBCAST      5
+
+/*
+ * Control the MAC
+ *
+ * The MAC filter table is managed by the hypervisor, the guest should
+ * assume the size is infinite.  Filtering should be considered
+ * non-perfect, ie. based on hypervisor resources, the guest may
+ * received packets from sources not specified in the filter list.
+ *
+ * In addition to the class/cmd header, the TABLE_SET command requires
+ * two out scatterlists.  Each contains a 4 byte count of entries followed
+ * by a concatenated byte stream of the ETH_ALEN MAC addresses.  The
+ * first sg list contains unicast addresses, the second is for multicast.
+ * This functionality is present if the VIRTIO_NET_F_CTRL_RX feature
+ * is available.
+ *
+ * The ADDR_SET command requests one out scatterlist, it contains a
+ * 6 bytes MAC address. This functionality is present if the
+ * VIRTIO_NET_F_CTRL_MAC_ADDR feature is available.
+ */
+struct virtio_net_ctrl_mac {
+	__virtio32 entries;
+	uint8_t macs[][ETH_ALEN];
+} QEMU_PACKED;
+
+#define VIRTIO_NET_CTRL_MAC    1
+ #define VIRTIO_NET_CTRL_MAC_TABLE_SET        0
+ #define VIRTIO_NET_CTRL_MAC_ADDR_SET         1
+
+/*
+ * Control VLAN filtering
+ *
+ * The VLAN filter table is controlled via a simple ADD/DEL interface.
+ * VLAN IDs not added may be filterd by the hypervisor.  Del is the
+ * opposite of add.  Both commands expect an out entry containing a 2
+ * byte VLAN ID.  VLAN filterting is available with the
+ * VIRTIO_NET_F_CTRL_VLAN feature bit.
+ */
+#define VIRTIO_NET_CTRL_VLAN       2
+ #define VIRTIO_NET_CTRL_VLAN_ADD             0
+ #define VIRTIO_NET_CTRL_VLAN_DEL             1
+
+/*
+ * Control link announce acknowledgement
+ *
+ * The command VIRTIO_NET_CTRL_ANNOUNCE_ACK is used to indicate that
+ * driver has recevied the notification; device would clear the
+ * VIRTIO_NET_S_ANNOUNCE bit in the status field after it receives
+ * this command.
+ */
+#define VIRTIO_NET_CTRL_ANNOUNCE       3
+ #define VIRTIO_NET_CTRL_ANNOUNCE_ACK         0
+
+/*
+ * Control Receive Flow Steering
+ */
+#define VIRTIO_NET_CTRL_MQ   4
+/*
+ * The command VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET
+ * enables Receive Flow Steering, specifying the number of the transmit and
+ * receive queues that will be used. After the command is consumed and acked by
+ * the device, the device will not steer new packets on receive virtqueues
+ * other than specified nor read from transmit virtqueues other than specified.
+ * Accordingly, driver should not transmit new packets  on virtqueues other than
+ * specified.
+ */
+struct virtio_net_ctrl_mq {
+	__virtio16 virtqueue_pairs;
+};
+
+ #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET        0
+ #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN        1
+ #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX        0x8000
+
+/*
+ * The command VIRTIO_NET_CTRL_MQ_RSS_CONFIG has the same effect as
+ * VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET does and additionally configures
+ * the receive steering to use a hash calculated for incoming packet
+ * to decide on receive virtqueue to place the packet. The command
+ * also provides parameters to calculate a hash and receive virtqueue.
+ */
+struct virtio_net_rss_config {
+	uint32_t hash_types;
+	uint16_t indirection_table_mask;
+	uint16_t unclassified_queue;
+	uint16_t indirection_table[1/* + indirection_table_mask */];
+	uint16_t max_tx_vq;
+	uint8_t hash_key_length;
+	uint8_t hash_key_data[/* hash_key_length */];
+};
+
+ #define VIRTIO_NET_CTRL_MQ_RSS_CONFIG          1
+
+/*
+ * The command VIRTIO_NET_CTRL_MQ_HASH_CONFIG requests the device
+ * to include in the virtio header of the packet the value of the
+ * calculated hash and the report type of hash. It also provides
+ * parameters for hash calculation. The command requires feature
+ * VIRTIO_NET_F_HASH_REPORT to be negotiated to extend the
+ * layout of virtio header as defined in virtio_net_hdr_v1_hash.
+ */
+struct virtio_net_hash_config {
+	uint32_t hash_types;
+	/* for compatibility with virtio_net_rss_config */
+	uint16_t reserved[4];
+	uint8_t hash_key_length;
+	uint8_t hash_key_data[/* hash_key_length */];
+};
+
+ #define VIRTIO_NET_CTRL_MQ_HASH_CONFIG         2
+
+/*
+ * Control network offloads
+ *
+ * Reconfigures the network offloads that Guest can handle.
+ *
+ * Available with the VIRTIO_NET_F_CTRL_GUEST_OFFLOADS feature bit.
+ *
+ * Command data format matches the feature bit mask exactly.
+ *
+ * See VIRTIO_NET_F_GUEST_* for the list of offloads
+ * that can be enabled/disabled.
+ */
+#define VIRTIO_NET_CTRL_GUEST_OFFLOADS   5
+#define VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET        0
+
+#endif /* _LINUX_VIRTIO_NET_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_pci.h b/subprojects/libvhost-user/standard-headers/linux/virtio_pci.h
new file mode 100644
index 0000000..db7a8e2
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_pci.h
@@ -0,0 +1,208 @@
+/*
+ * Virtio PCI driver
+ *
+ * This module allows virtio devices to be used over a virtual PCI device.
+ * This can be used with QEMU based VMMs like KVM or Xen.
+ *
+ * Copyright IBM Corp. 2007
+ *
+ * Authors:
+ *  Anthony Liguori  <aliguori@us.ibm.com>
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_VIRTIO_PCI_H
+#define _LINUX_VIRTIO_PCI_H
+
+#include "standard-headers/linux/types.h"
+
+#ifndef VIRTIO_PCI_NO_LEGACY
+
+/* A 32-bit r/o bitmask of the features supported by the host */
+#define VIRTIO_PCI_HOST_FEATURES	0
+
+/* A 32-bit r/w bitmask of features activated by the guest */
+#define VIRTIO_PCI_GUEST_FEATURES	4
+
+/* A 32-bit r/w PFN for the currently selected queue */
+#define VIRTIO_PCI_QUEUE_PFN		8
+
+/* A 16-bit r/o queue size for the currently selected queue */
+#define VIRTIO_PCI_QUEUE_NUM		12
+
+/* A 16-bit r/w queue selector */
+#define VIRTIO_PCI_QUEUE_SEL		14
+
+/* A 16-bit r/w queue notifier */
+#define VIRTIO_PCI_QUEUE_NOTIFY		16
+
+/* An 8-bit device status register.  */
+#define VIRTIO_PCI_STATUS		18
+
+/* An 8-bit r/o interrupt status register.  Reading the value will return the
+ * current contents of the ISR and will also clear it.  This is effectively
+ * a read-and-acknowledge. */
+#define VIRTIO_PCI_ISR			19
+
+/* MSI-X registers: only enabled if MSI-X is enabled. */
+/* A 16-bit vector for configuration changes. */
+#define VIRTIO_MSI_CONFIG_VECTOR        20
+/* A 16-bit vector for selected queue notifications. */
+#define VIRTIO_MSI_QUEUE_VECTOR         22
+
+/* The remaining space is defined by each driver as the per-driver
+ * configuration space */
+#define VIRTIO_PCI_CONFIG_OFF(msix_enabled)	((msix_enabled) ? 24 : 20)
+/* Deprecated: please use VIRTIO_PCI_CONFIG_OFF instead */
+#define VIRTIO_PCI_CONFIG(dev)	VIRTIO_PCI_CONFIG_OFF((dev)->msix_enabled)
+
+/* Virtio ABI version, this must match exactly */
+#define VIRTIO_PCI_ABI_VERSION		0
+
+/* How many bits to shift physical queue address written to QUEUE_PFN.
+ * 12 is historical, and due to x86 page size. */
+#define VIRTIO_PCI_QUEUE_ADDR_SHIFT	12
+
+/* The alignment to use between consumer and producer parts of vring.
+ * x86 pagesize again. */
+#define VIRTIO_PCI_VRING_ALIGN		4096
+
+#endif /* VIRTIO_PCI_NO_LEGACY */
+
+/* The bit of the ISR which indicates a device configuration change. */
+#define VIRTIO_PCI_ISR_CONFIG		0x2
+/* Vector value used to disable MSI for queue */
+#define VIRTIO_MSI_NO_VECTOR            0xffff
+
+#ifndef VIRTIO_PCI_NO_MODERN
+
+/* IDs for different capabilities.  Must all exist. */
+
+/* Common configuration */
+#define VIRTIO_PCI_CAP_COMMON_CFG	1
+/* Notifications */
+#define VIRTIO_PCI_CAP_NOTIFY_CFG	2
+/* ISR access */
+#define VIRTIO_PCI_CAP_ISR_CFG		3
+/* Device specific configuration */
+#define VIRTIO_PCI_CAP_DEVICE_CFG	4
+/* PCI configuration access */
+#define VIRTIO_PCI_CAP_PCI_CFG		5
+/* Additional shared memory capability */
+#define VIRTIO_PCI_CAP_SHARED_MEMORY_CFG 8
+
+/* This is the PCI capability header: */
+struct virtio_pci_cap {
+	uint8_t cap_vndr;		/* Generic PCI field: PCI_CAP_ID_VNDR */
+	uint8_t cap_next;		/* Generic PCI field: next ptr. */
+	uint8_t cap_len;		/* Generic PCI field: capability length */
+	uint8_t cfg_type;		/* Identifies the structure. */
+	uint8_t bar;		/* Where to find it. */
+	uint8_t id;		/* Multiple capabilities of the same type */
+	uint8_t padding[2];	/* Pad to full dword. */
+	uint32_t offset;		/* Offset within bar. */
+	uint32_t length;		/* Length of the structure, in bytes. */
+};
+
+struct virtio_pci_cap64 {
+	struct virtio_pci_cap cap;
+	uint32_t offset_hi;             /* Most sig 32 bits of offset */
+	uint32_t length_hi;             /* Most sig 32 bits of length */
+};
+
+struct virtio_pci_notify_cap {
+	struct virtio_pci_cap cap;
+	uint32_t notify_off_multiplier;	/* Multiplier for queue_notify_off. */
+};
+
+/* Fields in VIRTIO_PCI_CAP_COMMON_CFG: */
+struct virtio_pci_common_cfg {
+	/* About the whole device. */
+	uint32_t device_feature_select;	/* read-write */
+	uint32_t device_feature;		/* read-only */
+	uint32_t guest_feature_select;	/* read-write */
+	uint32_t guest_feature;		/* read-write */
+	uint16_t msix_config;		/* read-write */
+	uint16_t num_queues;		/* read-only */
+	uint8_t device_status;		/* read-write */
+	uint8_t config_generation;		/* read-only */
+
+	/* About a specific virtqueue. */
+	uint16_t queue_select;		/* read-write */
+	uint16_t queue_size;		/* read-write, power of 2. */
+	uint16_t queue_msix_vector;	/* read-write */
+	uint16_t queue_enable;		/* read-write */
+	uint16_t queue_notify_off;	/* read-only */
+	uint32_t queue_desc_lo;		/* read-write */
+	uint32_t queue_desc_hi;		/* read-write */
+	uint32_t queue_avail_lo;		/* read-write */
+	uint32_t queue_avail_hi;		/* read-write */
+	uint32_t queue_used_lo;		/* read-write */
+	uint32_t queue_used_hi;		/* read-write */
+};
+
+/* Fields in VIRTIO_PCI_CAP_PCI_CFG: */
+struct virtio_pci_cfg_cap {
+	struct virtio_pci_cap cap;
+	uint8_t pci_cfg_data[4]; /* Data for BAR access. */
+};
+
+/* Macro versions of offsets for the Old Timers! */
+#define VIRTIO_PCI_CAP_VNDR		0
+#define VIRTIO_PCI_CAP_NEXT		1
+#define VIRTIO_PCI_CAP_LEN		2
+#define VIRTIO_PCI_CAP_CFG_TYPE		3
+#define VIRTIO_PCI_CAP_BAR		4
+#define VIRTIO_PCI_CAP_OFFSET		8
+#define VIRTIO_PCI_CAP_LENGTH		12
+
+#define VIRTIO_PCI_NOTIFY_CAP_MULT	16
+
+#define VIRTIO_PCI_COMMON_DFSELECT	0
+#define VIRTIO_PCI_COMMON_DF		4
+#define VIRTIO_PCI_COMMON_GFSELECT	8
+#define VIRTIO_PCI_COMMON_GF		12
+#define VIRTIO_PCI_COMMON_MSIX		16
+#define VIRTIO_PCI_COMMON_NUMQ		18
+#define VIRTIO_PCI_COMMON_STATUS	20
+#define VIRTIO_PCI_COMMON_CFGGENERATION	21
+#define VIRTIO_PCI_COMMON_Q_SELECT	22
+#define VIRTIO_PCI_COMMON_Q_SIZE	24
+#define VIRTIO_PCI_COMMON_Q_MSIX	26
+#define VIRTIO_PCI_COMMON_Q_ENABLE	28
+#define VIRTIO_PCI_COMMON_Q_NOFF	30
+#define VIRTIO_PCI_COMMON_Q_DESCLO	32
+#define VIRTIO_PCI_COMMON_Q_DESCHI	36
+#define VIRTIO_PCI_COMMON_Q_AVAILLO	40
+#define VIRTIO_PCI_COMMON_Q_AVAILHI	44
+#define VIRTIO_PCI_COMMON_Q_USEDLO	48
+#define VIRTIO_PCI_COMMON_Q_USEDHI	52
+
+#endif /* VIRTIO_PCI_NO_MODERN */
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_pmem.h b/subprojects/libvhost-user/standard-headers/linux/virtio_pmem.h
new file mode 100644
index 0000000..fc029de
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_pmem.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause */
+/*
+ * Definitions for virtio-pmem devices.
+ *
+ * Copyright (C) 2019 Red Hat, Inc.
+ *
+ * Author(s): Pankaj Gupta <pagupta@redhat.com>
+ */
+
+#ifndef _LINUX_VIRTIO_PMEM_H
+#define _LINUX_VIRTIO_PMEM_H
+
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+struct virtio_pmem_config {
+	uint64_t start;
+	uint64_t size;
+};
+
+#define VIRTIO_PMEM_REQ_TYPE_FLUSH      0
+
+struct virtio_pmem_resp {
+	/* Host return status corresponding to flush request */
+	uint32_t ret;
+};
+
+struct virtio_pmem_req {
+	/* command type */
+	uint32_t type;
+};
+
+#endif
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_ring.h b/subprojects/libvhost-user/standard-headers/linux/virtio_ring.h
new file mode 100644
index 0000000..0fa0e10
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_ring.h
@@ -0,0 +1,242 @@
+#ifndef _LINUX_VIRTIO_RING_H
+#define _LINUX_VIRTIO_RING_H
+/* An interface for efficient virtio implementation, currently for use by KVM,
+ * but hopefully others soon.  Do NOT change this since it will
+ * break existing servers and clients.
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Copyright Rusty Russell IBM Corporation 2007. */
+#include <stdint.h>
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_types.h"
+
+/* This marks a buffer as continuing via the next field. */
+#define VRING_DESC_F_NEXT	1
+/* This marks a buffer as write-only (otherwise read-only). */
+#define VRING_DESC_F_WRITE	2
+/* This means the buffer contains a list of buffer descriptors. */
+#define VRING_DESC_F_INDIRECT	4
+
+/*
+ * Mark a descriptor as available or used in packed ring.
+ * Notice: they are defined as shifts instead of shifted values.
+ */
+#define VRING_PACKED_DESC_F_AVAIL	7
+#define VRING_PACKED_DESC_F_USED	15
+
+/* The Host uses this in used->flags to advise the Guest: don't kick me when
+ * you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
+ * will still kick if it's out of buffers. */
+#define VRING_USED_F_NO_NOTIFY	1
+/* The Guest uses this in avail->flags to advise the Host: don't interrupt me
+ * when you consume a buffer.  It's unreliable, so it's simply an
+ * optimization.  */
+#define VRING_AVAIL_F_NO_INTERRUPT	1
+
+/* Enable events in packed ring. */
+#define VRING_PACKED_EVENT_FLAG_ENABLE	0x0
+/* Disable events in packed ring. */
+#define VRING_PACKED_EVENT_FLAG_DISABLE	0x1
+/*
+ * Enable events for a specific descriptor in packed ring.
+ * (as specified by Descriptor Ring Change Event Offset/Wrap Counter).
+ * Only valid if VIRTIO_RING_F_EVENT_IDX has been negotiated.
+ */
+#define VRING_PACKED_EVENT_FLAG_DESC	0x2
+
+/*
+ * Wrap counter bit shift in event suppression structure
+ * of packed ring.
+ */
+#define VRING_PACKED_EVENT_F_WRAP_CTR	15
+
+/* We support indirect buffer descriptors */
+#define VIRTIO_RING_F_INDIRECT_DESC	28
+
+/* The Guest publishes the used index for which it expects an interrupt
+ * at the end of the avail ring. Host should ignore the avail->flags field. */
+/* The Host publishes the avail index for which it expects a kick
+ * at the end of the used ring. Guest should ignore the used->flags field. */
+#define VIRTIO_RING_F_EVENT_IDX		29
+
+/* Alignment requirements for vring elements.
+ * When using pre-virtio 1.0 layout, these fall out naturally.
+ */
+#define VRING_AVAIL_ALIGN_SIZE 2
+#define VRING_USED_ALIGN_SIZE 4
+#define VRING_DESC_ALIGN_SIZE 16
+
+/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
+struct vring_desc {
+	/* Address (guest-physical). */
+	__virtio64 addr;
+	/* Length. */
+	__virtio32 len;
+	/* The flags as indicated above. */
+	__virtio16 flags;
+	/* We chain unused descriptors via this, too */
+	__virtio16 next;
+};
+
+struct vring_avail {
+	__virtio16 flags;
+	__virtio16 idx;
+	__virtio16 ring[];
+};
+
+/* uint32_t is used here for ids for padding reasons. */
+struct vring_used_elem {
+	/* Index of start of used descriptor chain. */
+	__virtio32 id;
+	/* Total length of the descriptor chain which was used (written to) */
+	__virtio32 len;
+};
+
+typedef struct vring_used_elem __attribute__((aligned(VRING_USED_ALIGN_SIZE)))
+	vring_used_elem_t;
+
+struct vring_used {
+	__virtio16 flags;
+	__virtio16 idx;
+	vring_used_elem_t ring[];
+};
+
+/*
+ * The ring element addresses are passed between components with different
+ * alignments assumptions. Thus, we might need to decrease the compiler-selected
+ * alignment, and so must use a typedef to make sure the aligned attribute
+ * actually takes hold:
+ *
+ * https://gcc.gnu.org/onlinedocs//gcc/Common-Type-Attributes.html#Common-Type-Attributes
+ *
+ * When used on a struct, or struct member, the aligned attribute can only
+ * increase the alignment; in order to decrease it, the packed attribute must
+ * be specified as well. When used as part of a typedef, the aligned attribute
+ * can both increase and decrease alignment, and specifying the packed
+ * attribute generates a warning.
+ */
+typedef struct vring_desc __attribute__((aligned(VRING_DESC_ALIGN_SIZE)))
+	vring_desc_t;
+typedef struct vring_avail __attribute__((aligned(VRING_AVAIL_ALIGN_SIZE)))
+	vring_avail_t;
+typedef struct vring_used __attribute__((aligned(VRING_USED_ALIGN_SIZE)))
+	vring_used_t;
+
+struct vring {
+	unsigned int num;
+
+	vring_desc_t *desc;
+
+	vring_avail_t *avail;
+
+	vring_used_t *used;
+};
+
+#ifndef VIRTIO_RING_NO_LEGACY
+
+/* The standard layout for the ring is a continuous chunk of memory which looks
+ * like this.  We assume num is a power of 2.
+ *
+ * struct vring
+ * {
+ *	// The actual descriptors (16 bytes each)
+ *	struct vring_desc desc[num];
+ *
+ *	// A ring of available descriptor heads with free-running index.
+ *	__virtio16 avail_flags;
+ *	__virtio16 avail_idx;
+ *	__virtio16 available[num];
+ *	__virtio16 used_event_idx;
+ *
+ *	// Padding to the next align boundary.
+ *	char pad[];
+ *
+ *	// A ring of used descriptor heads with free-running index.
+ *	__virtio16 used_flags;
+ *	__virtio16 used_idx;
+ *	struct vring_used_elem used[num];
+ *	__virtio16 avail_event_idx;
+ * };
+ */
+/* We publish the used event index at the end of the available ring, and vice
+ * versa. They are at the end for backwards compatibility. */
+#define vring_used_event(vr) ((vr)->avail->ring[(vr)->num])
+#define vring_avail_event(vr) (*(__virtio16 *)&(vr)->used->ring[(vr)->num])
+
+static inline void vring_init(struct vring *vr, unsigned int num, void *p,
+			      unsigned long align)
+{
+	vr->num = num;
+	vr->desc = p;
+	vr->avail = (struct vring_avail *)((char *)p + num * sizeof(struct vring_desc));
+	vr->used = (void *)(((uintptr_t)&vr->avail->ring[num] + sizeof(__virtio16)
+		+ align-1) & ~(align - 1));
+}
+
+static inline unsigned vring_size(unsigned int num, unsigned long align)
+{
+	return ((sizeof(struct vring_desc) * num + sizeof(__virtio16) * (3 + num)
+		 + align - 1) & ~(align - 1))
+		+ sizeof(__virtio16) * 3 + sizeof(struct vring_used_elem) * num;
+}
+
+#endif /* VIRTIO_RING_NO_LEGACY */
+
+/* The following is used with USED_EVENT_IDX and AVAIL_EVENT_IDX */
+/* Assuming a given event_idx value from the other side, if
+ * we have just incremented index from old to new_idx,
+ * should we trigger an event? */
+static inline int vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
+{
+	/* Note: Xen has similar logic for notification hold-off
+	 * in include/xen/interface/io/ring.h with req_event and req_prod
+	 * corresponding to event_idx + 1 and new_idx respectively.
+	 * Note also that req_event and req_prod in Xen start at 1,
+	 * event indexes in virtio start at 0. */
+	return (uint16_t)(new_idx - event_idx - 1) < (uint16_t)(new_idx - old);
+}
+
+struct vring_packed_desc_event {
+	/* Descriptor Ring Change Event Offset/Wrap Counter. */
+	uint16_t off_wrap;
+	/* Descriptor Ring Change Event Flags. */
+	uint16_t flags;
+};
+
+struct vring_packed_desc {
+	/* Buffer Address. */
+	uint64_t addr;
+	/* Buffer Length. */
+	uint32_t len;
+	/* Buffer ID. */
+	uint16_t id;
+	/* The flags depending on descriptor type. */
+	uint16_t flags;
+};
+
+#endif /* _LINUX_VIRTIO_RING_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_rng.h b/subprojects/libvhost-user/standard-headers/linux/virtio_rng.h
new file mode 100644
index 0000000..60fc798
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_rng.h
@@ -0,0 +1,8 @@
+#ifndef _LINUX_VIRTIO_RNG_H
+#define _LINUX_VIRTIO_RNG_H
+/* This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers. */
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+#endif /* _LINUX_VIRTIO_RNG_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_scsi.h b/subprojects/libvhost-user/standard-headers/linux/virtio_scsi.h
new file mode 100644
index 0000000..663f36c
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_scsi.h
@@ -0,0 +1,172 @@
+/*
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_VIRTIO_SCSI_H
+#define _LINUX_VIRTIO_SCSI_H
+
+#include "standard-headers/linux/virtio_types.h"
+
+/* Default values of the CDB and sense data size configuration fields */
+#define VIRTIO_SCSI_CDB_DEFAULT_SIZE   32
+#define VIRTIO_SCSI_SENSE_DEFAULT_SIZE 96
+
+#ifndef VIRTIO_SCSI_CDB_SIZE
+#define VIRTIO_SCSI_CDB_SIZE VIRTIO_SCSI_CDB_DEFAULT_SIZE
+#endif
+#ifndef VIRTIO_SCSI_SENSE_SIZE
+#define VIRTIO_SCSI_SENSE_SIZE VIRTIO_SCSI_SENSE_DEFAULT_SIZE
+#endif
+
+/* SCSI command request, followed by data-out */
+struct virtio_scsi_cmd_req {
+	uint8_t lun[8];		/* Logical Unit Number */
+	__virtio64 tag;		/* Command identifier */
+	uint8_t task_attr;		/* Task attribute */
+	uint8_t prio;		/* SAM command priority field */
+	uint8_t crn;
+	uint8_t cdb[VIRTIO_SCSI_CDB_SIZE];
+} QEMU_PACKED;
+
+/* SCSI command request, followed by protection information */
+struct virtio_scsi_cmd_req_pi {
+	uint8_t lun[8];		/* Logical Unit Number */
+	__virtio64 tag;		/* Command identifier */
+	uint8_t task_attr;		/* Task attribute */
+	uint8_t prio;		/* SAM command priority field */
+	uint8_t crn;
+	__virtio32 pi_bytesout;	/* DataOUT PI Number of bytes */
+	__virtio32 pi_bytesin;		/* DataIN PI Number of bytes */
+	uint8_t cdb[VIRTIO_SCSI_CDB_SIZE];
+} QEMU_PACKED;
+
+/* Response, followed by sense data and data-in */
+struct virtio_scsi_cmd_resp {
+	__virtio32 sense_len;		/* Sense data length */
+	__virtio32 resid;		/* Residual bytes in data buffer */
+	__virtio16 status_qualifier;	/* Status qualifier */
+	uint8_t status;		/* Command completion status */
+	uint8_t response;		/* Response values */
+	uint8_t sense[VIRTIO_SCSI_SENSE_SIZE];
+} QEMU_PACKED;
+
+/* Task Management Request */
+struct virtio_scsi_ctrl_tmf_req {
+	__virtio32 type;
+	__virtio32 subtype;
+	uint8_t lun[8];
+	__virtio64 tag;
+} QEMU_PACKED;
+
+struct virtio_scsi_ctrl_tmf_resp {
+	uint8_t response;
+} QEMU_PACKED;
+
+/* Asynchronous notification query/subscription */
+struct virtio_scsi_ctrl_an_req {
+	__virtio32 type;
+	uint8_t lun[8];
+	__virtio32 event_requested;
+} QEMU_PACKED;
+
+struct virtio_scsi_ctrl_an_resp {
+	__virtio32 event_actual;
+	uint8_t response;
+} QEMU_PACKED;
+
+struct virtio_scsi_event {
+	__virtio32 event;
+	uint8_t lun[8];
+	__virtio32 reason;
+} QEMU_PACKED;
+
+struct virtio_scsi_config {
+	__virtio32 num_queues;
+	__virtio32 seg_max;
+	__virtio32 max_sectors;
+	__virtio32 cmd_per_lun;
+	__virtio32 event_info_size;
+	__virtio32 sense_size;
+	__virtio32 cdb_size;
+	__virtio16 max_channel;
+	__virtio16 max_target;
+	__virtio32 max_lun;
+} QEMU_PACKED;
+
+/* Feature Bits */
+#define VIRTIO_SCSI_F_INOUT                    0
+#define VIRTIO_SCSI_F_HOTPLUG                  1
+#define VIRTIO_SCSI_F_CHANGE                   2
+#define VIRTIO_SCSI_F_T10_PI                   3
+
+/* Response codes */
+#define VIRTIO_SCSI_S_OK                       0
+#define VIRTIO_SCSI_S_OVERRUN                  1
+#define VIRTIO_SCSI_S_ABORTED                  2
+#define VIRTIO_SCSI_S_BAD_TARGET               3
+#define VIRTIO_SCSI_S_RESET                    4
+#define VIRTIO_SCSI_S_BUSY                     5
+#define VIRTIO_SCSI_S_TRANSPORT_FAILURE        6
+#define VIRTIO_SCSI_S_TARGET_FAILURE           7
+#define VIRTIO_SCSI_S_NEXUS_FAILURE            8
+#define VIRTIO_SCSI_S_FAILURE                  9
+#define VIRTIO_SCSI_S_FUNCTION_SUCCEEDED       10
+#define VIRTIO_SCSI_S_FUNCTION_REJECTED        11
+#define VIRTIO_SCSI_S_INCORRECT_LUN            12
+
+/* Controlq type codes.  */
+#define VIRTIO_SCSI_T_TMF                      0
+#define VIRTIO_SCSI_T_AN_QUERY                 1
+#define VIRTIO_SCSI_T_AN_SUBSCRIBE             2
+
+/* Valid TMF subtypes.  */
+#define VIRTIO_SCSI_T_TMF_ABORT_TASK           0
+#define VIRTIO_SCSI_T_TMF_ABORT_TASK_SET       1
+#define VIRTIO_SCSI_T_TMF_CLEAR_ACA            2
+#define VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET       3
+#define VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET      4
+#define VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET   5
+#define VIRTIO_SCSI_T_TMF_QUERY_TASK           6
+#define VIRTIO_SCSI_T_TMF_QUERY_TASK_SET       7
+
+/* Events.  */
+#define VIRTIO_SCSI_T_EVENTS_MISSED            0x80000000
+#define VIRTIO_SCSI_T_NO_EVENT                 0
+#define VIRTIO_SCSI_T_TRANSPORT_RESET          1
+#define VIRTIO_SCSI_T_ASYNC_NOTIFY             2
+#define VIRTIO_SCSI_T_PARAM_CHANGE             3
+
+/* Reasons of transport reset event */
+#define VIRTIO_SCSI_EVT_RESET_HARD             0
+#define VIRTIO_SCSI_EVT_RESET_RESCAN           1
+#define VIRTIO_SCSI_EVT_RESET_REMOVED          2
+
+#define VIRTIO_SCSI_S_SIMPLE                   0
+#define VIRTIO_SCSI_S_ORDERED                  1
+#define VIRTIO_SCSI_S_HEAD                     2
+#define VIRTIO_SCSI_S_ACA                      3
+
+
+#endif /* _LINUX_VIRTIO_SCSI_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_snd.h b/subprojects/libvhost-user/standard-headers/linux/virtio_snd.h
new file mode 100644
index 0000000..1af96b9
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_snd.h
@@ -0,0 +1,334 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright (C) 2021 OpenSynergy GmbH
+ */
+#ifndef VIRTIO_SND_IF_H
+#define VIRTIO_SND_IF_H
+
+#include "standard-headers/linux/virtio_types.h"
+
+/*******************************************************************************
+ * CONFIGURATION SPACE
+ */
+struct virtio_snd_config {
+	/* # of available physical jacks */
+	uint32_t jacks;
+	/* # of available PCM streams */
+	uint32_t streams;
+	/* # of available channel maps */
+	uint32_t chmaps;
+};
+
+enum {
+	/* device virtqueue indexes */
+	VIRTIO_SND_VQ_CONTROL = 0,
+	VIRTIO_SND_VQ_EVENT,
+	VIRTIO_SND_VQ_TX,
+	VIRTIO_SND_VQ_RX,
+	/* # of device virtqueues */
+	VIRTIO_SND_VQ_MAX
+};
+
+/*******************************************************************************
+ * COMMON DEFINITIONS
+ */
+
+/* supported dataflow directions */
+enum {
+	VIRTIO_SND_D_OUTPUT = 0,
+	VIRTIO_SND_D_INPUT
+};
+
+enum {
+	/* jack control request types */
+	VIRTIO_SND_R_JACK_INFO = 1,
+	VIRTIO_SND_R_JACK_REMAP,
+
+	/* PCM control request types */
+	VIRTIO_SND_R_PCM_INFO = 0x0100,
+	VIRTIO_SND_R_PCM_SET_PARAMS,
+	VIRTIO_SND_R_PCM_PREPARE,
+	VIRTIO_SND_R_PCM_RELEASE,
+	VIRTIO_SND_R_PCM_START,
+	VIRTIO_SND_R_PCM_STOP,
+
+	/* channel map control request types */
+	VIRTIO_SND_R_CHMAP_INFO = 0x0200,
+
+	/* jack event types */
+	VIRTIO_SND_EVT_JACK_CONNECTED = 0x1000,
+	VIRTIO_SND_EVT_JACK_DISCONNECTED,
+
+	/* PCM event types */
+	VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED = 0x1100,
+	VIRTIO_SND_EVT_PCM_XRUN,
+
+	/* common status codes */
+	VIRTIO_SND_S_OK = 0x8000,
+	VIRTIO_SND_S_BAD_MSG,
+	VIRTIO_SND_S_NOT_SUPP,
+	VIRTIO_SND_S_IO_ERR
+};
+
+/* common header */
+struct virtio_snd_hdr {
+	uint32_t code;
+};
+
+/* event notification */
+struct virtio_snd_event {
+	/* VIRTIO_SND_EVT_XXX */
+	struct virtio_snd_hdr hdr;
+	/* optional event data */
+	uint32_t data;
+};
+
+/* common control request to query an item information */
+struct virtio_snd_query_info {
+	/* VIRTIO_SND_R_XXX_INFO */
+	struct virtio_snd_hdr hdr;
+	/* item start identifier */
+	uint32_t start_id;
+	/* item count to query */
+	uint32_t count;
+	/* item information size in bytes */
+	uint32_t size;
+};
+
+/* common item information header */
+struct virtio_snd_info {
+	/* function group node id (High Definition Audio Specification 7.1.2) */
+	uint32_t hda_fn_nid;
+};
+
+/*******************************************************************************
+ * JACK CONTROL MESSAGES
+ */
+struct virtio_snd_jack_hdr {
+	/* VIRTIO_SND_R_JACK_XXX */
+	struct virtio_snd_hdr hdr;
+	/* 0 ... virtio_snd_config::jacks - 1 */
+	uint32_t jack_id;
+};
+
+/* supported jack features */
+enum {
+	VIRTIO_SND_JACK_F_REMAP = 0
+};
+
+struct virtio_snd_jack_info {
+	/* common header */
+	struct virtio_snd_info hdr;
+	/* supported feature bit map (1 << VIRTIO_SND_JACK_F_XXX) */
+	uint32_t features;
+	/* pin configuration (High Definition Audio Specification 7.3.3.31) */
+	uint32_t hda_reg_defconf;
+	/* pin capabilities (High Definition Audio Specification 7.3.4.9) */
+	uint32_t hda_reg_caps;
+	/* current jack connection status (0: disconnected, 1: connected) */
+	uint8_t connected;
+
+	uint8_t padding[7];
+};
+
+/* jack remapping control request */
+struct virtio_snd_jack_remap {
+	/* .code = VIRTIO_SND_R_JACK_REMAP */
+	struct virtio_snd_jack_hdr hdr;
+	/* selected association number */
+	uint32_t association;
+	/* selected sequence number */
+	uint32_t sequence;
+};
+
+/*******************************************************************************
+ * PCM CONTROL MESSAGES
+ */
+struct virtio_snd_pcm_hdr {
+	/* VIRTIO_SND_R_PCM_XXX */
+	struct virtio_snd_hdr hdr;
+	/* 0 ... virtio_snd_config::streams - 1 */
+	uint32_t stream_id;
+};
+
+/* supported PCM stream features */
+enum {
+	VIRTIO_SND_PCM_F_SHMEM_HOST = 0,
+	VIRTIO_SND_PCM_F_SHMEM_GUEST,
+	VIRTIO_SND_PCM_F_MSG_POLLING,
+	VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS,
+	VIRTIO_SND_PCM_F_EVT_XRUNS
+};
+
+/* supported PCM sample formats */
+enum {
+	/* analog formats (width / physical width) */
+	VIRTIO_SND_PCM_FMT_IMA_ADPCM = 0,	/*  4 /  4 bits */
+	VIRTIO_SND_PCM_FMT_MU_LAW,		/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_A_LAW,		/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_S8,			/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_U8,			/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_S16,			/* 16 / 16 bits */
+	VIRTIO_SND_PCM_FMT_U16,			/* 16 / 16 bits */
+	VIRTIO_SND_PCM_FMT_S18_3,		/* 18 / 24 bits */
+	VIRTIO_SND_PCM_FMT_U18_3,		/* 18 / 24 bits */
+	VIRTIO_SND_PCM_FMT_S20_3,		/* 20 / 24 bits */
+	VIRTIO_SND_PCM_FMT_U20_3,		/* 20 / 24 bits */
+	VIRTIO_SND_PCM_FMT_S24_3,		/* 24 / 24 bits */
+	VIRTIO_SND_PCM_FMT_U24_3,		/* 24 / 24 bits */
+	VIRTIO_SND_PCM_FMT_S20,			/* 20 / 32 bits */
+	VIRTIO_SND_PCM_FMT_U20,			/* 20 / 32 bits */
+	VIRTIO_SND_PCM_FMT_S24,			/* 24 / 32 bits */
+	VIRTIO_SND_PCM_FMT_U24,			/* 24 / 32 bits */
+	VIRTIO_SND_PCM_FMT_S32,			/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_U32,			/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_FLOAT,		/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_FLOAT64,		/* 64 / 64 bits */
+	/* digital formats (width / physical width) */
+	VIRTIO_SND_PCM_FMT_DSD_U8,		/*  8 /  8 bits */
+	VIRTIO_SND_PCM_FMT_DSD_U16,		/* 16 / 16 bits */
+	VIRTIO_SND_PCM_FMT_DSD_U32,		/* 32 / 32 bits */
+	VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME	/* 32 / 32 bits */
+};
+
+/* supported PCM frame rates */
+enum {
+	VIRTIO_SND_PCM_RATE_5512 = 0,
+	VIRTIO_SND_PCM_RATE_8000,
+	VIRTIO_SND_PCM_RATE_11025,
+	VIRTIO_SND_PCM_RATE_16000,
+	VIRTIO_SND_PCM_RATE_22050,
+	VIRTIO_SND_PCM_RATE_32000,
+	VIRTIO_SND_PCM_RATE_44100,
+	VIRTIO_SND_PCM_RATE_48000,
+	VIRTIO_SND_PCM_RATE_64000,
+	VIRTIO_SND_PCM_RATE_88200,
+	VIRTIO_SND_PCM_RATE_96000,
+	VIRTIO_SND_PCM_RATE_176400,
+	VIRTIO_SND_PCM_RATE_192000,
+	VIRTIO_SND_PCM_RATE_384000
+};
+
+struct virtio_snd_pcm_info {
+	/* common header */
+	struct virtio_snd_info hdr;
+	/* supported feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
+	uint32_t features;
+	/* supported sample format bit map (1 << VIRTIO_SND_PCM_FMT_XXX) */
+	uint64_t formats;
+	/* supported frame rate bit map (1 << VIRTIO_SND_PCM_RATE_XXX) */
+	uint64_t rates;
+	/* dataflow direction (VIRTIO_SND_D_XXX) */
+	uint8_t direction;
+	/* minimum # of supported channels */
+	uint8_t channels_min;
+	/* maximum # of supported channels */
+	uint8_t channels_max;
+
+	uint8_t padding[5];
+};
+
+/* set PCM stream format */
+struct virtio_snd_pcm_set_params {
+	/* .code = VIRTIO_SND_R_PCM_SET_PARAMS */
+	struct virtio_snd_pcm_hdr hdr;
+	/* size of the hardware buffer */
+	uint32_t buffer_bytes;
+	/* size of the hardware period */
+	uint32_t period_bytes;
+	/* selected feature bit map (1 << VIRTIO_SND_PCM_F_XXX) */
+	uint32_t features;
+	/* selected # of channels */
+	uint8_t channels;
+	/* selected sample format (VIRTIO_SND_PCM_FMT_XXX) */
+	uint8_t format;
+	/* selected frame rate (VIRTIO_SND_PCM_RATE_XXX) */
+	uint8_t rate;
+
+	uint8_t padding;
+};
+
+/*******************************************************************************
+ * PCM I/O MESSAGES
+ */
+
+/* I/O request header */
+struct virtio_snd_pcm_xfer {
+	/* 0 ... virtio_snd_config::streams - 1 */
+	uint32_t stream_id;
+};
+
+/* I/O request status */
+struct virtio_snd_pcm_status {
+	/* VIRTIO_SND_S_XXX */
+	uint32_t status;
+	/* current device latency */
+	uint32_t latency_bytes;
+};
+
+/*******************************************************************************
+ * CHANNEL MAP CONTROL MESSAGES
+ */
+struct virtio_snd_chmap_hdr {
+	/* VIRTIO_SND_R_CHMAP_XXX */
+	struct virtio_snd_hdr hdr;
+	/* 0 ... virtio_snd_config::chmaps - 1 */
+	uint32_t chmap_id;
+};
+
+/* standard channel position definition */
+enum {
+	VIRTIO_SND_CHMAP_NONE = 0,	/* undefined */
+	VIRTIO_SND_CHMAP_NA,		/* silent */
+	VIRTIO_SND_CHMAP_MONO,		/* mono stream */
+	VIRTIO_SND_CHMAP_FL,		/* front left */
+	VIRTIO_SND_CHMAP_FR,		/* front right */
+	VIRTIO_SND_CHMAP_RL,		/* rear left */
+	VIRTIO_SND_CHMAP_RR,		/* rear right */
+	VIRTIO_SND_CHMAP_FC,		/* front center */
+	VIRTIO_SND_CHMAP_LFE,		/* low frequency (LFE) */
+	VIRTIO_SND_CHMAP_SL,		/* side left */
+	VIRTIO_SND_CHMAP_SR,		/* side right */
+	VIRTIO_SND_CHMAP_RC,		/* rear center */
+	VIRTIO_SND_CHMAP_FLC,		/* front left center */
+	VIRTIO_SND_CHMAP_FRC,		/* front right center */
+	VIRTIO_SND_CHMAP_RLC,		/* rear left center */
+	VIRTIO_SND_CHMAP_RRC,		/* rear right center */
+	VIRTIO_SND_CHMAP_FLW,		/* front left wide */
+	VIRTIO_SND_CHMAP_FRW,		/* front right wide */
+	VIRTIO_SND_CHMAP_FLH,		/* front left high */
+	VIRTIO_SND_CHMAP_FCH,		/* front center high */
+	VIRTIO_SND_CHMAP_FRH,		/* front right high */
+	VIRTIO_SND_CHMAP_TC,		/* top center */
+	VIRTIO_SND_CHMAP_TFL,		/* top front left */
+	VIRTIO_SND_CHMAP_TFR,		/* top front right */
+	VIRTIO_SND_CHMAP_TFC,		/* top front center */
+	VIRTIO_SND_CHMAP_TRL,		/* top rear left */
+	VIRTIO_SND_CHMAP_TRR,		/* top rear right */
+	VIRTIO_SND_CHMAP_TRC,		/* top rear center */
+	VIRTIO_SND_CHMAP_TFLC,		/* top front left center */
+	VIRTIO_SND_CHMAP_TFRC,		/* top front right center */
+	VIRTIO_SND_CHMAP_TSL,		/* top side left */
+	VIRTIO_SND_CHMAP_TSR,		/* top side right */
+	VIRTIO_SND_CHMAP_LLFE,		/* left LFE */
+	VIRTIO_SND_CHMAP_RLFE,		/* right LFE */
+	VIRTIO_SND_CHMAP_BC,		/* bottom center */
+	VIRTIO_SND_CHMAP_BLC,		/* bottom left center */
+	VIRTIO_SND_CHMAP_BRC		/* bottom right center */
+};
+
+/* maximum possible number of channels */
+#define VIRTIO_SND_CHMAP_MAX_SIZE	18
+
+struct virtio_snd_chmap_info {
+	/* common header */
+	struct virtio_snd_info hdr;
+	/* dataflow direction (VIRTIO_SND_D_XXX) */
+	uint8_t direction;
+	/* # of valid channel position values */
+	uint8_t channels;
+	/* channel position values (VIRTIO_SND_CHMAP_XXX) */
+	uint8_t positions[VIRTIO_SND_CHMAP_MAX_SIZE];
+};
+
+#endif /* VIRTIO_SND_IF_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_types.h b/subprojects/libvhost-user/standard-headers/linux/virtio_types.h
new file mode 100644
index 0000000..fd0d351
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_types.h
@@ -0,0 +1,46 @@
+#ifndef _LINUX_VIRTIO_TYPES_H
+#define _LINUX_VIRTIO_TYPES_H
+/* Type definitions for virtio implementations.
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Copyright (C) 2014 Red Hat, Inc.
+ * Author: Michael S. Tsirkin <mst@redhat.com>
+ */
+#include "standard-headers/linux/types.h"
+
+/*
+ * __virtio{16,32,64} have the following meaning:
+ * - __u{16,32,64} for virtio devices in legacy mode, accessed in native endian
+ * - __le{16,32,64} for standard-compliant virtio devices
+ */
+
+typedef uint16_t  __virtio16;
+typedef uint32_t  __virtio32;
+typedef uint64_t  __virtio64;
+
+#endif /* _LINUX_VIRTIO_TYPES_H */
diff --git a/subprojects/libvhost-user/standard-headers/linux/virtio_vsock.h b/subprojects/libvhost-user/standard-headers/linux/virtio_vsock.h
new file mode 100644
index 0000000..3a23488
--- /dev/null
+++ b/subprojects/libvhost-user/standard-headers/linux/virtio_vsock.h
@@ -0,0 +1,103 @@
+/*
+ * This header, excluding the #ifdef __KERNEL__ part, is BSD licensed so
+ * anyone can use the definitions to implement compatible drivers/servers:
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Copyright (C) Red Hat, Inc., 2013-2015
+ * Copyright (C) Asias He <asias@redhat.com>, 2013
+ * Copyright (C) Stefan Hajnoczi <stefanha@redhat.com>, 2015
+ */
+
+#ifndef _LINUX_VIRTIO_VSOCK_H
+#define _LINUX_VIRTIO_VSOCK_H
+
+#include "standard-headers/linux/types.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include "standard-headers/linux/virtio_config.h"
+
+/* The feature bitmap for virtio vsock */
+#define VIRTIO_VSOCK_F_SEQPACKET	1	/* SOCK_SEQPACKET supported */
+
+struct virtio_vsock_config {
+	uint64_t guest_cid;
+} QEMU_PACKED;
+
+enum virtio_vsock_event_id {
+	VIRTIO_VSOCK_EVENT_TRANSPORT_RESET = 0,
+};
+
+struct virtio_vsock_event {
+	uint32_t id;
+} QEMU_PACKED;
+
+struct virtio_vsock_hdr {
+	uint64_t	src_cid;
+	uint64_t	dst_cid;
+	uint32_t	src_port;
+	uint32_t	dst_port;
+	uint32_t	len;
+	uint16_t	type;		/* enum virtio_vsock_type */
+	uint16_t	op;		/* enum virtio_vsock_op */
+	uint32_t	flags;
+	uint32_t	buf_alloc;
+	uint32_t	fwd_cnt;
+} QEMU_PACKED;
+
+enum virtio_vsock_type {
+	VIRTIO_VSOCK_TYPE_STREAM = 1,
+	VIRTIO_VSOCK_TYPE_SEQPACKET = 2,
+};
+
+enum virtio_vsock_op {
+	VIRTIO_VSOCK_OP_INVALID = 0,
+
+	/* Connect operations */
+	VIRTIO_VSOCK_OP_REQUEST = 1,
+	VIRTIO_VSOCK_OP_RESPONSE = 2,
+	VIRTIO_VSOCK_OP_RST = 3,
+	VIRTIO_VSOCK_OP_SHUTDOWN = 4,
+
+	/* To send payload */
+	VIRTIO_VSOCK_OP_RW = 5,
+
+	/* Tell the peer our credit info */
+	VIRTIO_VSOCK_OP_CREDIT_UPDATE = 6,
+	/* Request the peer to send the credit info to us */
+	VIRTIO_VSOCK_OP_CREDIT_REQUEST = 7,
+};
+
+/* VIRTIO_VSOCK_OP_SHUTDOWN flags values */
+enum virtio_vsock_shutdown {
+	VIRTIO_VSOCK_SHUTDOWN_RCV = 1,
+	VIRTIO_VSOCK_SHUTDOWN_SEND = 2,
+};
+
+/* VIRTIO_VSOCK_OP_RW flags values */
+enum virtio_vsock_rw {
+	VIRTIO_VSOCK_SEQ_EOR = 1,
+};
+
+#endif /* _LINUX_VIRTIO_VSOCK_H */
diff --git a/target/ppc/excp_helper.c b/target/ppc/excp_helper.c
index 17607ad..1c8b373 100644
--- a/target/ppc/excp_helper.c
+++ b/target/ppc/excp_helper.c
@@ -454,15 +454,13 @@ static inline void powerpc_excp(PowerPCCPU *cpu, int excp_model, int excp)
         break;
     }
     case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */
+        /* Get rS/rD and rA from faulting opcode */
         /*
-         * Get rS/rD and rA from faulting opcode.
-         * Note: We will only invoke ALIGN for atomic operations,
-         * so all instructions are X-form.
+         * Note: the opcode fields will not be set properly for a
+         * direct store load/store, but nobody cares as nobody
+         * actually uses direct store segments.
          */
-        {
-            uint32_t insn = cpu_ldl_code(env, env->nip);
-            env->spr[SPR_DSISR] |= (insn & 0x03FF0000) >> 16;
-        }
+        env->spr[SPR_DSISR] |= (env->error_code & 0x03FF0000) >> 16;
         break;
     case POWERPC_EXCP_PROGRAM:   /* Program exception                        */
         switch (env->error_code & ~0xF) {
@@ -1461,6 +1459,11 @@ void ppc_cpu_do_unaligned_access(CPUState *cs, vaddr vaddr,
                                  int mmu_idx, uintptr_t retaddr)
 {
     CPUPPCState *env = cs->env_ptr;
+    uint32_t insn;
+
+    /* Restore state and reload the insn we executed, for filling in DSISR.  */
+    cpu_restore_state(cs, retaddr, true);
+    insn = cpu_ldl_code(env, env->nip);
 
     switch (env->mmu_model) {
     case POWERPC_MMU_SOFT_4xx:
@@ -1477,8 +1480,8 @@ void ppc_cpu_do_unaligned_access(CPUState *cs, vaddr vaddr,
     }
 
     cs->exception_index = POWERPC_EXCP_ALIGN;
-    env->error_code = 0;
-    cpu_loop_exit_restore(cs, retaddr);
+    env->error_code = insn & 0x03FF0000;
+    cpu_loop_exit(cs);
 }
 #endif /* CONFIG_TCG */
 #endif /* !CONFIG_USER_ONLY */
diff --git a/target/ppc/excp_helper.c.orig b/target/ppc/excp_helper.c.orig
new file mode 100644
index 0000000..17607ad
--- /dev/null
+++ b/target/ppc/excp_helper.c.orig
@@ -0,0 +1,1484 @@
+/*
+ *  PowerPC exception emulation helpers for QEMU.
+ *
+ *  Copyright (c) 2003-2007 Jocelyn Mayer
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "qemu/osdep.h"
+#include "qemu/main-loop.h"
+#include "cpu.h"
+#include "exec/exec-all.h"
+#include "internal.h"
+#include "helper_regs.h"
+
+#include "trace.h"
+
+#ifdef CONFIG_TCG
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#endif
+
+/* #define DEBUG_SOFTWARE_TLB */
+
+/*****************************************************************************/
+/* Exception processing */
+#if !defined(CONFIG_USER_ONLY)
+
+static inline void dump_syscall(CPUPPCState *env)
+{
+    qemu_log_mask(CPU_LOG_INT, "syscall r0=%016" PRIx64
+                  " r3=%016" PRIx64 " r4=%016" PRIx64 " r5=%016" PRIx64
+                  " r6=%016" PRIx64 " r7=%016" PRIx64 " r8=%016" PRIx64
+                  " nip=" TARGET_FMT_lx "\n",
+                  ppc_dump_gpr(env, 0), ppc_dump_gpr(env, 3),
+                  ppc_dump_gpr(env, 4), ppc_dump_gpr(env, 5),
+                  ppc_dump_gpr(env, 6), ppc_dump_gpr(env, 7),
+                  ppc_dump_gpr(env, 8), env->nip);
+}
+
+static inline void dump_hcall(CPUPPCState *env)
+{
+    qemu_log_mask(CPU_LOG_INT, "hypercall r3=%016" PRIx64
+                  " r4=%016" PRIx64 " r5=%016" PRIx64 " r6=%016" PRIx64
+                  " r7=%016" PRIx64 " r8=%016" PRIx64 " r9=%016" PRIx64
+                  " r10=%016" PRIx64 " r11=%016" PRIx64 " r12=%016" PRIx64
+                  " nip=" TARGET_FMT_lx "\n",
+                  ppc_dump_gpr(env, 3), ppc_dump_gpr(env, 4),
+                  ppc_dump_gpr(env, 5), ppc_dump_gpr(env, 6),
+                  ppc_dump_gpr(env, 7), ppc_dump_gpr(env, 8),
+                  ppc_dump_gpr(env, 9), ppc_dump_gpr(env, 10),
+                  ppc_dump_gpr(env, 11), ppc_dump_gpr(env, 12),
+                  env->nip);
+}
+
+static int powerpc_reset_wakeup(CPUState *cs, CPUPPCState *env, int excp,
+                                target_ulong *msr)
+{
+    /* We no longer are in a PM state */
+    env->resume_as_sreset = false;
+
+    /* Pretend to be returning from doze always as we don't lose state */
+    *msr |= SRR1_WS_NOLOSS;
+
+    /* Machine checks are sent normally */
+    if (excp == POWERPC_EXCP_MCHECK) {
+        return excp;
+    }
+    switch (excp) {
+    case POWERPC_EXCP_RESET:
+        *msr |= SRR1_WAKERESET;
+        break;
+    case POWERPC_EXCP_EXTERNAL:
+        *msr |= SRR1_WAKEEE;
+        break;
+    case POWERPC_EXCP_DECR:
+        *msr |= SRR1_WAKEDEC;
+        break;
+    case POWERPC_EXCP_SDOOR:
+        *msr |= SRR1_WAKEDBELL;
+        break;
+    case POWERPC_EXCP_SDOOR_HV:
+        *msr |= SRR1_WAKEHDBELL;
+        break;
+    case POWERPC_EXCP_HV_MAINT:
+        *msr |= SRR1_WAKEHMI;
+        break;
+    case POWERPC_EXCP_HVIRT:
+        *msr |= SRR1_WAKEHVI;
+        break;
+    default:
+        cpu_abort(cs, "Unsupported exception %d in Power Save mode\n",
+                  excp);
+    }
+    return POWERPC_EXCP_RESET;
+}
+
+/*
+ * AIL - Alternate Interrupt Location, a mode that allows interrupts to be
+ * taken with the MMU on, and which uses an alternate location (e.g., so the
+ * kernel/hv can map the vectors there with an effective address).
+ *
+ * An interrupt is considered to be taken "with AIL" or "AIL applies" if they
+ * are delivered in this way. AIL requires the LPCR to be set to enable this
+ * mode, and then a number of conditions have to be true for AIL to apply.
+ *
+ * First of all, SRESET, MCE, and HMI are always delivered without AIL, because
+ * they specifically want to be in real mode (e.g., the MCE might be signaling
+ * a SLB multi-hit which requires SLB flush before the MMU can be enabled).
+ *
+ * After that, behaviour depends on the current MSR[IR], MSR[DR], MSR[HV],
+ * whether or not the interrupt changes MSR[HV] from 0 to 1, and the current
+ * radix mode (LPCR[HR]).
+ *
+ * POWER8, POWER9 with LPCR[HR]=0
+ * | LPCR[AIL] | MSR[IR||DR] | MSR[HV] | new MSR[HV] | AIL |
+ * +-----------+-------------+---------+-------------+-----+
+ * | a         | 00/01/10    | x       | x           | 0   |
+ * | a         | 11          | 0       | 1           | 0   |
+ * | a         | 11          | 1       | 1           | a   |
+ * | a         | 11          | 0       | 0           | a   |
+ * +-------------------------------------------------------+
+ *
+ * POWER9 with LPCR[HR]=1
+ * | LPCR[AIL] | MSR[IR||DR] | MSR[HV] | new MSR[HV] | AIL |
+ * +-----------+-------------+---------+-------------+-----+
+ * | a         | 00/01/10    | x       | x           | 0   |
+ * | a         | 11          | x       | x           | a   |
+ * +-------------------------------------------------------+
+ *
+ * The difference with POWER9 being that MSR[HV] 0->1 interrupts can be sent to
+ * the hypervisor in AIL mode if the guest is radix. This is good for
+ * performance but allows the guest to influence the AIL of hypervisor
+ * interrupts using its MSR, and also the hypervisor must disallow guest
+ * interrupts (MSR[HV] 0->0) from using AIL if the hypervisor does not want to
+ * use AIL for its MSR[HV] 0->1 interrupts.
+ *
+ * POWER10 addresses those issues with a new LPCR[HAIL] bit that is applied to
+ * interrupts that begin execution with MSR[HV]=1 (so both MSR[HV] 0->1 and
+ * MSR[HV] 1->1).
+ *
+ * HAIL=1 is equivalent to AIL=3, for interrupts delivered with MSR[HV]=1.
+ *
+ * POWER10 behaviour is
+ * | LPCR[AIL] | LPCR[HAIL] | MSR[IR||DR] | MSR[HV] | new MSR[HV] | AIL |
+ * +-----------+------------+-------------+---------+-------------+-----+
+ * | a         | h          | 00/01/10    | 0       | 0           | 0   |
+ * | a         | h          | 11          | 0       | 0           | a   |
+ * | a         | h          | x           | 0       | 1           | h   |
+ * | a         | h          | 00/01/10    | 1       | 1           | 0   |
+ * | a         | h          | 11          | 1       | 1           | h   |
+ * +--------------------------------------------------------------------+
+ */
+static inline void ppc_excp_apply_ail(PowerPCCPU *cpu, int excp_model, int excp,
+                                      target_ulong msr,
+                                      target_ulong *new_msr,
+                                      target_ulong *vector)
+{
+#if defined(TARGET_PPC64)
+    CPUPPCState *env = &cpu->env;
+    bool mmu_all_on = ((msr >> MSR_IR) & 1) && ((msr >> MSR_DR) & 1);
+    bool hv_escalation = !(msr & MSR_HVB) && (*new_msr & MSR_HVB);
+    int ail = 0;
+
+    if (excp == POWERPC_EXCP_MCHECK ||
+        excp == POWERPC_EXCP_RESET ||
+        excp == POWERPC_EXCP_HV_MAINT) {
+        /* SRESET, MCE, HMI never apply AIL */
+        return;
+    }
+
+    if (excp_model == POWERPC_EXCP_POWER8 ||
+        excp_model == POWERPC_EXCP_POWER9) {
+        if (!mmu_all_on) {
+            /* AIL only works if MSR[IR] and MSR[DR] are both enabled. */
+            return;
+        }
+        if (hv_escalation && !(env->spr[SPR_LPCR] & LPCR_HR)) {
+            /*
+             * AIL does not work if there is a MSR[HV] 0->1 transition and the
+             * partition is in HPT mode. For radix guests, such interrupts are
+             * allowed to be delivered to the hypervisor in ail mode.
+             */
+            return;
+        }
+
+        ail = (env->spr[SPR_LPCR] & LPCR_AIL) >> LPCR_AIL_SHIFT;
+        if (ail == 0) {
+            return;
+        }
+        if (ail == 1) {
+            /* AIL=1 is reserved, treat it like AIL=0 */
+            return;
+        }
+
+    } else if (excp_model == POWERPC_EXCP_POWER10) {
+        if (!mmu_all_on && !hv_escalation) {
+            /*
+             * AIL works for HV interrupts even with guest MSR[IR/DR] disabled.
+             * Guest->guest and HV->HV interrupts do require MMU on.
+             */
+            return;
+        }
+
+        if (*new_msr & MSR_HVB) {
+            if (!(env->spr[SPR_LPCR] & LPCR_HAIL)) {
+                /* HV interrupts depend on LPCR[HAIL] */
+                return;
+            }
+            ail = 3; /* HAIL=1 gives AIL=3 behaviour for HV interrupts */
+        } else {
+            ail = (env->spr[SPR_LPCR] & LPCR_AIL) >> LPCR_AIL_SHIFT;
+        }
+        if (ail == 0) {
+            return;
+        }
+        if (ail == 1 || ail == 2) {
+            /* AIL=1 and AIL=2 are reserved, treat them like AIL=0 */
+            return;
+        }
+    } else {
+        /* Other processors do not support AIL */
+        return;
+    }
+
+    /*
+     * AIL applies, so the new MSR gets IR and DR set, and an offset applied
+     * to the new IP.
+     */
+    *new_msr |= (1 << MSR_IR) | (1 << MSR_DR);
+
+    if (excp != POWERPC_EXCP_SYSCALL_VECTORED) {
+        if (ail == 2) {
+            *vector |= 0x0000000000018000ull;
+        } else if (ail == 3) {
+            *vector |= 0xc000000000004000ull;
+        }
+    } else {
+        /*
+         * scv AIL is a little different. AIL=2 does not change the address,
+         * only the MSR. AIL=3 replaces the 0x17000 base with 0xc...3000.
+         */
+        if (ail == 3) {
+            *vector &= ~0x0000000000017000ull; /* Un-apply the base offset */
+            *vector |= 0xc000000000003000ull; /* Apply scv's AIL=3 offset */
+        }
+    }
+#endif
+}
+
+static inline void powerpc_set_excp_state(PowerPCCPU *cpu,
+                                          target_ulong vector, target_ulong msr)
+{
+    CPUState *cs = CPU(cpu);
+    CPUPPCState *env = &cpu->env;
+
+    /*
+     * We don't use hreg_store_msr here as already have treated any
+     * special case that could occur. Just store MSR and update hflags
+     *
+     * Note: We *MUST* not use hreg_store_msr() as-is anyway because it
+     * will prevent setting of the HV bit which some exceptions might need
+     * to do.
+     */
+    env->msr = msr & env->msr_mask;
+    hreg_compute_hflags(env);
+    env->nip = vector;
+    /* Reset exception state */
+    cs->exception_index = POWERPC_EXCP_NONE;
+    env->error_code = 0;
+
+    /* Reset the reservation */
+    env->reserve_addr = -1;
+
+    /*
+     * Any interrupt is context synchronizing, check if TCG TLB needs
+     * a delayed flush on ppc64
+     */
+    check_tlb_flush(env, false);
+}
+
+/*
+ * Note that this function should be greatly optimized when called
+ * with a constant excp, from ppc_hw_interrupt
+ */
+static inline void powerpc_excp(PowerPCCPU *cpu, int excp_model, int excp)
+{
+    CPUState *cs = CPU(cpu);
+    CPUPPCState *env = &cpu->env;
+    target_ulong msr, new_msr, vector;
+    int srr0, srr1, asrr0, asrr1, lev = -1;
+
+    qemu_log_mask(CPU_LOG_INT, "Raise exception at " TARGET_FMT_lx
+                  " => %08x (%02x)\n", env->nip, excp, env->error_code);
+
+    /* new srr1 value excluding must-be-zero bits */
+    if (excp_model == POWERPC_EXCP_BOOKE) {
+        msr = env->msr;
+    } else {
+        msr = env->msr & ~0x783f0000ULL;
+    }
+
+    /*
+     * new interrupt handler msr preserves existing HV and ME unless
+     * explicitly overriden
+     */
+    new_msr = env->msr & (((target_ulong)1 << MSR_ME) | MSR_HVB);
+
+    /* target registers */
+    srr0 = SPR_SRR0;
+    srr1 = SPR_SRR1;
+    asrr0 = -1;
+    asrr1 = -1;
+
+    /*
+     * check for special resume at 0x100 from doze/nap/sleep/winkle on
+     * P7/P8/P9
+     */
+    if (env->resume_as_sreset) {
+        excp = powerpc_reset_wakeup(cs, env, excp, &msr);
+    }
+
+    /*
+     * Hypervisor emulation assistance interrupt only exists on server
+     * arch 2.05 server or later. We also don't want to generate it if
+     * we don't have HVB in msr_mask (PAPR mode).
+     */
+    if (excp == POWERPC_EXCP_HV_EMU
+#if defined(TARGET_PPC64)
+        && !(mmu_is_64bit(env->mmu_model) && (env->msr_mask & MSR_HVB))
+#endif /* defined(TARGET_PPC64) */
+
+    ) {
+        excp = POWERPC_EXCP_PROGRAM;
+    }
+
+    switch (excp) {
+    case POWERPC_EXCP_NONE:
+        /* Should never happen */
+        return;
+    case POWERPC_EXCP_CRITICAL:    /* Critical input                         */
+        switch (excp_model) {
+        case POWERPC_EXCP_40x:
+            srr0 = SPR_40x_SRR2;
+            srr1 = SPR_40x_SRR3;
+            break;
+        case POWERPC_EXCP_BOOKE:
+            srr0 = SPR_BOOKE_CSRR0;
+            srr1 = SPR_BOOKE_CSRR1;
+            break;
+        case POWERPC_EXCP_G2:
+            break;
+        default:
+            goto excp_invalid;
+        }
+        break;
+    case POWERPC_EXCP_MCHECK:    /* Machine check exception                  */
+        if (msr_me == 0) {
+            /*
+             * Machine check exception is not enabled.  Enter
+             * checkstop state.
+             */
+            fprintf(stderr, "Machine check while not allowed. "
+                    "Entering checkstop state\n");
+            if (qemu_log_separate()) {
+                qemu_log("Machine check while not allowed. "
+                        "Entering checkstop state\n");
+            }
+            cs->halted = 1;
+            cpu_interrupt_exittb(cs);
+        }
+        if (env->msr_mask & MSR_HVB) {
+            /*
+             * ISA specifies HV, but can be delivered to guest with HV
+             * clear (e.g., see FWNMI in PAPR).
+             */
+            new_msr |= (target_ulong)MSR_HVB;
+        }
+
+        /* machine check exceptions don't have ME set */
+        new_msr &= ~((target_ulong)1 << MSR_ME);
+
+        /* XXX: should also have something loaded in DAR / DSISR */
+        switch (excp_model) {
+        case POWERPC_EXCP_40x:
+            srr0 = SPR_40x_SRR2;
+            srr1 = SPR_40x_SRR3;
+            break;
+        case POWERPC_EXCP_BOOKE:
+            /* FIXME: choose one or the other based on CPU type */
+            srr0 = SPR_BOOKE_MCSRR0;
+            srr1 = SPR_BOOKE_MCSRR1;
+            asrr0 = SPR_BOOKE_CSRR0;
+            asrr1 = SPR_BOOKE_CSRR1;
+            break;
+        default:
+            break;
+        }
+        break;
+    case POWERPC_EXCP_DSI:       /* Data storage exception                   */
+        trace_ppc_excp_dsi(env->spr[SPR_DSISR], env->spr[SPR_DAR]);
+        break;
+    case POWERPC_EXCP_ISI:       /* Instruction storage exception            */
+        trace_ppc_excp_isi(msr, env->nip);
+        msr |= env->error_code;
+        break;
+    case POWERPC_EXCP_EXTERNAL:  /* External input                           */
+    {
+        bool lpes0;
+
+        cs = CPU(cpu);
+
+        /*
+         * Exception targeting modifiers
+         *
+         * LPES0 is supported on POWER7/8/9
+         * LPES1 is not supported (old iSeries mode)
+         *
+         * On anything else, we behave as if LPES0 is 1
+         * (externals don't alter MSR:HV)
+         */
+#if defined(TARGET_PPC64)
+        if (excp_model == POWERPC_EXCP_POWER7 ||
+            excp_model == POWERPC_EXCP_POWER8 ||
+            excp_model == POWERPC_EXCP_POWER9 ||
+            excp_model == POWERPC_EXCP_POWER10) {
+            lpes0 = !!(env->spr[SPR_LPCR] & LPCR_LPES0);
+        } else
+#endif /* defined(TARGET_PPC64) */
+        {
+            lpes0 = true;
+        }
+
+        if (!lpes0) {
+            new_msr |= (target_ulong)MSR_HVB;
+            new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
+            srr0 = SPR_HSRR0;
+            srr1 = SPR_HSRR1;
+        }
+        if (env->mpic_proxy) {
+            /* IACK the IRQ on delivery */
+            env->spr[SPR_BOOKE_EPR] = ldl_phys(cs->as, env->mpic_iack);
+        }
+        break;
+    }
+    case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */
+        /*
+         * Get rS/rD and rA from faulting opcode.
+         * Note: We will only invoke ALIGN for atomic operations,
+         * so all instructions are X-form.
+         */
+        {
+            uint32_t insn = cpu_ldl_code(env, env->nip);
+            env->spr[SPR_DSISR] |= (insn & 0x03FF0000) >> 16;
+        }
+        break;
+    case POWERPC_EXCP_PROGRAM:   /* Program exception                        */
+        switch (env->error_code & ~0xF) {
+        case POWERPC_EXCP_FP:
+            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {
+                trace_ppc_excp_fp_ignore();
+                cs->exception_index = POWERPC_EXCP_NONE;
+                env->error_code = 0;
+                return;
+            }
+
+            /*
+             * FP exceptions always have NIP pointing to the faulting
+             * instruction, so always use store_next and claim we are
+             * precise in the MSR.
+             */
+            msr |= 0x00100000;
+            env->spr[SPR_BOOKE_ESR] = ESR_FP;
+            break;
+        case POWERPC_EXCP_INVAL:
+            trace_ppc_excp_inval(env->nip);
+            msr |= 0x00080000;
+            env->spr[SPR_BOOKE_ESR] = ESR_PIL;
+            break;
+        case POWERPC_EXCP_PRIV:
+            msr |= 0x00040000;
+            env->spr[SPR_BOOKE_ESR] = ESR_PPR;
+            break;
+        case POWERPC_EXCP_TRAP:
+            msr |= 0x00020000;
+            env->spr[SPR_BOOKE_ESR] = ESR_PTR;
+            break;
+        default:
+            /* Should never occur */
+            cpu_abort(cs, "Invalid program exception %d. Aborting\n",
+                      env->error_code);
+            break;
+        }
+        break;
+    case POWERPC_EXCP_SYSCALL:   /* System call exception                    */
+        lev = env->error_code;
+
+        if ((lev == 1) && cpu->vhyp) {
+            dump_hcall(env);
+        } else {
+            dump_syscall(env);
+        }
+
+        /*
+         * We need to correct the NIP which in this case is supposed
+         * to point to the next instruction
+         */
+        env->nip += 4;
+
+        /* "PAPR mode" built-in hypercall emulation */
+        if ((lev == 1) && cpu->vhyp) {
+            PPCVirtualHypervisorClass *vhc =
+                PPC_VIRTUAL_HYPERVISOR_GET_CLASS(cpu->vhyp);
+            vhc->hypercall(cpu->vhyp, cpu);
+            return;
+        }
+        if (lev == 1) {
+            new_msr |= (target_ulong)MSR_HVB;
+        }
+        break;
+    case POWERPC_EXCP_SYSCALL_VECTORED: /* scv exception                     */
+        lev = env->error_code;
+        dump_syscall(env);
+        env->nip += 4;
+        new_msr |= env->msr & ((target_ulong)1 << MSR_EE);
+        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
+        break;
+    case POWERPC_EXCP_FPU:       /* Floating-point unavailable exception     */
+    case POWERPC_EXCP_APU:       /* Auxiliary processor unavailable          */
+    case POWERPC_EXCP_DECR:      /* Decrementer exception                    */
+        break;
+    case POWERPC_EXCP_FIT:       /* Fixed-interval timer interrupt           */
+        /* FIT on 4xx */
+        trace_ppc_excp_print("FIT");
+        break;
+    case POWERPC_EXCP_WDT:       /* Watchdog timer interrupt                 */
+        trace_ppc_excp_print("WDT");
+        switch (excp_model) {
+        case POWERPC_EXCP_BOOKE:
+            srr0 = SPR_BOOKE_CSRR0;
+            srr1 = SPR_BOOKE_CSRR1;
+            break;
+        default:
+            break;
+        }
+        break;
+    case POWERPC_EXCP_DTLB:      /* Data TLB error                           */
+    case POWERPC_EXCP_ITLB:      /* Instruction TLB error                    */
+        break;
+    case POWERPC_EXCP_DEBUG:     /* Debug interrupt                          */
+        if (env->flags & POWERPC_FLAG_DE) {
+            /* FIXME: choose one or the other based on CPU type */
+            srr0 = SPR_BOOKE_DSRR0;
+            srr1 = SPR_BOOKE_DSRR1;
+            asrr0 = SPR_BOOKE_CSRR0;
+            asrr1 = SPR_BOOKE_CSRR1;
+            /* DBSR already modified by caller */
+        } else {
+            cpu_abort(cs, "Debug exception triggered on unsupported model\n");
+        }
+        break;
+    case POWERPC_EXCP_SPEU:      /* SPE/embedded floating-point unavailable  */
+        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
+        break;
+    case POWERPC_EXCP_EFPDI:     /* Embedded floating-point data interrupt   */
+        /* XXX: TODO */
+        cpu_abort(cs, "Embedded floating point data exception "
+                  "is not implemented yet !\n");
+        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
+        break;
+    case POWERPC_EXCP_EFPRI:     /* Embedded floating-point round interrupt  */
+        /* XXX: TODO */
+        cpu_abort(cs, "Embedded floating point round exception "
+                  "is not implemented yet !\n");
+        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
+        break;
+    case POWERPC_EXCP_EPERFM:    /* Embedded performance monitor interrupt   */
+        /* XXX: TODO */
+        cpu_abort(cs,
+                  "Performance counter exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_DOORI:     /* Embedded doorbell interrupt              */
+        break;
+    case POWERPC_EXCP_DOORCI:    /* Embedded doorbell critical interrupt     */
+        srr0 = SPR_BOOKE_CSRR0;
+        srr1 = SPR_BOOKE_CSRR1;
+        break;
+    case POWERPC_EXCP_RESET:     /* System reset exception                   */
+        /* A power-saving exception sets ME, otherwise it is unchanged */
+        if (msr_pow) {
+            /* indicate that we resumed from power save mode */
+            msr |= 0x10000;
+            new_msr |= ((target_ulong)1 << MSR_ME);
+        }
+        if (env->msr_mask & MSR_HVB) {
+            /*
+             * ISA specifies HV, but can be delivered to guest with HV
+             * clear (e.g., see FWNMI in PAPR, NMI injection in QEMU).
+             */
+            new_msr |= (target_ulong)MSR_HVB;
+        } else {
+            if (msr_pow) {
+                cpu_abort(cs, "Trying to deliver power-saving system reset "
+                          "exception %d with no HV support\n", excp);
+            }
+        }
+        break;
+    case POWERPC_EXCP_DSEG:      /* Data segment exception                   */
+    case POWERPC_EXCP_ISEG:      /* Instruction segment exception            */
+    case POWERPC_EXCP_TRACE:     /* Trace exception                          */
+        break;
+    case POWERPC_EXCP_HISI:      /* Hypervisor instruction storage exception */
+        msr |= env->error_code;
+        /* fall through */
+    case POWERPC_EXCP_HDECR:     /* Hypervisor decrementer exception         */
+    case POWERPC_EXCP_HDSI:      /* Hypervisor data storage exception        */
+    case POWERPC_EXCP_HDSEG:     /* Hypervisor data segment exception        */
+    case POWERPC_EXCP_HISEG:     /* Hypervisor instruction segment exception */
+    case POWERPC_EXCP_SDOOR_HV:  /* Hypervisor Doorbell interrupt            */
+    case POWERPC_EXCP_HV_EMU:
+    case POWERPC_EXCP_HVIRT:     /* Hypervisor virtualization                */
+        srr0 = SPR_HSRR0;
+        srr1 = SPR_HSRR1;
+        new_msr |= (target_ulong)MSR_HVB;
+        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
+        break;
+    case POWERPC_EXCP_VPU:       /* Vector unavailable exception             */
+    case POWERPC_EXCP_VSXU:       /* VSX unavailable exception               */
+    case POWERPC_EXCP_FU:         /* Facility unavailable exception          */
+#ifdef TARGET_PPC64
+        env->spr[SPR_FSCR] |= ((target_ulong)env->error_code << 56);
+#endif
+        break;
+    case POWERPC_EXCP_HV_FU:     /* Hypervisor Facility Unavailable Exception */
+#ifdef TARGET_PPC64
+        env->spr[SPR_HFSCR] |= ((target_ulong)env->error_code << FSCR_IC_POS);
+        srr0 = SPR_HSRR0;
+        srr1 = SPR_HSRR1;
+        new_msr |= (target_ulong)MSR_HVB;
+        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
+#endif
+        break;
+    case POWERPC_EXCP_PIT:       /* Programmable interval timer interrupt    */
+        trace_ppc_excp_print("PIT");
+        break;
+    case POWERPC_EXCP_IO:        /* IO error exception                       */
+        /* XXX: TODO */
+        cpu_abort(cs, "601 IO error exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_RUNM:      /* Run mode exception                       */
+        /* XXX: TODO */
+        cpu_abort(cs, "601 run mode exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_EMUL:      /* Emulation trap exception                 */
+        /* XXX: TODO */
+        cpu_abort(cs, "602 emulation trap exception "
+                  "is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_IFTLB:     /* Instruction fetch TLB error              */
+    case POWERPC_EXCP_DLTLB:     /* Data load TLB miss                       */
+    case POWERPC_EXCP_DSTLB:     /* Data store TLB miss                      */
+        switch (excp_model) {
+        case POWERPC_EXCP_602:
+        case POWERPC_EXCP_603:
+        case POWERPC_EXCP_603E:
+        case POWERPC_EXCP_G2:
+            /* Swap temporary saved registers with GPRs */
+            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {
+                new_msr |= (target_ulong)1 << MSR_TGPR;
+                hreg_swap_gpr_tgpr(env);
+            }
+            /* fall through */
+        case POWERPC_EXCP_7x5:
+#if defined(DEBUG_SOFTWARE_TLB)
+            if (qemu_log_enabled()) {
+                const char *es;
+                target_ulong *miss, *cmp;
+                int en;
+
+                if (excp == POWERPC_EXCP_IFTLB) {
+                    es = "I";
+                    en = 'I';
+                    miss = &env->spr[SPR_IMISS];
+                    cmp = &env->spr[SPR_ICMP];
+                } else {
+                    if (excp == POWERPC_EXCP_DLTLB) {
+                        es = "DL";
+                    } else {
+                        es = "DS";
+                    }
+                    en = 'D';
+                    miss = &env->spr[SPR_DMISS];
+                    cmp = &env->spr[SPR_DCMP];
+                }
+                qemu_log("6xx %sTLB miss: %cM " TARGET_FMT_lx " %cC "
+                         TARGET_FMT_lx " H1 " TARGET_FMT_lx " H2 "
+                         TARGET_FMT_lx " %08x\n", es, en, *miss, en, *cmp,
+                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],
+                         env->error_code);
+            }
+#endif
+            msr |= env->crf[0] << 28;
+            msr |= env->error_code; /* key, D/I, S/L bits */
+            /* Set way using a LRU mechanism */
+            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;
+            break;
+        case POWERPC_EXCP_74xx:
+#if defined(DEBUG_SOFTWARE_TLB)
+            if (qemu_log_enabled()) {
+                const char *es;
+                target_ulong *miss, *cmp;
+                int en;
+
+                if (excp == POWERPC_EXCP_IFTLB) {
+                    es = "I";
+                    en = 'I';
+                    miss = &env->spr[SPR_TLBMISS];
+                    cmp = &env->spr[SPR_PTEHI];
+                } else {
+                    if (excp == POWERPC_EXCP_DLTLB) {
+                        es = "DL";
+                    } else {
+                        es = "DS";
+                    }
+                    en = 'D';
+                    miss = &env->spr[SPR_TLBMISS];
+                    cmp = &env->spr[SPR_PTEHI];
+                }
+                qemu_log("74xx %sTLB miss: %cM " TARGET_FMT_lx " %cC "
+                         TARGET_FMT_lx " %08x\n", es, en, *miss, en, *cmp,
+                         env->error_code);
+            }
+#endif
+            msr |= env->error_code; /* key bit */
+            break;
+        default:
+            cpu_abort(cs, "Invalid TLB miss exception\n");
+            break;
+        }
+        break;
+    case POWERPC_EXCP_FPA:       /* Floating-point assist exception          */
+        /* XXX: TODO */
+        cpu_abort(cs, "Floating point assist exception "
+                  "is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_DABR:      /* Data address breakpoint                  */
+        /* XXX: TODO */
+        cpu_abort(cs, "DABR exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_IABR:      /* Instruction address breakpoint           */
+        /* XXX: TODO */
+        cpu_abort(cs, "IABR exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_SMI:       /* System management interrupt              */
+        /* XXX: TODO */
+        cpu_abort(cs, "SMI exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_THERM:     /* Thermal interrupt                        */
+        /* XXX: TODO */
+        cpu_abort(cs, "Thermal management exception "
+                  "is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_PERFM:     /* Embedded performance monitor interrupt   */
+        /* XXX: TODO */
+        cpu_abort(cs,
+                  "Performance counter exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_VPUA:      /* Vector assist exception                  */
+        /* XXX: TODO */
+        cpu_abort(cs, "VPU assist exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_SOFTP:     /* Soft patch exception                     */
+        /* XXX: TODO */
+        cpu_abort(cs,
+                  "970 soft-patch exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_MAINT:     /* Maintenance exception                    */
+        /* XXX: TODO */
+        cpu_abort(cs,
+                  "970 maintenance exception is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_MEXTBR:    /* Maskable external breakpoint             */
+        /* XXX: TODO */
+        cpu_abort(cs, "Maskable external exception "
+                  "is not implemented yet !\n");
+        break;
+    case POWERPC_EXCP_NMEXTBR:   /* Non maskable external breakpoint         */
+        /* XXX: TODO */
+        cpu_abort(cs, "Non maskable external exception "
+                  "is not implemented yet !\n");
+        break;
+    default:
+    excp_invalid:
+        cpu_abort(cs, "Invalid PowerPC exception %d. Aborting\n", excp);
+        break;
+    }
+
+    /* Sanity check */
+    if (!(env->msr_mask & MSR_HVB)) {
+        if (new_msr & MSR_HVB) {
+            cpu_abort(cs, "Trying to deliver HV exception (MSR) %d with "
+                      "no HV support\n", excp);
+        }
+        if (srr0 == SPR_HSRR0) {
+            cpu_abort(cs, "Trying to deliver HV exception (HSRR) %d with "
+                      "no HV support\n", excp);
+        }
+    }
+
+    /*
+     * Sort out endianness of interrupt, this differs depending on the
+     * CPU, the HV mode, etc...
+     */
+#ifdef TARGET_PPC64
+    if (excp_model == POWERPC_EXCP_POWER7) {
+        if (!(new_msr & MSR_HVB) && (env->spr[SPR_LPCR] & LPCR_ILE)) {
+            new_msr |= (target_ulong)1 << MSR_LE;
+        }
+    } else if (excp_model == POWERPC_EXCP_POWER8) {
+        if (new_msr & MSR_HVB) {
+            if (env->spr[SPR_HID0] & HID0_HILE) {
+                new_msr |= (target_ulong)1 << MSR_LE;
+            }
+        } else if (env->spr[SPR_LPCR] & LPCR_ILE) {
+            new_msr |= (target_ulong)1 << MSR_LE;
+        }
+    } else if (excp_model == POWERPC_EXCP_POWER9 ||
+               excp_model == POWERPC_EXCP_POWER10) {
+        if (new_msr & MSR_HVB) {
+            if (env->spr[SPR_HID0] & HID0_POWER9_HILE) {
+                new_msr |= (target_ulong)1 << MSR_LE;
+            }
+        } else if (env->spr[SPR_LPCR] & LPCR_ILE) {
+            new_msr |= (target_ulong)1 << MSR_LE;
+        }
+    } else if (msr_ile) {
+        new_msr |= (target_ulong)1 << MSR_LE;
+    }
+#else
+    if (msr_ile) {
+        new_msr |= (target_ulong)1 << MSR_LE;
+    }
+#endif
+
+    vector = env->excp_vectors[excp];
+    if (vector == (target_ulong)-1ULL) {
+        cpu_abort(cs, "Raised an exception without defined vector %d\n",
+                  excp);
+    }
+
+    vector |= env->excp_prefix;
+
+    /* If any alternate SRR register are defined, duplicate saved values */
+    if (asrr0 != -1) {
+        env->spr[asrr0] = env->nip;
+    }
+    if (asrr1 != -1) {
+        env->spr[asrr1] = msr;
+    }
+
+#if defined(TARGET_PPC64)
+    if (excp_model == POWERPC_EXCP_BOOKE) {
+        if (env->spr[SPR_BOOKE_EPCR] & EPCR_ICM) {
+            /* Cat.64-bit: EPCR.ICM is copied to MSR.CM */
+            new_msr |= (target_ulong)1 << MSR_CM;
+        } else {
+            vector = (uint32_t)vector;
+        }
+    } else {
+        if (!msr_isf && !mmu_is_64bit(env->mmu_model)) {
+            vector = (uint32_t)vector;
+        } else {
+            new_msr |= (target_ulong)1 << MSR_SF;
+        }
+    }
+#endif
+
+    if (excp != POWERPC_EXCP_SYSCALL_VECTORED) {
+        /* Save PC */
+        env->spr[srr0] = env->nip;
+
+        /* Save MSR */
+        env->spr[srr1] = msr;
+
+#if defined(TARGET_PPC64)
+    } else {
+        vector += lev * 0x20;
+
+        env->lr = env->nip;
+        env->ctr = msr;
+#endif
+    }
+
+    /* This can update new_msr and vector if AIL applies */
+    ppc_excp_apply_ail(cpu, excp_model, excp, msr, &new_msr, &vector);
+
+    powerpc_set_excp_state(cpu, vector, new_msr);
+}
+
+void ppc_cpu_do_interrupt(CPUState *cs)
+{
+    PowerPCCPU *cpu = POWERPC_CPU(cs);
+    CPUPPCState *env = &cpu->env;
+
+    powerpc_excp(cpu, env->excp_model, cs->exception_index);
+}
+
+static void ppc_hw_interrupt(CPUPPCState *env)
+{
+    PowerPCCPU *cpu = env_archcpu(env);
+    bool async_deliver;
+
+    /* External reset */
+    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {
+        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);
+        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_RESET);
+        return;
+    }
+    /* Machine check exception */
+    if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {
+        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);
+        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_MCHECK);
+        return;
+    }
+#if 0 /* TODO */
+    /* External debug exception */
+    if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {
+        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);
+        powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DEBUG);
+        return;
+    }
+#endif
+
+    /*
+     * For interrupts that gate on MSR:EE, we need to do something a
+     * bit more subtle, as we need to let them through even when EE is
+     * clear when coming out of some power management states (in order
+     * for them to become a 0x100).
+     */
+    async_deliver = (msr_ee != 0) || env->resume_as_sreset;
+
+    /* Hypervisor decrementer exception */
+    if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {
+        /* LPCR will be clear when not supported so this will work */
+        bool hdice = !!(env->spr[SPR_LPCR] & LPCR_HDICE);
+        if ((async_deliver || msr_hv == 0) && hdice) {
+            /* HDEC clears on delivery */
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_HDECR);
+            return;
+        }
+    }
+
+    /* Hypervisor virtualization interrupt */
+    if (env->pending_interrupts & (1 << PPC_INTERRUPT_HVIRT)) {
+        /* LPCR will be clear when not supported so this will work */
+        bool hvice = !!(env->spr[SPR_LPCR] & LPCR_HVICE);
+        if ((async_deliver || msr_hv == 0) && hvice) {
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_HVIRT);
+            return;
+        }
+    }
+
+    /* External interrupt can ignore MSR:EE under some circumstances */
+    if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {
+        bool lpes0 = !!(env->spr[SPR_LPCR] & LPCR_LPES0);
+        bool heic = !!(env->spr[SPR_LPCR] & LPCR_HEIC);
+        /* HEIC blocks delivery to the hypervisor */
+        if ((async_deliver && !(heic && msr_hv && !msr_pr)) ||
+            (env->has_hv_mode && msr_hv == 0 && !lpes0)) {
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_EXTERNAL);
+            return;
+        }
+    }
+    if (msr_ce != 0) {
+        /* External critical interrupt */
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CEXT)) {
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_CRITICAL);
+            return;
+        }
+    }
+    if (async_deliver != 0) {
+        /* Watchdog timer on embedded PowerPC */
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_WDT);
+            return;
+        }
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CDOORBELL)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CDOORBELL);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORCI);
+            return;
+        }
+        /* Fixed interval timer on embedded PowerPC */
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_FIT);
+            return;
+        }
+        /* Programmable interval timer on embedded PowerPC */
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PIT);
+            return;
+        }
+        /* Decrementer exception */
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {
+            if (ppc_decr_clear_on_delivery(env)) {
+                env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);
+            }
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DECR);
+            return;
+        }
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DOORBELL)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DOORBELL);
+            if (is_book3s_arch2x(env)) {
+                powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_SDOOR);
+            } else {
+                powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_DOORI);
+            }
+            return;
+        }
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDOORBELL)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDOORBELL);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_SDOOR_HV);
+            return;
+        }
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PERFM)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PERFM);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_PERFM);
+            return;
+        }
+        /* Thermal interrupt */
+        if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {
+            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);
+            powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_THERM);
+            return;
+        }
+    }
+
+    if (env->resume_as_sreset) {
+        /*
+         * This is a bug ! It means that has_work took us out of halt without
+         * anything to deliver while in a PM state that requires getting
+         * out via a 0x100
+         *
+         * This means we will incorrectly execute past the power management
+         * instruction instead of triggering a reset.
+         *
+         * It generally means a discrepancy between the wakeup conditions in the
+         * processor has_work implementation and the logic in this function.
+         */
+        cpu_abort(env_cpu(env),
+                  "Wakeup from PM state but interrupt Undelivered");
+    }
+}
+
+void ppc_cpu_do_system_reset(CPUState *cs)
+{
+    PowerPCCPU *cpu = POWERPC_CPU(cs);
+    CPUPPCState *env = &cpu->env;
+
+    powerpc_excp(cpu, env->excp_model, POWERPC_EXCP_RESET);
+}
+
+void ppc_cpu_do_fwnmi_machine_check(CPUState *cs, target_ulong vector)
+{
+    PowerPCCPU *cpu = POWERPC_CPU(cs);
+    CPUPPCState *env = &cpu->env;
+    target_ulong msr = 0;
+
+    /*
+     * Set MSR and NIP for the handler, SRR0/1, DAR and DSISR have already
+     * been set by KVM.
+     */
+    msr = (1ULL << MSR_ME);
+    msr |= env->msr & (1ULL << MSR_SF);
+    if (ppc_interrupts_little_endian(cpu)) {
+        msr |= (1ULL << MSR_LE);
+    }
+
+    powerpc_set_excp_state(cpu, vector, msr);
+}
+
+bool ppc_cpu_exec_interrupt(CPUState *cs, int interrupt_request)
+{
+    PowerPCCPU *cpu = POWERPC_CPU(cs);
+    CPUPPCState *env = &cpu->env;
+
+    if (interrupt_request & CPU_INTERRUPT_HARD) {
+        ppc_hw_interrupt(env);
+        if (env->pending_interrupts == 0) {
+            cs->interrupt_request &= ~CPU_INTERRUPT_HARD;
+        }
+        return true;
+    }
+    return false;
+}
+
+#endif /* !CONFIG_USER_ONLY */
+
+/*****************************************************************************/
+/* Exceptions processing helpers */
+
+void raise_exception_err_ra(CPUPPCState *env, uint32_t exception,
+                            uint32_t error_code, uintptr_t raddr)
+{
+    CPUState *cs = env_cpu(env);
+
+    cs->exception_index = exception;
+    env->error_code = error_code;
+    cpu_loop_exit_restore(cs, raddr);
+}
+
+void raise_exception_err(CPUPPCState *env, uint32_t exception,
+                         uint32_t error_code)
+{
+    raise_exception_err_ra(env, exception, error_code, 0);
+}
+
+void raise_exception(CPUPPCState *env, uint32_t exception)
+{
+    raise_exception_err_ra(env, exception, 0, 0);
+}
+
+void raise_exception_ra(CPUPPCState *env, uint32_t exception,
+                        uintptr_t raddr)
+{
+    raise_exception_err_ra(env, exception, 0, raddr);
+}
+
+#ifdef CONFIG_TCG
+void helper_raise_exception_err(CPUPPCState *env, uint32_t exception,
+                                uint32_t error_code)
+{
+    raise_exception_err_ra(env, exception, error_code, 0);
+}
+
+void helper_raise_exception(CPUPPCState *env, uint32_t exception)
+{
+    raise_exception_err_ra(env, exception, 0, 0);
+}
+#endif
+
+#if !defined(CONFIG_USER_ONLY)
+#ifdef CONFIG_TCG
+void helper_store_msr(CPUPPCState *env, target_ulong val)
+{
+    uint32_t excp = hreg_store_msr(env, val, 0);
+
+    if (excp != 0) {
+        CPUState *cs = env_cpu(env);
+        cpu_interrupt_exittb(cs);
+        raise_exception(env, excp);
+    }
+}
+
+#if defined(TARGET_PPC64)
+void helper_scv(CPUPPCState *env, uint32_t lev)
+{
+    if (env->spr[SPR_FSCR] & (1ull << FSCR_SCV)) {
+        raise_exception_err(env, POWERPC_EXCP_SYSCALL_VECTORED, lev);
+    } else {
+        raise_exception_err(env, POWERPC_EXCP_FU, FSCR_IC_SCV);
+    }
+}
+
+void helper_pminsn(CPUPPCState *env, powerpc_pm_insn_t insn)
+{
+    CPUState *cs;
+
+    cs = env_cpu(env);
+    cs->halted = 1;
+
+    /* Condition for waking up at 0x100 */
+    env->resume_as_sreset = (insn != PPC_PM_STOP) ||
+        (env->spr[SPR_PSSCR] & PSSCR_EC);
+}
+#endif /* defined(TARGET_PPC64) */
+#endif /* CONFIG_TCG */
+
+static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)
+{
+    CPUState *cs = env_cpu(env);
+
+    /* MSR:POW cannot be set by any form of rfi */
+    msr &= ~(1ULL << MSR_POW);
+
+#if defined(TARGET_PPC64)
+    /* Switching to 32-bit ? Crop the nip */
+    if (!msr_is_64bit(env, msr)) {
+        nip = (uint32_t)nip;
+    }
+#else
+    nip = (uint32_t)nip;
+#endif
+    /* XXX: beware: this is false if VLE is supported */
+    env->nip = nip & ~((target_ulong)0x00000003);
+    hreg_store_msr(env, msr, 1);
+    trace_ppc_excp_rfi(env->nip, env->msr);
+    /*
+     * No need to raise an exception here, as rfi is always the last
+     * insn of a TB
+     */
+    cpu_interrupt_exittb(cs);
+    /* Reset the reservation */
+    env->reserve_addr = -1;
+
+    /* Context synchronizing: check if TCG TLB needs flush */
+    check_tlb_flush(env, false);
+}
+
+#ifdef CONFIG_TCG
+void helper_rfi(CPUPPCState *env)
+{
+    do_rfi(env, env->spr[SPR_SRR0], env->spr[SPR_SRR1] & 0xfffffffful);
+}
+
+#define MSR_BOOK3S_MASK
+#if defined(TARGET_PPC64)
+void helper_rfid(CPUPPCState *env)
+{
+    /*
+     * The architecture defines a number of rules for which bits can
+     * change but in practice, we handle this in hreg_store_msr()
+     * which will be called by do_rfi(), so there is no need to filter
+     * here
+     */
+    do_rfi(env, env->spr[SPR_SRR0], env->spr[SPR_SRR1]);
+}
+
+void helper_rfscv(CPUPPCState *env)
+{
+    do_rfi(env, env->lr, env->ctr);
+}
+
+void helper_hrfid(CPUPPCState *env)
+{
+    do_rfi(env, env->spr[SPR_HSRR0], env->spr[SPR_HSRR1]);
+}
+#endif
+
+/*****************************************************************************/
+/* Embedded PowerPC specific helpers */
+void helper_40x_rfci(CPUPPCState *env)
+{
+    do_rfi(env, env->spr[SPR_40x_SRR2], env->spr[SPR_40x_SRR3]);
+}
+
+void helper_rfci(CPUPPCState *env)
+{
+    do_rfi(env, env->spr[SPR_BOOKE_CSRR0], env->spr[SPR_BOOKE_CSRR1]);
+}
+
+void helper_rfdi(CPUPPCState *env)
+{
+    /* FIXME: choose CSRR1 or DSRR1 based on cpu type */
+    do_rfi(env, env->spr[SPR_BOOKE_DSRR0], env->spr[SPR_BOOKE_DSRR1]);
+}
+
+void helper_rfmci(CPUPPCState *env)
+{
+    /* FIXME: choose CSRR1 or MCSRR1 based on cpu type */
+    do_rfi(env, env->spr[SPR_BOOKE_MCSRR0], env->spr[SPR_BOOKE_MCSRR1]);
+}
+#endif /* CONFIG_TCG */
+#endif /* !defined(CONFIG_USER_ONLY) */
+
+#ifdef CONFIG_TCG
+void helper_tw(CPUPPCState *env, target_ulong arg1, target_ulong arg2,
+               uint32_t flags)
+{
+    if (!likely(!(((int32_t)arg1 < (int32_t)arg2 && (flags & 0x10)) ||
+                  ((int32_t)arg1 > (int32_t)arg2 && (flags & 0x08)) ||
+                  ((int32_t)arg1 == (int32_t)arg2 && (flags & 0x04)) ||
+                  ((uint32_t)arg1 < (uint32_t)arg2 && (flags & 0x02)) ||
+                  ((uint32_t)arg1 > (uint32_t)arg2 && (flags & 0x01))))) {
+        raise_exception_err_ra(env, POWERPC_EXCP_PROGRAM,
+                               POWERPC_EXCP_TRAP, GETPC());
+    }
+}
+
+#if defined(TARGET_PPC64)
+void helper_td(CPUPPCState *env, target_ulong arg1, target_ulong arg2,
+               uint32_t flags)
+{
+    if (!likely(!(((int64_t)arg1 < (int64_t)arg2 && (flags & 0x10)) ||
+                  ((int64_t)arg1 > (int64_t)arg2 && (flags & 0x08)) ||
+                  ((int64_t)arg1 == (int64_t)arg2 && (flags & 0x04)) ||
+                  ((uint64_t)arg1 < (uint64_t)arg2 && (flags & 0x02)) ||
+                  ((uint64_t)arg1 > (uint64_t)arg2 && (flags & 0x01))))) {
+        raise_exception_err_ra(env, POWERPC_EXCP_PROGRAM,
+                               POWERPC_EXCP_TRAP, GETPC());
+    }
+}
+#endif
+#endif
+
+#if !defined(CONFIG_USER_ONLY)
+/*****************************************************************************/
+/* PowerPC 601 specific instructions (POWER bridge) */
+
+#ifdef CONFIG_TCG
+void helper_rfsvc(CPUPPCState *env)
+{
+    do_rfi(env, env->lr, env->ctr & 0x0000FFFF);
+}
+
+/* Embedded.Processor Control */
+static int dbell2irq(target_ulong rb)
+{
+    int msg = rb & DBELL_TYPE_MASK;
+    int irq = -1;
+
+    switch (msg) {
+    case DBELL_TYPE_DBELL:
+        irq = PPC_INTERRUPT_DOORBELL;
+        break;
+    case DBELL_TYPE_DBELL_CRIT:
+        irq = PPC_INTERRUPT_CDOORBELL;
+        break;
+    case DBELL_TYPE_G_DBELL:
+    case DBELL_TYPE_G_DBELL_CRIT:
+    case DBELL_TYPE_G_DBELL_MC:
+        /* XXX implement */
+    default:
+        break;
+    }
+
+    return irq;
+}
+
+void helper_msgclr(CPUPPCState *env, target_ulong rb)
+{
+    int irq = dbell2irq(rb);
+
+    if (irq < 0) {
+        return;
+    }
+
+    env->pending_interrupts &= ~(1 << irq);
+}
+
+void helper_msgsnd(target_ulong rb)
+{
+    int irq = dbell2irq(rb);
+    int pir = rb & DBELL_PIRTAG_MASK;
+    CPUState *cs;
+
+    if (irq < 0) {
+        return;
+    }
+
+    qemu_mutex_lock_iothread();
+    CPU_FOREACH(cs) {
+        PowerPCCPU *cpu = POWERPC_CPU(cs);
+        CPUPPCState *cenv = &cpu->env;
+
+        if ((rb & DBELL_BRDCAST) || (cenv->spr[SPR_BOOKE_PIR] == pir)) {
+            cenv->pending_interrupts |= 1 << irq;
+            cpu_interrupt(cs, CPU_INTERRUPT_HARD);
+        }
+    }
+    qemu_mutex_unlock_iothread();
+}
+
+/* Server Processor Control */
+
+static bool dbell_type_server(target_ulong rb)
+{
+    /*
+     * A Directed Hypervisor Doorbell message is sent only if the
+     * message type is 5. All other types are reserved and the
+     * instruction is a no-op
+     */
+    return (rb & DBELL_TYPE_MASK) == DBELL_TYPE_DBELL_SERVER;
+}
+
+void helper_book3s_msgclr(CPUPPCState *env, target_ulong rb)
+{
+    if (!dbell_type_server(rb)) {
+        return;
+    }
+
+    env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDOORBELL);
+}
+
+static void book3s_msgsnd_common(int pir, int irq)
+{
+    CPUState *cs;
+
+    qemu_mutex_lock_iothread();
+    CPU_FOREACH(cs) {
+        PowerPCCPU *cpu = POWERPC_CPU(cs);
+        CPUPPCState *cenv = &cpu->env;
+
+        /* TODO: broadcast message to all threads of the same  processor */
+        if (cenv->spr_cb[SPR_PIR].default_value == pir) {
+            cenv->pending_interrupts |= 1 << irq;
+            cpu_interrupt(cs, CPU_INTERRUPT_HARD);
+        }
+    }
+    qemu_mutex_unlock_iothread();
+}
+
+void helper_book3s_msgsnd(target_ulong rb)
+{
+    int pir = rb & DBELL_PROCIDTAG_MASK;
+
+    if (!dbell_type_server(rb)) {
+        return;
+    }
+
+    book3s_msgsnd_common(pir, PPC_INTERRUPT_HDOORBELL);
+}
+
+#if defined(TARGET_PPC64)
+void helper_book3s_msgclrp(CPUPPCState *env, target_ulong rb)
+{
+    helper_hfscr_facility_check(env, HFSCR_MSGP, "msgclrp", HFSCR_IC_MSGP);
+
+    if (!dbell_type_server(rb)) {
+        return;
+    }
+
+    env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DOORBELL);
+}
+
+/*
+ * sends a message to other threads that are on the same
+ * multi-threaded processor
+ */
+void helper_book3s_msgsndp(CPUPPCState *env, target_ulong rb)
+{
+    int pir = env->spr_cb[SPR_PIR].default_value;
+
+    helper_hfscr_facility_check(env, HFSCR_MSGP, "msgsndp", HFSCR_IC_MSGP);
+
+    if (!dbell_type_server(rb)) {
+        return;
+    }
+
+    /* TODO: TCG supports only one thread */
+
+    book3s_msgsnd_common(pir, PPC_INTERRUPT_DOORBELL);
+}
+#endif /* TARGET_PPC64 */
+
+void ppc_cpu_do_unaligned_access(CPUState *cs, vaddr vaddr,
+                                 MMUAccessType access_type,
+                                 int mmu_idx, uintptr_t retaddr)
+{
+    CPUPPCState *env = cs->env_ptr;
+
+    switch (env->mmu_model) {
+    case POWERPC_MMU_SOFT_4xx:
+    case POWERPC_MMU_SOFT_4xx_Z:
+        env->spr[SPR_40x_DEAR] = vaddr;
+        break;
+    case POWERPC_MMU_BOOKE:
+    case POWERPC_MMU_BOOKE206:
+        env->spr[SPR_BOOKE_DEAR] = vaddr;
+        break;
+    default:
+        env->spr[SPR_DAR] = vaddr;
+        break;
+    }
+
+    cs->exception_index = POWERPC_EXCP_ALIGN;
+    env->error_code = 0;
+    cpu_loop_exit_restore(cs, retaddr);
+}
+#endif /* CONFIG_TCG */
+#endif /* !CONFIG_USER_ONLY */
diff --git a/tools/virtiofsd/build/.hgignore b/tools/virtiofsd/build/.hgignore
new file mode 100644
index 0000000..80dc5ea
--- /dev/null
+++ b/tools/virtiofsd/build/.hgignore
@@ -0,0 +1,3 @@
+# This file is autogenerated by Meson. If you change or delete it, it won't be recreated.
+syntax: glob
+**/*
diff --git a/tools/virtiofsd/build/meson-logs/meson-log.txt b/tools/virtiofsd/build/meson-logs/meson-log.txt
new file mode 100644
index 0000000..d67e4f2
--- /dev/null
+++ b/tools/virtiofsd/build/meson-logs/meson-log.txt
@@ -0,0 +1,13 @@
+Build started at 2024-04-12T11:19:10.716205
+Main binary: /usr/bin/python3
+Build Options: 
+Python system: Linux
+The Meson build system
+Version: 0.60.3
+Source dir: /opt/ipu/qemu-kata/tools/virtiofsd
+Build dir: /opt/ipu/qemu-kata/tools/virtiofsd/build
+Build type: native build
+
+ERROR: Not the project root: first statement must be a call to project()
+
+Did you mean to run meson from the directory: "/opt/ipu/qemu-kata"?
diff --git a/tools/virtiofsd/build/meson-private/meson.lock b/tools/virtiofsd/build/meson-private/meson.lock
new file mode 100644
index 0000000..e69de29
diff --git a/ui/keycodemapdb/LICENSE.BSD b/ui/keycodemapdb/LICENSE.BSD
new file mode 100644
index 0000000..ec1a29d
--- /dev/null
+++ b/ui/keycodemapdb/LICENSE.BSD
@@ -0,0 +1,27 @@
+Copyright (c) Individual contributors.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    1. Redistributions of source code must retain the above copyright notice,
+       this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+    3. Neither the name of PyCA Cryptography nor the names of its contributors
+       may be used to endorse or promote products derived from this software
+       without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/ui/keycodemapdb/LICENSE.GPL2 b/ui/keycodemapdb/LICENSE.GPL2
new file mode 100644
index 0000000..d511905
--- /dev/null
+++ b/ui/keycodemapdb/LICENSE.GPL2
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/ui/keycodemapdb/README b/ui/keycodemapdb/README
new file mode 100644
index 0000000..8b4a845
--- /dev/null
+++ b/ui/keycodemapdb/README
@@ -0,0 +1,115 @@
+   Key code / scan code / key symbol mapping database
+   ==================================================
+
+This module provides a database that maps between different
+key code / scan code / key symbol sets:
+
+ - Linux evdev
+ - OS-X
+ - AT Set 1
+ - AT Set 2
+ - AT Set 3
+ - XT
+ - Linux XT KBD driver
+ - USB HID
+ - Win32
+ - XWin XT
+ - XKBD XT
+ - Xorg Evdev
+ - Xorg KBD
+ - Xorg OS-X
+ - XOrg Cygwin
+ - RFB
+
+Licensing
+---------
+
+The contents of this package are dual licensed under the terms of:
+
+ - GNU General Public License (version 2 or later)
+ - 3-clause BSD License
+
+The output files generated by keymap-gen may be distributed & used under
+the terms of either of the above licenses.
+
+Data formats
+------------
+
+The following output formats are possible
+
+ - Code map
+
+   An array mapping between key code sets values
+
+   Indexes in the array are values from the source code set.
+   Entries in the array are values from the target code set
+
+
+ - Code table
+
+   An array listing all values in a key code set
+
+   Indexes in the array are simply a numeric counter
+   Entries in the array are values from the key code set
+
+   The size of the array matches the total number of entries in
+   the keycode database.
+
+
+ - Name map
+
+   An array mapping between key code sets values and names
+
+   Indexes in the array are values from the source code set
+   Entries in the array are names from the target code set
+
+
+ - Name table
+
+   An array listing all names in a key code set
+
+   Indexes in the array are simply a numeric counter
+   Entries in the array are values from the key code set
+
+   The size of the array matches the total number of entries in
+   the keycode database.
+
+
+Output languages
+----------------
+
+The tool is capable of generating data tables for the following
+programming languages / environments
+
+ - Standard C
+ - GLib2 (standard C, but with GLib2 data types)
+ - Python
+ - Perl
+ - Rust
+
+
+Usage
+-----
+
+Map values from AT Set 1 to USB HID, generating tables for the
+C programming language
+
+ $ keymap-gen --lang stdc code-map data/keymaps.csv atset1 usb
+
+Generate a tables of names for Linux key codes, OS-X key codes,
+in python - equivalent array indexes map between the two sets.
+A variable name override is used
+
+ $ keymap-gen --varname linux_keycodes --lang stdc \
+              code-table data/keymaps.csv linux
+ $ keymap-gen --varname osx_keycodes --lang stdc \
+              code-table data/keymaps.csv os-x
+
+Generate a mapping from XOrg XWin values to Win32 names
+
+ $ keymap-gen --lang perl name-map data/keymaps.csv xorgxwin win32
+
+Generate a table of names for Linux key codes in Perl
+
+ $ keymap-gen --lang perl name-table data/keymaps.csv linux
+
diff --git a/ui/keycodemapdb/data/README b/ui/keycodemapdb/data/README
new file mode 100644
index 0000000..6b56534
--- /dev/null
+++ b/ui/keycodemapdb/data/README
@@ -0,0 +1,89 @@
+This directory contains the raw data for mapping between different
+keyboard codes. Naming if often based on the US keyboard layout, but
+does not indicate the symbol actually generated by the key.
+
+The columns currently in this data set are:
+
+Linux
+-----
+
+Name and value of the hardware independent keycodes used by the linux
+kernel and exposed through the input subsystem.
+
+References: linux/input.h
+
+macOS
+-----
+
+Low level key codes as exposed by Mac OS X/macOS.
+
+References: Carbon/HIToolbox/Events.h
+
+PC scan code sets
+-----------------
+
+Scan codes for the three orignal PC keyboard generations:
+
+ Set 1: XT
+ Set 2: AT
+ Set 3: PS/2
+
+The sets include codes for modern keys as well and not just the keys
+present on those original keyboards.
+
+References: linux/drivers/input/keyboard/atkbd.c
+
+USB HID
+-------
+
+Codes as specified by the HID profile in USB.
+
+References: linux/drivers/hid/usbhid/usbkbd.c
+
+Windows Virtual-key codes
+-------------------------
+
+The low level, hardware independent "VKEYs" exposed by Windows.
+
+References: mingw32/winuser.h
+
+XWin XT
+-------
+
+X11 keycodes generated by the XWin server. Based on the XT scan code
+set.
+
+References: xorg-server/hw/xwin/{winkeybd.c,winkeynames.h}
+
+Xfree86 KBD XT
+--------------
+
+X11 keycodes generated by the Xfree86 keyboard drivers. Based on the XT
+scan code set.
+
+References: xf86-input-keyboard/src/at_scancode.c
+
+X11 keysyms
+-----------
+
+Corresponding X11 keysym value(s) for a US keyboard layout.
+
+WARNING: These columns represent symbols, not physical keys, and should
+         be used with extreme care.
+
+References: http://cgit.freedesktop.org/xorg/proto/x11proto/plain/keysymdef.h
+
+HTML KeyboardEvent.code
+-----------------------
+
+Key codes seen in the KeyboardEvent.code attribute as part of the
+UI Events specification.
+
+References: https://www.w3.org/TR/uievents-code/
+
+XKEYBOARD key names
+-------------------
+
+Hardware independent key names as used in the XKEYBOARD extension.
+
+References: /usr/share/X11/xkb/keycodes/
diff --git a/ui/keycodemapdb/data/keymaps.csv b/ui/keycodemapdb/data/keymaps.csv
new file mode 100644
index 0000000..1ffe3b0
--- /dev/null
+++ b/ui/keycodemapdb/data/keymaps.csv
@@ -0,0 +1,539 @@
+"Linux Name","Linux Keycode","OS-X Name","OS-X Keycode","AT set1 keycode","AT set2 keycode","AT set3 keycode","USB Keycodes","Win32 Name","Win32 Keycode","Xwin XT","Xfree86 KBD XT","X11 keysym name","X11 keysym","HTML code","XKB key name","QEMU QKeyCode","Sun KBD","Apple ADB"
+KEY_RESERVED,0,,0xff,,,,,,,,,,,,,unmapped,,0xff
+KEY_ESC,1,Escape,0x35,0x01,0x76,0x08,41,VK_ESCAPE,0x1b,1,1,XK_Escape,0xff1b,Escape,ESC,esc,0x1d,0x35
+KEY_1,2,ANSI_1,0x12,0x02,0x16,0x16,30,VK_1,0x31,2,2,XK_1,0x0031,Digit1,AE01,1,0x1e,0x12
+KEY_1,2,ANSI_1,0x12,0x02,0x16,0x16,30,VK_1,0x31,2,2,XK_exclam,0x0021,Digit1,AE01,1,0x1e,0x12
+KEY_2,3,ANSI_2,0x13,0x03,0x1e,0x1e,31,VK_2,0x32,3,3,XK_2,0x0032,Digit2,AE02,2,0x1f,0x13
+KEY_2,3,ANSI_2,0x13,0x03,0x1e,0x1e,31,VK_2,0x32,3,3,XK_at,0x0040,Digit2,AE02,2,0x1f,0x13
+KEY_3,4,ANSI_3,0x14,0x04,0x26,0x26,32,VK_3,0x33,4,4,XK_3,0x0033,Digit3,AE03,3,0x20,0x14
+KEY_3,4,ANSI_3,0x14,0x04,0x26,0x26,32,VK_3,0x33,4,4,XK_numbersign,0x0023,Digit3,AE03,3,0x20,0x14
+KEY_4,5,ANSI_4,0x15,0x05,0x25,0x25,33,VK_4,0x34,5,5,XK_4,0x0034,Digit4,AE04,4,0x21,0x15
+KEY_4,5,ANSI_4,0x15,0x05,0x25,0x25,33,VK_4,0x34,5,5,XK_dollar,0x0024,Digit4,AE04,4,0x21,0x15
+KEY_5,6,ANSI_5,0x17,0x06,0x2e,0x2e,34,VK_5,0x35,6,6,XK_5,0x0035,Digit5,AE05,5,0x22,0x17
+KEY_5,6,ANSI_5,0x17,0x06,0x2e,0x2e,34,VK_5,0x35,6,6,XK_percent,0x0025,Digit5,AE05,5,0x22,0x17
+KEY_6,7,ANSI_6,0x16,0x07,0x36,0x36,35,VK_6,0x36,7,7,XK_6,0x0036,Digit6,AE06,6,0x23,0x16
+KEY_6,7,ANSI_6,0x16,0x07,0x36,0x36,35,VK_6,0x36,7,7,XK_asciicircum,0x005e,Digit6,AE06,6,0x23,0x16
+KEY_7,8,ANSI_7,0x1a,0x08,0x3d,0x3d,36,VK_7,0x37,8,8,XK_7,0x0037,Digit7,AE07,7,0x24,0x1a
+KEY_7,8,ANSI_7,0x1a,0x08,0x3d,0x3d,36,VK_7,0x37,8,8,XK_ampersand,0x0026,Digit7,AE07,7,0x24,0x1a
+KEY_8,9,ANSI_8,0x1c,0x09,0x3e,0x3e,37,VK_8,0x38,9,9,XK_8,0x0038,Digit8,AE08,8,0x25,0x1c
+KEY_8,9,ANSI_8,0x1c,0x09,0x3e,0x3e,37,VK_8,0x38,9,9,XK_asterisk,0x002a,Digit8,AE08,8,0x25,0x1c
+KEY_9,10,ANSI_9,0x19,0x0a,0x46,0x46,38,VK_9,0x39,10,10,XK_9,0x0039,Digit9,AE09,9,0x26,0x19
+KEY_9,10,ANSI_9,0x19,0x0a,0x46,0x46,38,VK_9,0x39,10,10,XK_parenleft,0x0028,Digit9,AE09,9,0x26,0x19
+KEY_0,11,ANSI_0,0x1d,0x0b,0x45,0x45,39,VK_0,0x30,11,11,XK_0,0x0030,Digit0,AE10,0,0x27,0x1d
+KEY_0,11,ANSI_0,0x1d,0x0b,0x45,0x45,39,VK_0,0x30,11,11,XK_parenright,0x0029,Digit0,AE10,0,0x27,0x1d
+KEY_MINUS,12,ANSI_Minus,0x1b,0x0c,0x4e,0x4e,45,VK_OEM_MINUS,0xbd,12,12,XK_minus,0x002d,Minus,AE11,minus,0x28,0x1b
+KEY_MINUS,12,ANSI_Minus,0x1b,0x0c,0x4e,0x4e,45,VK_OEM_MINUS,0xbd,12,12,XK_underscore,0x005f,Minus,AE11,minus,0x28,0x1b
+KEY_EQUAL,13,ANSI_Equal,0x18,0x0d,0x55,0x55,46,VK_OEM_PLUS,0xbb,13,13,XK_equal,0x003d,Equal,AE12,equal,0x29,0x18
+KEY_EQUAL,13,ANSI_Equal,0x18,0x0d,0x55,0x55,46,VK_OEM_PLUS,0xbb,13,13,XK_plus,0x002b,Equal,AE12,equal,0x29,0x18
+KEY_BACKSPACE,14,Delete,0x33,0x0e,0x66,0x66,42,VK_BACK,0x08,14,14,XK_BackSpace,0xff08,Backspace,BKSP,backspace,0x2b,0x33
+KEY_TAB,15,Tab,0x30,0x0f,0x0d,0x0d,43,VK_TAB,0x09,15,15,XK_Tab,0xff09,Tab,TAB,tab,0x35,0x30
+KEY_Q,16,ANSI_Q,0xc,0x10,0x15,0x15,20,VK_Q,0x51,16,16,XK_Q,0x0051,KeyQ,AD01,q,0x36,0xc
+KEY_Q,16,ANSI_Q,0xc,0x10,0x15,0x15,20,VK_Q,0x51,16,16,XK_q,0x0071,KeyQ,AD01,q,0x36,0xc
+KEY_W,17,ANSI_W,0xd,0x11,0x1d,0x1d,26,VK_W,0x57,17,17,XK_W,0x0057,KeyW,AD02,w,0x37,0xd
+KEY_W,17,ANSI_W,0xd,0x11,0x1d,0x1d,26,VK_W,0x57,17,17,XK_w,0x0077,KeyW,AD02,w,0x37,0xd
+KEY_E,18,ANSI_E,0xe,0x12,0x24,0x24,8,VK_E,0x45,18,18,XK_E,0x0045,KeyE,AD03,e,0x38,0xe
+KEY_E,18,ANSI_E,0xe,0x12,0x24,0x24,8,VK_E,0x45,18,18,XK_e,0x0065,KeyE,AD03,e,0x38,0xe
+KEY_R,19,ANSI_R,0xf,0x13,0x2d,0x2d,21,VK_R,0x52,19,19,XK_R,0x0052,KeyR,AD04,r,0x39,0xf
+KEY_R,19,ANSI_R,0xf,0x13,0x2d,0x2d,21,VK_R,0x52,19,19,XK_r,0x0072,KeyR,AD04,r,0x39,0xf
+KEY_T,20,ANSI_T,0x11,0x14,0x2c,0x2c,23,VK_T,0x54,20,20,XK_T,0x0054,KeyT,AD05,t,0x3a,0x11
+KEY_T,20,ANSI_T,0x11,0x14,0x2c,0x2c,23,VK_T,0x54,20,20,XK_t,0x0074,KeyT,AD05,t,0x3a,0x11
+KEY_Y,21,ANSI_Y,0x10,0x15,0x35,0x35,28,VK_Y,0x59,21,21,XK_Y,0x0059,KeyY,AD06,y,0x3b,0x10
+KEY_Y,21,ANSI_Y,0x10,0x15,0x35,0x35,28,VK_Y,0x59,21,21,XK_y,0x0079,KeyY,AD06,y,0x3b,0x10
+KEY_U,22,ANSI_U,0x20,0x16,0x3c,0x3c,24,VK_U,0x55,22,22,XK_U,0x0055,KeyU,AD07,u,0x3c,0x20
+KEY_U,22,ANSI_U,0x20,0x16,0x3c,0x3c,24,VK_U,0x55,22,22,XK_u,0x0075,KeyU,AD07,u,0x3c,0x20
+KEY_I,23,ANSI_I,0x22,0x17,0x43,0x43,12,VK_I,0x49,23,23,XK_I,0x0049,KeyI,AD08,i,0x3d,0x22
+KEY_I,23,ANSI_I,0x22,0x17,0x43,0x43,12,VK_I,0x49,23,23,XK_i,0x0069,KeyI,AD08,i,0x3d,0x22
+KEY_O,24,ANSI_O,0x1f,0x18,0x44,0x44,18,VK_O,0x4f,24,24,XK_O,0x004f,KeyO,AD09,o,0x3e,0x1f
+KEY_O,24,ANSI_O,0x1f,0x18,0x44,0x44,18,VK_O,0x4f,24,24,XK_o,0x006f,KeyO,AD09,o,0x3e,0x1f
+KEY_P,25,ANSI_P,0x23,0x19,0x4d,0x4d,19,VK_P,0x50,25,25,XK_P,0x0050,KeyP,AD10,p,0x3f,0x23
+KEY_P,25,ANSI_P,0x23,0x19,0x4d,0x4d,19,VK_P,0x50,25,25,XK_p,0x0070,KeyP,AD10,p,0x3f,0x23
+KEY_LEFTBRACE,26,ANSI_LeftBracket,0x21,0x1a,0x54,0x54,47,VK_OEM_4,0xdb,26,26,XK_bracketleft,0x005b,BracketLeft,AD11,bracket_left,0x40,0x21
+KEY_LEFTBRACE,26,ANSI_LeftBracket,0x21,0x1a,0x54,0x54,47,VK_OEM_4,0xdb,26,26,XK_braceleft,0x007b,BracketLeft,AD11,bracket_left,0x40,0x21
+KEY_RIGHTBRACE,27,ANSI_RightBracket,0x1e,0x1b,0x5b,0x5b,48,VK_OEM_6,0xdd,27,27,XK_bracketright,0x005d,BracketRight,AD12,bracket_right,0x41,0x1e
+KEY_RIGHTBRACE,27,ANSI_RightBracket,0x1e,0x1b,0x5b,0x5b,48,VK_OEM_6,0xdd,27,27,XK_braceright,0x007d,BracketRight,AD12,bracket_right,0x41,0x1e
+KEY_ENTER,28,Return,0x24,0x1c,0x5a,0x5a,40,VK_RETURN,0x0d,28,28,XK_Return,0xff0d,Enter,RTRN,ret,0x59,0x24
+KEY_LEFTCTRL,29,Control,0x3b,0x1d,0x14,0x11,224,VK_LCONTROL,0xa2,29,29,XK_Control_L,0xffe3,ControlLeft,LCTL,ctrl,0x4c,0x36
+KEY_LEFTCTRL,29,Control,0x3b,0x1d,0x14,0x11,224,VK_CONTROL,0x11,29,29,XK_Control_L,0xffe3,ControlLeft,LCTL,ctrl,0x4c,0x36
+KEY_A,30,ANSI_A,0x0,0x1e,0x1c,0x1c,4,VK_A,0x41,30,30,XK_A,0x0041,KeyA,AC01,a,0x4d,0x0
+KEY_A,30,ANSI_A,0x0,0x1e,0x1c,0x1c,4,VK_A,0x41,30,30,XK_a,0x0061,KeyA,AC01,a,0x4d,0x0
+KEY_S,31,ANSI_S,0x1,0x1f,0x1b,0x1b,22,VK_S,0x53,31,31,XK_S,0x0053,KeyS,AC02,s,0x4e,0x1
+KEY_S,31,ANSI_S,0x1,0x1f,0x1b,0x1b,22,VK_S,0x53,31,31,XK_s,0x0073,KeyS,AC02,s,0x4e,0x1
+KEY_D,32,ANSI_D,0x2,0x20,0x23,0x23,7,VK_D,0x44,32,32,XK_D,0x0044,KeyD,AC03,d,0x4f,0x2
+KEY_D,32,ANSI_D,0x2,0x20,0x23,0x23,7,VK_D,0x44,32,32,XK_d,0x0064,KeyD,AC03,d,0x4f,0x2
+KEY_F,33,ANSI_F,0x3,0x21,0x2b,0x2b,9,VK_F,0x46,33,33,XK_F,0x0046,KeyF,AC04,f,0x50,0x3
+KEY_F,33,ANSI_F,0x3,0x21,0x2b,0x2b,9,VK_F,0x46,33,33,XK_f,0x0066,KeyF,AC04,f,0x50,0x3
+KEY_G,34,ANSI_G,0x5,0x22,0x34,0x34,10,VK_G,0x47,34,34,XK_G,0x0047,KeyG,AC05,g,0x51,0x5
+KEY_G,34,ANSI_G,0x5,0x22,0x34,0x34,10,VK_G,0x47,34,34,XK_g,0x0067,KeyG,AC05,g,0x51,0x5
+KEY_H,35,ANSI_H,0x4,0x23,0x33,0x33,11,VK_H,0x48,35,35,XK_H,0x0048,KeyH,AC06,h,0x52,0x4
+KEY_H,35,ANSI_H,0x4,0x23,0x33,0x33,11,VK_H,0x48,35,35,XK_h,0x0068,KeyH,AC06,h,0x52,0x4
+KEY_J,36,ANSI_J,0x26,0x24,0x3b,0x3b,13,VK_J,0x4a,36,36,XK_J,0x004a,KeyJ,AC07,j,0x53,0x26
+KEY_J,36,ANSI_J,0x26,0x24,0x3b,0x3b,13,VK_J,0x4a,36,36,XK_j,0x006a,KeyJ,AC07,j,0x53,0x26
+KEY_K,37,ANSI_K,0x28,0x25,0x42,0x42,14,VK_K,0x4b,37,37,XK_K,0x004b,KeyK,AC08,k,0x54,0x28
+KEY_K,37,ANSI_K,0x28,0x25,0x42,0x42,14,VK_K,0x4b,37,37,XK_k,0x006b,KeyK,AC08,k,0x54,0x28
+KEY_L,38,ANSI_L,0x25,0x26,0x4b,0x4b,15,VK_L,0x4c,38,38,XK_L,0x004c,KeyL,AC09,l,0x55,0x25
+KEY_L,38,ANSI_L,0x25,0x26,0x4b,0x4b,15,VK_L,0x4c,38,38,XK_l,0x006c,KeyL,AC09,l,0x55,0x25
+KEY_SEMICOLON,39,ANSI_Semicolon,0x29,0x27,0x4c,0x4c,51,VK_OEM_1,0xba,39,39,XK_semicolon,0x003b,Semicolon,AC10,semicolon,0x56,0x29
+KEY_SEMICOLON,39,ANSI_Semicolon,0x29,0x27,0x4c,0x4c,51,VK_OEM_1,0xba,39,39,XK_colon,0x003a,Semicolon,AC10,semicolon,0x56,0x29
+KEY_APOSTROPHE,40,ANSI_Quote,0x27,0x28,0x52,0x52,52,VK_OEM_7,0xde,40,40,XK_apostrophe,0x0027,Quote,AC11,apostrophe,0x57,0x27
+KEY_APOSTROPHE,40,ANSI_Quote,0x27,0x28,0x52,0x52,52,VK_OEM_7,0xde,40,40,XK_quotedbl,0x0022,Quote,AC11,apostrophe,0x57,0x27
+KEY_GRAVE,41,ANSI_Grave,0x32,0x29,0x0e,0x0e,53,VK_OEM_3,0xc0,41,41,XK_grave,0x0060,Backquote,TLDE,grave_accent,0x2a,0x32
+KEY_GRAVE,41,ANSI_Grave,0x32,0x29,0x0e,0x0e,53,VK_OEM_3,0xc0,41,41,XK_grave,0x0060,Backquote,AB00,grave_accent,0x2a,0x32
+KEY_GRAVE,41,ANSI_Grave,0x32,0x29,0x0e,0x0e,53,VK_OEM_3,0xc0,41,41,XK_asciitilde,0x007e,Backquote,TLDE,grave_accent,0x2a,0x32
+KEY_GRAVE,41,ANSI_Grave,0x32,0x29,0x0e,0x0e,53,VK_OEM_3,0xc0,41,41,XK_asciitilde,0x007e,Backquote,AB00,grave_accent,0x2a,0x32
+KEY_SHIFT,42,Shift,0x38,0x2a,0x12,0x12,225,VK_SHIFT,0x10,42,42,XK_Shift_L,0xffe1,ShiftLeft,LFSH,shift,0x63,0x38
+KEY_LEFTSHIFT,42,Shift,0x38,0x2a,0x12,0x12,225,VK_LSHIFT,0xa0,42,42,XK_Shift_L,0xffe1,ShiftLeft,LFSH,shift,0x63,0x38
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,49,VK_OEM_5,0xdc,43,43,XK_backslash,0x005c,Backslash,BKSL,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,49,VK_OEM_5,0xdc,43,43,XK_backslash,0x005c,Backslash,AC12,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,49,VK_OEM_5,0xdc,43,43,XK_bar,0x007c,Backslash,BKSL,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,49,VK_OEM_5,0xdc,43,43,XK_bar,0x007c,Backslash,AC12,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,50,VK_OEM_5,0xdc,43,43,XK_backslash,0x005c,Backslash,BKSL,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,50,VK_OEM_5,0xdc,43,43,XK_backslash,0x005c,Backslash,AC12,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,50,VK_OEM_5,0xdc,43,43,XK_bar,0x007c,Backslash,BKSL,backslash,0x58,0x2a
+KEY_BACKSLASH,43,ANSI_Backslash,0x2a,0x2b,0x5d,0x5c,50,VK_OEM_5,0xdc,43,43,XK_bar,0x007c,Backslash,AC12,backslash,0x58,0x2a
+KEY_Z,44,ANSI_Z,0x6,0x2c,0x1a,0x1a,29,VK_Z,0x5a,44,44,XK_Z,0x005a,KeyZ,AB01,z,0x64,0x6
+KEY_Z,44,ANSI_Z,0x6,0x2c,0x1a,0x1a,29,VK_Z,0x5a,44,44,XK_z,0x007a,KeyZ,AB01,z,0x64,0x6
+KEY_X,45,ANSI_X,0x7,0x2d,0x22,0x22,27,VK_X,0x58,45,45,XK_X,0x0058,KeyX,AB02,x,0x65,0x7
+KEY_X,45,ANSI_X,0x7,0x2d,0x22,0x22,27,VK_X,0x58,45,45,XK_x,0x0078,KeyX,AB02,x,0x65,0x7
+KEY_C,46,ANSI_C,0x8,0x2e,0x21,0x21,6,VK_C,0x43,46,46,XK_C,0x0043,KeyC,AB03,c,0x66,0x8
+KEY_C,46,ANSI_C,0x8,0x2e,0x21,0x21,6,VK_C,0x43,46,46,XK_c,0x0063,KeyC,AB03,c,0x66,0x8
+KEY_V,47,ANSI_V,0x9,0x2f,0x2a,0x2a,25,VK_V,0x56,47,47,XK_V,0x0056,KeyV,AB04,v,0x67,0x9
+KEY_V,47,ANSI_V,0x9,0x2f,0x2a,0x2a,25,VK_V,0x56,47,47,XK_v,0x0076,KeyV,AB04,v,0x67,0x9
+KEY_B,48,ANSI_B,0xb,0x30,0x32,0x32,5,VK_B,0x42,48,48,XK_B,0x0042,KeyB,AB05,b,0x68,0xb
+KEY_B,48,ANSI_B,0xb,0x30,0x32,0x32,5,VK_B,0x42,48,48,XK_b,0x0062,KeyB,AB05,b,0x68,0xb
+KEY_N,49,ANSI_N,0x2d,0x31,0x31,0x31,17,VK_N,0x4e,49,49,XK_N,0x004e,KeyN,AB06,n,0x69,0x2d
+KEY_N,49,ANSI_N,0x2d,0x31,0x31,0x31,17,VK_N,0x4e,49,49,XK_n,0x006e,KeyN,AB06,n,0x69,0x2d
+KEY_M,50,ANSI_M,0x2e,0x32,0x3a,0x3a,16,VK_M,0x4d,50,50,XK_M,0x004d,KeyM,AB07,m,0x6a,0x2e
+KEY_M,50,ANSI_M,0x2e,0x32,0x3a,0x3a,16,VK_M,0x4d,50,50,XK_m,0x006d,KeyM,AB07,m,0x6a,0x2e
+KEY_COMMA,51,ANSI_Comma,0x2b,0x33,0x41,0x41,54,VK_OEM_COMMA,0xbc,51,51,XK_comma,0x002c,Comma,AB08,comma,0x6b,0x2b
+KEY_COMMA,51,ANSI_Comma,0x2b,0x33,0x41,0x41,54,VK_OEM_COMMA,0xbc,51,51,XK_less,0x003c,Comma,AB08,comma,0x6b,0x2b
+KEY_DOT,52,ANSI_Period,0x2f,0x34,0x49,0x49,55,VK_OEM_PERIOD,0xbe,52,52,XK_period,0x002e,Period,AB09,dot,0x6c,0x2f
+KEY_DOT,52,ANSI_Period,0x2f,0x34,0x49,0x49,55,VK_OEM_PERIOD,0xbe,52,52,XK_greater,0x003e,Period,AB09,dot,0x6c,0x2f
+KEY_SLASH,53,ANSI_Slash,0x2c,0x35,0x4a,0x4a,56,VK_OEM_2,0xbf,53,53,XK_slash,0x002f,Slash,AB10,slash,0x6d,0x2c
+KEY_SLASH,53,ANSI_Slash,0x2c,0x35,0x4a,0x4a,56,VK_OEM_2,0xbf,53,53,XK_question,0x003f,Slash,AB10,slash,0x6d,0x2c
+KEY_RIGHTSHIFT,54,RightShift,0x3c,0x36,0x59,0x59,229,VK_RSHIFT,0xa1,54,54,XK_Shift_R,0xffe2,ShiftRight,RTSH,shift_r,0x6e,0x7b
+KEY_KPASTERISK,55,ANSI_KeypadMultiply,0x43,0x37,0x7c,0x7e,85,VK_MULTIPLY,0x6a,55,55,XK_multiply,0x00d7,NumpadMultiply,KPMU,asterisk,0x2f,0x43
+KEY_KPASTERISK,55,ANSI_KeypadMultiply,0x43,0x37,0x7c,0x7e,85,VK_MULTIPLY,0x6a,55,55,XK_multiply,0x00d7,NumpadMultiply,KPMU,kp_multiply,0x2f,0x43
+KEY_LEFTALT,56,Option,0x3a,0x38,0x11,0x19,226,VK_LMENU,0xa4,56,56,XK_Alt_L,0xffe9,AltLeft,LALT,alt,0x13,0x3a
+KEY_LEFTALT,56,Option,0x3a,0x38,0x11,0x19,226,VK_MENU,0x12,56,56,XK_Alt_L,0xffe9,AltLeft,LALT,alt,0x13,0x3a
+KEY_SPACE,57,Space,0x31,0x39,0x29,0x29,44,VK_SPACE,0x20,57,57,XK_space,0x0020,Space,SPCE,spc,0x79,0x31
+KEY_CAPSLOCK,58,CapsLock,0x39,0x3a,0x58,0x14,57,VK_CAPITAL,0x14,58,58,XK_Caps_Lock,0xffe5,CapsLock,CAPS,caps_lock,0x77,0x39
+KEY_F1,59,F1,0x7a,0x3b,0x05,0x07,58,VK_F1,0x70,59,59,XK_F1,0xffbe,F1,FK01,f1,0x05,0x7a
+KEY_F2,60,F2,0x78,0x3c,0x06,0x0f,59,VK_F2,0x71,60,60,XK_F2,0xffbf,F2,FK02,f2,0x06,0x78
+KEY_F3,61,F3,0x63,0x3d,0x04,0x17,60,VK_F3,0x72,61,61,XK_F3,0xffc0,F3,FK03,f3,0x08,0x63
+KEY_F4,62,F4,0x76,0x3e,0x0c,0x1f,61,VK_F4,0x73,62,62,XK_F4,0xffc1,F4,FK04,f4,0x0a,0x76
+KEY_F5,63,F5,0x60,0x3f,0x03,0x27,62,VK_F5,0x74,63,63,XK_F5,0xffc2,F5,FK05,f5,0x0c,0x60
+KEY_F6,64,F6,0x61,0x40,0x0b,0x2f,63,VK_F6,0x75,64,64,XK_F6,0xffc3,F6,FK06,f6,0x0e,0x61
+KEY_F7,65,F7,0x62,0x41,0x83,0x37,64,VK_F7,0x76,65,65,XK_F7,0xffc4,F7,FK07,f7,0x10,0x62
+KEY_F8,66,F8,0x64,0x42,0x0a,0x3f,65,VK_F8,0x77,66,66,XK_F8,0xffc5,F8,FK08,f8,0x11,0x64
+KEY_F9,67,F9,0x65,0x43,0x01,0x47,66,VK_F9,0x78,67,67,XK_F9,0xffc6,F9,FK09,f9,0x12,0x65
+KEY_F10,68,F10,0x6d,0x44,0x09,0x4f,67,VK_F10,0x79,68,68,XK_F10,0xffc7,F10,FK10,f10,0x07,0x6d
+KEY_NUMLOCK,69,ANSI_KeypadClear,0x47,0x45,0x77,0x76,83,VK_NUMLOCK,0x90,69,69,XK_Num_Lock,0xff7f,NumLock,NMLK,num_lock,0x62,0x47
+KEY_SCROLLLOCK,70,,,0x46,0x7e,0x5f,71,VK_SCROLL,0x91,70,70,XK_Scroll_Lock,0xff14,ScrollLock,SCLK,scroll_lock,0x17,0x6b
+KEY_KP7,71,ANSI_Keypad7,0x59,0x47,0x6c,0x6c,95,VK_NUMPAD7,0x67,71,71,XK_KP_7,0xffb7,Numpad7,KP7,kp_7,0x44,0x59
+KEY_KP8,72,ANSI_Keypad8,0x5b,0x48,0x75,0x75,96,VK_NUMPAD8,0x68,72,72,XK_KP_8,0xffb8,Numpad8,KP8,kp_8,0x45,0x5b
+KEY_KP9,73,ANSI_Keypad9,0x5c,0x49,0x7d,0x7d,97,VK_NUMPAD9,0x69,73,73,XK_KP_9,0xffb9,Numpad9,KP9,kp_9,0x46,0x5c
+KEY_KPMINUS,74,ANSI_KeypadMinus,0x4e,0x4a,0x7b,0x4e,86,VK_SUBTRACT,0x6d,74,74,XK_KP_Subtract,0xffad,NumpadSubtract,KPSU,kp_subtract,0x47,0x4e
+KEY_KP4,75,ANSI_Keypad4,0x56,0x4b,0x6b,0x6b,92,VK_NUMPAD4,0x64,75,75,XK_KP_4,0xffb4,Numpad4,KP4,kp_4,0x5b,0x56
+KEY_KP5,76,ANSI_Keypad5,0x57,0x4c,0x73,0x73,93,VK_NUMPAD5,0x65,76,76,XK_KP_5,0xffb5,Numpad5,KP5,kp_5,0x5c,0x57
+KEY_KP6,77,ANSI_Keypad6,0x58,0x4d,0x74,0x74,94,VK_NUMPAD6,0x66,77,77,XK_KP_6,0xffb6,Numpad6,KP6,kp_6,0x5d,0x58
+KEY_KPPLUS,78,ANSI_KeypadPlus,0x45,0x4e,0x79,0x7c,87,VK_ADD,0x6b,78,78,XK_KP_Add,0xffab,NumpadAdd,KPAD,kp_add,0x7d,0x45
+KEY_KP1,79,ANSI_Keypad1,0x53,0x4f,0x69,0x69,89,VK_NUMPAD1,0x61,79,79,XK_KP_1,0xffb1,Numpad1,KP1,kp_1,0x70,0x53
+KEY_KP2,80,ANSI_Keypad2,0x54,0x50,0x72,0x72,90,VK_NUMPAD2,0x62,80,80,XK_KP_2,0xffb2,Numpad2,KP2,kp_2,0x71,0x54
+KEY_KP3,81,ANSI_Keypad3,0x55,0x51,0x7a,0x7a,91,VK_NUMPAD3,0x63,81,81,XK_KP_3,0xffb3,Numpad3,KP3,kp_3,0x72,0x55
+KEY_KP0,82,ANSI_Keypad0,0x52,0x52,0x70,0x70,98,VK_NUMPAD0,0x60,82,82,XK_KP_0,0xffb0,Numpad0,KP0,kp_0,0x5e,0x52
+KEY_KPDOT,83,ANSI_KeypadDecimal,0x41,0x53,0x71,0x71,99,VK_DECIMAL,0x6e,83,83,XK_KP_Decimal,0xffae,NumpadDecimal,KPDL,kp_decimal,0x32,0x41
+KEY_KPDOT,83,ANSI_KeypadDecimal,0x41,0x53,0x71,0x71,99,VK_DECIMAL,0x6e,83,83,XK_KP_Decimal,0xffae,NumpadDecimal,KPDC,kp_decimal,0x32,0x41
+,84,,,0x54,,,,,,,,,,,,,,
+KEY_ZENKAKUHANKAKU,85,,,0x76,0x5f,,148,,,,,,,Lang5,HZTG,,,
+KEY_102ND,86,,,0x56,0x61,0x13,100,VK_OEM_102,0xe2,86,86,,,IntlBackslash,LSGT,less,0x7c,
+KEY_F11,87,F11,0x67,0x57,0x78,0x56,68,VK_F11,0x7a,87,87,XK_F11,0xffc8,F11,FK11,f11,0x09,0x67
+KEY_F12,88,F12,0x6f,0x58,0x07,0x5e,69,VK_F12,0x7b,88,88,XK_F12,0xffc9,F12,FK12,f12,0x0b,0x6f
+KEY_RO,89,JIS_Underscore,0x5e,0x73,0x51,,135,,,,,,,IntlRo,AB11,ro,,
+KEY_KATAKANA,90,,,0x78,0x63,,146,VK_KANA,0x15,,,,,Katakana,KATA,,,
+KEY_KATAKANA,90,,,0x78,0x63,,146,VK_KANA,0x15,,,,,Lang3,KATA,,,
+KEY_HIRAGANA,91,,,0x77,0x62,0x87,147,,,,,,,Hiragana,HIRA,hiragana,,
+KEY_HIRAGANA,91,,,0x77,0x62,0x87,147,,,,,,,Lang4,HIRA,hiragana,,
+KEY_HENKAN,92,,,0x79,0x64,0x86,138,,,,,,,Convert,HENK,henkan,,
+KEY_KATAKANAHIRAGANA,93,,,0x70,0x13,0x87,136,,,0xc8,0xc8,,,KanaMode,HKTG,katakanahiragana,,
+KEY_MUHENKAN,94,,,0x7b,0x67,0x85,139,,,,,,,NonConvert,NFER,muhenkan,,
+KEY_MUHENKAN,94,,,0x7b,0x67,0x85,139,,,,,,,NonConvert,MUHE,muhenkan,,
+KEY_KPJPCOMMA,95,JIS_KeypadComma,0x5f,0x5c,0x27,,140,,,,,XK_KP_Separator,0xffac,,KPSP,,,
+KEY_KPJPCOMMA,95,JIS_KeypadComma,0x5f,0x5c,0x27,,140,,,,,XK_KP_Separator,0xffac,,JPCM,,,
+KEY_KPENTER,96,ANSI_KeypadEnter,0x4c,0xe01c,0xe05a,0x79,88,,,0x64,0x64,XK_KP_Enter,0xff8d,NumpadEnter,KPEN,kp_enter,0x5a,0x4c
+KEY_RIGHTCTRL,97,RightControl,0x3e,0xe01d,0xe014,0x58,228,VK_RCONTROL,0xa3,0x65,0x65,XK_Control_R,0xffe4,ControlRight,RCTL,ctrl_r,0x4c,0x7d
+KEY_KPSLASH,98,ANSI_KeypadDivide,0x4b,0xe035,0xe04a,0x4a,84,VK_DIVIDE,0x6f,0x68,0x68,XK_KP_Divide,0xffaf,NumpadDivide,KPDV,kp_divide,0x2e,0x4b
+KEY_SYSRQ,99,,,0x54,0x7f,0x57,70,VK_SNAPSHOT,0x2c,0x67,0x67,XK_Sys_Req,0xff15,PrintScreen,PRSC,print,0x16,0x69
+KEY_SYSRQ,99,,,0x54,0x7f,0x57,70,VK_SNAPSHOT,0x2c,0x67,0x67,XK_Sys_Req,0xff15,PrintScreen,SYRQ,sysrq,0x16,0x69
+KEY_RIGHTALT,100,RightOption,0x3d,0xe038,0xe011,0x39,230,VK_RMENU,0xa5,0x69,0x69,XK_Alt_R,0xffea,AltRight,ALGR,alt_r,0x0d,0x7c
+KEY_RIGHTALT,100,RightOption,0x3d,0xe038,0xe011,0x39,230,VK_RMENU,0xa5,0x69,0x69,XK_Alt_R,0xffea,AltRight,RALT,alt_r,0x0d,0x7c
+KEY_LINEFEED,101,,,0x5b,,,,,,,,,,,LNFD,lf,0x6f,
+KEY_HOME,102,Home,0x73,0xe047,0xe06c,0x6e,74,VK_HOME,0x24,0x59,0x59,XK_Home,0xff50,Home,HOME,home,0x34,0x73
+KEY_UP,103,UpArrow,0x7e,0xe048,0xe075,0x63,82,VK_UP,0x26,0x5a,0x5a,XK_Up,0xff52,ArrowUp,UP,up,0x14,0x3e
+KEY_PAGEUP,104,PageUp,0x74,0xe049,0xe07d,0x6f,75,VK_PRIOR,0x21,0x5b,0x5b,XK_Page_Up,0xff55,PageUp,PGUP,pgup,0x60,0x74
+KEY_LEFT,105,LeftArrow,0x7b,0xe04b,0xe06b,0x61,80,VK_LEFT,0x25,0x5c,0x5c,XK_Left,0xff51,ArrowLeft,LEFT,left,0x18,0x3b
+KEY_RIGHT,106,RightArrow,0x7c,0xe04d,0xe074,0x6a,79,VK_RIGHT,0x27,0x5e,0x5e,XK_Right,0xff53,ArrowRight,RGHT,right,0x1c,0x3c
+KEY_END,107,End,0x77,0xe04f,0xe069,0x65,77,VK_END,0x23,0x5f,0x5f,XK_End,0xff57,End,END,end,0x4a,0x77
+KEY_DOWN,108,DownArrow,0x7d,0xe050,0xe072,0x60,81,VK_DOWN,0x28,0x60,0x60,XK_Down,0xff54,ArrowDown,DOWN,down,0x1b,0x3d
+KEY_PAGEDOWN,109,PageDown,0x79,0xe051,0xe07a,0x6d,78,VK_NEXT,0x22,0x61,0x61,XK_Page_Down,0xff56,PageDown,PGDN,pgdn,0x7b,0x79
+KEY_INSERT,110,,,0xe052,0xe070,0x67,73,VK_INSERT,0x2d,0x62,0x62,XK_Insert,0xff63,Insert,INS,insert,0x2c,0x72
+KEY_DELETE,111,ForwardDelete,0x75,0xe053,0xe071,0x64,76,VK_DELETE,0x2e,0x63,0x63,XK_Delete,0xffff,Delete,DEL,delete,0x42,0x75
+KEY_DELETE,111,ForwardDelete,0x75,0xe053,0xe071,0x64,76,VK_DELETE,0x2e,0x63,0x63,XK_Delete,0xffff,Delete,DELE,,0x42,0x75
+KEY_MACRO,112,,,0xe06f,0xe06f,0x8e,,,,,,,,,I120,,,
+KEY_MUTE,113,Mute,0x4a,0xe020,0xe023,0x9c,127,VK_VOLUME_MUTE,0xad,,,,,AudioVolumeMute,MUTE,audiomute,,
+KEY_MUTE,113,Mute,0x4a,0xe020,0xe023,0x9c,239,VK_VOLUME_MUTE,0xad,,,,,AudioVolumeMute,MUTE,audiomute,,
+KEY_VOLUMEDOWN,114,VolumeDown,0x49,0xe02e,0xe021,0x9d,129,VK_VOLUME_DOWN,0xae,,,,,AudioVolumeDown,VOL-,volumedown,,
+KEY_VOLUMEDOWN,114,VolumeDown,0x49,0xe02e,0xe021,0x9d,238,VK_VOLUME_DOWN,0xae,,,,,AudioVolumeDown,VOL-,volumedown,,
+KEY_VOLUMEUP,115,VolumeUp,0x48,0xe030,0xe032,0x95,128,VK_VOLUME_UP,0xaf,,,,,AudioVolumeUp,VOL+,volumeup,,
+KEY_VOLUMEUP,115,VolumeUp,0x48,0xe030,0xe032,0x95,237,VK_VOLUME_UP,0xaf,,,,,AudioVolumeUp,VOL+,volumeup,,
+KEY_POWER,116,,,0xe05e,0xe037,,102,,,,,,,Power,POWR,power,,0x7f7f
+KEY_KPEQUAL,117,ANSI_KeypadEquals,0x51,0x59,0x0f,,103,,,0x76,0x76,XK_KP_Equal,0xffbd,NumpadEqual,KPEQ,kp_equals,0x2d,0x51
+KEY_KPPLUSMINUS,118,,,0xe04e,0xe079,,,,,,,,,,I126,,,
+KEY_PAUSE,119,,,0xe046,0xe077,0x62,72,VK_PAUSE,0x013,0x66,0x66,XK_Pause,0xff13,Pause,PAUS,pause,0x15,0x71
+KEY_SCALE,120,,,0xe00b,,,,,,,,,,,I128,,,
+KEY_KPCOMMA,121,,,0x7e,0x6d,,133,VK_SEPARATOR??,0x6c,,,,,NumpadComma,KPCO,kp_comma,,
+KEY_KPCOMMA,121,,,0x7e,0x6d,,133,VK_SEPARATOR??,0x6c,,,,,NumpadComma,I129,,,
+KEY_HANGEUL,122,JIS_Kana,0x68,0x72,,,144,VK_HANGEUL,0x15,,0x71,,,Lang1,HNGL,lang1,,
+KEY_HANJA,123,JIS_Eisu,0x66,0x71,,,145,VK_HANJA,0x19,,0x72,,,Lang2,HJCV,lang2,,
+KEY_YEN,124,JIS_Yen,0x5d,0x7d,0x6a,0x5d,137,,,0x7d,0x7d,,,IntlYen,AE13,yen,,
+KEY_LEFTMETA,125,Command,0x37,0xe05b,0xe01f,0x8b,227,VK_LWIN,0x5b,0x6b,0x6b,XK_Meta_L,0xffe7,MetaLeft,LMTA,meta_l,0x78,0x37
+KEY_LEFTMETA,125,Command,0x37,0xe05b,0xe01f,0x8b,227,VK_LWIN,0x5b,0x6b,0x6b,XK_Meta_L,0xffe7,MetaLeft,LWIN,meta_l,0x78,0x37
+KEY_RIGHTMETA,126,RightCommand,0x36,0xe05c,0xe027,0x8c,231,VK_RWIN,0x5c,0x6c,0x6c,XK_Meta_R,0xffe8,MetaRight,RMTA,meta_r,0x7a,0x37
+KEY_RIGHTMETA,126,RightCommand,0x36,0xe05c,0xe027,0x8c,231,VK_RWIN,0x5c,0x6c,0x6c,XK_Meta_R,0xffe8,MetaRight,RWIN,meta_r,0x7a,0x37
+KEY_COMPOSE,127,,0x6e,0xe05d,0xe02f,0x8d,101,VK_APPS,0x5d,0x6d,0x6d,,,ContextMenu,MENU,compose,0x43,
+KEY_COMPOSE,127,,0x6e,0xe05d,0xe02f,0x8d,101,VK_APPS,0x5d,0x6d,0x6d,,,ContextMenu,COMP,compose,0x43,
+KEY_STOP,128,,,0xe068,0xe028,0x0a,120,VK_BROWSER_STOP,0xa9,,,,,BrowserStop,STOP,stop,0x01,
+KEY_STOP,128,,,0xe068,0xe028,0x0a,243,VK_BROWSER_STOP,0xa9,,,,,BrowserStop,STOP,stop,0x01,
+KEY_AGAIN,129,,,0xe005,,0x0b,121,,,,,,,Again,AGAI,again,0x03,
+KEY_PROPS,130,,,0xe006,,0x0c,,,,,,,,Props,PROP,props,0x19,
+KEY_UNDO,131,,,0xe007,,0x10,122,,,,,,,Undo,UNDO,undo,0x1a,
+KEY_FRONT,132,,,0xe00c,,,119,,,,,,,,FRNT,front,0x31,
+KEY_COPY,133,,,0xe078,,0x18,124,,,,,,,Copy,COPY,copy,0x33,
+KEY_OPEN,134,,,0x64,,0x20,116,,,,,,,Open,OPEN,open,0x48,
+KEY_PASTE,135,,,0x65,,0x28,125,,,,,,,Paste,PAST,paste,0x49,
+KEY_FIND,136,,,0xe041,,0x30,126,,,,,,,Find,FIND,find,0x5f,
+KEY_FIND,136,,,0xe041,,0x30,244,,,,,,,Find,FIND,find,0x5f,
+KEY_CUT,137,,,0xe03c,,0x38,123,,,,,,,Cut,CUT,cut,0x61,
+KEY_HELP,138,Help,0x72,0xe075,,0x09,117,VK_HELP,0x2f,,,XK_Help,0xff6a,Help,HELP,help,0x76,
+KEY_MENU,139,,,0xe01e,,0x91,118,,,,,,,,I147,menu,,
+KEY_CALC,140,,,0xe021,0xe02b,0xa3,251,,,,,,,LaunchApp2,I148,calculator,,
+KEY_SETUP,141,,,0x66,,,,,,,,,,,I149,,,
+KEY_SLEEP,142,,,0xe05f,0xe03f,,248,VK_SLEEP,0x5f,,,,,Sleep,I150,sleep,,
+KEY_WAKEUP,143,,,0xe063,0xe05e,,,,,,,,,WakeUp,I151,wake,,
+KEY_FILE,144,,,0x67,,,,,,,,,,,I152,,,
+KEY_SENDFILE,145,,,0x68,,,,,,,,,,,I153,,,
+KEY_DELETEFILE,146,,,0x69,,,,,,,,,,,I154,,,
+KEY_XFER,147,,,0xe013,,0xa2,,,,,,,,,XFER,,,
+KEY_XFER,147,,,0xe013,,0xa2,,,,,,,,,I155,,,
+KEY_PROG1,148,,,0xe01f,,0xa0,,,,,,,,,I156,,,
+KEY_PROG2,149,,,0xe017,,0xa1,,,,,,,,,I157,,,
+KEY_WWW,150,,,0xe002,,,240,,,,,,,,I158,,,
+KEY_MSDOS,151,,,0x6a,,,,,,,,,,,I159,,,
+KEY_SCREENLOCK,152,,,0xe012,,0x96,249,,,,,,,,I160,,,
+KEY_DIRECTION,153,,,0x6b,,,,,,,,,,,I161,,,
+KEY_CYCLEWINDOWS,154,,,0xe026,,0x9b,,,,,,,,,I162,,,
+KEY_MAIL,155,,,0xe06c,0xe048,,,,,,,,,LaunchMail,I163,mail,,
+KEY_BOOKMARKS,156,,,0xe066,0xe018,,,,,,,,,BrowserFavorites,I164,ac_bookmarks,,
+KEY_COMPUTER,157,,,0xe06b,0xe040,,,,,,,,,LaunchApp1,I165,computer,,
+KEY_BACK,158,,,0xe06a,0xe038,,241,VK_BROWSER_BACK,0xa6,,,,,BrowserBack,I166,ac_back,,
+KEY_FORWARD,159,,,0xe069,0xe030,,242,VK_BROWSER_FORWARD,0xa7,,,,,BrowserForward,I167,ac_forward,,
+KEY_CLOSECD,160,,,0xe023,,0x9a,,,,,,,,,I168,,,
+KEY_EJECTCD,161,,,0x6c,,,236,,,,,,,,I169,,,
+KEY_EJECTCLOSECD,162,,,0xe07d,,,,,,,,,,Eject,I170,,,
+KEY_NEXTSONG,163,,,0xe019,0xe04d,0x93,235,VK_MEDIA_NEXT_TRACK,0xb0,,,,,MediaTrackNext,I171,audionext,,
+KEY_PLAYPAUSE,164,,,0xe022,0xe034,,232,VK_MEDIA_PLAY_PAUSE,0xb3,,,,,MediaPlayPause,I172,audioplay,,
+KEY_PREVIOUSSONG,165,,,0xe010,0xe015,0x94,234,VK_MEDIA_PREV_TRACK,0xb1,,,,,MediaTrackPrevious,I173,audioprev,,
+KEY_STOPCD,166,,,0xe024,0xe03b,0x98,233,VK_MEDIA_STOP,0xb2,,,,,MediaStop,I174,audiostop,,
+KEY_RECORD,167,,,0xe031,,0x9e,,,,,,,,,I175,,,
+KEY_REWIND,168,,,0xe018,,0x9f,,,,,,,,,I176,,,
+KEY_PHONE,169,,,0x63,,,,,,,,,,,I177,,,
+KEY_ISO,170,ISO_Section,0xa,,,,,,,,,,,,I178,,,
+KEY_CONFIG,171,,,0xe001,,,,,,,,,,,I179,,,
+KEY_HOMEPAGE,172,,,0xe032,0xe03a,0x97,,VK_BROWSER_HOME,0xac,,,,,BrowserHome,I180,ac_home,,
+KEY_REFRESH,173,,,0xe067,0xe020,,250,VK_BROWSER_REFRESH,0xa8,,,,,BrowserRefresh,I181,ac_refresh,,
+KEY_EXIT,174,,,,,,,,,,,,,,I182,,,
+KEY_MOVE,175,,,,,,,,,,,,,,I183,,,
+KEY_EDIT,176,,,0xe008,,,247,,,,,,,,I184,,,
+KEY_SCROLLUP,177,,,0x75,,,245,,,,,,,,I185,,,
+KEY_SCROLLDOWN,178,,,0xe00f,,,246,,,,,,,,I186,,,
+KEY_KPLEFTPAREN,179,,,0xe076,,,182,,,,,,,NumpadParenLeft,I187,,,
+KEY_KPRIGHTPAREN,180,,,0xe07b,,,183,,,,,,,NumpadParenRight,I188,,,
+KEY_NEW,181,,,0xe009,,,,,,,,,,,I189,,,
+KEY_REDO,182,,,0xe00a,,,,,,,,,,,I190,,,
+KEY_F13,183,F13,0x69,0x5d,0x2f,0x7f,104,VK_F13,0x7c,0x6e,0x6e,,,F13,FK13,,,0x69
+KEY_F14,184,F14,0x6b,0x5e,0x37,0x80,105,VK_F14,0x7d,0x6f,0x6f,,,F14,FK14,,,0x6b
+KEY_F15,185,F15,0x71,0x5f,0x3f,0x81,106,VK_F15,0x7e,0x70,0x70,,,F15,FK15,,,0x71
+KEY_F16,186,F16,0x6a,0x55,,0x82,107,VK_F16,0x7f,0x71,0x71,,,F16,FK16,,,
+KEY_F17,187,F17,0x40,0xe003,,0x83,108,VK_F17,0x80,0x72,0x72,,,F17,FK17,,,
+KEY_F18,188,F18,0x4f,0xe077,,,109,VK_F18,0x81,,,,,F18,FK18,,,
+KEY_F19,189,F19,0x50,0xe004,,,110,VK_F19,0x82,,,,,F19,FK19,,,
+KEY_F20,190,F20,0x5a,0x5a,,,111,VK_F20,0x83,,,,,F20,FK20,,,
+KEY_F21,191,,,0x74,,,112,VK_F21,0x84,,,,,F21,FK21,,,
+KEY_F22,192,,,0xe079,,,113,VK_F22,0x85,,,,,F22,FK22,,,
+KEY_F23,193,,,0x6d,,,114,VK_F23,0x86,,,,,F23,FK23,,,
+KEY_F24,194,,,0x6f,,,115,VK_F24,0x87,,,,,F24,FK24,,,
+,195,,,0xe015,,,,,,,,,,,,,,
+,196,,,0xe016,,,,,,,,,,,,,,
+,197,,,0xe01a,,,,,,,,,,,,,,
+,198,,,0xe01b,,,,,,,,,,,,,,
+,199,,,0xe027,,,,,,,,,,,,,,
+KEY_PLAYCD,200,,,0xe028,,,,,,,,,,,I208,,,
+KEY_PAUSECD,201,,,0xe029,,,,,,,,,,,I209,,,
+KEY_PROG3,202,,,0xe02b,,,,,,,,,,,I210,,,
+KEY_PROG4,203,,,0xe02c,,,,,,,,,,,I211,,,
+KEY_DASHBOARD,204,,,0xe02d,,,,,,,,,,,I212,,,
+KEY_SUSPEND,205,,,0xe025,,,,,,,,,,Suspend,I213,,,
+KEY_CLOSE,206,,,0xe02f,,,,,,,,,,,I214,,,
+KEY_PLAY,207,,,0xe033,,,,VK_PLAY,0xfa,,,,,,I215,,,
+KEY_FASTFORWARD,208,,,0xe034,,,,,,,,,,,I216,,,
+KEY_BASSBOOST,209,,,0xe036,,,,,,,,,,,I217,,,
+KEY_PRINT,210,,,0xe039,,,,VK_PRINT,0x2a,,,,,,I218,,,
+KEY_HP,211,,,0xe03a,,,,,,,,,,,I219,,,
+KEY_CAMERA,212,,,0xe03b,,,,,,,,,,,I220,,,
+KEY_SOUND,213,,,0xe03d,,,,,,,,,,,I221,,,
+KEY_QUESTION,214,,,0xe03e,,,,,,,,,,,I222,,,
+KEY_EMAIL,215,,,0xe03f,,,,VK_LAUNCH_MAIL,0xb4,,,,,,I223,,,
+KEY_CHAT,216,,,0xe040,,,,,,,,,,,I224,,,
+KEY_SEARCH,217,,,0xe065,0xe010,,,VK_BROWSER_SEARCH,0xaa,,,,,BrowserSearch,I225,,,
+KEY_CONNECT,218,,,0xe042,,,,,,,,,,,I226,,,
+KEY_FINANCE,219,,,0xe043,,,,,,,,,,,I227,,,
+KEY_SPORT,220,,,0xe044,,,,,,,,,,,I228,,,
+KEY_SHOP,221,,,0xe045,,,,,,,,,,,I229,,,
+KEY_ALTERASE,222,,,0xe014,,,,,,,,,,,I230,,,
+KEY_CANCEL,223,,,0xe04a,,,,,,,,,,,I231,,,
+KEY_BRIGHTNESSDOWN,224,,,0xe04c,,,,,,,,,,,I232,,,
+KEY_BRIGHTNESSUP,225,,,0xe054,,,,,,,,,,,I233,,,
+KEY_MEDIA,226,,,0xe06d,0xe050,,,,,,,,,MediaSelect,I234,mediaselect,,
+KEY_SWITCHVIDEOMODE,227,,,0xe056,,,,,,,,,,,I235,,,
+KEY_KBDILLUMTOGGLE,228,,,0xe057,,,,,,,,,,,I236,,,
+KEY_KBDILLUMDOWN,229,,,0xe058,,,,,,,,,,,I237,,,
+KEY_KBDILLUMUP,230,,,0xe059,,,,,,,,,,,I238,,,
+KEY_SEND,231,,,0xe05a,,,,,,,,,,,I239,,,
+KEY_REPLY,232,,,0xe064,,,,,,,,,,,I240,,,
+KEY_FORWARDMAIL,233,,,0xe00e,,,,,,,,,,,I241,,,
+KEY_SAVE,234,,,0xe055,,,,,,,,,,,I242,,,
+KEY_DOCUMENTS,235,,,0xe070,,,,,,,,,,,I243,,,
+KEY_BATTERY,236,,,0xe071,,,,,,,,,,,I244,,,
+KEY_BLUETOOTH,237,,,0xe072,,,,,,,,,,,I245,,,
+KEY_WLAN,238,,,0xe073,,,,,,,,,,,I246,,,
+KEY_UWB,239,,,0xe074,,,,,,,,,,,I247,,,
+KEY_UNKNOWN,240,,,,,,,,,,,,,,I248,,,
+KEY_VIDEO_NEXT,241,,,,,,,,,,,,,,I249,,,
+KEY_VIDEO_PREV,242,,,,,,,,,,,,,,I250,,,
+KEY_BRIGHTNESS_CYCLE,243,,,,,,,,,,,,,,I251,,,
+KEY_BRIGHTNESS_ZERO,244,,,,,,,,,,,,,,I252,,,
+KEY_DISPLAY_OFF,245,,,,,,,,,,,,,,I253,,,
+KEY_WIMAX,246,,,,,,,,,,,,,,,,,
+,247,,,,,,,,,,,,,,,,,
+,248,,,,,,,,,,,,,,,,,
+,249,,,,,,,,,,,,,,,,,
+,250,,,,,,,,,,,,,,,,,
+,251,,,,,,,,,,,,,,,,,
+,252,,,,,,,,,,,,,,,,,
+,253,,,,,,,,,,,,,,,,,
+,254,,,,,,,,,,,,,,,,,
+,255,,,,0xe012,,,,,,,,,,,,,
+BTN_MISC,0x100,,,,,,,,,,,,,,,,,
+BTN_0,0x100,,,,,,,VK_LBUTTON,0x01,,,,,,,,,
+BTN_1,0x101,,,,,,,VK_RBUTTON,0x02,,,,,,,,,
+BTN_2,0x102,,,,,,,VK_MBUTTON,0x04,,,,,,,,,
+BTN_3,0x103,,,,,,,VK_XBUTTON1,0x05,,,,,,,,,
+BTN_4,0x104,,,,,,,VK_XBUTTON2,0x06,,,,,,,,,
+BTN_5,0x105,,,,,,,,,,,,,,,,,
+BTN_6,0x106,,,,,,,,,,,,,,,,,
+BTN_7,0x107,,,,,,,,,,,,,,,,,
+BTN_8,0x108,,,,,,,,,,,,,,,,,
+BTN_9,0x109,,,,,,,,,,,,,,,,,
+BTN_MOUSE,0x110,,,,,,,,,,,,,,,,,
+BTN_LEFT,0x110,,,,,,,,,,,,,,,,,
+BTN_RIGHT,0x111,,,,,,,,,,,,,,,,,
+BTN_MIDDLE,0x112,,,,,,,,,,,,,,,,,
+BTN_SIDE,0x113,,,,,,,,,,,,,,,,,
+BTN_EXTRA,0x114,,,,,,,,,,,,,,,,,
+BTN_FORWARD,0x115,,,,,,,,,,,,,,,,,
+BTN_BACK,0x116,,,,,,,,,,,,,,,,,
+BTN_TASK,0x117,,,,,,,,,,,,,,,,,
+BTN_JOYSTICK,0x120,,,,,,,,,,,,,,,,,
+BTN_TRIGGER,0x120,,,,,,,,,,,,,,,,,
+BTN_THUMB,0x121,,,,,,,,,,,,,,,,,
+BTN_THUMB2,0x122,,,,,,,,,,,,,,,,,
+BTN_TOP,0x123,,,,,,,,,,,,,,,,,
+BTN_TOP2,0x124,,,,,,,,,,,,,,,,,
+BTN_PINKIE,0x125,,,,,,,,,,,,,,,,,
+BTN_BASE,0x126,,,,,,,,,,,,,,,,,
+BTN_BASE2,0x127,,,,,,,,,,,,,,,,,
+BTN_BASE3,0x128,,,,,,,,,,,,,,,,,
+BTN_BASE4,0x129,,,,,,,,,,,,,,,,,
+BTN_BASE5,0x12a,,,,,,,,,,,,,,,,,
+BTN_BASE6,0x12b,,,,,,,,,,,,,,,,,
+BTN_DEAD,0x12f,,,,,,,,,,,,,,,,,
+BTN_GAMEPAD,0x130,,,,,,,,,,,,,,,,,
+BTN_A,0x130,,,,,,,,,,,,,,,,,
+BTN_B,0x131,,,,,,,,,,,,,,,,,
+BTN_C,0x132,,,,,,,,,,,,,,,,,
+BTN_X,0x133,,,,,,,,,,,,,,,,,
+BTN_Y,0x134,,,,,,,,,,,,,,,,,
+BTN_Z,0x135,,,,,,,,,,,,,,,,,
+BTN_TL,0x136,,,,,,,,,,,,,,,,,
+BTN_TR,0x137,,,,,,,,,,,,,,,,,
+BTN_TL2,0x138,,,,,,,,,,,,,,,,,
+BTN_TR2,0x139,,,,,,,,,,,,,,,,,
+BTN_SELECT,0x13a,,,,,,,,,,,,,,,,,
+BTN_START,0x13b,,,,,,,,,,,,,,,,,
+BTN_MODE,0x13c,,,,,,,,,,,,,,,,,
+BTN_THUMBL,0x13d,,,,,,,,,,,,,,,,,
+BTN_THUMBR,0x13e,,,,,,,,,,,,,,,,,
+BTN_DIGI,0x140,,,,,,,,,,,,,,,,,
+BTN_TOOL_PEN,0x140,,,,,,,,,,,,,,,,,
+BTN_TOOL_RUBBER,0x141,,,,,,,,,,,,,,,,,
+BTN_TOOL_BRUSH,0x142,,,,,,,,,,,,,,,,,
+BTN_TOOL_PENCIL,0x143,,,,,,,,,,,,,,,,,
+BTN_TOOL_AIRBRUSH,0x144,,,,,,,,,,,,,,,,,
+BTN_TOOL_FINGER,0x145,,,,,,,,,,,,,,,,,
+BTN_TOOL_MOUSE,0x146,,,,,,,,,,,,,,,,,
+BTN_TOOL_LENS,0x147,,,,,,,,,,,,,,,,,
+BTN_TOUCH,0x14a,,,,,,,,,,,,,,,,,
+BTN_STYLUS,0x14b,,,,,,,,,,,,,,,,,
+BTN_STYLUS2,0x14c,,,,,,,,,,,,,,,,,
+BTN_TOOL_DOUBLETAP,0x14d,,,,,,,,,,,,,,,,,
+BTN_TOOL_TRIPLETAP,0x14e,,,,,,,,,,,,,,,,,
+BTN_TOOL_QUADTAP,0x14f,,,,,,,,,,,,,,,,,
+BTN_WHEEL,0x150,,,,,,,,,,,,,,,,,
+BTN_GEAR_DOWN,0x150,,,,,,,,,,,,,,,,,
+BTN_GEAR_UP,0x151,,,,,,,,,,,,,,,,,
+KEY_OK,0x160,,,,,,,,,,,,,,,,,
+KEY_SELECT,0x161,,,,,,,VK_SELECT,0x29,,,XK_Select,0xff60,Select,SELE,,,
+KEY_GOTO,0x162,,,,,,,,,,,,,,,,,
+KEY_CLEAR,0x163,,,,,,,,,,,,,NumpadClear,CLR,,,
+KEY_POWER2,0x164,,,,,,,,,,,,,,,,,
+KEY_OPTION,0x165,,,,,,,,,,,,,,,,,
+KEY_INFO,0x166,,,,,,,,,,,,,,,,,
+KEY_TIME,0x167,,,,,,,,,,,,,,,,,
+KEY_VENDOR,0x168,,,,,,,,,,,,,,,,,
+KEY_ARCHIVE,0x169,,,,,,,,,,,,,,,,,
+KEY_PROGRAM,0x16a,,,,,,,,,,,,,,,,,
+KEY_CHANNEL,0x16b,,,,,,,,,,,,,,,,,
+KEY_FAVORITES,0x16c,,,,,,,VK_BROWSER_FAVOURITES,0xab,,,,,,,,,
+KEY_EPG,0x16d,,,,,,,,,,,,,,,,,
+KEY_PVR,0x16e,,,,,,,,,,,,,,,,,
+KEY_MHP,0x16f,,,,,,,,,,,,,,,,,
+KEY_LANGUAGE,0x170,,,,,,,,,,,,,,,,,
+KEY_TITLE,0x171,,,,,,,,,,,,,,,,,
+KEY_SUBTITLE,0x172,,,,,,,,,,,,,,,,,
+KEY_ANGLE,0x173,,,,,,,,,,,,,,,,,
+KEY_ZOOM,0x174,,,,,,,VK_ZOOM,0xfb,,,,,,,,,
+KEY_MODE,0x175,,,,,,,,,,,,,,,,,
+KEY_KEYBOARD,0x176,,,,,,,,,,,,,,,,,
+KEY_SCREEN,0x177,,,,,,,,,,,,,,,,,
+KEY_PC,0x178,,,,,,,,,,,,,,,,,
+KEY_TV,0x179,,,,,,,,,,,,,,,,,
+KEY_TV2,0x17a,,,,,,,,,,,,,,,,,
+KEY_VCR,0x17b,,,,,,,,,,,,,,,,,
+KEY_VCR2,0x17c,,,,,,,,,,,,,,,,,
+KEY_SAT,0x17d,,,,,,,,,,,,,,,,,
+KEY_SAT2,0x17e,,,,,,,,,,,,,,,,,
+KEY_CD,0x17f,,,,,,,,,,,,,,,,,
+KEY_TAPE,0x180,,,,,,,,,,,,,,,,,
+KEY_RADIO,0x181,,,,,,,,,,,,,,,,,
+KEY_TUNER,0x182,,,,,,,,,,,,,,,,,
+KEY_PLAYER,0x183,,,,,,,,,,,,,,,,,
+KEY_TEXT,0x184,,,,,,,,,,,,,,,,,
+KEY_DVD,0x185,,,,,,,,,,,,,,,,,
+KEY_AUX,0x186,,,,,,,,,,,,,,,,,
+KEY_MP3,0x187,,,,,,,,,,,,,,,,,
+KEY_AUDIO,0x188,,,,,,,,,,,,,,,,,
+KEY_VIDEO,0x189,,,,,,,,,,,,,,,,,
+KEY_DIRECTORY,0x18a,,,,,,,,,,,,,,,,,
+KEY_LIST,0x18b,,,,,,,,,,,,,,,,,
+KEY_MEMO,0x18c,,,,,,,,,,,,,,,,,
+KEY_CALENDAR,0x18d,,,,,,,,,,,,,,,,,
+KEY_RED,0x18e,,,,,,,,,,,,,,,,,
+KEY_GREEN,0x18f,,,,,,,,,,,,,,,,,
+KEY_YELLOW,0x190,,,,,,,,,,,,,,,,,
+KEY_BLUE,0x191,,,,,,,,,,,,,,,,,
+KEY_CHANNELUP,0x192,,,,,,,,,,,,,,,,,
+KEY_CHANNELDOWN,0x193,,,,,,,,,,,,,,,,,
+KEY_FIRST,0x194,,,,,,,,,,,,,,,,,
+KEY_LAST,0x195,,,,,,,,,,,,,,,,,
+KEY_AB,0x196,,,,,,,,,,,,,,,,,
+KEY_NEXT,0x197,,,,,,,,,,,,,,,,,
+KEY_RESTART,0x198,,,,,,,,,,,,,,,,,
+KEY_SLOW,0x199,,,,,,,,,,,,,,,,,
+KEY_SHUFFLE,0x19a,,,,,,,,,,,,,,,,,
+KEY_BREAK,0x19b,,,,,,,,,,,,,,BREA,,,
+KEY_BREAK,0x19b,,,,,,,,,,,,,,BRK,,,
+KEY_PREVIOUS,0x19c,,,,,,,,,,,,,,,,,
+KEY_DIGITS,0x19d,,,,,,,,,,,,,,,,,
+KEY_TEEN,0x19e,,,,,,,,,,,,,,,,,
+KEY_TWEN,0x19f,,,,,,,,,,,,,,,,,
+KEY_VIDEOPHONE,0x1a0,,,,,,,,,,,,,,,,,
+KEY_GAMES,0x1a1,,,,,,,,,,,,,,,,,
+KEY_ZOOMIN,0x1a2,,,,,,,,,,,,,,,,,
+KEY_ZOOMOUT,0x1a3,,,,,,,,,,,,,,,,,
+KEY_ZOOMRESET,0x1a4,,,,,,,,,,,,,,,,,
+KEY_WORDPROCESSOR,0x1a5,,,,,,,,,,,,,,,,,
+KEY_EDITOR,0x1a6,,,,,,,,,,,,,,,,,
+KEY_SPREADSHEET,0x1a7,,,,,,,,,,,,,,,,,
+KEY_GRAPHICSEDITOR,0x1a8,,,,,,,,,,,,,,,,,
+KEY_PRESENTATION,0x1a9,,,,,,,,,,,,,,,,,
+KEY_DATABASE,0x1aa,,,,,,,,,,,,,,,,,
+KEY_NEWS,0x1ab,,,,,,,,,,,,,,,,,
+KEY_VOICEMAIL,0x1ac,,,,,,,,,,,,,,,,,
+KEY_ADDRESSBOOK,0x1ad,,,,,,,,,,,,,,,,,
+KEY_MESSENGER,0x1ae,,,,,,,,,,,,,,,,,
+KEY_DISPLAYTOGGLE,0x1af,,,,,,,,,,,,,,,,,
+KEY_SPELLCHECK,0x1b0,,,,,,,,,,,,,,,,,
+KEY_LOGOFF,0x1b1,,,,,,,,,,,,,,,,,
+KEY_DOLLAR,0x1b2,,,,,,,,,,,,,,,,,
+KEY_EURO,0x1b3,,,,,,,,,,,,,,,,,
+KEY_FRAMEBACK,0x1b4,,,,,,,,,,,,,,,,,
+KEY_FRAMEFORWARD,0x1b5,,,,,,,,,,,,,,,,,
+KEY_CONTEXT_MENU,0x1b6,,,,,,,,,,,,,,,,,
+KEY_MEDIA_REPEAT,0x1b7,,,,,,,,,,,,,,,,,
+KEY_DEL_EOL,0x1c0,,,,,,,,,,,,,,,,,
+KEY_DEL_EOS,0x1c1,,,,,,,,,,,,,,,,,
+KEY_INS_LINE,0x1c2,,,,,,,,,,,,,,,,,
+KEY_DEL_LINE,0x1c3,,,,,,,,,,,,,,,,,
+KEY_FN,0x1d0,Function,0x3f,,,,,,,,,,,Fn,,,,
+KEY_FN_ESC,0x1d1,,,,,,,,,,,,,,,,,
+KEY_FN_F1,0x1d2,,,,,,,,,,,,,,,,,
+KEY_FN_F2,0x1d3,,,,,,,,,,,,,,,,,
+KEY_FN_F3,0x1d4,,,,,,,,,,,,,,,,,
+KEY_FN_F4,0x1d5,,,,,,,,,,,,,,,,,
+KEY_FN_F5,0x1d6,,,,,,,,,,,,,,,,,
+KEY_FN_F6,0x1d7,,,,,,,,,,,,,,,,,
+KEY_FN_F7,0x1d8,,,,,,,,,,,,,,,,,
+KEY_FN_F8,0x1d9,,,,,,,,,,,,,,,,,
+KEY_FN_F9,0x1da,,,,,,,,,,,,,,,,,
+KEY_FN_F10,0x1db,,,,,,,,,,,,,,,,,
+KEY_FN_F11,0x1dc,,,,,,,,,,,,,,,,,
+KEY_FN_F12,0x1dd,,,,,,,,,,,,,,,,,
+KEY_FN_1,0x1de,,,,,,,,,,,,,,,,,
+KEY_FN_2,0x1df,,,,,,,,,,,,,,,,,
+KEY_FN_D,0x1e0,,,,,,,,,,,,,,,,,
+KEY_FN_E,0x1e1,,,,,,,,,,,,,,,,,
+KEY_FN_F,0x1e2,,,,,,,,,,,,,,,,,
+KEY_FN_S,0x1e3,,,,,,,,,,,,,,,,,
+KEY_FN_B,0x1e4,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT1,0x1f1,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT2,0x1f2,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT3,0x1f3,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT4,0x1f4,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT5,0x1f5,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT6,0x1f6,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT7,0x1f7,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT8,0x1f8,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT9,0x1f9,,,,,,,,,,,,,,,,,
+KEY_BRL_DOT10,0x1fa,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_0,0x200,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_1,0x201,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_2,0x202,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_3,0x203,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_4,0x204,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_5,0x205,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_6,0x206,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_7,0x207,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_8,0x208,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_9,0x209,,,,,,,,,,,,,,,,,
+KEY_NUMERIC_STAR,0x20a,,,,,,,,,,,,,NumpadStar,,,,
+KEY_NUMERIC_POUND,0x20b,,,,,,,,,,,,,NumpadHash,,,,
+KEY_RFKILL,0x20c,,,,,,,,,,,,,,,,,
diff --git a/ui/keycodemapdb/meson.build b/ui/keycodemapdb/meson.build
new file mode 100644
index 0000000..eb9416b
--- /dev/null
+++ b/ui/keycodemapdb/meson.build
@@ -0,0 +1 @@
+project('keycodemapdb')
diff --git a/ui/keycodemapdb/tests/Makefile b/ui/keycodemapdb/tests/Makefile
new file mode 100644
index 0000000..3ac7a21
--- /dev/null
+++ b/ui/keycodemapdb/tests/Makefile
@@ -0,0 +1,171 @@
+TESTS := stdc stdc++ python2 python3 javascript rust
+
+check: $(TESTS)
+	@set -e; for fn in $(TESTS); do \
+		./$$fn; \
+		echo $$fn: OK; \
+	done
+	@echo Done.
+
+GEN := ../tools/keymap-gen
+DATA := ../data/keymaps.csv
+SOURCES := $(GEN) $(DATA)
+
+.DELETE_ON_ERROR:
+
+stdc: stdc.c osx2win32.h osx2win32.c osx2win32_name.h osx2win32_name.c \
+             osx2xkb.h osx2xkb.c osx2xkb_name.h osx2xkb_name.c \
+             html2win32.h html2win32.c html2win32_name.h html2win32_name.c \
+             osx.h osx.c osx_name.h osx_name.c
+	$(CC) -Wall -o $@ $(filter %.c, $^)
+osx2win32.c: $(SOURCES)
+	$(GEN) code-map --lang stdc $(DATA) osx win32 > $@
+osx2win32.h: $(SOURCES)
+	$(GEN) code-map --lang stdc-header $(DATA) osx win32 > $@
+osx2win32_name.c: $(SOURCES)
+	$(GEN) name-map --lang stdc $(DATA) osx win32 > $@
+osx2win32_name.h: $(SOURCES)
+	$(GEN) name-map --lang stdc-header $(DATA) osx win32 > $@
+osx2xkb.c: $(SOURCES)
+	$(GEN) code-map --lang stdc $(DATA) osx xkb > $@
+osx2xkb.h: $(SOURCES)
+	$(GEN) code-map --lang stdc-header $(DATA) osx xkb > $@
+osx2xkb_name.c: $(SOURCES)
+	$(GEN) name-map --lang stdc $(DATA) osx xkb > $@
+osx2xkb_name.h: $(SOURCES)
+	$(GEN) name-map --lang stdc-header $(DATA) osx xkb > $@
+html2win32.c: $(SOURCES)
+	$(GEN) code-map --lang stdc $(DATA) html win32 > $@
+html2win32.h: $(SOURCES)
+	$(GEN) code-map --lang stdc-header $(DATA) html win32 > $@
+html2win32_name.c: $(SOURCES)
+	$(GEN) name-map --lang stdc $(DATA) html win32 > $@
+html2win32_name.h: $(SOURCES)
+	$(GEN) name-map --lang stdc-header $(DATA) html win32 > $@
+osx.c: $(SOURCES)
+	$(GEN) code-table --lang stdc $(DATA) osx > $@
+osx.h: $(SOURCES)
+	$(GEN) code-table --lang stdc-header $(DATA) osx > $@
+osx_name.c: $(SOURCES)
+	$(GEN) name-table --lang stdc $(DATA) osx > $@
+osx_name.h: $(SOURCES)
+	$(GEN) name-table --lang stdc-header $(DATA) osx > $@
+
+stdc++: stdc++.cc osx2win32.hh osx2win32.cc osx2win32_name.hh osx2win32_name.cc \
+             osx2xkb.hh osx2xkb.cc osx2xkb_name.hh osx2xkb_name.cc \
+             html2win32.hh html2win32.cc html2win32_name.hh html2win32_name.cc \
+             osx.hh osx.cc osx_name.hh osx_name.cc
+	$(CXX) -Wall -std=c++11 -o $@ $(filter %.cc, $^)
+osx2win32.cc: $(SOURCES)
+	$(GEN) code-map --lang stdc++ $(DATA) osx win32 > $@
+osx2win32.hh: $(SOURCES)
+	$(GEN) code-map --lang stdc++-header $(DATA) osx win32 > $@
+osx2win32_name.cc: $(SOURCES)
+	$(GEN) name-map --lang stdc++ $(DATA) osx win32 > $@
+osx2win32_name.hh: $(SOURCES)
+	$(GEN) name-map --lang stdc++-header $(DATA) osx win32 > $@
+osx2xkb.cc: $(SOURCES)
+	$(GEN) code-map --lang stdc++ $(DATA) osx xkb > $@
+osx2xkb.hh: $(SOURCES)
+	$(GEN) code-map --lang stdc++-header $(DATA) osx xkb > $@
+osx2xkb_name.cc: $(SOURCES)
+	$(GEN) name-map --lang stdc++ $(DATA) osx xkb > $@
+osx2xkb_name.hh: $(SOURCES)
+	$(GEN) name-map --lang stdc++-header $(DATA) osx xkb > $@
+html2win32.cc: $(SOURCES)
+	$(GEN) code-map --lang stdc++ $(DATA) html win32 > $@
+html2win32.hh: $(SOURCES)
+	$(GEN) code-map --lang stdc++-header $(DATA) html win32 > $@
+html2win32_name.cc: $(SOURCES)
+	$(GEN) name-map --lang stdc++ $(DATA) html win32 > $@
+html2win32_name.hh: $(SOURCES)
+	$(GEN) name-map --lang stdc++-header $(DATA) html win32 > $@
+osx.cc: $(SOURCES)
+	$(GEN) code-table --lang stdc++ $(DATA) osx > $@
+osx.hh: $(SOURCES)
+	$(GEN) code-table --lang stdc++-header $(DATA) osx > $@
+osx_name.cc: $(SOURCES)
+	$(GEN) name-table --lang stdc++ $(DATA) osx > $@
+osx_name.hh: $(SOURCES)
+	$(GEN) name-table --lang stdc++-header $(DATA) osx > $@
+
+python2: osx2win32.py osx2win32_name.py \
+         osx2xkb.py osx2xkb_name.py \
+         html2win32.py html2win32_name.py \
+         osx.py osx_name.py
+osx2win32.py: $(SOURCES)
+	$(GEN) code-map --lang python2 $(DATA) osx win32 > $@
+osx2win32_name.py: $(SOURCES)
+	$(GEN) name-map --lang python2 $(DATA) osx win32 > $@
+osx2xkb.py: $(SOURCES)
+	$(GEN) code-map --lang python2 $(DATA) osx xkb > $@
+osx2xkb_name.py: $(SOURCES)
+	$(GEN) name-map --lang python2 $(DATA) osx xkb > $@
+html2win32.py: $(SOURCES)
+	$(GEN) code-map --lang python2 $(DATA) html win32 > $@
+html2win32_name.py: $(SOURCES)
+	$(GEN) name-map --lang python2 $(DATA) html win32 > $@
+osx.py: $(SOURCES)
+	$(GEN) code-table --lang python2 $(DATA) osx > $@
+osx_name.py: $(SOURCES)
+	$(GEN) name-table --lang python2 $(DATA) osx > $@
+
+javascript: node_modules/babel-core \
+            node_modules/babel-plugin-transform-es2015-modules-commonjs \
+            osx2win32.js osx2win32_name.js \
+            osx2xkb.js osx2xkb_name.js \
+            html2win32.js html2win32_name.js \
+            osx.js osx_name.js
+node_modules/babel-core:
+	npm install babel-core
+node_modules/babel-plugin-transform-es2015-modules-commonjs:
+	npm install babel-plugin-transform-es2015-modules-commonjs
+osx2win32.js: $(SOURCES)
+	$(GEN) code-map --lang js $(DATA) osx win32 > $@
+osx2win32_name.js: $(SOURCES)
+	$(GEN) name-map --lang js $(DATA) osx win32 > $@
+osx2xkb.js: $(SOURCES)
+	$(GEN) code-map --lang js $(DATA) osx xkb > $@
+osx2xkb_name.js: $(SOURCES)
+	$(GEN) name-map --lang js $(DATA) osx xkb > $@
+html2win32.js: $(SOURCES)
+	$(GEN) code-map --lang js $(DATA) html win32 > $@
+html2win32_name.js: $(SOURCES)
+	$(GEN) name-map --lang js $(DATA) html win32 > $@
+osx.js: $(SOURCES)
+	$(GEN) code-table --lang js $(DATA) osx > $@
+osx_name.js: $(SOURCES)
+	$(GEN) name-table --lang js $(DATA) osx > $@
+
+rust: osx2win32.rs osx2win32_name.rs \
+      osx2xkb.rs osx2xkb_name.rs \
+      html2win32.rs html2win32_name.rs \
+      osx.rs osx_name.rs
+osx2win32.rs: $(SOURCES)
+	$(GEN) code-map --lang rust $(DATA) osx win32 > $@
+osx2win32_name.rs: $(SOURCES)
+	$(GEN) name-map --lang rust $(DATA) osx win32 > $@
+osx2xkb.rs: $(SOURCES)
+	$(GEN) code-map --lang rust $(DATA) osx xkb > $@
+osx2xkb_name.rs: $(SOURCES)
+	$(GEN) name-map --lang rust $(DATA) osx xkb > $@
+html2win32.rs: $(SOURCES)
+	$(GEN) code-map --lang rust $(DATA) html win32 > $@
+html2win32_name.rs: $(SOURCES)
+	$(GEN) name-map --lang rust $(DATA) html win32 > $@
+osx.rs: $(SOURCES)
+	$(GEN) code-table --lang rust $(DATA) osx > $@
+osx_name.rs: $(SOURCES)
+	$(GEN) name-table --lang rust $(DATA) osx > $@
+
+clean:
+	rm -rf node_modules
+	rm -f osx2win32.*
+	rm -f osx2win32_name.*
+	rm -f osx2xkb.*
+	rm -f osx2xkb_name.*
+	rm -f html2win32.*
+	rm -f html2win32_name.*
+	rm -f osx.*
+	rm -f osx_name.*
+	rm -f stdc stdc++
diff --git a/ui/keycodemapdb/tests/javascript b/ui/keycodemapdb/tests/javascript
new file mode 100755
index 0000000..5179db2
--- /dev/null
+++ b/ui/keycodemapdb/tests/javascript
@@ -0,0 +1,53 @@
+#!/usr/bin/env node
+/*
+ * Keycode Map Generator JavaScript Tests
+ *
+ * Copyright 2017 Pierre Ossman for Cendio AB
+ *
+ * This file is dual license under the terms of the GPLv2 or later
+ * and 3-clause BSD licenses.
+ */
+
+"use strict";
+
+var assert = require('assert');
+var babel = require('babel-core');
+var fs = require('fs');
+
+function include(fn) {
+  var options = {
+    plugins: ["transform-es2015-modules-commonjs"]
+  };
+
+  var code = babel.transformFileSync(fn, options).code;
+  fs.writeFileSync("." + fn + "_nodejs.js", code);
+  var imp = require("./." + fn + "_nodejs.js");
+  fs.unlinkSync("./." + fn + "_nodejs.js");
+
+  return imp
+}
+
+var code_map_osx_to_win32 = include("osx2win32.js").default;
+var name_map_osx_to_win32 = include("osx2win32_name.js").default;
+
+var code_map_osx_to_xkb = include("osx2xkb.js").default;
+var name_map_osx_to_xkb = include("osx2xkb_name.js").default;
+
+var code_map_html_to_win32 = include("html2win32.js").default;
+var name_map_html_to_win32 = include("html2win32_name.js").default;
+
+var code_table_osx = include("osx.js").default;
+var name_table_osx = include("osx_name.js").default;
+
+assert.equal(code_map_osx_to_win32[0x1d], 0x30);
+assert.equal(name_map_osx_to_win32[0x1d], "VK_0");
+
+assert.equal(code_map_osx_to_xkb[0x1d], "AE10");
+assert.equal(name_map_osx_to_xkb[0x1d], "AE10");
+
+assert.equal(code_map_html_to_win32["ControlLeft"], 0x11);
+assert.equal(name_map_html_to_win32["ControlLeft"], "VK_CONTROL");
+
+assert.equal(code_table_osx[0x1d], 0x3b);
+assert.equal(name_table_osx[0x1d], "Control");
+
diff --git a/ui/keycodemapdb/tests/python2 b/ui/keycodemapdb/tests/python2
new file mode 100755
index 0000000..28a5b03
--- /dev/null
+++ b/ui/keycodemapdb/tests/python2
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+python ./test.py
diff --git a/ui/keycodemapdb/tests/python3 b/ui/keycodemapdb/tests/python3
new file mode 100755
index 0000000..ded1f68
--- /dev/null
+++ b/ui/keycodemapdb/tests/python3
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+python3 ./test.py
diff --git a/ui/keycodemapdb/tests/rust b/ui/keycodemapdb/tests/rust
new file mode 100755
index 0000000..0e133b1
--- /dev/null
+++ b/ui/keycodemapdb/tests/rust
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+cd rust-test
+cargo test
+cargo clippy
diff --git a/ui/keycodemapdb/tests/rust-test/Cargo.toml b/ui/keycodemapdb/tests/rust-test/Cargo.toml
new file mode 100644
index 0000000..832ac37
--- /dev/null
+++ b/ui/keycodemapdb/tests/rust-test/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "rust-test"
+version = "0.1.0"
+authors = ["Marc-Andr Lureau <marcandre.lureau@redhat.com>"]
+edition = "2018"
+
+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
+
+[dependencies]
+phf = { version = "0.8", features = ["macros"] }
diff --git a/ui/keycodemapdb/tests/rust-test/src/main.rs b/ui/keycodemapdb/tests/rust-test/src/main.rs
new file mode 100644
index 0000000..ba165d0
--- /dev/null
+++ b/ui/keycodemapdb/tests/rust-test/src/main.rs
@@ -0,0 +1,28 @@
+include!("../../html2win32_name.rs");
+include!("../../html2win32.rs");
+include!("../../osx2win32_name.rs");
+include!("../../osx2win32.rs");
+include!("../../osx2xkb_name.rs");
+include!("../../osx2xkb.rs");
+include!("../../osx_name.rs");
+include!("../../osx.rs");
+
+fn main() {
+    assert_eq!(CODE_MAP_OSX_TO_WIN32[0x1d], 0x30);
+    assert_eq!(NAME_MAP_OSX_TO_WIN32[0x1d], "VK_0");
+
+    assert_eq!(CODE_MAP_OSX_TO_XKB[0x1d], "AE10");
+    assert_eq!(NAME_MAP_OSX_TO_XKB[0x1d], "AE10");
+
+    assert_eq!(CODE_MAP_HTML_TO_WIN32["ControlLeft"], 0x11);
+    assert_eq!(NAME_MAP_HTML_TO_WIN32["ControlLeft"], "VK_CONTROL");
+
+    assert_eq!(CODE_TABLE_OSX[0x1d], 0x3b);
+    assert_eq!(NAME_TABLE_OSX[0x1d], "Control");
+}
+
+
+#[test]
+fn test() {
+    main()
+}
diff --git a/ui/keycodemapdb/tests/stdc++.cc b/ui/keycodemapdb/tests/stdc++.cc
new file mode 100644
index 0000000..5e3e8f5
--- /dev/null
+++ b/ui/keycodemapdb/tests/stdc++.cc
@@ -0,0 +1,40 @@
+/*
+ * Keycode Map Generator C++ Tests
+ *
+ * Copyright 2017 Pierre Ossman for Cendio AB
+ *
+ * This file is dual license under the terms of the GPLv2 or later
+ * and 3-clause BSD licenses.
+ */
+
+#include <assert.h>
+#include <string.h>
+
+#include "osx2win32.hh"
+#include "osx2win32_name.hh"
+
+#include "osx2xkb.hh"
+#include "osx2xkb_name.hh"
+
+#include "html2win32.hh"
+#include "html2win32_name.hh"
+
+#include "osx.hh"
+#include "osx_name.hh"
+
+int main(int argc, char** argv)
+{
+	assert(code_map_osx_to_win32[0x1d] == 0x30);
+	assert(strcmp(name_map_osx_to_win32[0x1d], "VK_0") == 0);
+
+	assert(strcmp(code_map_osx_to_xkb[0x1d], "AE10") == 0);
+	assert(strcmp(name_map_osx_to_xkb[0x1d], "AE10") == 0);
+
+	assert(code_map_html_to_win32.at("ControlLeft") == 0x11);
+	assert(strcmp(name_map_html_to_win32.at("ControlLeft"), "VK_CONTROL") == 0);
+
+	assert(code_table_osx[0x1d] == 0x3b);
+	assert(strcmp(name_table_osx[0x1d], "Control") == 0);
+
+	return 0;
+}
diff --git a/ui/keycodemapdb/tests/stdc.c b/ui/keycodemapdb/tests/stdc.c
new file mode 100644
index 0000000..e4946fa
--- /dev/null
+++ b/ui/keycodemapdb/tests/stdc.c
@@ -0,0 +1,64 @@
+/*
+ * Keycode Map Generator C Tests
+ *
+ * Copyright 2017 Pierre Ossman for Cendio AB
+ *
+ * This file is dual license under the terms of the GPLv2 or later
+ * and 3-clause BSD licenses.
+ */
+
+#include <assert.h>
+#include <string.h>
+
+#include "osx2win32.h"
+#include "osx2win32_name.h"
+
+#include "osx2xkb.h"
+#include "osx2xkb_name.h"
+
+#include "html2win32.h"
+#include "html2win32_name.h"
+
+#include "osx.h"
+#include "osx_name.h"
+
+#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
+
+int main(int argc, char** argv)
+{
+	unsigned i;
+
+	assert(code_map_osx_to_win32_len == ARRAY_SIZE(code_map_osx_to_win32));
+	assert(code_map_osx_to_win32[0x1d] == 0x30);
+	assert(name_map_osx_to_win32_len == ARRAY_SIZE(name_map_osx_to_win32));
+	assert(strcmp(name_map_osx_to_win32[0x1d], "VK_0") == 0);
+
+	assert(code_map_osx_to_xkb_len == ARRAY_SIZE(code_map_osx_to_xkb));
+	assert(strcmp(code_map_osx_to_xkb[0x1d], "AE10") == 0);
+	assert(name_map_osx_to_xkb_len == ARRAY_SIZE(name_map_osx_to_xkb));
+	assert(strcmp(name_map_osx_to_xkb[0x1d], "AE10") == 0);
+
+	assert(code_map_html_to_win32_len == ARRAY_SIZE(code_map_html_to_win32));
+	for (i = 0;i < code_map_html_to_win32_len;i++) {
+		if (strcmp(code_map_html_to_win32[i].from, "ControlLeft") == 0) {
+			assert(code_map_html_to_win32[i].to == 0x11);
+			break;
+		}
+	}
+	assert(i != code_map_html_to_win32_len);
+	assert(name_map_html_to_win32_len == ARRAY_SIZE(name_map_html_to_win32));
+	for (i = 0;i < name_map_html_to_win32_len;i++) {
+		if (strcmp(name_map_html_to_win32[i].from, "ControlLeft") == 0) {
+			assert(strcmp(name_map_html_to_win32[i].to, "VK_CONTROL") == 0);
+			break;
+		}
+	}
+	assert(i != name_map_html_to_win32_len);
+
+	assert(code_table_osx_len == ARRAY_SIZE(code_table_osx));
+	assert(code_table_osx[0x1d] == 0x3b);
+	assert(name_table_osx_len == ARRAY_SIZE(name_table_osx));
+	assert(strcmp(name_table_osx[0x1d], "Control") == 0);
+
+	return 0;
+}
diff --git a/ui/keycodemapdb/tests/test.py b/ui/keycodemapdb/tests/test.py
new file mode 100644
index 0000000..f265145
--- /dev/null
+++ b/ui/keycodemapdb/tests/test.py
@@ -0,0 +1,30 @@
+# Keycode Map Generator Python Tests
+#
+# Copyright 2017 Pierre Ossman for Cendio AB
+#
+# This file is dual license under the terms of the GPLv2 or later
+# and 3-clause BSD licenses.
+
+import osx2win32
+import osx2win32_name
+
+import osx2xkb
+import osx2xkb_name
+
+import html2win32
+import html2win32_name
+
+import osx
+import osx_name
+
+assert osx2win32.code_map_osx_to_win32[0x1d] == 0x30
+assert osx2win32_name.name_map_osx_to_win32[0x1d] == "VK_0"
+
+assert osx2xkb.code_map_osx_to_xkb[0x1d] == "AE10"
+assert osx2xkb_name.name_map_osx_to_xkb[0x1d] == "AE10"
+
+assert html2win32.code_map_html_to_win32["ControlLeft"] == 0x11
+assert html2win32_name.name_map_html_to_win32["ControlLeft"] == "VK_CONTROL"
+
+assert osx.code_table_osx[0x1d] == 0x3b;
+assert osx_name.name_table_osx[0x1d] == "Control";
diff --git a/ui/keycodemapdb/thirdparty/LICENSE-argparse.txt b/ui/keycodemapdb/thirdparty/LICENSE-argparse.txt
new file mode 100644
index 0000000..640bc78
--- /dev/null
+++ b/ui/keycodemapdb/thirdparty/LICENSE-argparse.txt
@@ -0,0 +1,20 @@
+argparse is (c) 2006-2009 Steven J. Bethard <steven.bethard@gmail.com>.
+
+The argparse module was contributed to Python as of Python 2.7 and thus
+was licensed under the Python license. Same license applies to all files in
+the argparse package project.
+
+For details about the Python License, please see doc/Python-License.txt.
+
+History
+-------
+
+Before (and including) argparse 1.1, the argparse package was licensed under
+Apache License v2.0.
+
+After argparse 1.1, all project files from the argparse project were deleted
+due to license compatibility issues between Apache License 2.0 and GNU GPL v2.
+
+The project repository then had a clean start with some files taken from
+Python 2.7.1, so definitely all files are under Python License now.
+
diff --git a/ui/keycodemapdb/thirdparty/__init__.py b/ui/keycodemapdb/thirdparty/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/ui/keycodemapdb/thirdparty/argparse.py b/ui/keycodemapdb/thirdparty/argparse.py
new file mode 100644
index 0000000..70a77cc
--- /dev/null
+++ b/ui/keycodemapdb/thirdparty/argparse.py
@@ -0,0 +1,2392 @@
+# Author: Steven J. Bethard <steven.bethard@gmail.com>.
+# Maintainer: Thomas Waldmann <tw@waldmann-edv.de>
+
+"""Command-line parsing library
+
+This module is an optparse-inspired command-line parsing library that:
+
+    - handles both optional and positional arguments
+    - produces highly informative usage messages
+    - supports parsers that dispatch to sub-parsers
+
+The following is a simple usage example that sums integers from the
+command-line and writes the result to a file::
+
+    parser = argparse.ArgumentParser(
+        description='sum the integers at the command line')
+    parser.add_argument(
+        'integers', metavar='int', nargs='+', type=int,
+        help='an integer to be summed')
+    parser.add_argument(
+        '--log', default=sys.stdout, type=argparse.FileType('w'),
+        help='the file where the sum should be written')
+    args = parser.parse_args()
+    args.log.write('%s' % sum(args.integers))
+    args.log.close()
+
+The module contains the following public classes:
+
+    - ArgumentParser -- The main entry point for command-line parsing. As the
+        example above shows, the add_argument() method is used to populate
+        the parser with actions for optional and positional arguments. Then
+        the parse_args() method is invoked to convert the args at the
+        command-line into an object with attributes.
+
+    - ArgumentError -- The exception raised by ArgumentParser objects when
+        there are errors with the parser's actions. Errors raised while
+        parsing the command-line are caught by ArgumentParser and emitted
+        as command-line messages.
+
+    - FileType -- A factory for defining types of files to be created. As the
+        example above shows, instances of FileType are typically passed as
+        the type= argument of add_argument() calls.
+
+    - Action -- The base class for parser actions. Typically actions are
+        selected by passing strings like 'store_true' or 'append_const' to
+        the action= argument of add_argument(). However, for greater
+        customization of ArgumentParser actions, subclasses of Action may
+        be defined and passed as the action= argument.
+
+    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
+        ArgumentDefaultsHelpFormatter -- Formatter classes which
+        may be passed as the formatter_class= argument to the
+        ArgumentParser constructor. HelpFormatter is the default,
+        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
+        not to change the formatting for help text, and
+        ArgumentDefaultsHelpFormatter adds information about argument defaults
+        to the help.
+
+All other classes in this module are considered implementation details.
+(Also note that HelpFormatter and RawDescriptionHelpFormatter are only
+considered public as object names -- the API of the formatter objects is
+still considered an implementation detail.)
+"""
+
+__version__ = '1.4.0'  # we use our own version number independant of the
+                       # one in stdlib and we release this on pypi.
+
+__external_lib__ = True  # to make sure the tests really test THIS lib,
+                         # not the builtin one in Python stdlib
+
+__all__ = [
+    'ArgumentParser',
+    'ArgumentError',
+    'ArgumentTypeError',
+    'FileType',
+    'HelpFormatter',
+    'ArgumentDefaultsHelpFormatter',
+    'RawDescriptionHelpFormatter',
+    'RawTextHelpFormatter',
+    'Namespace',
+    'Action',
+    'ONE_OR_MORE',
+    'OPTIONAL',
+    'PARSER',
+    'REMAINDER',
+    'SUPPRESS',
+    'ZERO_OR_MORE',
+]
+
+
+import copy as _copy
+import os as _os
+import re as _re
+import sys as _sys
+import textwrap as _textwrap
+
+from gettext import gettext as _
+
+try:
+    set
+except NameError:
+    # for python < 2.4 compatibility (sets module is there since 2.3):
+    from sets import Set as set
+
+try:
+    basestring
+except NameError:
+    basestring = str
+
+try:
+    sorted
+except NameError:
+    # for python < 2.4 compatibility:
+    def sorted(iterable, reverse=False):
+        result = list(iterable)
+        result.sort()
+        if reverse:
+            result.reverse()
+        return result
+
+
+def _callable(obj):
+    return hasattr(obj, '__call__') or hasattr(obj, '__bases__')
+
+
+SUPPRESS = '==SUPPRESS=='
+
+OPTIONAL = '?'
+ZERO_OR_MORE = '*'
+ONE_OR_MORE = '+'
+PARSER = 'A...'
+REMAINDER = '...'
+_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'
+
+# =============================
+# Utility functions and classes
+# =============================
+
+class _AttributeHolder(object):
+    """Abstract base class that provides __repr__.
+
+    The __repr__ method returns a string in the format::
+        ClassName(attr=name, attr=name, ...)
+    The attributes are determined either by a class-level attribute,
+    '_kwarg_names', or by inspecting the instance __dict__.
+    """
+
+    def __repr__(self):
+        type_name = type(self).__name__
+        arg_strings = []
+        for arg in self._get_args():
+            arg_strings.append(repr(arg))
+        for name, value in self._get_kwargs():
+            arg_strings.append('%s=%r' % (name, value))
+        return '%s(%s)' % (type_name, ', '.join(arg_strings))
+
+    def _get_kwargs(self):
+        return sorted(self.__dict__.items())
+
+    def _get_args(self):
+        return []
+
+
+def _ensure_value(namespace, name, value):
+    if getattr(namespace, name, None) is None:
+        setattr(namespace, name, value)
+    return getattr(namespace, name)
+
+
+# ===============
+# Formatting Help
+# ===============
+
+class HelpFormatter(object):
+    """Formatter for generating usage messages and argument help strings.
+
+    Only the name of this class is considered a public API. All the methods
+    provided by the class are considered an implementation detail.
+    """
+
+    def __init__(self,
+                 prog,
+                 indent_increment=2,
+                 max_help_position=24,
+                 width=None):
+
+        # default setting for width
+        if width is None:
+            try:
+                width = int(_os.environ['COLUMNS'])
+            except (KeyError, ValueError):
+                width = 80
+            width -= 2
+
+        self._prog = prog
+        self._indent_increment = indent_increment
+        self._max_help_position = max_help_position
+        self._width = width
+
+        self._current_indent = 0
+        self._level = 0
+        self._action_max_length = 0
+
+        self._root_section = self._Section(self, None)
+        self._current_section = self._root_section
+
+        self._whitespace_matcher = _re.compile(r'\s+')
+        self._long_break_matcher = _re.compile(r'\n\n\n+')
+
+    # ===============================
+    # Section and indentation methods
+    # ===============================
+    def _indent(self):
+        self._current_indent += self._indent_increment
+        self._level += 1
+
+    def _dedent(self):
+        self._current_indent -= self._indent_increment
+        assert self._current_indent >= 0, 'Indent decreased below 0.'
+        self._level -= 1
+
+    class _Section(object):
+
+        def __init__(self, formatter, parent, heading=None):
+            self.formatter = formatter
+            self.parent = parent
+            self.heading = heading
+            self.items = []
+
+        def format_help(self):
+            # format the indented section
+            if self.parent is not None:
+                self.formatter._indent()
+            join = self.formatter._join_parts
+            for func, args in self.items:
+                func(*args)
+            item_help = join([func(*args) for func, args in self.items])
+            if self.parent is not None:
+                self.formatter._dedent()
+
+            # return nothing if the section was empty
+            if not item_help:
+                return ''
+
+            # add the heading if the section was non-empty
+            if self.heading is not SUPPRESS and self.heading is not None:
+                current_indent = self.formatter._current_indent
+                heading = '%*s%s:\n' % (current_indent, '', self.heading)
+            else:
+                heading = ''
+
+            # join the section-initial newline, the heading and the help
+            return join(['\n', heading, item_help, '\n'])
+
+    def _add_item(self, func, args):
+        self._current_section.items.append((func, args))
+
+    # ========================
+    # Message building methods
+    # ========================
+    def start_section(self, heading):
+        self._indent()
+        section = self._Section(self, self._current_section, heading)
+        self._add_item(section.format_help, [])
+        self._current_section = section
+
+    def end_section(self):
+        self._current_section = self._current_section.parent
+        self._dedent()
+
+    def add_text(self, text):
+        if text is not SUPPRESS and text is not None:
+            self._add_item(self._format_text, [text])
+
+    def add_usage(self, usage, actions, groups, prefix=None):
+        if usage is not SUPPRESS:
+            args = usage, actions, groups, prefix
+            self._add_item(self._format_usage, args)
+
+    def add_argument(self, action):
+        if action.help is not SUPPRESS:
+
+            # find all invocations
+            get_invocation = self._format_action_invocation
+            invocations = [get_invocation(action)]
+            for subaction in self._iter_indented_subactions(action):
+                invocations.append(get_invocation(subaction))
+
+            # update the maximum item length
+            invocation_length = max([len(s) for s in invocations])
+            action_length = invocation_length + self._current_indent
+            self._action_max_length = max(self._action_max_length,
+                                          action_length)
+
+            # add the item to the list
+            self._add_item(self._format_action, [action])
+
+    def add_arguments(self, actions):
+        for action in actions:
+            self.add_argument(action)
+
+    # =======================
+    # Help-formatting methods
+    # =======================
+    def format_help(self):
+        help = self._root_section.format_help()
+        if help:
+            help = self._long_break_matcher.sub('\n\n', help)
+            help = help.strip('\n') + '\n'
+        return help
+
+    def _join_parts(self, part_strings):
+        return ''.join([part
+                        for part in part_strings
+                        if part and part is not SUPPRESS])
+
+    def _format_usage(self, usage, actions, groups, prefix):
+        if prefix is None:
+            prefix = _('usage: ')
+
+        # if usage is specified, use that
+        if usage is not None:
+            usage = usage % dict(prog=self._prog)
+
+        # if no optionals or positionals are available, usage is just prog
+        elif usage is None and not actions:
+            usage = '%(prog)s' % dict(prog=self._prog)
+
+        # if optionals and positionals are available, calculate usage
+        elif usage is None:
+            prog = '%(prog)s' % dict(prog=self._prog)
+
+            # split optionals from positionals
+            optionals = []
+            positionals = []
+            for action in actions:
+                if action.option_strings:
+                    optionals.append(action)
+                else:
+                    positionals.append(action)
+
+            # build full usage string
+            format = self._format_actions_usage
+            action_usage = format(optionals + positionals, groups)
+            usage = ' '.join([s for s in [prog, action_usage] if s])
+
+            # wrap the usage parts if it's too long
+            text_width = self._width - self._current_indent
+            if len(prefix) + len(usage) > text_width:
+
+                # break usage into wrappable parts
+                part_regexp = r'\(.*?\)+|\[.*?\]+|\S+'
+                opt_usage = format(optionals, groups)
+                pos_usage = format(positionals, groups)
+                opt_parts = _re.findall(part_regexp, opt_usage)
+                pos_parts = _re.findall(part_regexp, pos_usage)
+                assert ' '.join(opt_parts) == opt_usage
+                assert ' '.join(pos_parts) == pos_usage
+
+                # helper for wrapping lines
+                def get_lines(parts, indent, prefix=None):
+                    lines = []
+                    line = []
+                    if prefix is not None:
+                        line_len = len(prefix) - 1
+                    else:
+                        line_len = len(indent) - 1
+                    for part in parts:
+                        if line_len + 1 + len(part) > text_width:
+                            lines.append(indent + ' '.join(line))
+                            line = []
+                            line_len = len(indent) - 1
+                        line.append(part)
+                        line_len += len(part) + 1
+                    if line:
+                        lines.append(indent + ' '.join(line))
+                    if prefix is not None:
+                        lines[0] = lines[0][len(indent):]
+                    return lines
+
+                # if prog is short, follow it with optionals or positionals
+                if len(prefix) + len(prog) <= 0.75 * text_width:
+                    indent = ' ' * (len(prefix) + len(prog) + 1)
+                    if opt_parts:
+                        lines = get_lines([prog] + opt_parts, indent, prefix)
+                        lines.extend(get_lines(pos_parts, indent))
+                    elif pos_parts:
+                        lines = get_lines([prog] + pos_parts, indent, prefix)
+                    else:
+                        lines = [prog]
+
+                # if prog is long, put it on its own line
+                else:
+                    indent = ' ' * len(prefix)
+                    parts = opt_parts + pos_parts
+                    lines = get_lines(parts, indent)
+                    if len(lines) > 1:
+                        lines = []
+                        lines.extend(get_lines(opt_parts, indent))
+                        lines.extend(get_lines(pos_parts, indent))
+                    lines = [prog] + lines
+
+                # join lines into usage
+                usage = '\n'.join(lines)
+
+        # prefix with 'usage:'
+        return '%s%s\n\n' % (prefix, usage)
+
+    def _format_actions_usage(self, actions, groups):
+        # find group indices and identify actions in groups
+        group_actions = set()
+        inserts = {}
+        for group in groups:
+            try:
+                start = actions.index(group._group_actions[0])
+            except ValueError:
+                continue
+            else:
+                end = start + len(group._group_actions)
+                if actions[start:end] == group._group_actions:
+                    for action in group._group_actions:
+                        group_actions.add(action)
+                    if not group.required:
+                        if start in inserts:
+                            inserts[start] += ' ['
+                        else:
+                            inserts[start] = '['
+                        inserts[end] = ']'
+                    else:
+                        if start in inserts:
+                            inserts[start] += ' ('
+                        else:
+                            inserts[start] = '('
+                        inserts[end] = ')'
+                    for i in range(start + 1, end):
+                        inserts[i] = '|'
+
+        # collect all actions format strings
+        parts = []
+        for i, action in enumerate(actions):
+
+            # suppressed arguments are marked with None
+            # remove | separators for suppressed arguments
+            if action.help is SUPPRESS:
+                parts.append(None)
+                if inserts.get(i) == '|':
+                    inserts.pop(i)
+                elif inserts.get(i + 1) == '|':
+                    inserts.pop(i + 1)
+
+            # produce all arg strings
+            elif not action.option_strings:
+                part = self._format_args(action, action.dest)
+
+                # if it's in a group, strip the outer []
+                if action in group_actions:
+                    if part[0] == '[' and part[-1] == ']':
+                        part = part[1:-1]
+
+                # add the action string to the list
+                parts.append(part)
+
+            # produce the first way to invoke the option in brackets
+            else:
+                option_string = action.option_strings[0]
+
+                # if the Optional doesn't take a value, format is:
+                #    -s or --long
+                if action.nargs == 0:
+                    part = '%s' % option_string
+
+                # if the Optional takes a value, format is:
+                #    -s ARGS or --long ARGS
+                else:
+                    default = action.dest.upper()
+                    args_string = self._format_args(action, default)
+                    part = '%s %s' % (option_string, args_string)
+
+                # make it look optional if it's not required or in a group
+                if not action.required and action not in group_actions:
+                    part = '[%s]' % part
+
+                # add the action string to the list
+                parts.append(part)
+
+        # insert things at the necessary indices
+        for i in sorted(inserts, reverse=True):
+            parts[i:i] = [inserts[i]]
+
+        # join all the action items with spaces
+        text = ' '.join([item for item in parts if item is not None])
+
+        # clean up separators for mutually exclusive groups
+        open = r'[\[(]'
+        close = r'[\])]'
+        text = _re.sub(r'(%s) ' % open, r'\1', text)
+        text = _re.sub(r' (%s)' % close, r'\1', text)
+        text = _re.sub(r'%s *%s' % (open, close), r'', text)
+        text = _re.sub(r'\(([^|]*)\)', r'\1', text)
+        text = text.strip()
+
+        # return the text
+        return text
+
+    def _format_text(self, text):
+        if '%(prog)' in text:
+            text = text % dict(prog=self._prog)
+        text_width = self._width - self._current_indent
+        indent = ' ' * self._current_indent
+        return self._fill_text(text, text_width, indent) + '\n\n'
+
+    def _format_action(self, action):
+        # determine the required width and the entry label
+        help_position = min(self._action_max_length + 2,
+                            self._max_help_position)
+        help_width = self._width - help_position
+        action_width = help_position - self._current_indent - 2
+        action_header = self._format_action_invocation(action)
+
+        # ho nelp; start on same line and add a final newline
+        if not action.help:
+            tup = self._current_indent, '', action_header
+            action_header = '%*s%s\n' % tup
+
+        # short action name; start on the same line and pad two spaces
+        elif len(action_header) <= action_width:
+            tup = self._current_indent, '', action_width, action_header
+            action_header = '%*s%-*s  ' % tup
+            indent_first = 0
+
+        # long action name; start on the next line
+        else:
+            tup = self._current_indent, '', action_header
+            action_header = '%*s%s\n' % tup
+            indent_first = help_position
+
+        # collect the pieces of the action help
+        parts = [action_header]
+
+        # if there was help for the action, add lines of help text
+        if action.help:
+            help_text = self._expand_help(action)
+            help_lines = self._split_lines(help_text, help_width)
+            parts.append('%*s%s\n' % (indent_first, '', help_lines[0]))
+            for line in help_lines[1:]:
+                parts.append('%*s%s\n' % (help_position, '', line))
+
+        # or add a newline if the description doesn't end with one
+        elif not action_header.endswith('\n'):
+            parts.append('\n')
+
+        # if there are any sub-actions, add their help as well
+        for subaction in self._iter_indented_subactions(action):
+            parts.append(self._format_action(subaction))
+
+        # return a single string
+        return self._join_parts(parts)
+
+    def _format_action_invocation(self, action):
+        if not action.option_strings:
+            metavar, = self._metavar_formatter(action, action.dest)(1)
+            return metavar
+
+        else:
+            parts = []
+
+            # if the Optional doesn't take a value, format is:
+            #    -s, --long
+            if action.nargs == 0:
+                parts.extend(action.option_strings)
+
+            # if the Optional takes a value, format is:
+            #    -s ARGS, --long ARGS
+            else:
+                default = action.dest.upper()
+                args_string = self._format_args(action, default)
+                for option_string in action.option_strings:
+                    parts.append('%s %s' % (option_string, args_string))
+
+            return ', '.join(parts)
+
+    def _metavar_formatter(self, action, default_metavar):
+        if action.metavar is not None:
+            result = action.metavar
+        elif action.choices is not None:
+            choice_strs = [str(choice) for choice in action.choices]
+            result = '{%s}' % ','.join(choice_strs)
+        else:
+            result = default_metavar
+
+        def format(tuple_size):
+            if isinstance(result, tuple):
+                return result
+            else:
+                return (result, ) * tuple_size
+        return format
+
+    def _format_args(self, action, default_metavar):
+        get_metavar = self._metavar_formatter(action, default_metavar)
+        if action.nargs is None:
+            result = '%s' % get_metavar(1)
+        elif action.nargs == OPTIONAL:
+            result = '[%s]' % get_metavar(1)
+        elif action.nargs == ZERO_OR_MORE:
+            result = '[%s [%s ...]]' % get_metavar(2)
+        elif action.nargs == ONE_OR_MORE:
+            result = '%s [%s ...]' % get_metavar(2)
+        elif action.nargs == REMAINDER:
+            result = '...'
+        elif action.nargs == PARSER:
+            result = '%s ...' % get_metavar(1)
+        else:
+            formats = ['%s' for _ in range(action.nargs)]
+            result = ' '.join(formats) % get_metavar(action.nargs)
+        return result
+
+    def _expand_help(self, action):
+        params = dict(vars(action), prog=self._prog)
+        for name in list(params):
+            if params[name] is SUPPRESS:
+                del params[name]
+        for name in list(params):
+            if hasattr(params[name], '__name__'):
+                params[name] = params[name].__name__
+        if params.get('choices') is not None:
+            choices_str = ', '.join([str(c) for c in params['choices']])
+            params['choices'] = choices_str
+        return self._get_help_string(action) % params
+
+    def _iter_indented_subactions(self, action):
+        try:
+            get_subactions = action._get_subactions
+        except AttributeError:
+            pass
+        else:
+            self._indent()
+            for subaction in get_subactions():
+                yield subaction
+            self._dedent()
+
+    def _split_lines(self, text, width):
+        text = self._whitespace_matcher.sub(' ', text).strip()
+        return _textwrap.wrap(text, width)
+
+    def _fill_text(self, text, width, indent):
+        text = self._whitespace_matcher.sub(' ', text).strip()
+        return _textwrap.fill(text, width, initial_indent=indent,
+                                           subsequent_indent=indent)
+
+    def _get_help_string(self, action):
+        return action.help
+
+
+class RawDescriptionHelpFormatter(HelpFormatter):
+    """Help message formatter which retains any formatting in descriptions.
+
+    Only the name of this class is considered a public API. All the methods
+    provided by the class are considered an implementation detail.
+    """
+
+    def _fill_text(self, text, width, indent):
+        return ''.join([indent + line for line in text.splitlines(True)])
+
+
+class RawTextHelpFormatter(RawDescriptionHelpFormatter):
+    """Help message formatter which retains formatting of all help text.
+
+    Only the name of this class is considered a public API. All the methods
+    provided by the class are considered an implementation detail.
+    """
+
+    def _split_lines(self, text, width):
+        return text.splitlines()
+
+
+class ArgumentDefaultsHelpFormatter(HelpFormatter):
+    """Help message formatter which adds default values to argument help.
+
+    Only the name of this class is considered a public API. All the methods
+    provided by the class are considered an implementation detail.
+    """
+
+    def _get_help_string(self, action):
+        help = action.help
+        if '%(default)' not in action.help:
+            if action.default is not SUPPRESS:
+                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
+                if action.option_strings or action.nargs in defaulting_nargs:
+                    help += ' (default: %(default)s)'
+        return help
+
+
+# =====================
+# Options and Arguments
+# =====================
+
+def _get_action_name(argument):
+    if argument is None:
+        return None
+    elif argument.option_strings:
+        return  '/'.join(argument.option_strings)
+    elif argument.metavar not in (None, SUPPRESS):
+        return argument.metavar
+    elif argument.dest not in (None, SUPPRESS):
+        return argument.dest
+    else:
+        return None
+
+
+class ArgumentError(Exception):
+    """An error from creating or using an argument (optional or positional).
+
+    The string value of this exception is the message, augmented with
+    information about the argument that caused it.
+    """
+
+    def __init__(self, argument, message):
+        self.argument_name = _get_action_name(argument)
+        self.message = message
+
+    def __str__(self):
+        if self.argument_name is None:
+            format = '%(message)s'
+        else:
+            format = 'argument %(argument_name)s: %(message)s'
+        return format % dict(message=self.message,
+                             argument_name=self.argument_name)
+
+
+class ArgumentTypeError(Exception):
+    """An error from trying to convert a command line string to a type."""
+    pass
+
+
+# ==============
+# Action classes
+# ==============
+
+class Action(_AttributeHolder):
+    """Information about how to convert command line strings to Python objects.
+
+    Action objects are used by an ArgumentParser to represent the information
+    needed to parse a single argument from one or more strings from the
+    command line. The keyword arguments to the Action constructor are also
+    all attributes of Action instances.
+
+    Keyword Arguments:
+
+        - option_strings -- A list of command-line option strings which
+            should be associated with this action.
+
+        - dest -- The name of the attribute to hold the created object(s)
+
+        - nargs -- The number of command-line arguments that should be
+            consumed. By default, one argument will be consumed and a single
+            value will be produced.  Other values include:
+                - N (an integer) consumes N arguments (and produces a list)
+                - '?' consumes zero or one arguments
+                - '*' consumes zero or more arguments (and produces a list)
+                - '+' consumes one or more arguments (and produces a list)
+            Note that the difference between the default and nargs=1 is that
+            with the default, a single value will be produced, while with
+            nargs=1, a list containing a single value will be produced.
+
+        - const -- The value to be produced if the option is specified and the
+            option uses an action that takes no values.
+
+        - default -- The value to be produced if the option is not specified.
+
+        - type -- The type which the command-line arguments should be converted
+            to, should be one of 'string', 'int', 'float', 'complex' or a
+            callable object that accepts a single string argument. If None,
+            'string' is assumed.
+
+        - choices -- A container of values that should be allowed. If not None,
+            after a command-line argument has been converted to the appropriate
+            type, an exception will be raised if it is not a member of this
+            collection.
+
+        - required -- True if the action must always be specified at the
+            command line. This is only meaningful for optional command-line
+            arguments.
+
+        - help -- The help string describing the argument.
+
+        - metavar -- The name to be used for the option's argument with the
+            help string. If None, the 'dest' value will be used as the name.
+    """
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 nargs=None,
+                 const=None,
+                 default=None,
+                 type=None,
+                 choices=None,
+                 required=False,
+                 help=None,
+                 metavar=None):
+        self.option_strings = option_strings
+        self.dest = dest
+        self.nargs = nargs
+        self.const = const
+        self.default = default
+        self.type = type
+        self.choices = choices
+        self.required = required
+        self.help = help
+        self.metavar = metavar
+
+    def _get_kwargs(self):
+        names = [
+            'option_strings',
+            'dest',
+            'nargs',
+            'const',
+            'default',
+            'type',
+            'choices',
+            'help',
+            'metavar',
+        ]
+        return [(name, getattr(self, name)) for name in names]
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        raise NotImplementedError(_('.__call__() not defined'))
+
+
+class _StoreAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 nargs=None,
+                 const=None,
+                 default=None,
+                 type=None,
+                 choices=None,
+                 required=False,
+                 help=None,
+                 metavar=None):
+        if nargs == 0:
+            raise ValueError('nargs for store actions must be > 0; if you '
+                             'have nothing to store, actions such as store '
+                             'true or store const may be more appropriate')
+        if const is not None and nargs != OPTIONAL:
+            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
+        super(_StoreAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            nargs=nargs,
+            const=const,
+            default=default,
+            type=type,
+            choices=choices,
+            required=required,
+            help=help,
+            metavar=metavar)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        setattr(namespace, self.dest, values)
+
+
+class _StoreConstAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 const,
+                 default=None,
+                 required=False,
+                 help=None,
+                 metavar=None):
+        super(_StoreConstAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            nargs=0,
+            const=const,
+            default=default,
+            required=required,
+            help=help)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        setattr(namespace, self.dest, self.const)
+
+
+class _StoreTrueAction(_StoreConstAction):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 default=False,
+                 required=False,
+                 help=None):
+        super(_StoreTrueAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            const=True,
+            default=default,
+            required=required,
+            help=help)
+
+
+class _StoreFalseAction(_StoreConstAction):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 default=True,
+                 required=False,
+                 help=None):
+        super(_StoreFalseAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            const=False,
+            default=default,
+            required=required,
+            help=help)
+
+
+class _AppendAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 nargs=None,
+                 const=None,
+                 default=None,
+                 type=None,
+                 choices=None,
+                 required=False,
+                 help=None,
+                 metavar=None):
+        if nargs == 0:
+            raise ValueError('nargs for append actions must be > 0; if arg '
+                             'strings are not supplying the value to append, '
+                             'the append const action may be more appropriate')
+        if const is not None and nargs != OPTIONAL:
+            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
+        super(_AppendAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            nargs=nargs,
+            const=const,
+            default=default,
+            type=type,
+            choices=choices,
+            required=required,
+            help=help,
+            metavar=metavar)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        items = _copy.copy(_ensure_value(namespace, self.dest, []))
+        items.append(values)
+        setattr(namespace, self.dest, items)
+
+
+class _AppendConstAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 const,
+                 default=None,
+                 required=False,
+                 help=None,
+                 metavar=None):
+        super(_AppendConstAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            nargs=0,
+            const=const,
+            default=default,
+            required=required,
+            help=help,
+            metavar=metavar)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        items = _copy.copy(_ensure_value(namespace, self.dest, []))
+        items.append(self.const)
+        setattr(namespace, self.dest, items)
+
+
+class _CountAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 dest,
+                 default=None,
+                 required=False,
+                 help=None):
+        super(_CountAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            nargs=0,
+            default=default,
+            required=required,
+            help=help)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        new_count = _ensure_value(namespace, self.dest, 0) + 1
+        setattr(namespace, self.dest, new_count)
+
+
+class _HelpAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 dest=SUPPRESS,
+                 default=SUPPRESS,
+                 help=None):
+        super(_HelpAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            default=default,
+            nargs=0,
+            help=help)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        parser.print_help()
+        parser.exit()
+
+
+class _VersionAction(Action):
+
+    def __init__(self,
+                 option_strings,
+                 version=None,
+                 dest=SUPPRESS,
+                 default=SUPPRESS,
+                 help="show program's version number and exit"):
+        super(_VersionAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            default=default,
+            nargs=0,
+            help=help)
+        self.version = version
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        version = self.version
+        if version is None:
+            version = parser.version
+        formatter = parser._get_formatter()
+        formatter.add_text(version)
+        parser.exit(message=formatter.format_help())
+
+
+class _SubParsersAction(Action):
+
+    class _ChoicesPseudoAction(Action):
+
+        def __init__(self, name, aliases, help):
+            metavar = dest = name
+            if aliases:
+                metavar += ' (%s)' % ', '.join(aliases)
+            sup = super(_SubParsersAction._ChoicesPseudoAction, self)
+            sup.__init__(option_strings=[], dest=dest, help=help,
+                        metavar=metavar)
+
+    def __init__(self,
+                 option_strings,
+                 prog,
+                 parser_class,
+                 dest=SUPPRESS,
+                 help=None,
+                 metavar=None):
+
+        self._prog_prefix = prog
+        self._parser_class = parser_class
+        self._name_parser_map = {}
+        self._choices_actions = []
+
+        super(_SubParsersAction, self).__init__(
+            option_strings=option_strings,
+            dest=dest,
+            nargs=PARSER,
+            choices=self._name_parser_map,
+            help=help,
+            metavar=metavar)
+
+    def add_parser(self, name, **kwargs):
+        # set prog from the existing prefix
+        if kwargs.get('prog') is None:
+            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)
+
+        aliases = kwargs.pop('aliases', ())
+
+        # create a pseudo-action to hold the choice help
+        if 'help' in kwargs:
+            help = kwargs.pop('help')
+            choice_action = self._ChoicesPseudoAction(name, aliases, help)
+            self._choices_actions.append(choice_action)
+
+        # create the parser and add it to the map
+        parser = self._parser_class(**kwargs)
+        self._name_parser_map[name] = parser
+
+        # make parser available under aliases also
+        for alias in aliases:
+            self._name_parser_map[alias] = parser
+
+        return parser
+
+    def _get_subactions(self):
+        return self._choices_actions
+
+    def __call__(self, parser, namespace, values, option_string=None):
+        parser_name = values[0]
+        arg_strings = values[1:]
+
+        # set the parser name if requested
+        if self.dest is not SUPPRESS:
+            setattr(namespace, self.dest, parser_name)
+
+        # select the parser
+        try:
+            parser = self._name_parser_map[parser_name]
+        except KeyError:
+            tup = parser_name, ', '.join(self._name_parser_map)
+            msg = _('unknown parser %r (choices: %s)' % tup)
+            raise ArgumentError(self, msg)
+
+        # parse all the remaining options into the namespace
+        # store any unrecognized options on the object, so that the top
+        # level parser can decide what to do with them
+        namespace, arg_strings = parser.parse_known_args(arg_strings, namespace)
+        if arg_strings:
+            vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR, [])
+            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)
+
+
+# ==============
+# Type classes
+# ==============
+
+class FileType(object):
+    """Factory for creating file object types
+
+    Instances of FileType are typically passed as type= arguments to the
+    ArgumentParser add_argument() method.
+
+    Keyword Arguments:
+        - mode -- A string indicating how the file is to be opened. Accepts the
+            same values as the builtin open() function.
+        - bufsize -- The file's desired buffer size. Accepts the same values as
+            the builtin open() function.
+    """
+
+    def __init__(self, mode='r', bufsize=None):
+        self._mode = mode
+        self._bufsize = bufsize
+
+    def __call__(self, string):
+        # the special argument "-" means sys.std{in,out}
+        if string == '-':
+            if 'r' in self._mode:
+                return _sys.stdin
+            elif 'w' in self._mode:
+                return _sys.stdout
+            else:
+                msg = _('argument "-" with mode %r' % self._mode)
+                raise ValueError(msg)
+
+        try:
+            # all other arguments are used as file names
+            if self._bufsize:
+                return open(string, self._mode, self._bufsize)
+            else:
+                return open(string, self._mode)
+        except IOError:
+            err = _sys.exc_info()[1]
+            message = _("can't open '%s': %s")
+            raise ArgumentTypeError(message % (string, err))
+
+    def __repr__(self):
+        args = [self._mode, self._bufsize]
+        args_str = ', '.join([repr(arg) for arg in args if arg is not None])
+        return '%s(%s)' % (type(self).__name__, args_str)
+
+# ===========================
+# Optional and Positional Parsing
+# ===========================
+
+class Namespace(_AttributeHolder):
+    """Simple object for storing attributes.
+
+    Implements equality by attribute names and values, and provides a simple
+    string representation.
+    """
+
+    def __init__(self, **kwargs):
+        for name in kwargs:
+            setattr(self, name, kwargs[name])
+
+    __hash__ = None
+
+    def __eq__(self, other):
+        return vars(self) == vars(other)
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __contains__(self, key):
+        return key in self.__dict__
+
+
+class _ActionsContainer(object):
+
+    def __init__(self,
+                 description,
+                 prefix_chars,
+                 argument_default,
+                 conflict_handler):
+        super(_ActionsContainer, self).__init__()
+
+        self.description = description
+        self.argument_default = argument_default
+        self.prefix_chars = prefix_chars
+        self.conflict_handler = conflict_handler
+
+        # set up registries
+        self._registries = {}
+
+        # register actions
+        self.register('action', None, _StoreAction)
+        self.register('action', 'store', _StoreAction)
+        self.register('action', 'store_const', _StoreConstAction)
+        self.register('action', 'store_true', _StoreTrueAction)
+        self.register('action', 'store_false', _StoreFalseAction)
+        self.register('action', 'append', _AppendAction)
+        self.register('action', 'append_const', _AppendConstAction)
+        self.register('action', 'count', _CountAction)
+        self.register('action', 'help', _HelpAction)
+        self.register('action', 'version', _VersionAction)
+        self.register('action', 'parsers', _SubParsersAction)
+
+        # raise an exception if the conflict handler is invalid
+        self._get_handler()
+
+        # action storage
+        self._actions = []
+        self._option_string_actions = {}
+
+        # groups
+        self._action_groups = []
+        self._mutually_exclusive_groups = []
+
+        # defaults storage
+        self._defaults = {}
+
+        # determines whether an "option" looks like a negative number
+        self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')
+
+        # whether or not there are any optionals that look like negative
+        # numbers -- uses a list so it can be shared and edited
+        self._has_negative_number_optionals = []
+
+    # ====================
+    # Registration methods
+    # ====================
+    def register(self, registry_name, value, object):
+        registry = self._registries.setdefault(registry_name, {})
+        registry[value] = object
+
+    def _registry_get(self, registry_name, value, default=None):
+        return self._registries[registry_name].get(value, default)
+
+    # ==================================
+    # Namespace default accessor methods
+    # ==================================
+    def set_defaults(self, **kwargs):
+        self._defaults.update(kwargs)
+
+        # if these defaults match any existing arguments, replace
+        # the previous default on the object with the new one
+        for action in self._actions:
+            if action.dest in kwargs:
+                action.default = kwargs[action.dest]
+
+    def get_default(self, dest):
+        for action in self._actions:
+            if action.dest == dest and action.default is not None:
+                return action.default
+        return self._defaults.get(dest, None)
+
+
+    # =======================
+    # Adding argument actions
+    # =======================
+    def add_argument(self, *args, **kwargs):
+        """
+        add_argument(dest, ..., name=value, ...)
+        add_argument(option_string, option_string, ..., name=value, ...)
+        """
+
+        # if no positional args are supplied or only one is supplied and
+        # it doesn't look like an option string, parse a positional
+        # argument
+        chars = self.prefix_chars
+        if not args or len(args) == 1 and args[0][0] not in chars:
+            if args and 'dest' in kwargs:
+                raise ValueError('dest supplied twice for positional argument')
+            kwargs = self._get_positional_kwargs(*args, **kwargs)
+
+        # otherwise, we're adding an optional argument
+        else:
+            kwargs = self._get_optional_kwargs(*args, **kwargs)
+
+        # if no default was supplied, use the parser-level default
+        if 'default' not in kwargs:
+            dest = kwargs['dest']
+            if dest in self._defaults:
+                kwargs['default'] = self._defaults[dest]
+            elif self.argument_default is not None:
+                kwargs['default'] = self.argument_default
+
+        # create the action object, and add it to the parser
+        action_class = self._pop_action_class(kwargs)
+        if not _callable(action_class):
+            raise ValueError('unknown action "%s"' % action_class)
+        action = action_class(**kwargs)
+
+        # raise an error if the action type is not callable
+        type_func = self._registry_get('type', action.type, action.type)
+        if not _callable(type_func):
+            raise ValueError('%r is not callable' % type_func)
+
+        return self._add_action(action)
+
+    def add_argument_group(self, *args, **kwargs):
+        group = _ArgumentGroup(self, *args, **kwargs)
+        self._action_groups.append(group)
+        return group
+
+    def add_mutually_exclusive_group(self, **kwargs):
+        group = _MutuallyExclusiveGroup(self, **kwargs)
+        self._mutually_exclusive_groups.append(group)
+        return group
+
+    def _add_action(self, action):
+        # resolve any conflicts
+        self._check_conflict(action)
+
+        # add to actions list
+        self._actions.append(action)
+        action.container = self
+
+        # index the action by any option strings it has
+        for option_string in action.option_strings:
+            self._option_string_actions[option_string] = action
+
+        # set the flag if any option strings look like negative numbers
+        for option_string in action.option_strings:
+            if self._negative_number_matcher.match(option_string):
+                if not self._has_negative_number_optionals:
+                    self._has_negative_number_optionals.append(True)
+
+        # return the created action
+        return action
+
+    def _remove_action(self, action):
+        self._actions.remove(action)
+
+    def _add_container_actions(self, container):
+        # collect groups by titles
+        title_group_map = {}
+        for group in self._action_groups:
+            if group.title in title_group_map:
+                msg = _('cannot merge actions - two groups are named %r')
+                raise ValueError(msg % (group.title))
+            title_group_map[group.title] = group
+
+        # map each action to its group
+        group_map = {}
+        for group in container._action_groups:
+
+            # if a group with the title exists, use that, otherwise
+            # create a new group matching the container's group
+            if group.title not in title_group_map:
+                title_group_map[group.title] = self.add_argument_group(
+                    title=group.title,
+                    description=group.description,
+                    conflict_handler=group.conflict_handler)
+
+            # map the actions to their new group
+            for action in group._group_actions:
+                group_map[action] = title_group_map[group.title]
+
+        # add container's mutually exclusive groups
+        # NOTE: if add_mutually_exclusive_group ever gains title= and
+        # description= then this code will need to be expanded as above
+        for group in container._mutually_exclusive_groups:
+            mutex_group = self.add_mutually_exclusive_group(
+                required=group.required)
+
+            # map the actions to their new mutex group
+            for action in group._group_actions:
+                group_map[action] = mutex_group
+
+        # add all actions to this container or their group
+        for action in container._actions:
+            group_map.get(action, self)._add_action(action)
+
+    def _get_positional_kwargs(self, dest, **kwargs):
+        # make sure required is not specified
+        if 'required' in kwargs:
+            msg = _("'required' is an invalid argument for positionals")
+            raise TypeError(msg)
+
+        # mark positional arguments as required if at least one is
+        # always required
+        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:
+            kwargs['required'] = True
+        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:
+            kwargs['required'] = True
+
+        # return the keyword arguments with no option strings
+        return dict(kwargs, dest=dest, option_strings=[])
+
+    def _get_optional_kwargs(self, *args, **kwargs):
+        # determine short and long option strings
+        option_strings = []
+        long_option_strings = []
+        for option_string in args:
+            # error on strings that don't start with an appropriate prefix
+            if not option_string[0] in self.prefix_chars:
+                msg = _('invalid option string %r: '
+                        'must start with a character %r')
+                tup = option_string, self.prefix_chars
+                raise ValueError(msg % tup)
+
+            # strings starting with two prefix characters are long options
+            option_strings.append(option_string)
+            if option_string[0] in self.prefix_chars:
+                if len(option_string) > 1:
+                    if option_string[1] in self.prefix_chars:
+                        long_option_strings.append(option_string)
+
+        # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
+        dest = kwargs.pop('dest', None)
+        if dest is None:
+            if long_option_strings:
+                dest_option_string = long_option_strings[0]
+            else:
+                dest_option_string = option_strings[0]
+            dest = dest_option_string.lstrip(self.prefix_chars)
+            if not dest:
+                msg = _('dest= is required for options like %r')
+                raise ValueError(msg % option_string)
+            dest = dest.replace('-', '_')
+
+        # return the updated keyword arguments
+        return dict(kwargs, dest=dest, option_strings=option_strings)
+
+    def _pop_action_class(self, kwargs, default=None):
+        action = kwargs.pop('action', default)
+        return self._registry_get('action', action, action)
+
+    def _get_handler(self):
+        # determine function from conflict handler string
+        handler_func_name = '_handle_conflict_%s' % self.conflict_handler
+        try:
+            return getattr(self, handler_func_name)
+        except AttributeError:
+            msg = _('invalid conflict_resolution value: %r')
+            raise ValueError(msg % self.conflict_handler)
+
+    def _check_conflict(self, action):
+
+        # find all options that conflict with this option
+        confl_optionals = []
+        for option_string in action.option_strings:
+            if option_string in self._option_string_actions:
+                confl_optional = self._option_string_actions[option_string]
+                confl_optionals.append((option_string, confl_optional))
+
+        # resolve any conflicts
+        if confl_optionals:
+            conflict_handler = self._get_handler()
+            conflict_handler(action, confl_optionals)
+
+    def _handle_conflict_error(self, action, conflicting_actions):
+        message = _('conflicting option string(s): %s')
+        conflict_string = ', '.join([option_string
+                                     for option_string, action
+                                     in conflicting_actions])
+        raise ArgumentError(action, message % conflict_string)
+
+    def _handle_conflict_resolve(self, action, conflicting_actions):
+
+        # remove all conflicting options
+        for option_string, action in conflicting_actions:
+
+            # remove the conflicting option
+            action.option_strings.remove(option_string)
+            self._option_string_actions.pop(option_string, None)
+
+            # if the option now has no option string, remove it from the
+            # container holding it
+            if not action.option_strings:
+                action.container._remove_action(action)
+
+
+class _ArgumentGroup(_ActionsContainer):
+
+    def __init__(self, container, title=None, description=None, **kwargs):
+        # add any missing keyword arguments by checking the container
+        update = kwargs.setdefault
+        update('conflict_handler', container.conflict_handler)
+        update('prefix_chars', container.prefix_chars)
+        update('argument_default', container.argument_default)
+        super_init = super(_ArgumentGroup, self).__init__
+        super_init(description=description, **kwargs)
+
+        # group attributes
+        self.title = title
+        self._group_actions = []
+
+        # share most attributes with the container
+        self._registries = container._registries
+        self._actions = container._actions
+        self._option_string_actions = container._option_string_actions
+        self._defaults = container._defaults
+        self._has_negative_number_optionals = \
+            container._has_negative_number_optionals
+
+    def _add_action(self, action):
+        action = super(_ArgumentGroup, self)._add_action(action)
+        self._group_actions.append(action)
+        return action
+
+    def _remove_action(self, action):
+        super(_ArgumentGroup, self)._remove_action(action)
+        self._group_actions.remove(action)
+
+
+class _MutuallyExclusiveGroup(_ArgumentGroup):
+
+    def __init__(self, container, required=False):
+        super(_MutuallyExclusiveGroup, self).__init__(container)
+        self.required = required
+        self._container = container
+
+    def _add_action(self, action):
+        if action.required:
+            msg = _('mutually exclusive arguments must be optional')
+            raise ValueError(msg)
+        action = self._container._add_action(action)
+        self._group_actions.append(action)
+        return action
+
+    def _remove_action(self, action):
+        self._container._remove_action(action)
+        self._group_actions.remove(action)
+
+
+class ArgumentParser(_AttributeHolder, _ActionsContainer):
+    """Object for parsing command line strings into Python objects.
+
+    Keyword Arguments:
+        - prog -- The name of the program (default: sys.argv[0])
+        - usage -- A usage message (default: auto-generated from arguments)
+        - description -- A description of what the program does
+        - epilog -- Text following the argument descriptions
+        - parents -- Parsers whose arguments should be copied into this one
+        - formatter_class -- HelpFormatter class for printing help messages
+        - prefix_chars -- Characters that prefix optional arguments
+        - fromfile_prefix_chars -- Characters that prefix files containing
+            additional arguments
+        - argument_default -- The default value for all arguments
+        - conflict_handler -- String indicating how to handle conflicts
+        - add_help -- Add a -h/-help option
+    """
+
+    def __init__(self,
+                 prog=None,
+                 usage=None,
+                 description=None,
+                 epilog=None,
+                 version=None,
+                 parents=[],
+                 formatter_class=HelpFormatter,
+                 prefix_chars='-',
+                 fromfile_prefix_chars=None,
+                 argument_default=None,
+                 conflict_handler='error',
+                 add_help=True):
+
+        if version is not None:
+            import warnings
+            warnings.warn(
+                """The "version" argument to ArgumentParser is deprecated. """
+                """Please use """
+                """"add_argument(..., action='version', version="N", ...)" """
+                """instead""", DeprecationWarning)
+
+        superinit = super(ArgumentParser, self).__init__
+        superinit(description=description,
+                  prefix_chars=prefix_chars,
+                  argument_default=argument_default,
+                  conflict_handler=conflict_handler)
+
+        # default setting for prog
+        if prog is None:
+            prog = _os.path.basename(_sys.argv[0])
+
+        self.prog = prog
+        self.usage = usage
+        self.epilog = epilog
+        self.version = version
+        self.formatter_class = formatter_class
+        self.fromfile_prefix_chars = fromfile_prefix_chars
+        self.add_help = add_help
+
+        add_group = self.add_argument_group
+        self._positionals = add_group(_('positional arguments'))
+        self._optionals = add_group(_('optional arguments'))
+        self._subparsers = None
+
+        # register types
+        def identity(string):
+            return string
+        self.register('type', None, identity)
+
+        # add help and version arguments if necessary
+        # (using explicit default to override global argument_default)
+        if '-' in prefix_chars:
+            default_prefix = '-'
+        else:
+            default_prefix = prefix_chars[0]
+        if self.add_help:
+            self.add_argument(
+                default_prefix+'h', default_prefix*2+'help',
+                action='help', default=SUPPRESS,
+                help=_('show this help message and exit'))
+        if self.version:
+            self.add_argument(
+                default_prefix+'v', default_prefix*2+'version',
+                action='version', default=SUPPRESS,
+                version=self.version,
+                help=_("show program's version number and exit"))
+
+        # add parent arguments and defaults
+        for parent in parents:
+            self._add_container_actions(parent)
+            try:
+                defaults = parent._defaults
+            except AttributeError:
+                pass
+            else:
+                self._defaults.update(defaults)
+
+    # =======================
+    # Pretty __repr__ methods
+    # =======================
+    def _get_kwargs(self):
+        names = [
+            'prog',
+            'usage',
+            'description',
+            'version',
+            'formatter_class',
+            'conflict_handler',
+            'add_help',
+        ]
+        return [(name, getattr(self, name)) for name in names]
+
+    # ==================================
+    # Optional/Positional adding methods
+    # ==================================
+    def add_subparsers(self, **kwargs):
+        if self._subparsers is not None:
+            self.error(_('cannot have multiple subparser arguments'))
+
+        # add the parser class to the arguments if it's not present
+        kwargs.setdefault('parser_class', type(self))
+
+        if 'title' in kwargs or 'description' in kwargs:
+            title = _(kwargs.pop('title', 'subcommands'))
+            description = _(kwargs.pop('description', None))
+            self._subparsers = self.add_argument_group(title, description)
+        else:
+            self._subparsers = self._positionals
+
+        # prog defaults to the usage message of this parser, skipping
+        # optional arguments and with no "usage:" prefix
+        if kwargs.get('prog') is None:
+            formatter = self._get_formatter()
+            positionals = self._get_positional_actions()
+            groups = self._mutually_exclusive_groups
+            formatter.add_usage(self.usage, positionals, groups, '')
+            kwargs['prog'] = formatter.format_help().strip()
+
+        # create the parsers action and add it to the positionals list
+        parsers_class = self._pop_action_class(kwargs, 'parsers')
+        action = parsers_class(option_strings=[], **kwargs)
+        self._subparsers._add_action(action)
+
+        # return the created parsers action
+        return action
+
+    def _add_action(self, action):
+        if action.option_strings:
+            self._optionals._add_action(action)
+        else:
+            self._positionals._add_action(action)
+        return action
+
+    def _get_optional_actions(self):
+        return [action
+                for action in self._actions
+                if action.option_strings]
+
+    def _get_positional_actions(self):
+        return [action
+                for action in self._actions
+                if not action.option_strings]
+
+    # =====================================
+    # Command line argument parsing methods
+    # =====================================
+    def parse_args(self, args=None, namespace=None):
+        args, argv = self.parse_known_args(args, namespace)
+        if argv:
+            msg = _('unrecognized arguments: %s')
+            self.error(msg % ' '.join(argv))
+        return args
+
+    def parse_known_args(self, args=None, namespace=None):
+        # args default to the system args
+        if args is None:
+            args = _sys.argv[1:]
+
+        # default Namespace built from parser defaults
+        if namespace is None:
+            namespace = Namespace()
+
+        # add any action defaults that aren't present
+        for action in self._actions:
+            if action.dest is not SUPPRESS:
+                if not hasattr(namespace, action.dest):
+                    if action.default is not SUPPRESS:
+                        setattr(namespace, action.dest, action.default)
+
+        # add any parser defaults that aren't present
+        for dest in self._defaults:
+            if not hasattr(namespace, dest):
+                setattr(namespace, dest, self._defaults[dest])
+
+        # parse the arguments and exit if there are any errors
+        try:
+            namespace, args = self._parse_known_args(args, namespace)
+            if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):
+                args.extend(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))
+                delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)
+            return namespace, args
+        except ArgumentError:
+            err = _sys.exc_info()[1]
+            self.error(str(err))
+
+    def _parse_known_args(self, arg_strings, namespace):
+        # replace arg strings that are file references
+        if self.fromfile_prefix_chars is not None:
+            arg_strings = self._read_args_from_files(arg_strings)
+
+        # map all mutually exclusive arguments to the other arguments
+        # they can't occur with
+        action_conflicts = {}
+        for mutex_group in self._mutually_exclusive_groups:
+            group_actions = mutex_group._group_actions
+            for i, mutex_action in enumerate(mutex_group._group_actions):
+                conflicts = action_conflicts.setdefault(mutex_action, [])
+                conflicts.extend(group_actions[:i])
+                conflicts.extend(group_actions[i + 1:])
+
+        # find all option indices, and determine the arg_string_pattern
+        # which has an 'O' if there is an option at an index,
+        # an 'A' if there is an argument, or a '-' if there is a '--'
+        option_string_indices = {}
+        arg_string_pattern_parts = []
+        arg_strings_iter = iter(arg_strings)
+        for i, arg_string in enumerate(arg_strings_iter):
+
+            # all args after -- are non-options
+            if arg_string == '--':
+                arg_string_pattern_parts.append('-')
+                for arg_string in arg_strings_iter:
+                    arg_string_pattern_parts.append('A')
+
+            # otherwise, add the arg to the arg strings
+            # and note the index if it was an option
+            else:
+                option_tuple = self._parse_optional(arg_string)
+                if option_tuple is None:
+                    pattern = 'A'
+                else:
+                    option_string_indices[i] = option_tuple
+                    pattern = 'O'
+                arg_string_pattern_parts.append(pattern)
+
+        # join the pieces together to form the pattern
+        arg_strings_pattern = ''.join(arg_string_pattern_parts)
+
+        # converts arg strings to the appropriate and then takes the action
+        seen_actions = set()
+        seen_non_default_actions = set()
+
+        def take_action(action, argument_strings, option_string=None):
+            seen_actions.add(action)
+            argument_values = self._get_values(action, argument_strings)
+
+            # error if this argument is not allowed with other previously
+            # seen arguments, assuming that actions that use the default
+            # value don't really count as "present"
+            if argument_values is not action.default:
+                seen_non_default_actions.add(action)
+                for conflict_action in action_conflicts.get(action, []):
+                    if conflict_action in seen_non_default_actions:
+                        msg = _('not allowed with argument %s')
+                        action_name = _get_action_name(conflict_action)
+                        raise ArgumentError(action, msg % action_name)
+
+            # take the action if we didn't receive a SUPPRESS value
+            # (e.g. from a default)
+            if argument_values is not SUPPRESS:
+                action(self, namespace, argument_values, option_string)
+
+        # function to convert arg_strings into an optional action
+        def consume_optional(start_index):
+
+            # get the optional identified at this index
+            option_tuple = option_string_indices[start_index]
+            action, option_string, explicit_arg = option_tuple
+
+            # identify additional optionals in the same arg string
+            # (e.g. -xyz is the same as -x -y -z if no args are required)
+            match_argument = self._match_argument
+            action_tuples = []
+            while True:
+
+                # if we found no optional action, skip it
+                if action is None:
+                    extras.append(arg_strings[start_index])
+                    return start_index + 1
+
+                # if there is an explicit argument, try to match the
+                # optional's string arguments to only this
+                if explicit_arg is not None:
+                    arg_count = match_argument(action, 'A')
+
+                    # if the action is a single-dash option and takes no
+                    # arguments, try to parse more single-dash options out
+                    # of the tail of the option string
+                    chars = self.prefix_chars
+                    if arg_count == 0 and option_string[1] not in chars:
+                        action_tuples.append((action, [], option_string))
+                        char = option_string[0]
+                        option_string = char + explicit_arg[0]
+                        new_explicit_arg = explicit_arg[1:] or None
+                        optionals_map = self._option_string_actions
+                        if option_string in optionals_map:
+                            action = optionals_map[option_string]
+                            explicit_arg = new_explicit_arg
+                        else:
+                            msg = _('ignored explicit argument %r')
+                            raise ArgumentError(action, msg % explicit_arg)
+
+                    # if the action expect exactly one argument, we've
+                    # successfully matched the option; exit the loop
+                    elif arg_count == 1:
+                        stop = start_index + 1
+                        args = [explicit_arg]
+                        action_tuples.append((action, args, option_string))
+                        break
+
+                    # error if a double-dash option did not use the
+                    # explicit argument
+                    else:
+                        msg = _('ignored explicit argument %r')
+                        raise ArgumentError(action, msg % explicit_arg)
+
+                # if there is no explicit argument, try to match the
+                # optional's string arguments with the following strings
+                # if successful, exit the loop
+                else:
+                    start = start_index + 1
+                    selected_patterns = arg_strings_pattern[start:]
+                    arg_count = match_argument(action, selected_patterns)
+                    stop = start + arg_count
+                    args = arg_strings[start:stop]
+                    action_tuples.append((action, args, option_string))
+                    break
+
+            # add the Optional to the list and return the index at which
+            # the Optional's string args stopped
+            assert action_tuples
+            for action, args, option_string in action_tuples:
+                take_action(action, args, option_string)
+            return stop
+
+        # the list of Positionals left to be parsed; this is modified
+        # by consume_positionals()
+        positionals = self._get_positional_actions()
+
+        # function to convert arg_strings into positional actions
+        def consume_positionals(start_index):
+            # match as many Positionals as possible
+            match_partial = self._match_arguments_partial
+            selected_pattern = arg_strings_pattern[start_index:]
+            arg_counts = match_partial(positionals, selected_pattern)
+
+            # slice off the appropriate arg strings for each Positional
+            # and add the Positional and its args to the list
+            for action, arg_count in zip(positionals, arg_counts):
+                args = arg_strings[start_index: start_index + arg_count]
+                start_index += arg_count
+                take_action(action, args)
+
+            # slice off the Positionals that we just parsed and return the
+            # index at which the Positionals' string args stopped
+            positionals[:] = positionals[len(arg_counts):]
+            return start_index
+
+        # consume Positionals and Optionals alternately, until we have
+        # passed the last option string
+        extras = []
+        start_index = 0
+        if option_string_indices:
+            max_option_string_index = max(option_string_indices)
+        else:
+            max_option_string_index = -1
+        while start_index <= max_option_string_index:
+
+            # consume any Positionals preceding the next option
+            next_option_string_index = min([
+                index
+                for index in option_string_indices
+                if index >= start_index])
+            if start_index != next_option_string_index:
+                positionals_end_index = consume_positionals(start_index)
+
+                # only try to parse the next optional if we didn't consume
+                # the option string during the positionals parsing
+                if positionals_end_index > start_index:
+                    start_index = positionals_end_index
+                    continue
+                else:
+                    start_index = positionals_end_index
+
+            # if we consumed all the positionals we could and we're not
+            # at the index of an option string, there were extra arguments
+            if start_index not in option_string_indices:
+                strings = arg_strings[start_index:next_option_string_index]
+                extras.extend(strings)
+                start_index = next_option_string_index
+
+            # consume the next optional and any arguments for it
+            start_index = consume_optional(start_index)
+
+        # consume any positionals following the last Optional
+        stop_index = consume_positionals(start_index)
+
+        # if we didn't consume all the argument strings, there were extras
+        extras.extend(arg_strings[stop_index:])
+
+        # if we didn't use all the Positional objects, there were too few
+        # arg strings supplied.
+        if positionals:
+            self.error(_('too few arguments'))
+
+        # make sure all required actions were present, and convert defaults.
+        for action in self._actions:
+            if action not in seen_actions:
+                if action.required:
+                    name = _get_action_name(action)
+                    self.error(_('argument %s is required') % name)
+                else:
+                    # Convert action default now instead of doing it before
+                    # parsing arguments to avoid calling convert functions
+                    # twice (which may fail) if the argument was given, but
+                    # only if it was defined already in the namespace
+                    if (action.default is not None and
+                            isinstance(action.default, basestring) and
+                            hasattr(namespace, action.dest) and
+                            action.default is getattr(namespace, action.dest)):
+                        setattr(namespace, action.dest,
+                                self._get_value(action, action.default))
+
+        # make sure all required groups had one option present
+        for group in self._mutually_exclusive_groups:
+            if group.required:
+                for action in group._group_actions:
+                    if action in seen_non_default_actions:
+                        break
+
+                # if no actions were used, report the error
+                else:
+                    names = [_get_action_name(action)
+                             for action in group._group_actions
+                             if action.help is not SUPPRESS]
+                    msg = _('one of the arguments %s is required')
+                    self.error(msg % ' '.join(names))
+
+        # return the updated namespace and the extra arguments
+        return namespace, extras
+
+    def _read_args_from_files(self, arg_strings):
+        # expand arguments referencing files
+        new_arg_strings = []
+        for arg_string in arg_strings:
+
+            # for regular arguments, just add them back into the list
+            if arg_string[0] not in self.fromfile_prefix_chars:
+                new_arg_strings.append(arg_string)
+
+            # replace arguments referencing files with the file content
+            else:
+                try:
+                    args_file = open(arg_string[1:])
+                    try:
+                        arg_strings = []
+                        for arg_line in args_file.read().splitlines():
+                            for arg in self.convert_arg_line_to_args(arg_line):
+                                arg_strings.append(arg)
+                        arg_strings = self._read_args_from_files(arg_strings)
+                        new_arg_strings.extend(arg_strings)
+                    finally:
+                        args_file.close()
+                except IOError:
+                    err = _sys.exc_info()[1]
+                    self.error(str(err))
+
+        # return the modified argument list
+        return new_arg_strings
+
+    def convert_arg_line_to_args(self, arg_line):
+        return [arg_line]
+
+    def _match_argument(self, action, arg_strings_pattern):
+        # match the pattern for this action to the arg strings
+        nargs_pattern = self._get_nargs_pattern(action)
+        match = _re.match(nargs_pattern, arg_strings_pattern)
+
+        # raise an exception if we weren't able to find a match
+        if match is None:
+            nargs_errors = {
+                None: _('expected one argument'),
+                OPTIONAL: _('expected at most one argument'),
+                ONE_OR_MORE: _('expected at least one argument'),
+            }
+            default = _('expected %s argument(s)') % action.nargs
+            msg = nargs_errors.get(action.nargs, default)
+            raise ArgumentError(action, msg)
+
+        # return the number of arguments matched
+        return len(match.group(1))
+
+    def _match_arguments_partial(self, actions, arg_strings_pattern):
+        # progressively shorten the actions list by slicing off the
+        # final actions until we find a match
+        result = []
+        for i in range(len(actions), 0, -1):
+            actions_slice = actions[:i]
+            pattern = ''.join([self._get_nargs_pattern(action)
+                               for action in actions_slice])
+            match = _re.match(pattern, arg_strings_pattern)
+            if match is not None:
+                result.extend([len(string) for string in match.groups()])
+                break
+
+        # return the list of arg string counts
+        return result
+
+    def _parse_optional(self, arg_string):
+        # if it's an empty string, it was meant to be a positional
+        if not arg_string:
+            return None
+
+        # if it doesn't start with a prefix, it was meant to be positional
+        if not arg_string[0] in self.prefix_chars:
+            return None
+
+        # if the option string is present in the parser, return the action
+        if arg_string in self._option_string_actions:
+            action = self._option_string_actions[arg_string]
+            return action, arg_string, None
+
+        # if it's just a single character, it was meant to be positional
+        if len(arg_string) == 1:
+            return None
+
+        # if the option string before the "=" is present, return the action
+        if '=' in arg_string:
+            option_string, explicit_arg = arg_string.split('=', 1)
+            if option_string in self._option_string_actions:
+                action = self._option_string_actions[option_string]
+                return action, option_string, explicit_arg
+
+        # search through all possible prefixes of the option string
+        # and all actions in the parser for possible interpretations
+        option_tuples = self._get_option_tuples(arg_string)
+
+        # if multiple actions match, the option string was ambiguous
+        if len(option_tuples) > 1:
+            options = ', '.join([option_string
+                for action, option_string, explicit_arg in option_tuples])
+            tup = arg_string, options
+            self.error(_('ambiguous option: %s could match %s') % tup)
+
+        # if exactly one action matched, this segmentation is good,
+        # so return the parsed action
+        elif len(option_tuples) == 1:
+            option_tuple, = option_tuples
+            return option_tuple
+
+        # if it was not found as an option, but it looks like a negative
+        # number, it was meant to be positional
+        # unless there are negative-number-like options
+        if self._negative_number_matcher.match(arg_string):
+            if not self._has_negative_number_optionals:
+                return None
+
+        # if it contains a space, it was meant to be a positional
+        if ' ' in arg_string:
+            return None
+
+        # it was meant to be an optional but there is no such option
+        # in this parser (though it might be a valid option in a subparser)
+        return None, arg_string, None
+
+    def _get_option_tuples(self, option_string):
+        result = []
+
+        # option strings starting with two prefix characters are only
+        # split at the '='
+        chars = self.prefix_chars
+        if option_string[0] in chars and option_string[1] in chars:
+            if '=' in option_string:
+                option_prefix, explicit_arg = option_string.split('=', 1)
+            else:
+                option_prefix = option_string
+                explicit_arg = None
+            for option_string in self._option_string_actions:
+                if option_string.startswith(option_prefix):
+                    action = self._option_string_actions[option_string]
+                    tup = action, option_string, explicit_arg
+                    result.append(tup)
+
+        # single character options can be concatenated with their arguments
+        # but multiple character options always have to have their argument
+        # separate
+        elif option_string[0] in chars and option_string[1] not in chars:
+            option_prefix = option_string
+            explicit_arg = None
+            short_option_prefix = option_string[:2]
+            short_explicit_arg = option_string[2:]
+
+            for option_string in self._option_string_actions:
+                if option_string == short_option_prefix:
+                    action = self._option_string_actions[option_string]
+                    tup = action, option_string, short_explicit_arg
+                    result.append(tup)
+                elif option_string.startswith(option_prefix):
+                    action = self._option_string_actions[option_string]
+                    tup = action, option_string, explicit_arg
+                    result.append(tup)
+
+        # shouldn't ever get here
+        else:
+            self.error(_('unexpected option string: %s') % option_string)
+
+        # return the collected option tuples
+        return result
+
+    def _get_nargs_pattern(self, action):
+        # in all examples below, we have to allow for '--' args
+        # which are represented as '-' in the pattern
+        nargs = action.nargs
+
+        # the default (None) is assumed to be a single argument
+        if nargs is None:
+            nargs_pattern = '(-*A-*)'
+
+        # allow zero or one arguments
+        elif nargs == OPTIONAL:
+            nargs_pattern = '(-*A?-*)'
+
+        # allow zero or more arguments
+        elif nargs == ZERO_OR_MORE:
+            nargs_pattern = '(-*[A-]*)'
+
+        # allow one or more arguments
+        elif nargs == ONE_OR_MORE:
+            nargs_pattern = '(-*A[A-]*)'
+
+        # allow any number of options or arguments
+        elif nargs == REMAINDER:
+            nargs_pattern = '([-AO]*)'
+
+        # allow one argument followed by any number of options or arguments
+        elif nargs == PARSER:
+            nargs_pattern = '(-*A[-AO]*)'
+
+        # all others should be integers
+        else:
+            nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)
+
+        # if this is an optional action, -- is not allowed
+        if action.option_strings:
+            nargs_pattern = nargs_pattern.replace('-*', '')
+            nargs_pattern = nargs_pattern.replace('-', '')
+
+        # return the pattern
+        return nargs_pattern
+
+    # ========================
+    # Value conversion methods
+    # ========================
+    def _get_values(self, action, arg_strings):
+        # for everything but PARSER args, strip out '--'
+        if action.nargs not in [PARSER, REMAINDER]:
+            arg_strings = [s for s in arg_strings if s != '--']
+
+        # optional argument produces a default when not present
+        if not arg_strings and action.nargs == OPTIONAL:
+            if action.option_strings:
+                value = action.const
+            else:
+                value = action.default
+            if isinstance(value, basestring):
+                value = self._get_value(action, value)
+                self._check_value(action, value)
+
+        # when nargs='*' on a positional, if there were no command-line
+        # args, use the default if it is anything other than None
+        elif (not arg_strings and action.nargs == ZERO_OR_MORE and
+              not action.option_strings):
+            if action.default is not None:
+                value = action.default
+            else:
+                value = arg_strings
+            self._check_value(action, value)
+
+        # single argument or optional argument produces a single value
+        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
+            arg_string, = arg_strings
+            value = self._get_value(action, arg_string)
+            self._check_value(action, value)
+
+        # REMAINDER arguments convert all values, checking none
+        elif action.nargs == REMAINDER:
+            value = [self._get_value(action, v) for v in arg_strings]
+
+        # PARSER arguments convert all values, but check only the first
+        elif action.nargs == PARSER:
+            value = [self._get_value(action, v) for v in arg_strings]
+            self._check_value(action, value[0])
+
+        # all other types of nargs produce a list
+        else:
+            value = [self._get_value(action, v) for v in arg_strings]
+            for v in value:
+                self._check_value(action, v)
+
+        # return the converted value
+        return value
+
+    def _get_value(self, action, arg_string):
+        type_func = self._registry_get('type', action.type, action.type)
+        if not _callable(type_func):
+            msg = _('%r is not callable')
+            raise ArgumentError(action, msg % type_func)
+
+        # convert the value to the appropriate type
+        try:
+            result = type_func(arg_string)
+
+        # ArgumentTypeErrors indicate errors
+        except ArgumentTypeError:
+            name = getattr(action.type, '__name__', repr(action.type))
+            msg = str(_sys.exc_info()[1])
+            raise ArgumentError(action, msg)
+
+        # TypeErrors or ValueErrors also indicate errors
+        except (TypeError, ValueError):
+            name = getattr(action.type, '__name__', repr(action.type))
+            msg = _('invalid %s value: %r')
+            raise ArgumentError(action, msg % (name, arg_string))
+
+        # return the converted value
+        return result
+
+    def _check_value(self, action, value):
+        # converted value must be one of the choices (if specified)
+        if action.choices is not None and value not in action.choices:
+            tup = value, ', '.join(map(repr, action.choices))
+            msg = _('invalid choice: %r (choose from %s)') % tup
+            raise ArgumentError(action, msg)
+
+    # =======================
+    # Help-formatting methods
+    # =======================
+    def format_usage(self):
+        formatter = self._get_formatter()
+        formatter.add_usage(self.usage, self._actions,
+                            self._mutually_exclusive_groups)
+        return formatter.format_help()
+
+    def format_help(self):
+        formatter = self._get_formatter()
+
+        # usage
+        formatter.add_usage(self.usage, self._actions,
+                            self._mutually_exclusive_groups)
+
+        # description
+        formatter.add_text(self.description)
+
+        # positionals, optionals and user-defined groups
+        for action_group in self._action_groups:
+            formatter.start_section(action_group.title)
+            formatter.add_text(action_group.description)
+            formatter.add_arguments(action_group._group_actions)
+            formatter.end_section()
+
+        # epilog
+        formatter.add_text(self.epilog)
+
+        # determine help from format above
+        return formatter.format_help()
+
+    def format_version(self):
+        import warnings
+        warnings.warn(
+            'The format_version method is deprecated -- the "version" '
+            'argument to ArgumentParser is no longer supported.',
+            DeprecationWarning)
+        formatter = self._get_formatter()
+        formatter.add_text(self.version)
+        return formatter.format_help()
+
+    def _get_formatter(self):
+        return self.formatter_class(prog=self.prog)
+
+    # =====================
+    # Help-printing methods
+    # =====================
+    def print_usage(self, file=None):
+        if file is None:
+            file = _sys.stdout
+        self._print_message(self.format_usage(), file)
+
+    def print_help(self, file=None):
+        if file is None:
+            file = _sys.stdout
+        self._print_message(self.format_help(), file)
+
+    def print_version(self, file=None):
+        import warnings
+        warnings.warn(
+            'The print_version method is deprecated -- the "version" '
+            'argument to ArgumentParser is no longer supported.',
+            DeprecationWarning)
+        self._print_message(self.format_version(), file)
+
+    def _print_message(self, message, file=None):
+        if message:
+            if file is None:
+                file = _sys.stderr
+            file.write(message)
+
+    # ===============
+    # Exiting methods
+    # ===============
+    def exit(self, status=0, message=None):
+        if message:
+            self._print_message(message, _sys.stderr)
+        _sys.exit(status)
+
+    def error(self, message):
+        """error(message: string)
+
+        Prints a usage message incorporating the message to stderr and
+        exits.
+
+        If you override this in a subclass, it should not return -- it
+        should either exit or raise an exception.
+        """
+        self.print_usage(_sys.stderr)
+        self.exit(2, _('%s: error: %s\n') % (self.prog, message))
diff --git a/ui/keycodemapdb/tools/keymap-gen b/ui/keycodemapdb/tools/keymap-gen
new file mode 100755
index 0000000..ac4b057
--- /dev/null
+++ b/ui/keycodemapdb/tools/keymap-gen
@@ -0,0 +1,1196 @@
+#!/usr/bin/python
+# -*- python -*-
+#
+# Keycode Map Generator
+#
+# Copyright (C) 2009-2017 Red Hat, Inc.
+#
+# This file is dual license under the terms of the GPLv2 or later
+# and 3-clause BSD licenses.
+#
+
+# Requires >= 2.6
+from __future__ import print_function
+
+import csv
+try:
+    import argparse
+except:
+    import os, sys
+    sys.path.append(os.path.join(os.path.dirname(__file__), "../thirdparty"))
+    import argparse
+import hashlib
+import time
+import sys
+
+class Database:
+
+    # Linux: linux/input.h
+    MAP_LINUX = "linux"
+
+    # OS-X: Carbon/HIToolbox/Events.h
+    MAP_OSX = "osx"
+
+    # AT Set 1: linux/drivers/input/keyboard/atkbd.c
+    #           (atkbd_set2_keycode + atkbd_unxlate_table)
+    MAP_ATSET1 = "atset1"
+
+    # AT Set 2: linux/drivers/input/keyboard/atkbd.c
+    #           (atkbd_set2_keycode)
+    MAP_ATSET2 = "atset2"
+
+    # AT Set 3: linux/drivers/input/keyboard/atkbd.c
+    #           (atkbd_set3_keycode)
+    MAP_ATSET3 = "atset3"
+
+    # Linux RAW: linux/drivers/char/keyboard.c (x86_keycodes)
+    MAP_XTKBD = "xtkbd"
+
+    # USB HID: linux/drivers/hid/usbhid/usbkbd.c (usb_kbd_keycode)
+    MAP_USB = "usb"
+
+    # Win32: mingw32/winuser.h
+    MAP_WIN32 = "win32"
+
+    # XWin XT: xorg-server/hw/xwin/{winkeybd.c,winkeynames.h}
+    #          (xt + manually transcribed)
+    MAP_XWINXT = "xwinxt"
+
+    # X11: http://cgit.freedesktop.org/xorg/proto/x11proto/plain/keysymdef.h
+    MAP_X11 = "x11"
+
+    # XKBD XT: xf86-input-keyboard/src/at_scancode.c
+    #          (xt + manually transcribed)
+    MAP_XKBDXT = "xkbdxt"
+
+    # Xorg with evdev: linux + an offset
+    MAP_XORGEVDEV = "xorgevdev"
+
+    # Xorg with kbd: xkbdxt + an offset
+    MAP_XORGKBD = "xorgkbd"
+
+    # Xorg with OS-X: osx + an offset
+    MAP_XORGXQUARTZ = "xorgxquartz"
+
+    # Xorg + Cygwin: xwinxt + an offset
+    MAP_XORGXWIN = "xorgxwin"
+
+    # QEMU key numbers: xtkbd + special re-encoding of high bit
+    MAP_QNUM = "qnum"
+
+    # HTML codes
+    MAP_HTML = "html"
+
+    # XKB key names
+    MAP_XKB = "xkb"
+
+    # QEMU keycodes
+    MAP_QCODE = "qcode"
+
+    # Sun / Sparc  scan codes
+    # Reference: "SPARC International Keyboard Spec 1", page 7 "US scan set"
+    MAP_SUN = "sun"
+
+    # Apple Desktop Bus
+    # Reference: http://www.archive.org/stream/apple-guide-macintosh-family-hardware/Apple_Guide_to_the_Macintosh_Family_Hardware_2e#page/n345/mode/2up
+    MAP_ADB = "adb"
+
+    MAP_LIST = (
+        MAP_LINUX,
+        MAP_OSX,
+        MAP_ATSET1,
+        MAP_ATSET2,
+        MAP_ATSET3,
+        MAP_USB,
+        MAP_WIN32,
+        MAP_XWINXT,
+        MAP_XKBDXT,
+        MAP_X11,
+        MAP_HTML,
+        MAP_XKB,
+        MAP_QCODE,
+        MAP_SUN,
+        MAP_ADB,
+
+        # These are derived from maps above
+        MAP_XTKBD,
+        MAP_XORGEVDEV,
+        MAP_XORGKBD,
+        MAP_XORGXQUARTZ,
+        MAP_XORGXWIN,
+        MAP_QNUM,
+    )
+
+    CODE_COLUMNS = {
+        MAP_LINUX: 1,
+        MAP_OSX: 3,
+        MAP_ATSET1: 4,
+        MAP_ATSET2: 5,
+        MAP_ATSET3: 6,
+        MAP_USB: 7,
+        MAP_WIN32: 9,
+        MAP_XWINXT: 10,
+        MAP_XKBDXT: 11,
+        MAP_X11: 13,
+        MAP_HTML: 14,
+        MAP_XKB: 15,
+        MAP_SUN: 17,
+        MAP_ADB: 18,
+    }
+
+    ENUM_COLUMNS = {
+        MAP_QCODE: 14,
+    }
+
+    NAME_COLUMNS = {
+        MAP_LINUX: 0,
+        MAP_OSX: 2,
+        MAP_WIN32: 8,
+        MAP_X11: 12,
+        MAP_HTML: 14,
+        MAP_XKB: 15,
+        MAP_QCODE: 16,
+    }
+
+    ENUM_BOUND = {
+        MAP_QCODE: "Q_KEY_CODE__MAX",
+    }
+
+    def __init__(self):
+
+        self.mapto = {}
+        self.mapfrom = {}
+        self.mapname = {}
+        self.mapchecksum = None
+
+        for name in self.MAP_LIST:
+            # Key is a MAP_LINUX, value is a MAP_XXX
+            self.mapto[name] = {}
+            # key is a MAP_XXX, value is a MAP_LINUX
+            self.mapfrom[name] = {}
+
+        for name in self.NAME_COLUMNS.keys():
+            # key is a MAP_LINUX, value is a string
+            self.mapname[name] = {}
+
+    def _generate_checksum(self, filename):
+        hash = hashlib.sha256()
+        with open(filename, "rb") as f:
+            for chunk in iter(lambda: f.read(4096), b""):
+                hash.update(chunk)
+        self.mapchecksum = hash.hexdigest()
+
+    def load(self, filename):
+        self._generate_checksum(filename)
+
+        with open(filename, 'r') as f:
+            reader = csv.reader(f)
+
+            first = True
+
+            for row in reader:
+                # Discard column headings
+                if first:
+                    first = False
+                    continue
+
+                # We special case MAP_LINUX since that is out
+                # master via which all other mappings are done
+                linux = self.load_linux(row)
+
+                # Now load all the remaining master data values
+                self.load_data(row, linux)
+
+                # Then load all the keycode names
+                self.load_names(row, linux)
+
+                # Finally calculate derived key maps
+                self.derive_data(row, linux)
+
+    def load_linux(self, row):
+        col = self.CODE_COLUMNS[self.MAP_LINUX]
+        linux = row[col]
+
+        if linux.startswith("0x"):
+            linux = int(linux, 16)
+        else:
+            linux = int(linux, 10)
+
+        self.mapto[self.MAP_LINUX][linux] = linux
+        self.mapfrom[self.MAP_LINUX][linux] = linux
+
+        return linux
+
+
+    def load_data(self, row, linux):
+        for mapname in self.CODE_COLUMNS:
+            if mapname == self.MAP_LINUX:
+                continue
+
+            col = self.CODE_COLUMNS[mapname]
+            val = row[col]
+
+            if val == "":
+                continue
+
+            if val.startswith("0x"):
+                val = int(val, 16)
+            elif val.isdigit():
+                val = int(val, 10)
+
+            self.mapto[mapname][linux] = val
+            self.mapfrom[mapname][val] = linux
+
+    def load_names(self, row, linux):
+        for mapname in self.NAME_COLUMNS:
+            col = self.NAME_COLUMNS[mapname]
+            val = row[col]
+
+            if val == "":
+                continue
+
+            self.mapname[mapname][linux] = val
+
+
+    def derive_data(self, row, linux):
+        # Linux RAW is XT scan codes with special encoding of the
+        # 0xe0 scan codes
+        if linux in self.mapto[self.MAP_ATSET1]:
+            at1 = self.mapto[self.MAP_ATSET1][linux]
+            if at1 > 0x7f:
+                assert((at1 & ~0x7f) == 0xe000)
+                xtkbd = 0x100 | (at1 & 0x7f)
+            else:
+                xtkbd = at1
+            self.mapto[self.MAP_XTKBD][linux] = xtkbd
+            self.mapfrom[self.MAP_XTKBD][xtkbd] = linux
+
+        # Xorg KBD is XKBD XT offset by 8
+        if linux in self.mapto[self.MAP_XKBDXT]:
+            xorgkbd = self.mapto[self.MAP_XKBDXT][linux] + 8
+            self.mapto[self.MAP_XORGKBD][linux] = xorgkbd
+            self.mapfrom[self.MAP_XORGKBD][xorgkbd] = linux
+
+        # Xorg evdev is Linux offset by 8
+        self.mapto[self.MAP_XORGEVDEV][linux] = linux + 8
+        self.mapfrom[self.MAP_XORGEVDEV][linux + 8] = linux
+
+        # Xorg XQuartx is OS-X offset by 8
+        if linux in self.mapto[self.MAP_OSX]:
+            xorgxquartz = self.mapto[self.MAP_OSX][linux] + 8
+            self.mapto[self.MAP_XORGXQUARTZ][linux] = xorgxquartz
+            self.mapfrom[self.MAP_XORGXQUARTZ][xorgxquartz] = linux
+
+        # Xorg Xwin (aka Cygwin) is XWin XT offset by 8
+        if linux in self.mapto[self.MAP_XWINXT]:
+            xorgxwin = self.mapto[self.MAP_XWINXT][linux] + 8
+            self.mapto[self.MAP_XORGXWIN][linux] = xorgxwin
+            self.mapfrom[self.MAP_XORGXWIN][xorgxwin] = linux
+
+        # QNUM keycodes are XT scan codes with a slightly
+        # different encoding of 0xe0 scan codes
+        if linux in self.mapto[self.MAP_ATSET1]:
+            at1 = self.mapto[self.MAP_ATSET1][linux]
+            if at1 > 0x7f:
+                assert((at1 & ~0x7f) == 0xe000)
+                qnum = 0x80 | (at1 & 0x7f)
+            else:
+                qnum = at1
+            self.mapto[self.MAP_QNUM][linux] = qnum
+            self.mapfrom[self.MAP_QNUM][qnum] = linux
+
+            # Hack for compatibility with previous mistakes in handling
+            # Print/SysRq. The preferred qnum for Print/SysRq is 0x54,
+            # but QEMU previously allowed 0xb7 too
+            if qnum == 0x54:
+                self.mapfrom[self.MAP_QNUM][0xb7] = self.mapfrom[self.MAP_QNUM][0x54]
+
+        if linux in self.mapname[self.MAP_QCODE]:
+            qcodeenum = self.mapname[self.MAP_QCODE][linux]
+            qcodeenum = "Q_KEY_CODE_" + qcodeenum.upper()
+            self.mapto[self.MAP_QCODE][linux] = qcodeenum
+            self.mapfrom[self.MAP_QCODE][qcodeenum] = linux
+
+class LanguageGenerator(object):
+
+    def _boilerplate(self, lines):
+        raise NotImplementedError()
+
+    def generate_header(self, database, args):
+        self._boilerplate([
+            "This file is auto-generated from keymaps.csv",
+            "Database checksum sha256(%s)" % database.mapchecksum,
+            "To re-generate, run:",
+            "  %s" % args,
+        ])
+
+class LanguageSrcGenerator(LanguageGenerator):
+
+    TYPE_INT = "integer"
+    TYPE_STRING = "string"
+    TYPE_ENUM = "enum"
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        raise NotImplementedError()
+
+    def _array_end(self, fromtype, totype):
+        raise NotImplementedError()
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        raise NotImplementedError()
+
+    def generate_code_map(self, varname, database, frommapname, tomapname):
+        if frommapname not in database.mapfrom:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            frommapname, ", ".join(database.mapfrom.keys())))
+        if tomapname not in database.mapto:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            tomapname, ", ".join(database.mapto.keys())))
+
+        tolinux = database.mapfrom[frommapname]
+        fromlinux = database.mapto[tomapname]
+
+        if varname is None:
+            varname = "code_map_%s_to_%s" % (frommapname, tomapname)
+
+        if frommapname in database.ENUM_COLUMNS:
+            fromtype = self.TYPE_ENUM
+        elif type(list(tolinux.keys())[0]) == str:
+            fromtype = self.TYPE_STRING
+        else:
+            fromtype = self.TYPE_INT
+
+        if tomapname in database.ENUM_COLUMNS:
+            totype = self.TYPE_ENUM
+        elif type(list(fromlinux.values())[0]) == str:
+            totype = self.TYPE_STRING
+        else:
+            totype = self.TYPE_INT
+
+        keys = list(tolinux.keys())
+        keys.sort()
+        if fromtype == self.TYPE_INT:
+            keys = range(keys[-1] + 1)
+
+        if fromtype == self.TYPE_ENUM:
+            keymax = database.ENUM_BOUND[frommapname]
+        else:
+            keymax = len(keys)
+
+        defvalue = fromlinux.get(0, None)
+        if fromtype == self.TYPE_ENUM:
+            self._array_start(varname, keymax, defvalue, fromtype, totype)
+        else:
+            self._array_start(varname, keymax, None, fromtype, totype)
+
+        for src in keys:
+            linux = tolinux.get(src, None)
+            if linux is None:
+                dst = None
+            else:
+                dst = fromlinux.get(linux, defvalue)
+
+            comment = "%s -> %s -> %s" % (self._label(database, frommapname, src, linux),
+                                          self._label(database, Database.MAP_LINUX, linux, linux),
+                                          self._label(database, tomapname, dst, linux))
+            self._array_entry(src, dst, comment, fromtype, totype)
+        self._array_end(fromtype, totype)
+
+    def generate_code_table(self, varname, database, mapname):
+        if mapname not in database.mapto:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            mapname, ", ".join(database.mapto.keys())))
+
+        keys = list(database.mapto[Database.MAP_LINUX].keys())
+        keys.sort()
+        names = [database.mapname[Database.MAP_LINUX].get(key, "unnamed") for key in keys]
+
+        if varname is None:
+            varname = "code_table_%s" % mapname
+
+        if mapname in database.ENUM_COLUMNS:
+            totype = self.TYPE_ENUM
+        elif type(list(database.mapto[mapname].values())[0]) == str:
+            totype = self.TYPE_STRING
+        else:
+            totype = self.TYPE_INT
+
+        self._array_start(varname, len(keys), None, self.TYPE_INT, totype)
+
+        defvalue = database.mapto[mapname].get(0, None)
+        for i in range(len(keys)):
+            key = keys[i]
+            dst = database.mapto[mapname].get(key, defvalue)
+            self._array_entry(i, dst, names[i], self.TYPE_INT, totype)
+
+        self._array_end(self.TYPE_INT, totype)
+
+    def generate_name_map(self, varname, database, frommapname, tomapname):
+        if frommapname not in database.mapfrom:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            frommapname, ", ".join(database.mapfrom.keys())))
+        if tomapname not in database.mapname:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            tomapname, ", ".join(database.mapname.keys())))
+
+        tolinux = database.mapfrom[frommapname]
+        fromlinux = database.mapname[tomapname]
+
+        if varname is None:
+            varname = "name_map_%s_to_%s" % (frommapname, tomapname)
+
+        keys = list(tolinux.keys())
+        keys.sort()
+        if type(keys[0]) == int:
+            keys = range(keys[-1] + 1)
+
+        if type(keys[0]) == int:
+            fromtype = self.TYPE_INT
+        else:
+            fromtype = self.TYPE_STRING
+
+        self._array_start(varname, len(keys), None, fromtype, self.TYPE_STRING)
+
+        for src in keys:
+            linux = tolinux.get(src, None)
+            if linux is None:
+                dst = None
+            else:
+                dst = fromlinux.get(linux, None)
+
+            comment = "%s -> %s -> %s" % (self._label(database, frommapname, src, linux),
+                                          self._label(database, Database.MAP_LINUX, linux, linux),
+                                          self._label(database, tomapname, dst, linux))
+            self._array_entry(src, dst, comment, fromtype, self.TYPE_STRING)
+        self._array_end(fromtype, self.TYPE_STRING)
+
+    def generate_name_table(self, varname, database, mapname):
+        if mapname not in database.mapname:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            mapname, ", ".join(database.mapname.keys())))
+
+        keys = list(database.mapto[Database.MAP_LINUX].keys())
+        keys.sort()
+        names = [database.mapname[Database.MAP_LINUX].get(key, "unnamed") for key in keys]
+
+        if varname is None:
+            varname = "name_table_%s" % mapname
+
+        self._array_start(varname, len(keys), None, self.TYPE_INT, self.TYPE_STRING)
+
+        for i in range(len(keys)):
+            key = keys[i]
+            dst = database.mapname[mapname].get(key, None)
+            self._array_entry(i, dst, names[i], self.TYPE_INT, self.TYPE_STRING)
+
+        self._array_end(self.TYPE_INT, self.TYPE_STRING)
+
+    def _label(self, database, mapname, val, linux):
+        if mapname in database.mapname:
+            return "%s:%s (%s)" % (mapname, val, database.mapname[mapname].get(linux, "unnamed"))
+        else:
+            return "%s:%s" % (mapname, val)
+
+class LanguageDocGenerator(LanguageGenerator):
+
+    def _array_start_name_doc(self, varname, namemap):
+        raise NotImplementedError()
+
+    def _array_start_code_doc(self, varname, namemap, codemap):
+        raise NotImplementedError()
+
+    def _array_end(self):
+        raise NotImplementedError()
+
+    def _array_name_entry(self, value, name):
+        raise NotImplementedError()
+
+    def _array_code_entry(self, value, name):
+        raise NotImplementedError()
+
+    def generate_name_docs(self, title, subtitle, database, mapname):
+        if mapname not in database.mapname:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            mapname, ", ".join(database.mapname.keys())))
+
+        keys = list(database.mapto[Database.MAP_LINUX].keys())
+        keys.sort()
+        names = [database.mapname[Database.MAP_LINUX].get(key, "unnamed") for key in keys]
+
+        if title is None:
+            title = mapname
+        if subtitle is None:
+            subtitle = "Docs for %s" % mapname
+
+        self._array_start_name_doc(title, subtitle, mapname)
+
+        for i in range(len(keys)):
+            key = keys[i]
+            dst = database.mapname[mapname].get(key, None)
+            self._array_name_entry(key, dst)
+
+        self._array_end()
+
+
+    def generate_code_docs(self, title, subtitle, database, mapname):
+        if mapname not in database.mapfrom:
+            raise Exception("Unknown map %s, expected one of %s" % (
+                            mapname, ", ".join(database.mapfrom.keys())))
+
+        tolinux = database.mapfrom[mapname]
+        keys = list(tolinux.keys())
+        keys.sort()
+        if mapname in database.mapname:
+            names = database.mapname[mapname]
+            namemap = mapname
+        else:
+            names = database.mapname[Database.MAP_LINUX]
+            namemap = Database.MAP_LINUX
+
+        if title is None:
+            title = mapname
+        if subtitle is None:
+            subtitle = "Docs for %s" % mapname
+
+        self._array_start_code_doc(title, subtitle, mapname, namemap)
+
+        for i in range(len(keys)):
+            key = keys[i]
+            self._array_code_entry(key, names.get(tolinux[key], "unnamed"))
+
+        self._array_end()
+
+class CLanguageGenerator(LanguageSrcGenerator):
+
+    def __init__(self, inttypename, strtypename, lentypename):
+        self.inttypename = inttypename
+        self.strtypename = strtypename
+        self.lentypename = lentypename
+
+    def _boilerplate(self, lines):
+        print("/*")
+        for line in lines:
+            print(" * %s" % line)
+        print("*/")
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        self._varname = varname;
+        totypename = self.strtypename if totype == self.TYPE_STRING else self.inttypename
+        if fromtype in (self.TYPE_INT, self.TYPE_ENUM):
+            if type(length) == str:
+                print("const %s %s[%s] = {" % (totypename, varname, length))
+            else:
+                print("const %s %s[%d] = {" % (totypename, varname, length))
+        else:
+            print("const struct _%s {" % varname)
+            print("  const %s from;" % self.strtypename)
+            print("  const %s to;" % totypename)
+            print("} %s[] = {" % varname)
+
+        if defvalue != None:
+            if totype == self.TYPE_ENUM:
+                if type(length) == str:
+                    print("  [0 ... %s-1] = %s," % (length, defvalue))
+                else:
+                    print("  [0 ... 0x%x-1] = %s," % (length, defvalue))
+            else:
+                if type(length) == str:
+                    print("  [0 ... %s-1] = 0x%x," % (length, defvalue))
+                else:
+                    print("  [0 ... 0x%x-1] = 0x%x," % (length, defvalue))
+
+    def _array_end(self, fromtype, totype):
+        print("};")
+        print("const %s %s_len = sizeof(%s)/sizeof(%s[0]);" %
+              (self.lentypename, self._varname, self._varname, self._varname))
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        if value is None:
+            return
+        if fromtype == self.TYPE_INT:
+            indexfmt = "0x%x"
+        elif fromtype == self.TYPE_ENUM:
+            indexfmt = "%s"
+        else:
+            indexfmt = "\"%s\""
+
+        if totype == self.TYPE_INT:
+            valuefmt = "0x%x"
+        elif totype == self.TYPE_ENUM:
+            valuefmt = "%s"
+        else:
+            valuefmt = "\"%s\""
+
+        if fromtype != self.TYPE_STRING:
+            print(("  [" + indexfmt + "] = " + valuefmt + ", /* %s */") % (index, value, comment))
+        else:
+            print(("  {" + indexfmt + ", " + valuefmt + "}, /* %s */") % (index, value, comment))
+
+class StdCLanguageGenerator(CLanguageGenerator):
+
+    def __init__(self):
+        super(StdCLanguageGenerator, self).__init__("unsigned short", "char *", "unsigned int")
+
+class GLib2LanguageGenerator(CLanguageGenerator):
+
+    def __init__(self):
+        super(GLib2LanguageGenerator, self).__init__("guint16", "gchar *", "guint")
+
+class CHeaderLanguageGenerator(LanguageSrcGenerator):
+
+    def __init__(self, inttypename, strtypename, lentypename):
+        self.inttypename = inttypename
+        self.strtypename = strtypename
+        self.lentypename = lentypename
+
+    def _boilerplate(self, lines):
+        print("/*")
+        for line in lines:
+            print(" * %s" % line)
+        print("*/")
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        self._varname = varname
+        if fromtype == self.TYPE_STRING:
+            self._length = 0
+        else:
+            self._length = length
+
+    def _array_end(self, fromtype, totype):
+        totypename = self.strtypename if totype == self.TYPE_STRING else self.inttypename
+        if fromtype == self.TYPE_STRING:
+            vartypename = "struct _%s" % self._varname
+            print("%s {" % vartypename)
+            print("  const %s from;" % self.strtypename)
+            print("  const %s to;" % totypename)
+            print("};")
+        else:
+            vartypename = totypename
+        if type(self._length) == str:
+            print("extern const %s %s[%s];" % (vartypename, self._varname, self._length))
+        else:
+            print("extern const %s %s[%d];" % (vartypename, self._varname, self._length))
+        print("extern const %s %s_len;" % (self.lentypename, self._varname))
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        if value is None:
+            return
+        if fromtype == self.TYPE_STRING:
+            self._length += 1
+
+class StdCHeaderLanguageGenerator(CHeaderLanguageGenerator):
+
+    def __init__(self):
+        super(StdCHeaderLanguageGenerator, self).__init__("unsigned short", "char *", "unsigned int")
+
+class GLib2HeaderLanguageGenerator(CHeaderLanguageGenerator):
+
+    def __init__(self):
+        super(GLib2HeaderLanguageGenerator, self).__init__("guint16", "gchar *", "guint")
+
+class CppLanguageGenerator(CLanguageGenerator):
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        if fromtype == self.TYPE_ENUM:
+            raise NotImplementedError("Enums not supported as source in C++ generator")
+        totypename = "const " + self.strtypename if totype == self.TYPE_STRING else self.inttypename
+        if fromtype == self.TYPE_INT:
+            print("#include <vector>")
+            print("extern const std::vector<%s> %s;" % (totypename, varname));
+            print("const std::vector<%s> %s = {" % (totypename, varname))
+        else:
+            print("#include <map>")
+            print("#include <string>")
+            print("extern const std::map<const std::string, %s> %s;" % (totypename, varname))
+            print("const std::map<const std::string, %s> %s = {" % (totypename, varname))
+
+    def _array_end(self, fromtype, totype):
+        print("};")
+
+    # designated initializers not available in C++
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        if fromtype == self.TYPE_STRING:
+            return super(CppLanguageGenerator, self)._array_entry(index, value, comment, fromtype, totype)
+
+        if value is None:
+            print("  0, /* %s */" % comment)
+        elif totype == self.TYPE_INT:
+            print("  0x%x, /* %s */" % (value, comment))
+        elif totype == self.TYPE_ENUM:
+            print("  %s, /* %s */" % (value, comment))
+        else:
+            print("  \"%s\", /* %s */" % (value, comment))
+
+class StdCppLanguageGenerator(CppLanguageGenerator):
+
+    def __init__(self):
+        super(StdCppLanguageGenerator, self).__init__("unsigned short", "char *", "unsigned int")
+
+class CppHeaderLanguageGenerator(CHeaderLanguageGenerator):
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        if fromtype == self.TYPE_ENUM:
+            raise NotImplementedError("Enums not supported as source in C++ generator")
+        totypename = "const " + self.strtypename if totype == self.TYPE_STRING else self.inttypename
+        if fromtype == self.TYPE_INT:
+            print("#include <vector>")
+            print("extern const std::vector<%s> %s;" % (totypename, varname));
+        else:
+            print("#include <map>")
+            print("#include <string>")
+            print("extern const std::map<const std::string, %s> %s;" % (totypename, varname))
+
+    def _array_end(self, fromtype, totype):
+        pass
+
+    # designated initializers not available in C++
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        pass
+
+class StdCppHeaderLanguageGenerator(CppHeaderLanguageGenerator):
+
+    def __init__(self):
+        super(StdCppHeaderLanguageGenerator, self).__init__("unsigned short", "char *", "unsigned int")
+
+
+class RustLanguageGenerator(LanguageSrcGenerator):
+
+    def _boilerplate(self, lines):
+        print("//")
+        for line in lines:
+            print("// %s" % line)
+        print("//")
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        if fromtype == self.TYPE_ENUM:
+            raise NotImplementedError("Enums not supported as source in Rust generator")
+
+        totypename = "&str" if totype == self.TYPE_STRING else "u16"
+        if fromtype != self.TYPE_STRING:
+            print("pub static %s: &[%s] = &[" % (varname.upper(), totypename))
+        else:
+            print("pub static %s: phf::Map<&str, %s> = phf::phf_map! {" %
+                  (varname.upper(), totypename))
+
+    def _array_end(self, fromtype, totype):
+        if fromtype != self.TYPE_STRING:
+            print("];")
+        else:
+            print("};")
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        none = "\"\"" if totype == self.TYPE_STRING else "0"
+        if fromtype == self.TYPE_INT:
+            if value is None:
+                print("  %s, // %s" % (none, comment))
+            elif totype == self.TYPE_INT:
+                print("  0x%x, // %s" % (value, comment))
+            elif totype == self.TYPE_ENUM:
+                print("  %s, // %s" % (value, comment))
+            else:
+                print("  \"%s\", // %s" % (value, comment))
+        else:
+            if value is None:
+                print("  \"%s\" => %s, // %s" % (index, none, comment))
+            elif totype == self.TYPE_INT:
+                print("  \"%s\" => 0x%x, // %s" % (index, value, comment))
+            elif totype == self.TYPE_ENUM:
+                print("  \"%s\" => %s, // %s" % (index, value, comment))
+            else:
+                print("  \"%s\" => \"%s\", // %s" % (index, value, comment))
+
+
+class PythonLanguageGenerator(LanguageSrcGenerator):
+
+    def _boilerplate(self, lines):
+        print("#")
+        for line in lines:
+            print("# %s" % line)
+        print("#")
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        if fromtype == self.TYPE_ENUM:
+            raise NotImplementedError("Enums not supported as source in Python generator")
+
+        if fromtype != self.TYPE_STRING:
+            print("%s = [" % varname)
+        else:
+            print("%s = {" % varname)
+
+    def _array_end(self, fromtype, totype):
+        if fromtype != self.TYPE_STRING:
+            print("]")
+        else:
+            print("}")
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        if fromtype == self.TYPE_INT:
+            if value is None:
+                print("  None, # %s" % (comment))
+            elif totype == self.TYPE_INT:
+                print("  0x%x, # %s" % (value, comment))
+            elif totype == self.TYPE_ENUM:
+                print("  %s, # %s" % (value, comment))
+            else:
+                print("  \"%s\", # %s" % (value, comment))
+        else:
+            if value is None:
+                print("  \"%s\": None, # %s" % (index, comment))
+            elif totype == self.TYPE_INT:
+                print("  \"%s\": 0x%x, # %s" % (index, value, comment))
+            elif totype == self.TYPE_ENUM:
+                print("  \"%s\": %s, # %s" % (index, value, comment))
+            else:
+                print("  \"%s\": \"%s\", # %s" % (index, value, comment))
+
+class PerlLanguageGenerator(LanguageSrcGenerator):
+
+    def _boilerplate(self, lines):
+        print("#")
+        for line in lines:
+            print("# %s" % line)
+        print("#")
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        if fromtype == self.TYPE_ENUN:
+            raise NotImplementedError("Enums not supported as source in Python generator")
+        if fromtype == self.TYPE_INT:
+            print("my @%s = (" % varname)
+        else:
+            print("my %%%s = (" % varname)
+
+    def _array_end(self, fromtype, totype):
+        print(");")
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        if fromtype == self.TYPE_INT:
+            if value is None:
+                print("  undef, # %s" % (comment))
+            elif totype == self.TYPE_INT:
+                print("  0x%x, # %s" % (value, comment))
+            elif totype == self.TYPE_ENUM:
+                print("  %s, # %s" % (value, comment))
+            else:
+                print("  \"%s\", # %s" % (value, comment))
+        else:
+            if value is None:
+                print("  \"%s\", undef, # %s" % (index, comment))
+            elif totype == self.TYPE_INT:
+                print("  \"%s\", 0x%x, # %s" % (index, value, comment))
+            elif totype == self.TYPE_ENUM:
+                print("  \"%s\", 0x%x, # %s" % (index, value, comment))
+            else:
+                print("  \"%s\", \"%s\", # %s" % (index, value, comment))
+
+class JavaScriptLanguageGenerator(LanguageSrcGenerator):
+
+    def _boilerplate(self, lines):
+        print("/*")
+        for line in lines:
+            print(" * %s" % line)
+        print("*/")
+
+    def _array_start(self, varname, length, defvalue, fromtype, totype):
+        print("export default {")
+
+    def _array_end(self, fromtype, totype):
+        print("};")
+
+    def _array_entry(self, index, value, comment, fromtype, totype):
+        if value is None:
+            return
+
+        if fromtype == self.TYPE_INT:
+            fromfmt = "0x%x"
+        elif fromtype == self.TYPE_ENUM:
+            fromfmt = "%s"
+        else:
+            fromfmt = "\"%s\""
+
+        if totype == self.TYPE_INT:
+            tofmt = "0x%x"
+        elif totype == self.TYPE_ENUM:
+            tofmt = "%s"
+        else:
+            tofmt = "\"%s\""
+
+        print(("  " + fromfmt + ": " + tofmt + ", /* %s */") % (index, value, comment))
+
+class PodLanguageGenerator(LanguageDocGenerator):
+
+    def _boilerplate(self, lines):
+        print("#")
+        for line in lines:
+            print("# %s" % line)
+        print("#")
+
+    def _array_start_name_doc(self, title, subtitle, namemap):
+        print("=head1 NAME")
+        print("")
+        print("%s - %s" % (title, subtitle))
+        print("")
+        print("=head1 DESCRIPTION")
+        print("")
+        print("List of %s key code names, with corresponding key code values" % namemap)
+        print("")
+        print("=over 4")
+        print("")
+
+    def _array_start_code_doc(self, title, subtitle, codemap, namemap):
+        print("=head1 NAME")
+        print("")
+        print("%s - %s" % (title, subtitle))
+        print("")
+        print("=head1 DESCRIPTION")
+        print("")
+        print("List of %s key code values, with corresponding %s key code names" % (codemap, namemap))
+        print("")
+        print("=over 4")
+        print("")
+
+    def _array_end(self):
+        print("=back")
+        print("")
+
+    def _array_name_entry(self, value, name):
+        print("=item %s" % name)
+        print("")
+        print("Key value %d (0x%x)" % (value, value))
+        print("")
+
+    def _array_code_entry(self, value, name):
+        print("=item %d (0x%x)" % (value, value))
+        print("")
+        print("Key name %s" % name)
+        print("")
+
+class RSTLanguageGenerator(LanguageDocGenerator):
+
+    def _boilerplate(self, lines):
+        print("..")
+        for line in lines:
+            print("   %s" % line)
+        print("")
+
+    def _array_start_name_doc(self, title, subtitle, namemap):
+        print("=" * len(title))
+        print(title)
+        print("=" * len(title))
+        print("")
+        print("-" * len(subtitle))
+        print(subtitle)
+        print("-" * len(subtitle))
+        print("")
+        print(":Manual section: 7")
+        print(":Manual group: Virtualization Support")
+        print("")
+        print("DESCRIPTION")
+        print("===========")
+        print("List of %s key code names, with corresponding key code values" % namemap)
+        print("")
+
+    def _array_start_code_doc(self, title, subtitle, codemap, namemap):
+        print("=" * len(title))
+        print(title)
+        print("=" * len(title))
+        print("")
+        print("-" * len(subtitle))
+        print(subtitle)
+        print("-" * len(subtitle))
+        print("")
+        print(":Manual section: 7")
+        print(":Manual group: Virtualization Support")
+        print("")
+        print("DESCRIPTION")
+        print("===========")
+        print("List of %s key code values, with corresponding %s key code names" % (codemap, namemap))
+        print("")
+
+    def _array_end(self):
+        print("")
+
+    def _array_name_entry(self, value, name):
+        print("* %s" % name)
+        print("")
+        print("  Key value %d (0x%x)" % (value, value))
+        print("")
+
+    def _array_code_entry(self, value, name):
+        print("* %d (0x%x)" % (value, value))
+        print("")
+        print("  Key name %s" % name)
+        print("")
+
+SRC_GENERATORS = {
+    "stdc": StdCLanguageGenerator(),
+    "stdc-header": StdCHeaderLanguageGenerator(),
+    "stdc++": StdCppLanguageGenerator(),
+    "stdc++-header": StdCppHeaderLanguageGenerator(),
+    "glib2": GLib2LanguageGenerator(),
+    "glib2-header": GLib2HeaderLanguageGenerator(),
+    "python2": PythonLanguageGenerator(),
+    "python3": PythonLanguageGenerator(),
+    "perl": PerlLanguageGenerator(),
+    "js": JavaScriptLanguageGenerator(),
+    "rust": RustLanguageGenerator(),
+}
+DOC_GENERATORS = {
+    "pod": PodLanguageGenerator(),
+    "rst": RSTLanguageGenerator(),
+}
+
+def code_map(args):
+    database = Database()
+    database.load(args.keymaps)
+
+    cliargs = ["keymap-gen", "code-map", "--lang=%s" % args.lang]
+    if args.varname is not None:
+        cliargs.append("--varname=%s" % args.varname)
+    cliargs.extend(["keymaps.csv", args.frommapname, args.tomapname])
+    SRC_GENERATORS[args.lang].generate_header(database, " ".join(cliargs))
+
+    SRC_GENERATORS[args.lang].generate_code_map(args.varname, database, args.frommapname, args.tomapname)
+
+def code_table(args):
+    database = Database()
+    database.load(args.keymaps)
+
+    cliargs = ["keymap-gen", "code-table", "--lang=%s" % args.lang]
+    if args.varname is not None:
+        cliargs.append("--varname=%s" % args.varname)
+    cliargs.extend(["keymaps.csv", args.mapname])
+    SRC_GENERATORS[args.lang].generate_header(database, " ".join(cliargs))
+
+    SRC_GENERATORS[args.lang].generate_code_table(args.varname, database, args.mapname)
+
+def name_map(args):
+    database = Database()
+    database.load(args.keymaps)
+
+    cliargs = ["keymap-gen", "name-map", "--lang=%s" % args.lang]
+    if args.varname is not None:
+        cliargs.append("--varname=%s" % args.varname)
+    cliargs.extend(["keymaps.csv", args.frommapname, args.tomapname])
+    SRC_GENERATORS[args.lang].generate_header(database, " ".join(cliargs))
+
+    SRC_GENERATORS[args.lang].generate_name_map(args.varname, database, args.frommapname, args.tomapname)
+
+def name_table(args):
+    database = Database()
+    database.load(args.keymaps)
+
+
+    cliargs = ["keymap-gen", "name-table", "--lang=%s" % args.lang]
+    if args.varname is not None:
+        cliargs.append("--varname=%s" % args.varname)
+    cliargs.extend(["keymaps.csv", args.mapname])
+    SRC_GENERATORS[args.lang].generate_header(database, " ".join(cliargs))
+
+    SRC_GENERATORS[args.lang].generate_name_table(args.varname, database, args.mapname)
+
+def code_docs(args):
+    database = Database()
+    database.load(args.keymaps)
+
+
+    cliargs = ["keymap-gen", "code-docs", "--lang=%s" % args.lang]
+    if args.title is not None:
+        cliargs.append("--title=%s" % args.title)
+    if args.subtitle is not None:
+        cliargs.append("--subtitle=%s" % args.subtitle)
+    cliargs.extend(["keymaps.csv", args.mapname])
+    DOC_GENERATORS[args.lang].generate_header(database, " ".join(cliargs))
+
+    DOC_GENERATORS[args.lang].generate_code_docs(args.title, args.subtitle, database, args.mapname)
+
+def name_docs(args):
+    database = Database()
+    database.load(args.keymaps)
+
+
+    cliargs = ["keymap-gen", "name-docs", "--lang=%s" % args.lang]
+    if args.title is not None:
+        cliargs.append("--title=%s" % args.title)
+    if args.subtitle is not None:
+        cliargs.append("--subtitle=%s" % args.subtitle)
+    cliargs.extend(["keymaps.csv", args.mapname])
+    DOC_GENERATORS[args.lang].generate_header(database, " ".join(cliargs))
+
+    DOC_GENERATORS[args.lang].generate_name_docs(args.title, args.subtitle, database, args.mapname)
+
+def usage():
+    print ("Please select a command:")
+    print ("  'code-map', 'code-table', 'name-map', 'name-table', 'docs'")
+    sys.exit(1)
+
+def main():
+    parser = argparse.ArgumentParser()
+
+    subparsers = parser.add_subparsers(help="sub-command help")
+
+    codemapparser = subparsers.add_parser("code-map", help="Generate a mapping between code tables")
+    codemapparser.add_argument("--varname", default=None, help="Data variable name")
+    codemapparser.add_argument("--lang", default="stdc",
+                        help="Output language (%s)" % (
+                            ",".join(SRC_GENERATORS.keys())))
+    codemapparser.add_argument("keymaps", help="Path to keymap CSV data file")
+    codemapparser.add_argument("frommapname", help="Source code table name")
+    codemapparser.add_argument("tomapname", help="Target code table name")
+    codemapparser.set_defaults(func=code_map)
+
+    codetableparser = subparsers.add_parser("code-table", help="Generate a flat code table")
+    codetableparser.add_argument("--lang", default="stdc",
+                        help="Output language (%s)" % (
+                            ",".join(SRC_GENERATORS.keys())))
+    codetableparser.add_argument("--varname", default=None, help="Data variable name")
+    codetableparser.add_argument("keymaps", help="Path to keymap CSV data file")
+    codetableparser.add_argument("mapname", help="Code table name")
+    codetableparser.set_defaults(func=code_table)
+
+    namemapparser = subparsers.add_parser("name-map", help="Generate a mapping to names")
+    namemapparser.add_argument("--lang", default="stdc",
+                        help="Output language (%s)" % (
+                            ",".join(SRC_GENERATORS.keys())))
+    namemapparser.add_argument("--varname", default=None, help="Data variable name")
+    namemapparser.add_argument("keymaps", help="Path to keymap CSV data file")
+    namemapparser.add_argument("frommapname", help="Source code table name")
+    namemapparser.add_argument("tomapname", help="Target name table name")
+    namemapparser.set_defaults(func=name_map)
+
+    nametableparser = subparsers.add_parser("name-table", help="Generate a flat name table")
+    nametableparser.add_argument("--lang", default="stdc",
+                        help="Output language, (%s)" % (
+                            ",".join(SRC_GENERATORS.keys())))
+    nametableparser.add_argument("--varname", default=None, help="Data variable name")
+    nametableparser.add_argument("keymaps", help="Path to keymap CSV data file")
+    nametableparser.add_argument("mapname", help="Name table name")
+    nametableparser.set_defaults(func=name_table)
+
+    codedocsparser = subparsers.add_parser("code-docs", help="Generate code documentation")
+    codedocsparser.add_argument("--lang", default="pod",
+                        help="Output language (%s)" % (
+                            ",".join(DOC_GENERATORS.keys())))
+    codedocsparser.add_argument("--title", default=None, help="Document title")
+    codedocsparser.add_argument("--subtitle", default=None, help="Document subtitle")
+    codedocsparser.add_argument("keymaps", help="Path to keymap CSV data file")
+    codedocsparser.add_argument("mapname", help="Code table name")
+    codedocsparser.set_defaults(func=code_docs)
+
+    namedocsparser = subparsers.add_parser("name-docs", help="Generate name documentation")
+    namedocsparser.add_argument("--lang", default="pod",
+                        help="Output language (%s)" % (
+                            ",".join(DOC_GENERATORS.keys())))
+    namedocsparser.add_argument("--title", default=None, help="Document title")
+    namedocsparser.add_argument("--subtitle", default=None, help="Document subtitle")
+    namedocsparser.add_argument("keymaps", help="Path to keymap CSV data file")
+    namedocsparser.add_argument("mapname", help="Name table name")
+    namedocsparser.set_defaults(func=name_docs)
+
+    args = parser.parse_args()
+    if hasattr(args, "func"):
+        args.func(args)
+    else:
+        usage()
+
+
+main()
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index e8bdb02..7947221 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -41,6 +41,8 @@
 #include "qemu/cutils.h"
 #include "qemu/compiler.h"
 
+//#include "hw/vfio/cni_logger.h"
+
 #ifdef CONFIG_LINUX
 #include <sys/syscall.h>
 #endif
diff --git a/util/vfio-helpers.c b/util/vfio-helpers.c
index 00a8043..2f51a8d 100644
--- a/util/vfio-helpers.c
+++ b/util/vfio-helpers.c
@@ -24,6 +24,8 @@
 #include "qemu/vfio-helpers.h"
 #include "qemu/lockable.h"
 #include "trace.h"
+//#include "hw/vfio/cni_logger.h"
+
 
 #define QEMU_VFIO_DEBUG 0
 
@@ -608,6 +610,16 @@ static IOVAMapping *qemu_vfio_add_mapping(QEMUVFIOState *s,
     return insert;
 }
 
+// static void cni_log_info(const char *message) {
+//     FILE *log_file = fopen("/home/hdcni/cnicmp/logs/qemu-vfio-helpers.log", "a");
+//     if (log_file != NULL) {
+//         fprintf(log_file, "%s\n", message);
+//         fclose(log_file);
+//     } else {
+//         fprintf(stderr, "Error opening log file\n");
+//     }
+// }
+
 /* Do the DMA mapping with VFIO. */
 static int qemu_vfio_do_mapping(QEMUVFIOState *s, void *host, size_t size,
                                 uint64_t iova, Error **errp)
@@ -621,6 +633,10 @@ static int qemu_vfio_do_mapping(QEMUVFIOState *s, void *host, size_t size,
     };
     trace_qemu_vfio_do_mapping(s, host, iova, size);
 
+    // char debug_info[512];
+    // sprintf(debug_info, "ioctl VFIO_IOMMU_MAP_DMA from qemu_vfio_do_mapping: iova=0x%010" HWADDR_PRIx ", size=%lu MB vaddr=%p [debug mark]", iova, int128_get64(size) / 1024 / 1024, host);
+    // cni_log_info(debug_info);
+
     if (ioctl(s->container, VFIO_IOMMU_MAP_DMA, &dma_map)) {
         error_setg_errno(errp, errno, "VFIO_MAP_DMA failed");
         return -errno;
-- 
2.39.3

